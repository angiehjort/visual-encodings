// undefined v1.0.0 Copyright 2024 Gapminder Foundation
// http://vizabi.org v1.31.6 Copyright 2024 Jasper Heeffer and others at Gapminder Foundation
(function () {
'use strict';
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('mobx'), require('d3')) :
  typeof define === 'function' && define.amd ? define(['mobx', 'd3'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Vizabi = factory(global.mobx, global.d3));
})(window, (function (mobx, d3$1) {
  function fail$1(message) {
      throw new Error("[mobx-utils] " + message);
  }
  function invariant(cond, message) {
      if (message === void 0) { message = "Illegal state"; }
      if (!cond)
          fail$1(message);
  }
  var deepFields = function (x) {
      return (x &&
          x !== Object.prototype &&
          Object.getOwnPropertyNames(x).concat(deepFields(Object.getPrototypeOf(x)) || []));
  };
  var distinctDeepFields = function (x) {
      var deepFieldsIndistinct = deepFields(x);
      var deepFieldsDistinct = deepFieldsIndistinct.filter(function (item, index) { return deepFieldsIndistinct.indexOf(item) === index; });
      return deepFieldsDistinct;
  };
  var getAllMethodsAndProperties = function (x) {
      return distinctDeepFields(x).filter(function (name) { return name !== "constructor" && !~name.indexOf("__"); });
  };

  var PENDING = "pending";
  var FULFILLED = "fulfilled";
  var REJECTED = "rejected";
  function caseImpl(handlers) {
      switch (this.state) {
          case PENDING:
              return handlers.pending && handlers.pending(this.value);
          case REJECTED:
              return handlers.rejected && handlers.rejected(this.value);
          case FULFILLED:
              return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;
      }
  }
  /**
   * `fromPromise` takes a Promise, extends it with 2 observable properties that track
   * the status of the promise and returns it. The returned object has the following observable properties:
   *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference.
   *  - `state`: one of `"pending"`, `"fulfilled"` or `"rejected"`
   *
   * And the following methods:
   * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.
   * - `then((value: TValue) => TResult1 | PromiseLike<TResult1>, [(rejectReason: any) => any])`: chains additional handlers to the provided promise.
   *
   * The returned object implements `PromiseLike<TValue>`, so you can chain additional `Promise` handlers using `then`. You may also use it with `await` in `async` functions.
   *
   * Note that the status strings are available as constants:
   * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`
   *
   * fromPromise takes an optional second argument, a previously created `fromPromise` based observable.
   * This is useful to replace one promise based observable with another, without going back to an intermediate
   * "pending" promise state while fetching data. For example:
   *
   * @example
   * \@observer
   * class SearchResults extends React.Component {
   *   \@observable.ref searchResults
   *
   *   componentDidUpdate(nextProps) {
   *     if (nextProps.query !== this.props.query)
   *       this.searchResults = fromPromise(
   *         window.fetch("/search?q=" + nextProps.query),
   *         // by passing, we won't render a pending state if we had a successful search query before
   *         // rather, we will keep showing the previous search results, until the new promise resolves (or rejects)
   *         this.searchResults
   *       )
   *   }
   *
   *   render() {
   *     return this.searchResults.case({
   *        pending: (staleValue) => {
   *          return staleValue || "searching" // <- value might set to previous results while the promise is still pending
   *        },
   *        fulfilled: (value) => {
   *          return value // the fresh results
   *        },
   *        rejected: (error) => {
   *          return "Oops: " + error
   *        }
   *     })
   *   }
   * }
   *
   * Observable promises can be created immediately in a certain state using
   * `fromPromise.reject(reason)` or `fromPromise.resolve(value?)`.
   * The main advantage of `fromPromise.resolve(value)` over `fromPromise(Promise.resolve(value))` is that the first _synchronously_ starts in the desired state.
   *
   * It is possible to directly create a promise using a resolve, reject function:
   * `fromPromise((resolve, reject) => setTimeout(() => resolve(true), 1000))`
   *
   * @example
   * const fetchResult = fromPromise(fetch("http://someurl"))
   *
   * // combine with when..
   * when(
   *   () => fetchResult.state !== "pending",
   *   () => {
   *     console.log("Got ", fetchResult.value)
   *   }
   * )
   *
   * // or a mobx-react component..
   * const myComponent = observer(({ fetchResult }) => {
   *   switch(fetchResult.state) {
   *      case "pending": return <div>Loading...</div>
   *      case "rejected": return <div>Ooops... {fetchResult.value}</div>
   *      case "fulfilled": return <div>Gotcha: {fetchResult.value}</div>
   *   }
   * })
   *
   * // or using the case method instead of switch:
   *
   * const myComponent = observer(({ fetchResult }) =>
   *   fetchResult.case({
   *     pending:   () => <div>Loading...</div>,
   *     rejected:  error => <div>Ooops.. {error}</div>,
   *     fulfilled: value => <div>Gotcha: {value}</div>,
   *   }))
   *
   * // chain additional handler(s) to the resolve/reject:
   *
   * fetchResult.then(
   *   (result) =>  doSomeTransformation(result),
   *   (rejectReason) => console.error('fetchResult was rejected, reason: ' + rejectReason)
   * ).then(
   *   (transformedResult) => console.log('transformed fetchResult: ' + transformedResult)
   * )
   *
   * @param {IThenable<T>} promise The promise which will be observed
   * @param {IThenable<T>} oldPromise? The previously observed promise
   * @returns {IPromiseBasedObservable<T>}
   */
  function fromPromise(origPromise, oldPromise) {
      invariant(arguments.length <= 2, "fromPromise expects up to two arguments");
      invariant(typeof origPromise === "function" ||
          (typeof origPromise === "object" &&
              origPromise &&
              typeof origPromise.then === "function"), "Please pass a promise or function to fromPromise");
      if (origPromise.isPromiseBasedObservable === true)
          return origPromise;
      if (typeof origPromise === "function") {
          // If it is a (reject, resolve function, wrap it)
          origPromise = new Promise(origPromise);
      }
      var promise = origPromise;
      origPromise.then(mobx.action("observableFromPromise-resolve", function (value) {
          promise.value = value;
          promise.state = FULFILLED;
      }), mobx.action("observableFromPromise-reject", function (reason) {
          promise.value = reason;
          promise.state = REJECTED;
      }));
      promise.isPromiseBasedObservable = true;
      promise.case = caseImpl;
      var oldData = oldPromise && oldPromise.state === FULFILLED
          ? oldPromise.value
          : undefined;
      mobx.extendObservable(promise, {
          value: oldData,
          state: PENDING,
      }, {}, { deep: false });
      return promise;
  }
  (function (fromPromise) {
      fromPromise.reject = mobx.action("fromPromise.reject", function (reason) {
          var p = fromPromise(Promise.reject(reason));
          p.state = REJECTED;
          p.value = reason;
          return p;
      });
      function resolveBase(value) {
          if (value === void 0) { value = undefined; }
          var p = fromPromise(Promise.resolve(value));
          p.state = FULFILLED;
          p.value = value;
          return p;
      }
      fromPromise.resolve = mobx.action("fromPromise.resolve", resolveBase);
  })(fromPromise || (fromPromise = {}));

  var __decorate = function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /** @class */ ((function () {
      function StreamListener(observable, initialValue) {
          var _this = this;
          mobx.runInAction(function () {
              _this.current = initialValue;
              _this.subscription = observable.subscribe(_this);
          });
      }
      StreamListener.prototype.dispose = function () {
          if (this.subscription) {
              this.subscription.unsubscribe();
          }
      };
      StreamListener.prototype.next = function (value) {
          this.current = value;
      };
      StreamListener.prototype.complete = function () {
          this.dispose();
      };
      StreamListener.prototype.error = function (value) {
          this.current = value;
          this.dispose();
      };
      __decorate([
          mobx.observable.ref
      ], StreamListener.prototype, "current", void 0);
      __decorate([
          mobx.action.bound
      ], StreamListener.prototype, "next", null);
      __decorate([
          mobx.action.bound
      ], StreamListener.prototype, "complete", null);
      __decorate([
          mobx.action.bound
      ], StreamListener.prototype, "error", null);
      return StreamListener;
  })());

  var __assign = function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  var __decorate$1 = function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var RESERVED_NAMES = ["model", "reset", "submit", "isDirty", "isPropertyDirty", "resetProperty"];
  /** @class */ ((function () {
      function ViewModel(model) {
          var _this = this;
          this.model = model;
          this.localValues = mobx.observable.map({});
          this.localComputedValues = mobx.observable.map({});
          this.isPropertyDirty = function (key) {
              return _this.localValues.has(key);
          };
          invariant(mobx.isObservableObject(model), "createViewModel expects an observable object");
          // use this helper as Object.getOwnPropertyNames doesn't return getters
          getAllMethodsAndProperties(model).forEach(function (key) {
              if (key === mobx.$mobx || key === "__mobxDidRunLazyInitializers") {
                  return;
              }
              invariant(RESERVED_NAMES.indexOf(key) === -1, "The propertyname " + key + " is reserved and cannot be used with viewModels");
              if (mobx.isComputedProp(model, key)) {
                  var derivation = mobx._getAdministration(model, key).derivation; // Fixme: there is no clear api to get the derivation
                  _this.localComputedValues.set(key, mobx.computed(derivation.bind(_this)));
              }
              var descriptor = Object.getOwnPropertyDescriptor(model, key);
              var additionalDescriptor = descriptor ? { enumerable: descriptor.enumerable } : {};
              Object.defineProperty(_this, key, __assign(__assign({}, additionalDescriptor), { configurable: true, get: function () {
                      if (mobx.isComputedProp(model, key))
                          return _this.localComputedValues.get(key).get();
                      if (_this.isPropertyDirty(key))
                          return _this.localValues.get(key);
                      else
                          return _this.model[key];
                  }, set: mobx.action(function (value) {
                      if (value !== _this.model[key]) {
                          _this.localValues.set(key, value);
                      }
                      else {
                          _this.localValues.delete(key);
                      }
                  }) }));
          });
      }
      Object.defineProperty(ViewModel.prototype, "isDirty", {
          get: function () {
              return this.localValues.size > 0;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ViewModel.prototype, "changedValues", {
          get: function () {
              return this.localValues.toJS();
          },
          enumerable: false,
          configurable: true
      });
      ViewModel.prototype.submit = function () {
          var _this = this;
          mobx.keys(this.localValues).forEach(function (key) {
              var source = _this.localValues.get(key);
              var destination = _this.model[key];
              if (mobx.isObservableArray(destination)) {
                  destination.replace(source);
              }
              else if (mobx.isObservableMap(destination)) {
                  destination.clear();
                  destination.merge(source);
              }
              else if (!mobx.isComputed(source)) {
                  _this.model[key] = source;
              }
          });
          this.localValues.clear();
      };
      ViewModel.prototype.reset = function () {
          this.localValues.clear();
      };
      ViewModel.prototype.resetProperty = function (key) {
          this.localValues.delete(key);
      };
      __decorate$1([
          mobx.computed
      ], ViewModel.prototype, "isDirty", null);
      __decorate$1([
          mobx.computed
      ], ViewModel.prototype, "changedValues", null);
      __decorate$1([
          mobx.action.bound
      ], ViewModel.prototype, "submit", null);
      __decorate$1([
          mobx.action.bound
      ], ViewModel.prototype, "reset", null);
      __decorate$1([
          mobx.action.bound
      ], ViewModel.prototype, "resetProperty", null);
      return ViewModel;
  })());

  var __extends = (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Reactively sorts a base observable array into multiple observable arrays based on the value of a
   * `groupBy: (item: T) => G` function.
   *
   * This observes the individual computed groupBy values and only updates the source and dest arrays
   * when there is an actual change, so this is far more efficient than, for example
   * `base.filter(i => groupBy(i) === 'we')`. Call #dispose() to stop tracking.
   *
   * No guarantees are made about the order of items in the grouped arrays.
   *
   * The resulting map of arrays is read-only. clear(), set(), delete() are not supported and
   * modifying the group arrays will lead to undefined behavior.
   *
   * NB: ObservableGroupMap relies on `Symbol`s. If you are targeting a platform which doesn't
   * support these natively, you will need to provide a polyfill.
   *
   * @param {array} base The array to sort into groups.
   * @param {function} groupBy The function used for grouping.
   * @param options Object with properties:
   *  `name`: Debug name of this ObservableGroupMap.
   *  `keyToName`: Function to create the debug names of the observable group arrays.
   *
   * @example
   * const slices = observable([
   *     { day: "mo", hours: 12 },
   *     { day: "tu", hours: 2 },
   * ])
   * const slicesByDay = new ObservableGroupMap(slices, (slice) => slice.day)
   * autorun(() => console.log(
   *     slicesByDay.get("mo")?.length ?? 0,
   *     slicesByDay.get("we"))) // outputs 1, undefined
   * slices[0].day = "we" // outputs 0, [{ day: "we", hours: 12 }]
   */
  /** @class */ ((function (_super) {
      __extends(ObservableGroupMap, _super);
      function ObservableGroupMap(base, groupBy, _a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.name, name = _c === void 0 ? "ogm" + ((Math.random() * 1000) | 0) : _c, _d = _b.keyToName, keyToName = _d === void 0 ? function (x) { return "" + x; } : _d;
          var _this = _super.call(this) || this;
          _this._keyToName = keyToName;
          _this._groupBy = groupBy;
          _this._ogmInfoKey = Symbol("ogmInfo" + name);
          _this._base = base;
          for (var i = 0; i < base.length; i++) {
              _this._addItem(base[i]);
          }
          _this._disposeBaseObserver = mobx.observe(_this._base, function (change) {
              if ("splice" === change.type) {
                  mobx.transaction(function () {
                      for (var _i = 0, _a = change.removed; _i < _a.length; _i++) {
                          var removed = _a[_i];
                          _this._removeItem(removed);
                      }
                      for (var _b = 0, _c = change.added; _b < _c.length; _b++) {
                          var added = _c[_b];
                          _this._addItem(added);
                      }
                  });
              }
              else if ("update" === change.type) {
                  mobx.transaction(function () {
                      _this._removeItem(change.oldValue);
                      _this._addItem(change.newValue);
                  });
              }
              else {
                  throw new Error("illegal state");
              }
          });
          return _this;
      }
      ObservableGroupMap.prototype.clear = function () {
          throw new Error("not supported");
      };
      ObservableGroupMap.prototype.delete = function (_key) {
          throw new Error("not supported");
      };
      ObservableGroupMap.prototype.set = function (_key, _value) {
          throw new Error("not supported");
      };
      /**
       * Disposes all observers created during construction and removes state added to base array
       * items.
       */
      ObservableGroupMap.prototype.dispose = function () {
          this._disposeBaseObserver();
          for (var i = 0; i < this._base.length; i++) {
              var item = this._base[i];
              var grouperItemInfo = item[this._ogmInfoKey];
              grouperItemInfo.reaction();
              delete item[this._ogmInfoKey];
          }
      };
      ObservableGroupMap.prototype._getGroupArr = function (key) {
          var result = _super.prototype.get.call(this, key);
          if (undefined === result) {
              result = mobx.observable([], { name: "GroupArray[" + this._keyToName(key) + "]", deep: false });
              _super.prototype.set.call(this, key, result);
          }
          return result;
      };
      ObservableGroupMap.prototype._removeFromGroupArr = function (key, itemIndex) {
          var arr = _super.prototype.get.call(this, key);
          if (1 === arr.length) {
              _super.prototype.delete.call(this, key);
          }
          else if (itemIndex === arr.length - 1) {
              // last position in array
              arr.length--;
          }
          else {
              arr[itemIndex] = arr[arr.length - 1];
              arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;
              arr.length--;
          }
      };
      ObservableGroupMap.prototype._addItem = function (item) {
          var _this = this;
          var groupByValue = this._groupBy(item);
          var groupArr = this._getGroupArr(groupByValue);
          var value = {
              groupByValue: groupByValue,
              groupArrIndex: groupArr.length,
              reaction: mobx.reaction(function () { return _this._groupBy(item); }, function (newGroupByValue, _r) {
                  var grouperItemInfo = item[_this._ogmInfoKey];
                  _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);
                  var newGroupArr = _this._getGroupArr(newGroupByValue);
                  var newGroupArrIndex = newGroupArr.length;
                  newGroupArr.push(item);
                  grouperItemInfo.groupByValue = newGroupByValue;
                  grouperItemInfo.groupArrIndex = newGroupArrIndex;
              }),
          };
          Object.defineProperty(item, this._ogmInfoKey, {
              configurable: true,
              enumerable: false,
              value: value,
          });
          groupArr.push(item);
      };
      ObservableGroupMap.prototype._removeItem = function (item) {
          var grouperItemInfo = item[this._ogmInfoKey];
          this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);
          grouperItemInfo.reaction();
          delete item[this._ogmInfoKey];
      };
      return ObservableGroupMap;
  })(mobx.ObservableMap));
  {
      Promise.resolve();
      if (typeof queueMicrotask !== "undefined") ;
      else if (typeof process !== "undefined" && process.nextTick) ;
      else ;
  }

  const directions$1 = {
      ascending: 1,
      decending: -1
  };

  function order$1(df, order_by = []) {
      if (order_by.length == 0) return df;

      const data = Array.from(df.values());
      const orderNormalized = normalizeOrder(order_by);
      const n = orderNormalized.length;

      data.sort((a,b) => {
          for (var i = 0; i < n; i++) {
              const { concept, direction } = orderNormalized[i];
              if (Array.isArray(direction))
                  return (direction.indexOf(a[concept]) - direction.indexOf(b[concept]));
              if (a[concept] < b[concept])
                  return -1 * direction;
              else if (a[concept] > b[concept])
                  return direction;
          } 
          return 0;
      });

      data.key = df.key;

      return DataFrame(data);
  }

  /**    
   * Process ["geo"] or [{"geo": "asc"}] to [{ concept: "geo", direction: 1 }];
   * @param {} order 
   */
  function normalizeOrder(order_by) {
      if (typeof order_by === "string") 
          return [{ concept: order_by, direction: directions$1.ascending }];
      return order_by.map(orderPart => {
          if (typeof orderPart == "string") {
              return { concept: orderPart, direction: directions$1.ascending };
          }	else {
              const concept = Object.keys(orderPart)[0];
              const direction = Array.isArray(orderPart[concept]) 
                  ? orderPart[concept] 
                  : orderPart[concept] == "asc" 
                      ? directions$1.ascending 
                      : directions$1.decending;
              return { concept, direction };
          }
      });
  }

  function getIter(iter) {
      if ("values" in iter && typeof iter.values === "function")
          return iter.values();
      return iter;
  }

  function isDataFrame(data) {
      return !!(data?.type == 'DataFrame' || data?.type == 'Group')
  }

  function isGroupedDataFrame(data) {
      return !!("descendantKeys" in data && Array.isArray(data.descendantKeys));
  }

  function isIterable$1(obj) {
      return Symbol.iterator in obj;
  }

  // returns true if a and b are identical, regardless of order (i.e. like sets)
  function arrayEquals$1(a, b) {
      const overlap = intersect$1(a, b);
      return overlap.length == a.length && overlap.length == b.length;
  }

  // intersect of two arrays (representing sets)
  // i.e. everything in A which is also in B
  function intersect$1(a, b) {
      return a.filter(e => b.includes(e));
  }

  function isNonNullObject$1(value) {
      return !!value && typeof value === 'object'
  }

  function normalizeKey(key) {
      return key.slice(0).sort();
  }

  const createKeyStr = (key) => normalizeKey(key).map(esc).join(joinchar);
  const joinchar = "¬";

  const dateCache = new Map();
  function dateToCachedString(d) {
      let int = d.getTime();
      if (!dateCache.has(int)) {
          dateCache.set(int, d.toISOString());
      }
      return dateCache.get(int);
  }

  function esc (str) {  
      if (str instanceof Date) return dateToCachedString(str); // .getTime();
      //if (isNumeric(str)) return str;
      //return replace(replace(str, escapechar, dblescape), joinchar, joinescape);
      return str; 
  }

  const createKeyFn = (space) => {
      space = normalizeKey(space);
      const l = space.length;
      return (row) => {
          const parts = [];
          for (let i = 0; i < l; i++) {
              parts[i] = esc(row[space[i]]);
          }
          return parts.join(joinchar);
      }
  };

  // end micro-optimizations

  function pick(object, keys) {
      const result = {};
      for (const key of keys) {
          if (key in object)
              result[key] = object[key];
      }
      return result;
  }
  function pickMultiGroup(object, keys) {
      let result = [{}];
      for (const key of keys) {
          if (key in object) {
              result = [].concat(object[key]).flatMap(objKey => 
                  result.map(res => Object.assign({}, res,{[key]: objKey}))
              );
          }
      }
      return result;
  }

  function unique$2(...arrays) {
      const uniqueSet = new Set(arrays.flat());
      return Array.from(uniqueSet);
  }

  function fullJoin(joinParams, joinKey = normalizeParam(joinParams[0]).dataFrame.key) {
      
      const normalizedParams = normalizeParams(joinParams);
      const result = normalizedParams.reduce(
              _fullJoin, 
              DataFrame([], joinKey)
          );

      // fill unjoined fields with explicit undefined
      const fields = unique$2(normalizedParams.map(param => Object.values(param.projection)).flat(2));
      for (const row of result.values()) {
          for (const field of fields) {
              if (!(field in row))
                  row[field] = undefined;
          }
      }
      return result;

  }

  /**
   * Full join. Impure: Modifies left df. Left key is join key. Right key must contain all join key fields (can't use regular fields for joining).
   * @param {DataFrame} left DataFrame used as base for join
   * @param {*} rightCfg { dataFrame: DataFrame, projection: { origField: [ projFields, ... ] } }
   */
  function _fullJoin(left, rightCfg) {
      // join or copy right rows onto result
      const joinKey = left.key;
      const dataKey = rightCfg.dataFrame.key;
      const projection = rightCfg.projection;

      if (!joinKey.every(dim => rightCfg.dataFrame.fields.includes(dim)))
          console.warn("Right dataFrame does not contain all join fields.", { left, rightCfg });

      if (arrayEquals$1(joinKey, dataKey)) { 
          for (let keyStr of rightCfg.dataFrame.keys()) {
              const rightRow = rightCfg.dataFrame.getByStr(keyStr);
              const leftRow = getOrCreateRow(left, rightRow, keyStr);  
              // project with aliases        
              for(let key in projection) {
                  for (let field of projection[key]) {
                      leftRow[field] = rightRow[key];
                  }
              }
          }
      } else {
          const keyFn = createKeyFn(joinKey);
          for (let keyStr of rightCfg.dataFrame.keys()) {
              const rightRow = rightCfg.dataFrame.getByStr(keyStr);
              const leftKeyStr = keyFn(rightRow);
              const leftRow = getOrCreateRow(left, rightRow, leftKeyStr);  
              // project with aliases        
              for(let key in projection) {
                  for (let field of projection[key]) 
                      leftRow[field] = rightRow[key];
              }
          }
      }

      return left;
  }

  // change array ["geo","year"] to { geo: [ "geo" ], year: [ "year" ] }
  function normalizeParams(params) {
      return params
          .map(normalizeParam)
          .reduce((params, param) => {
              const baseParam = params.find(baseParam => baseParam.dataFrame === param.dataFrame);
              if (baseParam)
                  mergeProjections(baseParam, param);
              else
                  params.push(param);
              return params;
          }, []);
  }

  function normalizeParam(param) {
      if (isDataFrame(param))
          param = { dataFrame: param };

      if (!("projection" in param))
          param.projection = relativeComplement(param.dataFrame.key, param.dataFrame.fields);

      if (!Array.isArray(param.projection))
          return param;
      
      param.projection = param.projection.reduce((obj, field) => {
          obj[field] = [ field ];
          return obj;
      }, {});
      return param;
  }

  function mergeProjections(destParam, sourceParam) {
      for (const [sourceField, destFields] of Object.entries(sourceParam.projection)) {
          if (sourceField in destParam.projection) 
              destParam.projection[sourceField].push(...destFields);
          else   
              destParam.projection[sourceField] = destFields;
      }
  }

  function createObj(space, row, keyStr) {
      const obj = {
          [Symbol.for('key')]: keyStr
      };
      space.forEach(dim => obj[dim] = row[dim]);
      return obj;
  }

  function getOrCreateRow(df, row, keyStr) {
      let obj;

      obj = df.getByStr(keyStr);
      if (obj === undefined) {
          obj = createObj(df.key, row, keyStr);
          df.set(obj, keyStr);
      }
      
      return obj;
  }

  function MapStorage(data = [], keyArr = data.key || []) {
      
      const storage = createEmptyMap();
      storage.key = keyArr;
      storage.batchSet(data);

      return storage;
  }

  function createEmptyMap() {
      const storage = new Map();
      let key = [];

      // local references to functions which will be decorated
      const has = storage.has.bind(storage);
      const get = storage.get.bind(storage);
      const set = storage.set.bind(storage);

      Object.defineProperty(storage, 'fields', { 
          get: function () { 
              return unique$2(storage.key, Object.keys(storage.values().next().value ?? {}) ?? [])
          }
      });  
      storage.setKey = newKey => {
          key = normalizeKey(newKey);
          storage.incrementIndex = storage.key.length === 0; 
          storage.keyFn = storage.incrementIndex ? () => storage.size : createKeyFn(storage.key);
          storage.updateIndexes();
      };
      Object.defineProperty(storage, 'key', { 
          set: storage.setKey,
          get: () => key
      });    
      storage.has = key => storage.incrementIndex || typeof key == 'string' ? has(key) : has(storage.keyFn(key));
      storage.get = key => {
          key = storage.incrementIndex || typeof key == 'string' ? key : storage.keyFn(key);
          
          //if (!has(key))
          //    throw(new Error('Key not found in dataframe: ' + JSON.stringify(keyObj)))
          return get(key);
      };
      storage.set = (row, keyStr) => {
          // passing keyStr is optimization to circumvent keyStr generation (TODO: check performance impact)
          // if keyStr set, we assume it's correct. Only use when you know keyStr fits with current key dims
          if (keyStr === undefined || storage.incrementIndex) {
              keyStr = storage.keyFn(row);
              row[Symbol.for('key')] = keyStr;
          }
          set(keyStr, row);
      };
      storage.setByStr = set;
      storage.hasByStr = has;
      storage.getByStr = get;
      storage.hasByObjOrStr = (keyObj, keyStr) => has(keyStr);
      storage.getByObjOrStr = (keyObj, keyStr) => get(keyStr);
      storage.batchSet = data => batchSet(storage, data);
      storage.rows = storage.values;
      storage.updateIndexes = () => updateIndexes(storage);

      storage.setKey(key);
      return storage;
  }

  function batchSet(storage, data) {

      const iter = getIter(data);

      if (!storage.incrementIndex) {

          let keyStr;
          const duplicates = [];
          const keyFn = Array.isArray(data.key) && arrayEquals$1(storage.key, data.key)
              ? row => row[Symbol.for('key')]
              : row => row[Symbol.for('key')] = storage.keyFn(row);

          for (let row of iter) {
              keyStr = keyFn(row);
              if (storage.hasByStr(keyStr))
                  duplicates.push({ keyStr, orig: storage.getByStr(keyStr), new: row});
              storage.setByStr(keyStr, row);
          }

          if (duplicates.length > 0)
              console.warn('Found duplicates for given key when constructing dataframe.', { key: storage.key, duplicates });

      } else {
          for (let row of iter) {
              storage.set(row);
          }
      }

  }

  function updateIndexes(storage) {
      for (let [key, row] of storage) {
          storage.delete(key);
          // set won't overwrite any not-yet-deleted keys 
          // because key dims are either different 
          // or if they're identical, we just removed the key it would overwrite
          storage.set(row); 
      }
  }

  /**
   * Virtual data frame storage based on lookups. A row is constructed on request from lookups for each dimension of requested key.
   * @param {*} concepts Map of concepts. Each concept is a map of dimensions. Each dimension is a map of values on that dimension. E.g. name=>geo=>swe=>Sweden
   */
  function LookupStorage(concepts, keyArr) {
      const storage = {};
      storage.key = keyArr = normalizeKey(keyArr);
      storage.fields = new Set([...keyArr, ...concepts.keys()]);
      storage.data = concepts;
      storage.has = (keyObj) => {
          // true if there is at least one concept which has a lookup for every dimension in key
          // i.e. a row can be returned for this key
          return true; //[...concepts.values()].some(lookups => keyArr.every(dim => dim in keyObj && lookups.has(dim)));
      };    
      /**
      * Given a key like 
      * { 
      *      geo: 'swe', 
      *      gender: 'fem' 
      * } 
      * Returns e.g. 
      * { 
      *      name: { 
      *          geo: 'Sweden', 
      *          gender: 'Female' 
      *      }, 
      *      description: { 
      *          geo: 'foo', 
      *          gender: 'bar' 
      *      }
      *  }
      */
      storage.get = (keyObj) => {
          const row = {};
          concepts.forEach((lookups, concept) => {
              const entityProps = {};
              keyArr.forEach(dim => {
                  if (lookups.has(dim))
                      entityProps[dim] = lookups.get(dim).get(keyObj[dim]) ?? keyObj[dim];
                  else
                      entityProps[dim] = keyObj[dim];
              });
              row[concept] = entityProps;
          });
          return row;
      };
      storage.hasByObjOrStr = (keyObj, keyStr) => storage.has(keyObj);
      storage.getByObjOrStr = (keyObj, keyStr) => storage.get(keyObj);
      storage.set = (keyObj, value) => { 
          console.warn("Invalid operation. Generated dataframe does not support .set().");
      };
      storage.values = () => { console.warn("Generated dataframe .values() not implemented yet");};
      storage.delete = () => { console.warn("Invalid operation. Generated dataframe does not support .delete()");};
      storage[Symbol.iterator] = function* generate() {
          console.warn("Invalid operation. Generated dataframe iterator not yet implemented.");
      }; 
      return storage;
  }

  function copyColumn(df, srcCol, newCol) {
      for (let row of df.values()) {
          row[newCol] = row[srcCol];
      }
      return df;
  }

  // TODO: add check for non-marker space dimensions to contain only one value
          // -> save first row values and all next values should be equal to first

  /**
   * Join right on left with overlapping columns of key as join columns.
   * @param {*} left 
   * @param  {...any} rights 
   */
  function leftJoin(left, rights) {
      const leftDf = left.dataFrame;
      const leftKey = leftDf.key;

      rights = normalizeParams(rights);
      rights.forEach(r => { 
          r.sameKey = arrayEquals$1(r.dataFrame.key, leftKey);
      });

      const result = DataFrame([], leftKey);

      for (let keyStr of leftDf.keys()) {
          const row = leftDf.getByStr(keyStr);
          // left row as base
          const leftRow = cloneRow(row);
          
          // join any rows in right dfs which have same key as left row
          for (let r of rights) {
              const rightRow = r.sameKey 
                  ? r.dataFrame.getByStr(keyStr) 
                  : r.dataFrame.get(row);
                  
              for(let key in r.projection) {
                  for (let field of r.projection[key]) 
                      leftRow[field] = rightRow[key];
              }
          }
          
          // set row
          result.set(leftRow, keyStr);
      }
      return result;
  }

  function joinRows(...rows) {
      return Object.assign(...rows);
  }
  function cloneRow(row) {
      return joinRows({}, row);
  }

  // use projection feature of full join
  const project = (df, projection) => fullJoin([{ dataFrame: df, projection: projection }]);

  /**
   * Adds column to df, in place
   * @param {DataFrame} df 
   * @param {string} name 
   * @param {value|function} value 
   */
  function addColumn(df, name, value) {
      if (typeof value == "function") {
          for (let row of df.values()) {
              row[name] = value(row);
          }
      }
      else {    
          for (let row of df.values()) {
              row[name] = value;
          }
      }
      return df;
  }

  /**
   * Get extent (i.e. domain) of a property in an iterable of objects or an iterable nested in a dataFrameGroup. Possibly grouped by a certain other property value, which can be limited to a subset.
   * @param {*} iter 
   * @param {String} concept 
   * @param {String} groupby 
   * @param {[String]} groupSubset 
   * @returns An `[min, max]` array or an object with groupby values as properties and `[min, max]` arrays as values.
   */
  function extent(iter, concept, groupby, groupSubset) {
      if (isGroupedDataFrame(iter))
          return extentGroups(...arguments);
      else 
          return extentIterable(...arguments);
  }

  function extentGroups(groups, concept, groupBy, groupSubset) {

      return [...getIter(groups)]
          .map(group => extent(group, concept, groupBy, groupSubset))
          .reduce(combineResults);
  }
   
  function combineResults(one, two) {
      if (Array.isArray(one))
          return [Math.min(one[0], two[0]), Math.max(one[1], two[1])];
      else {
          for (let key in two) {
              if (!(key in one))
                  one[key] = two[key];
              else
                  one[key] = combineResults(one[key], two[key]);
          }
          return one;
      }
          
  }

  // in the style of d3.extent
  function extentIterable(iter, concept, groupby, groupSubset) {
      iter = getIter(iter);
      let row;

      if (groupby) {
          groupSubset = groupSubset ? Array.from(groupSubset) : groupSubset;
          let keyFn = Array.isArray(groupby) ? createKeyFn(groupby) : undefined;
          let groups = {};
          for (row of iter) {
              const group = keyFn(row);
              if (groupSubset && !groupSubset.includes(group))
                  continue;
              if (!groups[group]) groups[group] = [];
              groups[group] = minmax(row[concept], groups[group]);
          }
          return groups
      } else {
          let minmaxArr = [];
          for (row of iter) {
              minmaxArr = minmax(row[concept], minmaxArr);
          }
          return minmaxArr;
      }
  }

  /**
   * Faster extent algorithm for specific grouped dataframes which satisfy:
   *  - grouping by `concept` you want to get extent of (e.g. frame concept)
   *  - each group has `groupBy` as its key (e.g. country-gender)
   *  - grouping is ordered by `concept`
   *  - grouping is interpolated. I.e. every group between min-max contains `groupBy` (e.g. each frame between 2000-2019 contains 'country-usa').
   *  - groupSubSet is given.
   * 
   * Can be used for finding frame-extents of specific markers in frameMap for e.g. trails or timeslider limits
   * @param {*} groups 
   * @param {*} concept 
   * @param {*} groupBy 
   * @param {*} groupSubset 
   * @returns 
   */
   function extentOfGroupKeyPerMarker(group, groupSubset, concept = group.key[0], groupBy = group.descendantKeys[0]) {
          
      if (!isGroupedDataFrame(group)) throw("iterable is not a grouped dataframe");
      const descKeys = group.descendantKeys;
      if (!arrayEquals$1(group.key, [concept])) throw("grouping is not by given concept");
      if (descKeys.length != 1) throw("grouping is more than 1 level deep");
      if (!arrayEquals$1(descKeys[0], groupBy)) throw("grouping members keys is not same as `groupBy`");
      if (!isIterable$1(groupSubset)) throw("groupSubset iterable not given.");
      // can't O(1) check ordering & interpolation requirements

      const extents = {};
      for (let groupValue of groupSubset) {
          
          let min, max, member;
          
          for (member of group.values()) { // each frame
              if (member.hasByStr(groupValue)) { // if frame contains marker
                  if (min === undefined) {
                      min = member;
                  }
                  max = member; // ordered frames, so any subsequent frame is higher
              } else if (min) {
                  break; // marker missing, interpolated & ordered frames so won't find marker later either. This is max.
              }
          }

          extents[groupValue] = [min, max].map(member => member?.getByStr(groupValue)[concept]);
      }
      return extents;
  }

  function extentOfGroupKey(group) {
      if (group.key.length > 1) throw("Can't get group key extent if key size is > 1")

      let keyConcept = group.key[0];
      let minmaxArr = [];
      group.each((member) => {
          const keyObj = group.keyObject(member);
          minmaxArr = minmax(keyObj[keyConcept], minmaxArr);
      });
      return minmaxArr;
  }

  function extentIndicesOfGroupKey(group, { filter = () => true }) {
      if (group.key.length > 1) throw("Can't get group key extent if key size is > 1")
      
      let keyConcept = group.key[0];
      let i = 0, mini, maxi;
      let min, max;
      group.each((member) => {
          if (filter(member)) {
              const value = group.keyObject(member)[keyConcept];
              if (value != null) {
                  if (min === undefined) {
                      // find first comparable values
                      if (value >= value) { min = max = value; mini = maxi = i; }                } else {
                      // compare remaining values 
                      if (min > value) { min = value; mini = i; }                    if (max < value) { max = value; maxi = i; }                }
              }
          }
          i++;
      });
      return [mini, maxi];
  }

  function minmax(value, [min, max]) {
      
      if (value != null) {
          if (min === undefined) {
              // find first comparable values
              if (value >= value) min = max = value;
          } else {
              // compare remaining values 
              if (min > value) min = value;
              if (max < value) max = value;
          }
      }
      return [min, max]
  }

  function extrapolateGroup(group, options) {
      const { fields = group.fields, sizeLimit, indexLimit, ammendNewRow = r => r } = options;
      const frameKeys = [...group.keys()];
      // limits extrapolation to certain range, used by frame to limit to future filterRequired result
      const [firstIndex, lastIndex] = indexLimit ?? [0, frameKeys.length - 1]; 

      const groupFields = group.values().next().value.fields;
      const copyFields = relativeComplement(fields, groupFields);
      copyFields.push(Symbol.for('key'));

      function copyOrCreate(member, rowKey, sourceMarker) {
          let extraRow = member.getByStr(rowKey);
          if (extraRow !== undefined) {
              if (!(Symbol.for('extrapolated') in extraRow)) { 
                  // not yet copied, so copy
                  extraRow = assign({}, extraRow); 
                  extraRow[Symbol.for('extrapolated')] = {};
                  member.setByStr(rowKey, extraRow);
              }
          } else {
              extraRow = Object.assign(pickGetters(sourceMarker, copyFields), group.keyObject(member));
              ammendNewRow(extraRow);
              extraRow[Symbol.for('extrapolated')] = {};
              member.setByStr(rowKey, extraRow);
          }
          return extraRow;
      }

      const newGroup = group.copy();

      for (const field of fields) {
          const lastIndices = new Map();
          for (let idx = firstIndex; idx < lastIndex + 1; idx++) {
              const frameKey = frameKeys[idx];
              const frame = newGroup.get(frameKey);
              for (const markerKey of frame.keys()) {
                  const marker = frame.getByStr(markerKey);
                  if (marker[field] != null) {
                      if (!lastIndices.has(markerKey) && idx > 0) {
                          // first occurence, extrapolate backwards
                          const fromIdx = Math.max(firstIndex, idx - sizeLimit);
                          const frames = getFrames(newGroup, fromIdx, idx, frameKeys);
                          doExtrapolate(frames, marker, field, copyOrCreate);
                      }
                      // keep track of last occurence
                      lastIndices.set(markerKey, idx);
                  }
              }
          }
          for (const markerKey of lastIndices.keys()) {
              const lastSeenIndex = lastIndices.get(markerKey);
              if (lastSeenIndex === lastIndex)
                  continue;
              const sourceFrame = newGroup.get(frameKeys[lastSeenIndex]);
              const fromIdx = Math.min(lastIndex + 1, lastSeenIndex + 1);
              const toIdx = Math.min(lastIndex + 1, fromIdx + sizeLimit);
              const frames = getFrames(newGroup, fromIdx, toIdx, frameKeys);
              const sourceMarker = sourceFrame.getByStr(markerKey);
              doExtrapolate(frames, sourceMarker, field, copyOrCreate);
          }
      }

      return newGroup;
  }

  function getFrames(group, fromIdx, toIdx, frameKeys) {
      const frames = [];
      for (let i = fromIdx; i < toIdx; i++) {
          frames.push(group.get(frameKeys[i]));
      }
      return frames;
  }

  function doExtrapolate(frames, sourceMarker, field, copyOrCreate) {
      const markerKey = sourceMarker[Symbol.for('key')];
      for (const extraMember of frames) {
          const extraMarker = copyOrCreate(extraMember, markerKey, sourceMarker);
          extraMarker[field] = sourceMarker[field];
          extraMarker[Symbol.for('extrapolated')][field] = sourceMarker;
      }
  }

  /**
   * Interpolate within a dataframe. Fill missing values in rows. Inplace.
   * @param {*} df 
   */
  function interpolate(df, fields = df.fields, interpolators = {}) {
      for (let field of fields) {
          interpolateField(df, field, interpolators[field]);
      }
      return df;
  }

  function interpolateField(df, field, interpolator) {
      const gap = newGap();
      for (let row of df.values()) {
          evaluateGap(row, field, gap, interpolator);
      }
  }

  function newGap() {
      return {
          start: undefined,
          rows: []
      }
  }

  function evaluateGap(row, field, gap, interpolator) {
      const { rows, start } = gap;
      const fieldVal = row[field];
      if (fieldVal == null) { // faster for undefined/null check
          if (start !== undefined)
              rows.push(row);
      } else {
          // fill gap if it exists and is inner
          if (rows.length > 0) {
              interpolateGap(rows, start, row, field, interpolator);
              rows.length = 0;
          }
          gap.start = row;
      }
  }

  function interpolateGap(gapRows, startRow, endRow, field, interpolator = d3$1.interpolate) {
      const startVal = startRow[field];
      const endVal = endRow[field];
      const int = interpolator(startVal, endVal);
      const delta = 1 / (gapRows.length+1);
      let mu = 0;
      for (let gapRow of gapRows) {
          mu += delta;
          gapRow[field] = int(mu);
          if (!(Symbol.for('interpolated') in gapRow))
              gapRow[Symbol.for('interpolated')] = {};
          gapRow[Symbol.for('interpolated')] = { [field]: [startRow, endRow] };
      }
  }


  function interpolateGroup(group, { fields = group.fields, frameField = "", frameCopyFields = [], interpolators = {}, ammendNewRow = () => {} } = {}) {
      
      // what fields to interpolate?
      const groupFields = group.values().next().value.fields;
      const copyFields = relativeComplement(fields, groupFields).filter(f => !frameCopyFields.includes(f));
      copyFields.push(Symbol.for('key'));

      //console.time('interpolate');
      const frameKeys = [...group.keys()];
      const numFrames = frameKeys.length;
      for (const field of fields) {
          const lastIndexPerMarker = new Map();
          for (let i = 0; i < numFrames; i ++) {
              const frame = group.get(frameKeys[i]);                  
              for (const markerKey of frame.keys()) {
                  const marker = frame.getByStr(markerKey);
                  if (marker[field] != null) {
                      const lastIndex = lastIndexPerMarker.get(markerKey);
                      if (lastIndex !== undefined && (i - lastIndex) > 1) {
                          const gapRows = []; // d3_range(lastIndex + 1, i).map(i => group.get(frameKeys[i]))
                          for (let j = lastIndex + 1; j < i; j++) {
                              const gapFrame = group.get(frameKeys[j]);
                              let gapRow = gapFrame.get(markerKey);
                              if (gapRow === undefined) {
                                  gapRow = Object.assign(pickGetters(marker, copyFields), group.keyObject(gapFrame));
                                  for (let frameCopyField of frameCopyFields) gapRow[frameCopyField] = gapRow[frameField];
                                  ammendNewRow(gapRow);
                                  gapRow[Symbol.for('interpolated')] = {};
                                  gapFrame.setByStr(markerKey, gapRow);
                              } else {
                                  if (!(Symbol.for('interpolated') in gapRow)) {
                                      gapRow = assign({}, gapRow);
                                      gapRow[Symbol.for('interpolated')] = {};
                                      gapFrame.setByStr(markerKey, gapRow);
                                  }
                              }
                              gapRows.push(gapRow);
                          }
                          const startRow = group.get(frameKeys[lastIndex]).get(markerKey);
                          const endRow = group.get(frameKeys[i]).get(markerKey);
                          interpolateGap(gapRows, startRow, endRow, field, interpolators[field]);
                      }
                      lastIndexPerMarker.set(markerKey, i);
                  }
              }
          }
          //console.log('finished interpolating field', field);
          //console.timeLog('interpolate');
      }
      //console.timeEnd('interpolate');
      return group;
  }

  // TODO: add check if there are rows that are don't fit stepfn 
  // (iterate over df and match one step of stepfn with step of iteration)
  function reindex(df, index) {
      const empty = createEmptyRow(df.fields);
      const result = DataFrame([], df.key);
      const keyConcept = df.key[0]; // supports only single indexed
      for (let key of index) {
          const keyObj = { [keyConcept]: key };
          const keyStr = df.keyFn(keyObj);
          const row = df.hasByStr(keyStr)
              ? df.getByStr(keyStr)
              : Object.assign({ }, empty, keyObj);
          result.setByStr(keyStr, row);
      }
      return result;
  }

  function createEmptyRow(fields) {
      const obj = {};
      for (let field of fields) obj[field] = null;
      return obj;
  }

  function reindexGroup(group, index) {
      const newGroup = DataFrameGroup([], group.key, group.descendantKeys);
      for (let i of index) {
          const keyObj = { [newGroup.key[0]]: i };
          const keyStr = newGroup.keyFn(keyObj);
          if (group.has(keyStr)) {
              let member = group.get(keyStr);
              newGroup.set(keyObj, member);
          } else {
              newGroup.createMember(keyObj);
          }
      }
      return newGroup;
  }

  function reindexGroupToKeyDomain(group, intervalSize) {
      if (group.size > 1) {
          const domain = group.keyExtent();
          const newIndex = inclusiveRange(domain[0], domain[1], intervalSize);
          group = reindexGroup(group, newIndex);
      }
      return group;
  }

  function DataFrameMultiGroup(data, key, descKeys = []) {

      if (!Array.isArray(descKeys)) descKeys = [[descKeys]]; // desc keys is single string (e.g. 'year')
      if (!Array.isArray(descKeys[0])) descKeys = [descKeys]; // desc keys is one key (e.g. ['year'])
      if (!Array.isArray(key)) key = [key]; // key is single string (e.g. 'year')
      if (descKeys.length === 0 && data.key) descKeys = [data.key];  // descKeys is empty
      
      const group = createGroup(key, descKeys);
      group.setRow = (row, key) => {
          return getDataFrameMultiGroup(group, row).map(df => df.set(row, key));
      };
      group.batchSetRow = (data) => {
          const descKeys = group.descendantKeys;
          if (data.key?.length > 0 && arrayEquals$1(data.key, descKeys[descKeys.length - 1])) {
              for (let row of data.values()) {
                  getDataFrameMultiGroup(group, row).forEach(df => df.setByStr(row[Symbol.for('key')], row));
              }
          } else {
              for (let row of data.values()) {
                  getDataFrameMultiGroup(group, row).forEach(df => df.set(row));
              }
          }
          return group;
      };

      return group.batchSetRow(data);
  }

  function getDataFrameMultiGroup(group, row) {
      if (group.type == 'DataFrame') return [group];
      let members;
      if (!row) {
          members = [group.values().next().value];
      } else {
          members = pickMultiGroup(row, group.key).map(keyObj => {
              const keyStr = group.keyFn(keyObj);
              if (group.has(keyStr)) {
                  return group.get(keyStr);
              } else {
                  return group.createMember(keyObj);
              }
          });
      }
      return members.flatMap(member => getDataFrameMultiGroup(member, row));
  }


  /**
   * 
   * @param {*} df DataFrame from which to create groups
   * @param {*} key key by which is grouped
   * @param {*} descKeys keys of members and their descendants
   */
  function DataFrameGroup(data, key, descKeys = []) {

      if (!Array.isArray(descKeys)) descKeys = [[descKeys]]; // desc keys is single string (e.g. 'year')
      if (!Array.isArray(descKeys[0])) descKeys = [descKeys]; // desc keys is one key (e.g. ['year'])
      if (!Array.isArray(key)) key = [key]; // key is single string (e.g. 'year')
      if (descKeys.length === 0 && data.key) descKeys = [data.key];  // descKeys is empty
      
      return createGroup(key, descKeys)
          .batchSetRow(data);
  }

  function createGroup(key, descendantKeys) {
      const group = new Map();
      const keyObjects = new WeakMap();
      const set = group.set.bind(group);

      group.type = 'Group';
      group.key = key;
      group.keyObject = member => keyObjects.get(member);
      group.keyFn = createKeyFn(key);
      group.descendantKeys = descendantKeys;
      group.each = (fn) => each(group, fn);
      group.map = (fn) => map(group, fn);
      // group.mapCall = (fn) => mapCall(group, fn); // not exposing mapcall
      group.interpolate = mapCall(group, "interpolate");
      group.filter = mapCall(group, "filter");
      group.filterNullish = mapCall(group, "filterNullish");
      group.order = mapCall(group, "order");
      group.reindex = mapCall(group, "reindex");
      group.interpolate = mapCall(group, "interpolate");
      group.extrapolate = mapCall(group, "extrapolate");
      group.reindexGroup = index => reindexGroup(group, index);
      group.reindexToKeyDomain = intervalSize => reindexGroupToKeyDomain(group, intervalSize);
      group.interpolateOverMembers = options => interpolateGroup(group, options);
      group.extrapolateOverMembers = options => extrapolateGroup(group, options);
      group.copy = () => group.map(member => member.copy());
      group.flatten = (key) => flatten(group, key);
      group.extent = (concept, groupBy, groupSubset) => extent(group, concept, groupBy, groupSubset),
      group.keyExtent = () => extentOfGroupKey(group);
      group.keyExtentIndices = options => extentIndicesOfGroupKey(group, options);
      group.extentOfGroupKeyPerMarker = (groupSubset) => extentOfGroupKeyPerMarker(group, groupSubset),
      group.groupBy = (key) => {
          for (let [keyStr, member] of group) {
              const keyObj = group.keyObject(member);
              const newMember = member.groupBy(key);

              // groups change from DataFrame to group
              if (member.type === 'DataFrame')
                  group.set(keyObj, newMember);
          }
          group.descendantKeys.push(key);
          return group;
      };
      group.createMember = (keyObj) => createMember(group, keyObj);
      group.toJSON = () => mapToObject(group);
      group.rows = function* () {
          let member, row; 
          for (member of group.values()) {
              for (row of member.rows()) // get rows recursively
                  yield row;
          }
      };
      group.filterGroups = (filterFn, inplace = false) => {
          let result = inplace ? group : DataFrameGroup([], group.key, group.descendantKeys);
          for (let [key, member] of group) {
              const keyObj = group.keyObject(member);
              const newMember = member.filterGroups(filterFn, inplace);
              const filterApplies = filterFn(newMember, key);
              if (!inplace && filterApplies)
                  result.set(keyObj, newMember);
              if (inplace && !filterApplies) 
                  result.delete(key);
          }
          return result;
      };
      group.set = (keyObj, member) => {
          keyObjects.set(member, keyObj);
          const keyStr = group.keyFn(keyObj);
          return set(keyStr, member);
      };
      group.setRow = (row, key) => {
          return getDataFrame(group, row)
              .set(row, key);
      };
      group.batchSetRow = (data) => {
          const descKeys = group.descendantKeys;
          if (data.key?.length > 0 && arrayEquals$1(data.key, descKeys[descKeys.length - 1])) {
              for (let row of data.values()) {
                  getDataFrame(group, row)
                      .setByStr(row[Symbol.for('key')], row);
              }
          } else {
              for (let row of data.values()) {
                  getDataFrame(group, row)
                      .set(row);
              }
          }
          return group;
      };
      return group;
  }

  function each(group, fn) {
      for (let [keyStr, member] of group) {
          fn(member, keyStr, group);
      }
      return group;
  }

  function map(group, fn) {
      let result = DataFrameGroup([], group.key, group.descendantKeys);
      for (let [keyStr, member] of group) {
          const keyObj = group.keyObject(member);
          result.set(keyObj, fn(member, keyStr, group));
      }
      return result;
  }

  function mapCall(group, fnName) {
      return function() {
          let result = DataFrameGroup([], group.key, group.descendantKeys);
          for (let [keyStr, member] of group) {
              const keyObj = group.keyObject(member);
              result.set(keyObj, member[fnName](...arguments));
          }
          return result;
      }
  }

  /**
   * 
   * @param {*} group the group to find dataframe in
   * @param {*} row data row to find dataframe for
   */
  function getDataFrame(group, row) {
      if (group.type == 'DataFrame') return group;
      let member;
      if (!row) {
          member = group.values().next().value;
      } else {
          const keyObj = pick(row, group.key);
          const keyStr = group.keyFn(keyObj);
          if (group.has(keyStr)) {
              member = group.get(keyStr);
          } else {
              member = group.createMember(keyObj);
          }
      }
      return getDataFrame(member, row);
  }

  function createMember(group, keyObj) {
      // DataFrames have no children of their own (= leafs)
      const newMember = group.descendantKeys.length === 1
          ? DataFrame([], group.descendantKeys[0])
          : DataFrameGroup([], group.descendantKeys[0], group.descendantKeys.slice(1));
      
      group.set(keyObj, newMember);
      return newMember;
  }

  function flatten(group, result) {
      for (let member of group.values()) {
          if (member.type == 'Group') {
              result = flatten(member, result);
          } else {
              if (!result)
                  result = DataFrame(member, member.key);
              else 
                  result.batchSet(member);
          }
      } 
      return result;
  }

  function groupBy(df, groupKey, memberKey = df.key) {

      return DataFrameGroup(df, groupKey, memberKey);
      
  }

  function groupByWithMultiGroupMembership(df, groupKey, memberKey = df.key) {

      return DataFrameMultiGroup(df, groupKey, memberKey);
      
  }

  function fillNull(df, fillValues) {
      let concept, row;
      // per concept fill
      if (isNonNullObject$1(fillValues)) {
          for (concept in fillValues) {
              const fillValue = fillValues[concept];
              // per concept function fill
              if (typeof fillValue == "function") {
                  for (row of df.values()) {
                      if (row[concept] === null)
                          row[concept] = fillValue(row);
                  }
              }
              // per concept constant fill
              else {
                  for (row of df.values()) {
                      if (row[concept] === null)
                          row[concept] = fillValue;
                  }
              }
          }
      }
      // constant fill
      else {
          for (row of df.values()) {
              for (concept in row) {
                  if (row[concept] === null)
                      row[concept] = fillValues;
              }
          }
      }
      return df;
  }

  function unique$1(iter, concept) {
      iter = getIter(iter);
      
      const unique = new Set();
      for (let row of iter) 
          unique.add(row[concept]); 

      return [...unique];
  }

  const copy = df => DataFrame(df);

  /*
    "Differentiate" a given field in this dataframe.
  */
  function differentiate(df, xField = 'x', yField = 'time') {
    let prevX;
    for (let row of df.values()) {
      const difference = prevX ? row[xField] - prevX : 0;
      prevX = row[xField];
      row[xField] = difference;
    }
    return df;
  }

  /**
   * Interplate between two DataFrames
   * @param {*} from 
   * @param {*} to 
   * @param {*} mu 
   */
  function interpolateBetween(from, to, mu, fields = from.fields, interpolators = {}) {
      const df = DataFrame([], from.key);

      let newRow, row2;
      for(const key of from.keys()) {
          const row1 = from.getByStr(key);
          row2 = to.getByStr(key);
          if (!row2) continue;
          if (row2 !== row1) { // same object, depends on trails using same object for trail markers across frames.
              newRow = Object.assign({}, row1);
              for (let field of fields) {
                  newRow[field] = (interpolators[field] || defaultInterpolator)(row1[field], row2[field])(mu);
              }
          } else {
              newRow = row1;
          }   
          df.set(newRow, newRow[Symbol.for('key')]);
      }
      return df;
  }

  function defaultInterpolator(a, b) {
      //d3.interpolate infers the interpolator type from the type of B
      //if a number A tries to interpolate towards undefined value B we would get undefined, as expected
      //but if an undefined value A tries to interpolate towards number B we would get a NaN, which can cause errors
      //this ensures the result is also undefined for the second case
      if ((a == null || isNaN(a)) && typeof b === "number")
          return () => undefined;
      else
          return d3$1.interpolate(a, b);
  }

  const fromLookups = (concepts, key) => constructDataFrame(LookupStorage(concepts, key));
  const fromArray = (data = [], key = data.key || []) => constructDataFrame(MapStorage(data, key));

  const DataFrame = fromArray;
  DataFrame.fromLookups = fromLookups;
  DataFrame.fromArray = fromArray;

  function constructDataFrame(storage) {
      // https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381
      // compose storage and DF methods by concatenation 
      // concatenation instead of aggregation/delegation as there is no overlap in keys and 
      // we want the full storage API to be available on the DataFrame
      const df = Object.assign(storage,
          {        
              // transforms
              order: (direction) => order$1(df, direction), 
              leftJoin: (joinParams) => leftJoin({ dataFrame: df }, joinParams),
              fullJoin: (joinParams, key) => fullJoin([df, ...joinParams], key),
              copyColumn: (src, dest) => copyColumn(df, src, dest),
              filter: (filterObj) => filter$1(df, filterObj),
              filterNullish: (fields) => filterNullish(df, fields),
              project: (projection) => project(df, projection),
              addColumn: (name, value) => addColumn(df, name, value),
              groupBy: (groupKey, memberKey) => groupBy(df, groupKey, memberKey),
              groupByWithMultiGroupMembership: (groupKey, memberKey) => groupByWithMultiGroupMembership(df, groupKey, memberKey),
              interpolate: () => interpolate(df),
              interpolateTowards: (df2, mu, fields, interpolators) => interpolateBetween(df, df2, mu, fields, interpolators),
              reindex: (iterable) => reindex(df, iterable),
              fillNull: (fillValues) => fillNull(df, fillValues),
              copy: () => copy(df),
              differentiate: (xField) => differentiate(df, xField),
      
              // info
              extent: (concept, groupBy, groupSubset) => extent(df, concept, groupBy, groupSubset),
              unique: (concept) => unique$1(df, concept),
              type: 'DataFrame',
          
              // export
              toJSON: () => [...df.values()]
          },
          {
              filterGroups: (filterFn, inplace = false) => {
                  return inplace ? df : df.copy();
              },
              setRow: (row, keyStr) => df.set(row, keyStr)
          }
      );

      return df;
  }

  /**
   * Filters dataframe based on either filter function or DDFQL filter specification
   * @param {DataFrame} df 
   * @param {Function|FilterSpec} filter 
   */
  function filter$1(df, filter) {

      if (!validFilterArg(filter))
          return df;

      const filterFn = (typeof filter == "function") ? 
          filter : createFilterFn(filter);    

      const result = DataFrame([], df.key);
      for(let key of df.keys()) {
          const row = df.getByStr(key);
          if (filterFn(row))
              result.set(row, key);
      }

      return result;
  }

  function validFilterArg(filter) {
      return filter && (typeof filter === "function" || Object.keys(filter).length > 0)
  }

  /**
   * Create a function, given a filter spec
   * @param {Object} filterSpec Filter specification according to DDFQL WHERE spec
   * @returns {Function} Filter function, which takes an object and returns a boolean representing if the object satifies the filterSpec
   */
  function createFilterFn(filterSpec = {}) {
      let fn = 'return ';
      fn += createFilterFnString(filterSpec);
      fn += ';';
      return new Function('row', fn);
  }

  function normalizeFilter(filterSpec) {
      
      filterSpec = deepclone(filterSpec);
      filterSpec = implicitAnd(filterSpec);
      filterSpec = implicitEq(filterSpec);

      return filterSpec;

      function implicitAnd(filter) {
          const keys = Object.keys(filter);
          if (keys.length > 1) {
              return { $and: 
                  keys.map(key => ({ [key]: filter[key] }))
              };
          } else {
              return filter;
          }
      }
      
      function implicitEq(filter) {
          const key = Object.keys(filter)[0];
          if (!key.startsWith('$') && typeof filter[key] != "object") {
              filter[key] = { $eq: filter[key] };
          }
          return filter;
      }
  }

  /**
   * Returns a string function body for the given filter spec. This method was tested to be faster than walking through filterSpec "run-time".
   * @param {*} filterSpec 
   * @returns 
   */
  function createFilterFnString(filterSpec) {
      filterSpec = normalizeFilter(filterSpec);
      let key = Object.keys(filterSpec)[0];
      if (key.startsWith('$')) {
          return logicalToString[key](filterSpec[key]);
      } else {
          const operator = Object.keys(filterSpec[key])[0];
          return comparisonToString[operator](key, JSON.stringify(filterSpec[key][operator]));
      } 
      
  }

  const logicalToString = {
      '$not': (spec) => `!${createFilterFnString(spec)}`,
      '$and': (spec) => `(${spec.map(createFilterFnString).join(' && ')})`,
      '$or':  (spec) => `(${spec.map(createFilterFnString).join(' || ')})`,
      '$nor': (spec) => `!(${spec.map(createFilterFnString).join(' || ')})`,
  };
  const comparisonToString = {
      "$eq":  (field, val) => `row["${field}"] == ${val}`,
      "$ne":  (field, val) => `row["${field}"] != ${val}`,
      "$gt":  (field, val) => `row["${field}"] > ${val}`,
      "$gte": (field, val) => `row["${field}"] >= ${val}`,
      "$lt":  (field, val) => `row["${field}"] < ${val}`,
      "$lte": (field, val) => `row["${field}"] <= ${val}`,
      "$in":  (field, val) => `${val}.includes(row["${field}"])`,
      "$nin": (field, val) => `!${val}.includes(row["${field}"])`,
  };

  //used by "filterRequired" transform
  function filterNullish(df, fields) {
      let filterParam = fields.every(isString)
          ? simpleNullishCheck(fields)
          : nullishFilterSpec(fields);
      return filter$1(df, filterParam);
  }

  // simple, fast filtering using function that checks for nullish value
  function simpleNullishCheck(fields) {
      const l = fields.length;
      return row => {
          //faster implementation with a for-loop
          for (let i = 0; i < l; i++) {
              if (row[fields[i]] == null) return false;
          }
          return true;
      }
  }

  // used for "repeat" encoding for example
  // allows defining fields with logical conditions like: [{ $or: ['x','x1'] }, 'y']
  function nullishFilterSpec(fields) {
      return { $nor: makeSpec(fields) }
      function makeSpec(fields) {
          return fields.map(predicate => {
              if (typeof predicate === 'string') {
                  return { $or: [ { [predicate]: { $eq: null } }, { [predicate]: { $eq: undefined } }] };
              } else {
                  return Object.fromEntries(Object.entries(predicate).map(([key, value]) => {
                      return [key, makeSpec(value)]
                  }))
              }
          })
      }
  }

  const isNumeric = (n) => !isNaN(n) && isFinite(n);

  function isString(value) {
      return typeof value == 'string' || value instanceof String;
  }

  function isEntityConcept(concept) {
      return ["entity_set", "entity_domain"].includes(concept.concept_type);
  }

  function isModel(model) {
      return isNonNullObject(model) && "config" in model;
  }

  function isDataSource(model) {
      return isModel(model) && model.type == "dataSource";
  }

  function isDataConfig(model) {
      return isModel(model) && model.type == "dataConfig";
  }

  function isFilter(model) {
      return isModel(model) && model.type == "filter";
  }

  function mapToObj(map) {
      const obj = {};
      map.forEach((v, k) => { obj[k] = v; });
      return obj;
  }

  function mode(arr = []) {
      return arr.reduce( ( acc, el ) => {
          acc.c[el] = acc.c[el] ? acc.c[el] + 1 : 1;
          acc.max = acc.max ? acc.max < acc.c[el] ? el : acc.max : el;
          return acc  
      }, { c:{} }).max
  }

  // intersect of two arrays (representing sets)
  // i.e. everything in A which is also in B
  function intersect(a, b) {
      return a.filter(e => b.includes(e));
  }

  /**
   * Is A a proper subset of B
   * Every A is in B, but A != B
   * @param {*} a 
   * @param {*} b 
   */
  function isProperSubset(a, b) {
      const intersection = intersect(a,b);
      return intersection.length == a.length && intersection.length != b.length;
  }

  function subsets(array) { 
      return array.reduce(
          (subsets, value) => [...subsets.map(set => [...set, value]), ...subsets],
          [[]]
      )
  }

  /**
   * Everything in B which is not in A. Relative complement (difference, B\A) of A with respect to B.
   * A=[geo,year], B=[geo,year,gender], B\A = [gender]
   * @param {Array|Set} a Array/Set representing set A
   * @param {Array|Set} b Array/Set representing set B
   */
  function relativeComplement(a, b) {
      if (a.has) {
          const result = [];
          for (let e of b) if (!a.has(e)) result.push(e);
          return result;
      }
      return b.filter(e => !a.includes(e));
  }

  function concatUnique(...arrays) {
      return Array.from(new Set(arrays.flat()));
  }

  // returns true if a and b are identical, regardless of order (i.e. like sets)
  function arrayEquals(a, b) {
      const overlap = intersect(a, b);
      return overlap.length == a.length && overlap.length == b.length;
  }

  // copies properties using property descriptors so accessors (and other meta-properties) get correctly copied
  // otherwise if you do regular Object.assign it would read directly from the object and execute getters 
  // and the return values would be what it assigns. but we want to actually copy getters and setters

  // source: https://www.webreflection.co.uk/blog/2015/10/06/how-to-copy-objects-in-javascript
  // rewrote for clarity and make sources overwrite target (mimic Object.assign)
  function assign(target, ...sources) {
      sources.forEach(source => {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      });
      return target;
  }
  function composeObj(...parts) {
      return assign({}, ...parts);
  }

  function ucFirst(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
  }

  // gets a getter accessor from an object and binds it to the object
  // used to overload methods when decorating objects
  function getBoundGetter(obj, prop) {
      return Object.getOwnPropertyDescriptor(obj, prop).get.bind(obj);
  }

  function moveProperty(oldObj, oldProp, newObj, newProp) {
      Object.defineProperty(newObj, newProp, Object.getOwnPropertyDescriptor(oldObj, oldProp));
  }
  function renameProperty(obj, oldProp, newProp) {
      moveProperty(obj, oldProp, obj, newProp);
  }

  function fromPromiseAll(promiseColl) {
      const promiseArray = Array.isArray(promiseColl) ? promiseColl : Object.values(promiseColl);
      if (promiseArray.every(p => p.state == "fulfilled"))
          return fromPromise.resolve(promiseColl);
      if (promiseArray.some(p => p.state == "rejected"))
          return fromPromise.reject(promiseColl);
      return fromPromise((res, rej) => { });
  }

  /**
   * Checks all states in parallel
   * @param {string[]} states 
   * @returns 
   */
  function combineStates(states) {
      if (states.some(state => state === "rejected")) return "rejected";
      if (states.every(state => state === "fulfilled")) return "fulfilled";
      return "pending";
  }

  /**
   * Checks all states sequantially (only check-trigger next state if previous is fulfilled)
   * @param {function[]} states state getters
   * @returns 
   */
  function combineStatesSequential(states) {
      if (!states.every(state => typeof state == 'function')) {
          throw new Error("Every state given to combineStatesSequential should be wrapped in a getter function.")
      }
      for (let state of states) {
          // state getter allows us to only read state (and thus trigger upstream computeds) when earlier states are fulfilled
          state = state();
          if (state == 'pending') return 'pending';
          if (state == 'rejected') return 'rejected';
      }
      return 'fulfilled';
  }

  // code from https://github.com/TehShrike/is-mergeable-object
  function isMergeableObject(value) {
      return isNonNullObject(value) &&
          !isSpecial(value)
  }

  function isNonNullObject(value) {
      return !!value && typeof value === 'object'
  }

  function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);

      return stringValue === '[object RegExp]' ||
          stringValue === '[object Date]' ||
          mobx.isObservableArray(value) ||
          isReactElement(value)
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

  function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE
  }

  // c merge and helpers
  // code from https://github.com/KyleAMathews/deepmerge
  function emptyTarget(val) {
      return Array.isArray(val) ? [] : {}
  }

  function cloneUnlessOtherwiseSpecified(value, options) {
      return (options.clone !== false && options.isMergeableObject(value)) 
          ? deepmerge(emptyTarget(value), value, options) 
          : Object.prototype.toString.call(value) == '[object Date]'
              ? new Date(value.getTime())
              : value;
  }

  function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
          Object.keys(target).forEach(function(key) {
              destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
      }
      Object.keys(source).forEach(function(key) {
          if (!options.isMergeableObject(source[key]) || !target[key]) {
              destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          } else {
              destination[key] = deepmerge(target[key], source[key], options);
          }
      });
      return destination
  }

  const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;

  function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || overwriteMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;

      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

      if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options)
      } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options)
      } else {
          return mergeObject(target, source, options)
      }
  }

  deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
          throw new Error('first argument should be an array')
      }

      return array.reduce(function(prev, next) {
          return deepmerge(prev, next, options)
      }, {})
  };

  function deepclone(object) {
      return deepmerge({}, object);
  }

  function createModel(modelType, config, parent, id) {
      //suffix for debugging
      let nameSuffix = id ? '-' + id : parent?.name ? '-' + parent.name : '';
      let model = mobx.observable(
          //actual constructor
          modelType.nonObservable(config, parent, id), 
          //decorators
          modelType.decorate,
          //extra options: name of observable
          { name: (modelType.name || config.modelType || 'base') + nameSuffix }
      );
      //lifecycle function
      if (model.onCreate) model.onCreate();
      return model;
  }

  function defaultDecorator({ base, renameProperties = {}, defaultConfig = {}, functions = {} }) {
      if (Array.isArray(functions)) functions = assign({}, ...functions);
      const newType = function (config, parent, id) {
          return createModel(newType, config, parent, id)
      };
      newType.nonObservable = function(config, parent, id) {
          applyDefaults(config, defaultConfig);
          delete functions.config;
          if (!base) base = (config, parent) => ({ config, parent });
          const baseObj = base.nonObservable(config, parent, id);
          for (const prop in renameProperties) {
              renameProperty(baseObj, prop, renameProperties[prop]);
          }
          return assign(baseObj, functions);
      };
      newType.decorate = base.decorate;
      return newType;
  }

  const applyDefaults = mobx.action('applyDefaults', function applyDefaults(config, defaults) {
      const defaultProps = Object.keys(defaults);
      defaultProps.forEach(prop => {
          if (!config.hasOwnProperty(prop)) {
              if (isMergeableObject(defaults[prop]))
                  config[prop] = deepclone(defaults[prop]); // object
              else
                  config[prop] = defaults[prop]; // non object, i.e. value
          } else if (isMergeableObject(defaults[prop])) {
              if (isMergeableObject(config[prop]))
                  applyDefaults(config[prop], defaults[prop]);
          }
      });
      return config;
  });

  function equals(a,b) {
      if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime();
      }
      return a === b;
  }

  function clamp(value, min, max) {
      if (Array.isArray(min))
          [min, max] = min;
      if (value > max)
          return max;
      if (value < min)
          return min;
      return value;
  }

  function configValue(value, concept) {
      if (value instanceof Date) {
          return concept?.format ? d3$1.utcFormat(concept.format)(value) : formatDate(value);
      }
      return ""+value;
  }


  function range(start, stop, intervalSize) {
      return interval(intervalSize).range(start, stop);
  }

  const POSSIBLE_INTERVALS = ["year", "month", "day", "week", "quarter"];

  function interval(intervalSize) {
      switch (intervalSize) {
          case "year": return d3$1.utcYear;
          case "day": return d3$1.utcDay;
          case "month": return d3$1.utcMonth;
          case "week": return d3$1.utcMonday;
          case "quarter": return d3$1.utcMonth.every(3);
          default: return {
              //not a time interval
              offset: (n, d) => isNumeric(n) && isNumeric(d) ? n + d : console.error("Can't offset using non-numeric values", { n, d }),
              range: d3$1.range,
              floor: Math.floor,
              ceil: Math.ceil,
              round: Math.round
          };
      }
  }

  function inclusiveRange(start, stop, intervalSize) {
      if (!start || !stop) return [];
      return range(start, stop, intervalSize).concat(stop);
  }

  const defaultParsers = [
      d3$1.utcParse('%Y'),
      d3$1.utcParse('%Y-%m'),
      d3$1.utcParse('%Y-%m-%d'),
      d3$1.utcParse('%Yw%V'),
      d3$1.utcParse('%Yq%q'),
      d3$1.utcParse('%Y-%m-%dT%HZ'),
      d3$1.utcParse('%Y-%m-%dT%H:%MZ'),
      d3$1.utcParse('%Y-%m-%dT%H:%M:%SZ'),
      d3$1.utcParse('%Y-%m-%dT%H:%M:%S.%LZ')
  ];

  function tryParse(timeString, parsers) {
      for (let i = 0; i < parsers.length; i++) {
        let dateObject = parsers[i](timeString);
        if (dateObject) return dateObject;
      }
      console.warn('Could not parse time string ' + timeString);
      return null;
  }

  /**
   * Parses string `valueStr` to different type, depending on `concept` type. 
   * Type `time` is parsed to `Date`, `measure` to `number`, any other to string. 
   * If `valueStr` is not a string, it is returned as is.
   * 
   * @param {string} valueStr String to parse
   * @param {Object} concept Concept object of which valueStr is a value
   */
  function parseConfigValue(valueStr, concept) {
      if (!isString(valueStr)) return valueStr;

      const { concept_type } = concept;

      if (concept_type === "time") {
          let parsers = concept.format 
              ? [d3$1.utcParse(concept.format), ...defaultParsers]
              : defaultParsers;
          return tryParse(valueStr, parsers);
      }

      if (concept_type === "measure") {
          return +valueStr;
      }

      return ""+valueStr;
  }

  function autoFormat(o) {
      if (o instanceof Date)
          return formatDate(o)
      return ""+o;
  }

  function formatDate(date) {
      var month = date.getUTCMonth(),
          day = date.getUTCDate(),
          hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : milliseconds ? formatFullDate(date) + "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
          : seconds ? formatFullDate(date) + "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
          : minutes || hours ? formatFullDate(date) + "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
          : day !== 1 ? formatFullDate(date)
          : month ? formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2)
          : formatYear(date.getUTCFullYear());
  }

  function formatFullDate(date) {
      return formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2);
  }

  function formatYear(year) {
      return year < 0 ? "-" + pad(-year, 6)
          : year > 9999 ? "+" + pad(year, 6)
          : pad(year, 4);
  }

  function pad(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
  }
      
  const defer = setTimeout;
  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

  function compose2(f, g) {
      return (...args) => f(g(...args));
  }
  function compose(...fns) {
      return fns.reduce(compose2);
  }
  function pipe(...fns) {
      return fns.reduceRight(compose2);
  }

  /**
   * Creates a stable, unique string representing the object, circumventing the unordered nature of object properties
   * @param {Object} obj 
   * @returns {String} Stable string representation of object
   */
  function stableStringifyObject(obj) { 
      return JSON.stringify(canonicalObject(obj));
  }

  /**
   * Recursively replace any object by an array where each element is on of the object's properties, sorted by the property name.
   * Can be used as stable input for hashing objects, circumventing the unordered nature of object properties.
   * @param {Object} where 
   * @returns {Array}
   */
  function canonicalObject(where) {
      if (!isNonNullObject(where)) 
          return where;
      const keys = Object.keys(where).sort();
      return keys.map(key => ({ [key]: canonicalObject(where[key]) }));
  }

  /**
   * Function for Array#sort which doesn't convert values to strings. Dates will be converted to integers and thus sort chronologically.
   * @param {*} a 
   * @param {*} b 
   * @returns 
   */
  const sortDateSafe = (a, b) => a > b ? 1 : a < b ? -1 : 0; 

  /**
   * Returns value for `key` in `map`. If `key` not in map, first create new value using `create` getter function and set it to `key`.
   * @param {Map} map Map to get from
   * @param {Any} key Key to map
   * @param {Function} create Function which returns new value for new keys
   */
  function getOrCreate(map, key, create) {
      let value;
      if (map.has(key))
          value = map.get(key);
      else {
          value = create();
          map.set(key, value);
      }
      return value;
  }

  /**
   * Return filtered object(shallow cloned)
   * @param {Object} obj 
   * @param {Function} filter
   */
  function filterObject(obj, filter) {
      let result = {}, key;

      for (key in obj) {
          if (obj.hasOwnProperty(key) && filter(obj[key], key)) {
              result[key] = obj[key];
          }
      }

      return result;
  }

  function createConceptFilterFn(filterSpec = {}) {
      if (Object.keys(filterSpec) == 0) {
          return () => true;
      }
      return createFilterFn(filterSpec);
  }

  function createSpaceFilterFn(filterSpec = {}, dataConfig) {
      if (Object.keys(filterSpec) == 0) {
          return () => true;
      }
      const filterFn = createFilterFn(filterSpec);
      const source = dataConfig.source;
      return function filter(spaceArray) {
          return spaceArray
              .map(dim => typeof dim != 'object' ? source.getConcept(dim) : dim)
              .every(filterFn);
      }
  }

  function pickGetters(object, keys) {
      const result = {};
      for (const key of keys) {
          if (key in object)
              Object.defineProperty(result, key, Object.getOwnPropertyDescriptor(object, key));
      }
      return result;
  }


  function getConceptsCatalog(concepts, dataConfig, maxDepth) {
      const promises = [];
      const result = {};
      const source = dataConfig.source;
      for (const conceptId of concepts) {
          const concept = source.getConcept(conceptId);
          result[conceptId] = {
              concept
          };
          if (source.isEntityConcept(conceptId)) {
              const setMembershipFlags = source.availability.data
                  .map(m => m.value)
                  .filter(f => f.includes("is--") || f == "un_state");

              const entityQuery = dataConfig.createQuery({ 
                  space: [conceptId],  
                  concept: ["name", "rank", ...setMembershipFlags],
                  locale: dataConfig.locale,
                  filter: null,
                  source
              });
              promises.push(source.query(entityQuery).then(response => {
                  result[conceptId]['entities'] = response.forQueryKey();
              }));
              if (maxDepth && maxDepth > 0) {
                  const props = source.availability.keyValueLookup.get(conceptId).keys();
                  const propDetails = getConceptsCatalog(props, dataConfig, maxDepth - 1);
                  promises.push(propDetails.then(response => {
                      result[conceptId]['properties'] = response;
                  }));
              }
          }
      }
      return Promise.all(promises).then(() => result);
  }

  function removeOnce(arr, value) {
      let index = arr.indexOf(value);
      if (index > -1) {
          arr.splice(index, 1);
      }
      return arr;
  }

  function lazyAsync(asyncFn, obsObj, obsProp) {
      let lazyDisposer;
      const dispObs = mobx.onBecomeObserved(obsObj, obsProp, () => {
          lazyDisposer = mobx.autorun(asyncFn);
      });
      const dispUnobs = mobx.onBecomeUnobserved(obsObj, obsProp, () => {
          lazyDisposer();
      });
      return () => {
          dispObs();
          dispUnobs();
          lazyDisposer?.();
      }
  }

  function isIterable(obj) {
    // checks for null and undefined
    if (obj == null) {
      return false;
    }
    return typeof obj[Symbol.iterator] === 'function';
  }

  function stepBeforeInterpolator(startVal, endVal) {
      if (typeof startVal === "object") {
          const jsonStartVal = JSON.stringify(startVal);
          const jsonEndtVal = JSON.stringify(endVal);
          return t => JSON.parse(t < 1 ? jsonStartVal : jsonEndtVal);
      } else return t => t < 1 ? startVal : endVal;
  }

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isNumeric: isNumeric,
    isString: isString,
    isEntityConcept: isEntityConcept,
    isModel: isModel,
    isDataSource: isDataSource,
    isDataConfig: isDataConfig,
    isFilter: isFilter,
    mapToObj: mapToObj,
    mode: mode,
    intersect: intersect,
    isProperSubset: isProperSubset,
    subsets: subsets,
    relativeComplement: relativeComplement,
    concatUnique: concatUnique,
    arrayEquals: arrayEquals,
    assign: assign,
    composeObj: composeObj,
    ucFirst: ucFirst,
    getBoundGetter: getBoundGetter,
    moveProperty: moveProperty,
    renameProperty: renameProperty,
    fromPromiseAll: fromPromiseAll,
    combineStates: combineStates,
    combineStatesSequential: combineStatesSequential,
    isMergeableObject: isMergeableObject,
    isNonNullObject: isNonNullObject,
    deepmerge: deepmerge,
    deepclone: deepclone,
    createModel: createModel,
    defaultDecorator: defaultDecorator,
    applyDefaults: applyDefaults,
    equals: equals,
    clamp: clamp,
    configValue: configValue,
    range: range,
    POSSIBLE_INTERVALS: POSSIBLE_INTERVALS,
    interval: interval,
    inclusiveRange: inclusiveRange,
    parseConfigValue: parseConfigValue,
    autoFormat: autoFormat,
    defer: defer,
    sleep: sleep,
    compose: compose,
    pipe: pipe,
    stableStringifyObject: stableStringifyObject,
    sortDateSafe: sortDateSafe,
    getOrCreate: getOrCreate,
    filterObject: filterObject,
    createConceptFilterFn: createConceptFilterFn,
    createSpaceFilterFn: createSpaceFilterFn,
    pickGetters: pickGetters,
    getConceptsCatalog: getConceptsCatalog,
    removeOnce: removeOnce,
    lazyAsync: lazyAsync,
    isIterable: isIterable,
    stepBeforeInterpolator: stepBeforeInterpolator
  });

  const defaultType = config => mobx.observable({ config });
  defaultType.nonObservable = config => ({ config });

  const createStore = function(baseType = defaultType, extendedTypes = {}) {
      return mobx.observable({
          // add types on store creation
          modelTypes: {
              baseType,
              ...extendedTypes
          },
          models: {},
          // add types later during runtime
          addType: function(modelType, modelConstructor) {
              if (this.modelTypes[modelType])
                  console.warn("Adding model type " + modelType + " failed. Type already exists", this);
              this.modelTypes[modelType] = modelConstructor;
          },    
          create: mobx.action('create', function(config, parent, id) {
              //model can be of a special type, such as frame or color scale
              //otherwise it falls back to generic type: encoding or scale that would be
              const createModelOfType = this.modelTypes[config.modelType] || this.modelTypes.baseType;
              //see utils.createModel()
              const model = createModelOfType(...arguments);
              if (id) this.set(id, model);
              return model;
          }),
          //used for example when passing multiple markers in Vizabi()
          createMany: mobx.action('createMany', function(configs) {
              const models = {};
              for (let id in configs) {
                  models[id] = this.create(configs[id], null, id);
              }
              return models;
          }),
          has: function(id) {
              return id in this.models;
          },   
          get(arg, parent, name) {
              //get or create actually
              if (isString(arg)) {
                  //resolve arg as reference if it's a string - get it from the store
                  return this.models[arg] // id
              } else if (isModel(arg)) {
                  //no-op: if asking for a model - return it without change
                  return arg;
              } else {
                  //otherwise assume arg is a config for a new model to be created
                  //allows creating multiple models from the same config
                  //e.g. order.data and size.data are created from the same config
                  //see marker get encoding(), marker.encodingCache() and encodingCache.js
                  return this.create(arg, parent, name)
              }
          },
          getAll: function() {
              return Object.values(this.models);
          }, 
          set: mobx.action('set', function(id, model) { 
              return this.models[id] = model;
          }),
          dispose: mobx.action('dispose', function(id) {
              this.models[id].dispose();
              delete this.models[id];
          }),
          disposeAll: mobx.action('disposeAll', function() {
              // first dispose all then delete, so that any models build through references to these markers can be reached for disposal
              for (let id in this.models) {
                  this.models[id].dispose();
              }
              for (let id in this.models) {
                  delete this.models[id];
              }
          })
      }, {
          models: mobx.observable.shallow
      });
  };

  const configurable = {
      applyConfig: mobx.action('applyConfig', function(config) {
          this.config = deepmerge(this.config, config);
          return this;
      })
  };

  // only on base level now, should be recursive
  function dotToJoin(query) {
      const props = query.where && Object.keys(query.where);
      if (!props || props.length == 0)
          return query;

      const where = query.where,
          newq = deepmerge({}, query);

      props.forEach(p => {
          const s = p.split('.');
          if (s.length > 1) {
              const [key, value] = s;
              const filter = where[p];
              const joinid = "$" + key;

              if (!newq.join) newq.join = {};
              if (!newq.join[joinid]) {
                  newq.join[joinid] = {
                      key,
                      where: {
                          [value]: filter
                      }
                  };
                  if (newq.where[key]) {
                      newq.join[joinid].where[key] = newq.where[key];
                  }
                  newq.where[key] = joinid;
              } else {
                  newq.join[joinid].where[value] = filter;
              }
              delete newq.where[p];
          }
      });

      //console.log("Transformed query: ", query, newq);
      return newq;
  }

  // needed for WS
  function addExplicitAnd(query) {
      // return if no where or only single where
      const props = query.where && Object.keys(query.where);
      if (!props || props.length < 2)
          return query;

      const newq = deepmerge({}, query);
      newq.where = {
          "$and": []
      };
      props.forEach(prop => {
          newq.where["$and"].push({
              [prop]: query.where[prop]
          });
      });

      //console.log("Transformed query: ", query, newq);
      return newq;
  }

  /**
   * @param {*} argPromise promise resolving to object { values, keyConcepts, dtypes }
   */
  function inlineReader(argPromise) {

      argPromise = Promise.resolve(argPromise).then((args) => {
          args.keyConcepts = args.keyConcepts ?? []; 
          return args;
      });

      let dataPromise, conceptPromise;

      return {
          async read(query) {
              if (!dataPromise) {
                  dataPromise = argPromise.then(parseValues);
              }
              
              let table = await dataPromise;

              if (isConceptQuery(query)) {
                  if (!conceptPromise) {
                      conceptPromise = await dataPromise
                          .then(getConcepts)
                          .then(concepts => DataFrame(concepts, ["concept"]));
                  }
                  table = await conceptPromise;
              }

              if (isSchemaQuery(query))
                  table = DataFrame(getSchema(table, query.from), ["key","value"]);

              return applyQuery(table, query);
          },
          getAsset(assetId) {
              console.warn('Inline reader does not support assets', { assetId });
          },
          async getDefaultEncoding() {
              const { keyConcepts } = await argPromise;
              const data = await dataPromise;
              const encConfig = {};
              data.fields.forEach(concept => {
                  encConfig[concept] = {
                      concept, 
                      space: keyConcepts
                  };
              });
              return encConfig;
          }
      }
  }

  function parseValues({ values, dtypes, keyConcepts}) {
      return DataFrame(makeParser(dtypes)(values), keyConcepts);
  }

  function isConceptQuery(query) {
      return "from" in query && query.from == "concepts";
  }

  function isSchemaQuery(query) {
      return "from" in query && query.from.endsWith('.schema');
  }

  function getConcepts(data) {
      const types = getConceptTypes(data);
      return [...data.fields].map(concept => ({
          concept,
          concept_type: types.get(concept)
      }));
  }

  function getSchema(data, from) {
      if (from == "datapoints.schema") {
          const indicatorConcepts = relativeComplement(data.key, [...data.fields]);
          return indicatorConcepts.map(concept => ({
              key: [...data.key],
              value: concept
          }));        
      }
      if (from == "concepts.schema") {
          return [{ key: ["concept"], value: "concept_type"}];
      }
      if (from == "entities.schema") {
          //make the key itself always present in schema
          const conceptTpes = getConceptTypes(data);
          const entitiesSchema = data.key
              .filter(f => conceptTpes.get(f) !== "time")
              .map(m => ({key: [m], value: m}));
          
          //this only supports names for the first dimension, but it is possible to add more, i.e. with dot notation
          if (data.fields.includes("name"))
              entitiesSchema.push({ key: [data.key[0]], value: "name" }); 
         
          return entitiesSchema;
      }
      console.warn("Invalid schema query `from` clause: ", from);
  }

  function applyQuery(data, query) {
      const { select, from, where, order_by, join } = query;
      const { key, value } = select;
      const projection = [...key, ...value];

      if ("join" in query){
          console.warn('Inline reader does not handle joins as it has only one table. Sections of "where" statement that refer to joins will be ignored.', { query });
          //delete where statements that refer to joins
          for (let w in where) {
              if(Object.keys(join).includes(where[w])) delete where[w]; 
          }
      }

      if (relativeComplement([...data.fields], projection).length > 0)
          console.error('Concepts found in query.select which are not in data', { query, dataFields: data.fields});

      let result = data
          .filter(where)
          .project(projection)
          .order(order_by);

      if (!arrayEquals(result.key, select.key))
          result = DataFrame(result, select.key);
      
      return result;
  }

  /*
  {
      year: { timeFormat: "%Y", locale: "ru-RU" }
      pop: number
  }
  */
  function makeParser(dtypes) {
      const parseRow = parserFromDtypes(dtypes);
      return function parseTable(data) {
          let row;
          for (row of data) {
              parseRow(row); // in place
          }
          return data;
      }
  }

  const dtypeParsers = {
      string: d => d,
      number: d => +d,
      boolean: d => d == '1' || d.toLowerCase() == 'true',
      auto: autoParse,
      time: (d) => {
          if ((""+d).length == 4) return dtypeParsers.year(d);
          if (d.length == 7 && d[4] == "-") return dtypeParsers.month(d);
          if (d.length == 10) return dtypeParsers.day(d);
          if (d[4].toLowerCase() == "w") return dtypeParsers.week(d);
          if (d[4].toLowerCase() == "q") return dtypeParsers.quarter(d);
      }, 
      year: d3$1.utcParse("%Y"),
      month: d3$1.utcParse("%Y-%m"),
      day: d3$1.utcParse("%Y-%m-%d"),
      week: d3$1.utcParse("%Yw%V"),
      quarter: d3$1.utcParse("%Yq%q")
  };

  function parserFromDtypes(dtypes) {

      if (dtypes == "auto") 
          return d3$1.autoType;

      // create field parsers
      const parsers = {};
      let field;
      
      for (field in dtypes) {
          const dtype = dtypes[field];

          let parser;
          if (dtype in dtypeParsers) parser = dtypeParsers[dtype];
          if (isNonNullObject(dtype) && "timeFormat" in dtype) parser = d3$1.utcParse(dtype.timeFormat);

          if (!parser) {
              console.warn('Unknown data type given, fall back to identity parser.', dtype);
              parser = d => d;
          }
          parsers[field] = parser;
      }

      // return row parser
      return (row) => {
          let parse, field;
          for (field in row) {
              if (parse = parsers[field]) {
                  row[field] = parse(row[field]);
              }
          }
      }
  }

  /**
   * Parse string to js primitives or Date. Based on d3_autoType
   * @param {any} value Value to be parsed 
   */
  function autoParse(value) {
      var value = value.trim(), number;
      if (!value) value = null;
      else if (value === "true") value = true;
      else if (value === "false") value = false;
      else if (value === "NaN") value = NaN;
      else if (!isNaN(number = +value)) value = number;
      else if (/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/.test(value)) value = new Date(value);
      return value;
  }

  function getConceptTypes(data) {
      const types = new Map();

      // get types from first row
      const [firstRow] = data.values();
      for (let field in firstRow) {
          types.set(field, getConceptType(firstRow[field], field, data.key));
      }
      // check if those types are consistent
      for (let [field, type] of types) {
          const checkedType = validateConceptType(data, field, type);
          if (!checkedType) {
              console.warn("Field " + field + " is not consistently typed " + type);
              types.set(field, "mixed");
          } else if (type === "null") {
              types.set(field, checkedType !== type ? checkedType : undefined);
          }
      }
      return types;
  }

  function validateConceptType(data, field, type) {
      let conceptType;
      for (let row of data.values()) {
          conceptType = getConceptType(row[field], field, data.key);
          if ( type !== conceptType ) {
              if (type === "null") {
                  type = conceptType;
              } else if (conceptType !== "null") return false;
          }
      }
      return type;
  }

  function getConceptType(value, field, datakey) {
      if (value === null) return 'null';
      if (isDate(value)) return 'time';
      if(datakey.includes(field)) return 'entity_domain';
      const type = typeof value;
      if (type == "string")  return 'string';
      if (type == "boolean") return 'boolean';
      if (type == "number" || isNumber(value))  return 'measure';
      console.warn("Couldn't decide type of value", { value, field, datakey });
  }

  const isDate = val => val instanceof Date;
  const isNumber = val => !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object Number]";

  function guessDelimiter(text, ERRORS) {
      const comma = ',',  semicolon = ';';
      const stringsToCheck = 2;
      const rows = _getRows(text.replace(/"[^\r]*?"/g, ''), stringsToCheck);

      if (rows.length !== stringsToCheck) {
          return {error: ERRORS.NOT_ENOUGH_ROWS_IN_FILE};
      }

      const [header, firstRow] = rows;
      const commasCountInHeader = _countCharsInLine(header, comma);
      const semicolonsCountInHeader = _countCharsInLine(header, semicolon);
      const commasCountInFirstRow = _countCharsInLine(firstRow, comma);
      const semicolonsCountInFirstRow = _countCharsInLine(firstRow, semicolon);

      if (
          _checkDelimiters(
              commasCountInHeader,
              commasCountInFirstRow,
              semicolonsCountInHeader,
              semicolonsCountInFirstRow
          )
      ) return comma;
      else if (
          _checkDelimiters(
              semicolonsCountInHeader,
              semicolonsCountInFirstRow,
              commasCountInHeader,
              commasCountInFirstRow
          )
      ) return semicolon;

      // failed to identify a delimiter
      return {error: ERRORS.UNDEFINED_DELIMITER};
  }

  function _checkDelimiters(
      firstDelimiterInHeader,
      firstDelimiterInFirstRow,
      secondDelimiterInHeader,
      secondDelimiterInFirstRow
  ) {
      return firstDelimiterInHeader === firstDelimiterInFirstRow
          && firstDelimiterInHeader > 1
          && (
              (secondDelimiterInHeader !== secondDelimiterInFirstRow)
              || (!secondDelimiterInHeader && !secondDelimiterInFirstRow)
              || (firstDelimiterInHeader > secondDelimiterInHeader && firstDelimiterInFirstRow > secondDelimiterInFirstRow)
          );
  }

  function  _getRows(text, count = 0) {
      const re = /([^\r\n]+)/g;
      const rows = [];

      let rowsCount = 0;
      let matches;

      do {
          matches = re.exec(text);
          if (matches && matches.length > 1) {
              ++rowsCount;
              rows.push(matches[1]);
          }
      } while (matches && rowsCount !== count);

      return rows;
  }

  function _countCharsInLine(text, char) {
      const re = new RegExp(char, 'g');
      const matches = text.match(re);
      return matches ? matches.length : 0;
  }

  const MISSED_INDICATOR_NAME = 'indicator';

  function timeInColumns({columns, rows, hasNameColumn, timeKey = "time", keySize = 1}, ERRORS, parsers) {
      let nameConcept = null;
      
      // remove column "name" as array's k+1 th element, but remember its header in a variable.
      // if it's an empty string, call it "name"
      // name column is not at its original index because it was moved by csv reader "load" method
      if (hasNameColumn) {
          nameConcept = columns.splice(keySize + 1, 1)[0] || 'name';
      }
      
      const missedIndicator = parsers && parsers[timeKey] && !!parsers[timeKey](columns[keySize]);

      if (missedIndicator) {
          console.warn('Indicator column is missed.');
      }

      const indicatorKey = missedIndicator ? MISSED_INDICATOR_NAME : columns[keySize];
      const concepts = columns.slice(0, keySize)
          .concat(timeKey)
          .concat(nameConcept || [])
          .concat(missedIndicator ? ucFirst(MISSED_INDICATOR_NAME) : rows.reduce((result, row) => {
              const concept = row[indicatorKey];
              if (!result.includes(concept) && concept) {
              result.push(concept);
              }
              return result;
      }, []));

      const indicators = concepts.slice(keySize + 1 + (nameConcept ? 1 : 0));
      const [entityDomain] = concepts;

      return {
          columns: concepts,
          rows: rows.reduce((result, row) => {
              const rowEntityDomain = row[entityDomain];
              const resultRows = result.filter(resultRow => resultRow[entityDomain] === rowEntityDomain);

              if (resultRows.length) {
              if (resultRows[0][row[indicatorKey]] !== null) {
                  throw {
                      name: ERRORS.REPEATED_KEYS,
                      message: `indicator: ${row[indicatorKey]}, key: ${row[entityDomain]}`
                  }
              }

              resultRows.forEach(resultRow => {
                  resultRow[row[indicatorKey]] = row[resultRow[timeKey]];
              });
              } else {
              Object.keys(row).forEach(key => {
                  if (![entityDomain, indicatorKey, nameConcept].includes(key)) {
                  const domainAndTime = {
                      [entityDomain]: row[entityDomain], 
                      [timeKey]: key
                  };
                  const optionalNameColumn = !nameConcept ? {} : {
                      [nameConcept]: row[nameConcept]
                  };
                  const indicatorsObject = indicators.reduce((indResult, indicator) => {
                      indResult[indicator] = missedIndicator || row[indicatorKey] === indicator ? row[key] : null;
                      return indResult;
                  }, {});

                  result.push(Object.assign(domainAndTime, optionalNameColumn, indicatorsObject));
                  }
              });
              }

              return result;
          }, [])
      };
  }

  const TIME_LIKE_CONCEPTS = ["time", "year", "month", "day", "week", "quarter"];
  const NAME_LIKE_CONCEPTS = ["name", "title"];
  const GOOGLE_DOC_PREFIX = 'https://docs.google.com/spreadsheets/';
  const ERRORS = {
      WRONG_TIME_COLUMN_OR_UNITS: 'reader/error/wrongTimeUnitsOrColumn',
      NOT_ENOUGH_ROWS_IN_FILE: 'reader/error/notEnoughRows',
      UNDEFINED_DELIMITER: 'reader/error/undefinedDelimiter',
      EMPTY_HEADERS: 'reader/error/emptyHeaders',
      DIFFERENT_SEPARATORS: 'reader/error/differentSeparators',
      FILE_NOT_FOUND: 'reader/error/fileNotFoundOrPermissionsOrEmpty',
      REPEATED_KEYS: 'reader/error/repeatedKeys'
  };

  function csvReader({ 
          path = "data.csv", 
          sheet = "", 
          externalTextReader,
          externalJsonReader,
          hasNameColumn = false,
          isTimeInColumns = false,
          assetsPath = "",
          delimiter = "",
          keyConcepts, 
          nameColumnIndex,
          dtypes 
      }, parent_id) {
      
      let cache = {};
      const cacheKey = path + sheet;

      path = _googleSpreadsheetURLAdaptor(path, sheet);

      return Object.assign(inlineReader(getValues().then(({values, dtypes, keyConcepts}) => ({ 
              values,
              keyConcepts,
              dtypes
          })
      )), {
          getDatasetInfo,
          getAsset,
          getValues
      });

      function getValues(){
          return cache[cacheKey] ? cache[cacheKey] : cache[cacheKey] = loadFile()
              .then(guessDelim)
              .then(parseTextToTable)
              .then(removeEmptyRows)
              .then(transformNameColumn)
              .then(transformTimeInColumns)
              .then(returnValuesDtypesAndKeyConcepts);
      }
    
      function loadFile(){
          let textReader = externalTextReader || d3$1.text;
          return textReader(path)
              .catch(error => {
                  error.name = ERRORS.FILE_NOT_FOUND;
                  error.message = `No permissions, missing or empty file: ${path}`;
                  error.endpoint = path;
                  throw error;
              });
      }

      function guessDelim(text){
          if (!delimiter) delimiter = guessDelimiter(text, ERRORS);
          if (delimiter.error) throw makeError(delimiter.error);
          return text;
      }

      function parseTextToTable(text){

          const rows = d3$1.dsvFormat(delimiter)
              //parse, and exclude empty rows
              .parse(text, row => Object.values(row).every(v => !v) ? null : row);

          //remove empty columns
          const columns = rows.columns.filter(c => c !== "");

          return {rows, columns};
      }

      //removes empty rows like these
      //'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\n', '', '', ''
      function removeEmptyRows({rows, columns}){
          rows = rows.filter(r => !Object.values(r).every(e => !e || e === "\n") );
          return {rows, columns};
      }

      function transformNameColumn({rows, columns}){
          // move column "name" so it goes after "time"
          // turns [name, geo, gender, time, lex] into [geo, gender, time, name, lex]
          nameColumnIndex = nameColumnIndex ?? NAME_LIKE_CONCEPTS.map(n => columns.indexOf(n)).find(f => f > -1);
          if (hasNameColumn && nameColumnIndex != undefined){
              const nameColumn = columns.splice(nameColumnIndex, 1); //mutates columns array
              const keySize = guessKeyConcepts(columns, keyConcepts).length;
              columns = columns.slice(0, keySize).concat(nameColumn).concat(columns.slice(keySize));
          }
          return {rows, columns};
      }

      function transformTimeInColumns({rows, columns}){

          if (isTimeInColumns) {
              try {
                  return timeInColumns({rows, columns}, ERRORS);
              } catch (error) {
                  throw makeError(error);
              }
          }
          
          return {rows, columns};
      }

      function returnValuesDtypesAndKeyConcepts({rows, columns}){
          const values = autotype(rows);
          return {
              values,
              keyConcepts: guessKeyConcepts(columns, keyConcepts),
              columns,
              dtypes: columns.reduce((dtypes, column) => {
                  const lowerCaseColumn = column.toLowerCase();
                  //skip dtypes config for time column which typed to Date with d3_autoType already ('day' and 'month' timeformats for ex.)
                  if (TIME_LIKE_CONCEPTS.includes(lowerCaseColumn) && !(values[0][column] instanceof Date)) dtypes[column] = lowerCaseColumn;
                  return dtypes;
              }, {})
          }
      }

      function autotype(rows){
          return rows.map(row => d3$1.autoType(row));
      }

      function guessKeyConcepts(columns, keyConcepts){
          if(keyConcepts) return keyConcepts;
          const index = columns.findIndex((f) => TIME_LIKE_CONCEPTS.includes(f.toLowerCase()));
          // +1 because we want to include time itself as well
          return columns.slice(0, index + 1);
      }

      function makeError(e){
          delete cache[cacheKey];
          return e;
      }

      /**
       * This function returns info about the dataset
       * in case of CSV reader it's just the name of the file
       * @returns {object} object of info about the dataset
       */
      function getDatasetInfo() {
          return {name: sheet ? (parent_id ? parent_id + ": " : "") + sheet : path.split('/').pop()};
      }

      function getAsset(assetName) {
          const path = assetsPath + assetName;
          const jsonReader = externalJsonReader || d3$1.json;

          return jsonReader(path)
              .catch(error => {
                  error.name = ERRORS.FILE_NOT_FOUND;
                  error.message = `No permissions, missing or empty file: ${path}`;
                  error.endpoint = path;
                  throw error;
              });
      }

      function _googleSpreadsheetURLAdaptor(path, sheet) {
        // adjust path if given a path to a google doc but without the correct export suffix. the first sheet is taken since none is specified
        if (path.includes(GOOGLE_DOC_PREFIX) && !path.includes('tqx=out:csv') && !path.includes('/pub?')) {
            const googleDocParsedUrl = path.split(GOOGLE_DOC_PREFIX)[1].split('/');
            const googleDocId = googleDocParsedUrl[googleDocParsedUrl.indexOf('d') + 1];
            return GOOGLE_DOC_PREFIX 
                + 'd/' 
                + googleDocId 
                + '/gviz/tq?tqx=out:csv' 
                + (sheet ? '&sheet=' + encodeURI(sheet.toLowerCase()) : '' );
        } else {
            return path;
        }
      }
      
  }

  function makeCache() {
      const cache = new Map();

      const makeKey = function(query) {
          if (query.select.value.length > 1) {
              //console.info('Cache can\'t handle query with more than one select value. Skipping query caching.', query);
              return undefined;
          }
          return stableStringifyObject(query);
      };
      const has = function (query) { return cache.has(makeKey(query)); };
      const get = function (query) { return cache.get(makeKey(query)); };
      const set = function(query, promise) {
          if (query.select.value.length > 1) 
              return splitQuery(query).map(q => set(q, promise));
          
          const key = makeKey(query);
          return cache.set(key, promise);
      };
      const splitQuery = function(query) {
          return query.select.value.map(concept => {
              const clone = deepclone(query);
              clone.select.value = [concept];
              return clone;
          });
      };

      return {
          has, 
          get, 
          set
      }
  }

  const defaultConfig$8 = {
      path: null,
      sheet: null,
      keyConcepts: null,
      values: null,
      transforms: []
  };

  const type$1 = "dataSource";

  function dataSource(...args) {
      return createModel(dataSource, ...args)
  }

  dataSource.nonObservable = function (config, parent, id) {
      applyDefaults(config, defaultConfig$8);


      const functions = {
          get path() { return this.config.path },
          get sheet() { return this.config.sheet },
          get keyConcepts() { return this.config.keyConcepts },
          get locale() { 
              if (this.config.locale)
                  return typeof this.config.locale == "string" ? this.config.locale : this.config.locale.id; 
          },
          get dtypes() { return this.config.dtypes },
          get reader() {
              if (this.values)
                  return inlineReader({ values: this.values, keyConcepts: this.keyConcepts, dtypes: this.dtypes });
              else if (this.path)
                  return csvReader(this.config, this.id);
              console.warn("No inline values or csv path found. Please set `values` or `path` property on dataSource.", this);
          },
          get values() { 
              // toJS: don't want insides of data to be observable (adds overhead & complexity)
              return mobx.toJS(this.config.values);
          },
          get defaultEncodingPromise() {
              if ("getDefaultEncoding" in this.reader)
                  return fromPromise(this.reader.getDefaultEncoding());
              else    
                  return fromPromise.resolve({});
          },
          get defaultEncoding() {
              const empty = {};
              return this.defaultEncodingPromise.case({
                  fulfilled: v => {
                      Object.values(v).forEach(enc => enc.source = this);
                      return v;
                  },
                  pending: () => { console.warn('Requesting default encoding before loaded. Will return empty. Recommended to await promise.'); return empty },
                  error: (e) => { console.warn('Requesting default encoding when loading errored. Will return empty. Recommended to catch exception.'); return empty }
              });
          },
          buildAvailability(responses = []) {
              const 
                  keyValueLookup = new Map(),
                  keyLookup = new Map(),
                  valueLookup = new Map(),
                  data = [];
      
              /* utility functions, probably move later */
              const getFromMap = (map, key, getNewVal) => {
                  map.has(key) || map.set(key, getNewVal());
                  return map.get(key);
              };
              const newSet = () => new Set();
              const newMap = () => new Map();
      
              /* handle availability responses */
              responses.forEach(response => {
                  response = response.forQueryKey().values(); // get dataframe iterator if there
                  for(let row of response) {
                      let keyStr;
                      row.key = Array.isArray(row.key) ? row.key : JSON.parse(row.key).sort();
                      keyStr = createKeyStr(row.key);
                      data.push(row);
                      keyLookup.set(keyStr, row.key);
                      getFromMap(keyValueLookup, keyStr, newMap)
                          .set(row.value, row);  
                      getFromMap(valueLookup, row.value, newSet)
                          .add(row.key);
                  }            });
      
              return {
                  valueLookup,
                  keyValueLookup,
                  keyLookup,
                  data
              };
          },
          get availabilityPromise() { return this.fetchAvailability(); },
          fetchAvailability() {
              //trace();
              const collections = ["concepts", "entities", "datapoints"];
              const getCollAvailPromise = (collection) => this.query({
                  select: {
                      key: ["key", "value"],
                      value: []
                  },
                  from: collection + ".schema"
              });
      
              return fromPromise(Promise.all(collections.map(getCollAvailPromise))
                  .then(this.buildAvailability));
          },
          get availabilityState() {
              if (this.availabilityPromise.state == 'rejected') 
                  throw this.availabilityPromise.value;
              return this.availabilityPromise.state;
          },
          get availability() {
              let empty = this.buildAvailability();
              return this.availabilityPromise.case({
                  fulfilled: v => v,
                  pending: () => { console.warn('Requesting availability before availability loaded. Will return empty. Recommended to await promise.'); return empty },
                  rejected: (e) => { console.warn('Requesting availability when loading errored. Will return empty. Recommended to catch exception.'); return empty }
              })
          },
          get conceptsPromise() { return this.fetchConcepts(); },
          fetchConcepts() {
              //trace();
              const locale = this.locale;
              return fromPromise(this.availabilityPromise.then(av => {
                  const conceptKeyString = createKeyStr(["concept"]);
                  const avConcepts = [...av.keyValueLookup.get(conceptKeyString).keys()];
          
                  const query = {
                      select: {
                          key: ["concept"],
                          value: avConcepts
                      },
                      from: "concepts"
                  };         
                    
                  if (locale) {
                      query.language = locale; 
                  }
      
                  return this.query(query)
              }));
          },
          get conceptsState() {
              //trace();
              if (this.conceptsPromise.state == 'rejected') 
                  throw this.conceptsPromise.value;
              return this.conceptsPromise.state;
          },
          get concepts() {
              //trace();
              const empty = new Map();
              return this.conceptsPromise.case({
                  fulfilled: v => v.forQueryKey(),
                  pending: () => { console.warn('Requesting concepts before loaded. Will return empty. Recommended to await promise.'); return empty; },
                  rejected: (e) => { console.warn('Requesting concepts when loading errored. Will return empty. Recommended to catch exception.'); return empty; }
              })
          },
          /* 
          *  separate state computed which don't become stale with new promise in same state  
          */
          get state() {
              return combineStates([this.availabilityState, this.conceptsState]);
          },
          getConcept(concept) {
              if (concept == "concept_type" || concept.indexOf('is--') === 0 || concept === "concept")
                  return { concept, name: concept }
              if (this.concepts.size && !this.concepts.has({ concept }))
                  console.warn("Could not find concept " + concept + " in data source ", this);
              return this.concepts.get({ concept }) || {};
          },
          isEntityConcept(conceptId) {
              return ["entity_set", "entity_domain"].includes(this.getConcept(conceptId).concept_type);
          },
          isTimeConcept(conceptId) {
              return this.getConcept(conceptId).concept_type === "time";
          },
          normalizeResponse(response, query) {
              const cache = {};
              if (isDataFrame(response)) {
                  cache[createKeyStr(response.key)] = response;
              } else if (response.length == 1 && Object.keys(response[0]).length == 0) {
                  // to handle faulty bw/ddfservice reader response
                  // https://github.com/Gapminder/big-waffle/issues/53
                  response.pop();
              }
              function forKey(key) {
                  //const t0 = performance.now();   
                  const keyStr = createKeyStr(key);
                  const df = cache[keyStr] ?? (cache[keyStr] = DataFrame(response, key)); 
                  //const time = performance.now() - t0;
                  //normalizingTime += time;
                  //console.log('normalized: ', time, 'total: ' + normalizingTime)
                  return df;
              }
              function forQueryKey() {
                  return forKey(query.select.key);
              }
              return {
                  //Sometimes the raw response is a dataframe (such as from CSV/inline reader)
                  //And sometimes it's a plain array (such as from ws-service reader)
                  //Some downstream code however expects "raw" to be a plain array, 
                  //for example, the for loop in entityPropertyDataConfig.js: lookups()
                  //hence, this converts response back to plain array
                  raw: isDataFrame(response) ? [...response.values()] : response,
                  forKey,
                  forQueryKey
              }
          },
          query(query) {
              query = dotToJoin(query);
              query = addExplicitAnd(query);
              //console.log('Processing query', query);
              return this.combineAndSendQueries(query);
          },
          cache: makeCache(),
          queue: new Map(),
          combineAndSendQueries(query) {
              if (this.cache.has(query)) 
                  return this.cache.get(query);

              //find out which queries can be combined (stringify all fields minus select.value)
              const queryCombineId = this.calcCombineId(query);
              if (this.queue.has(queryCombineId)) {
                  //add an extra column to a query already found in the queue
                  const { baseQuery, promise } = this.queue.get(queryCombineId);
                  baseQuery.select.value = concatUnique(baseQuery.select.value, query.select.value);
                  return promise;
              } else {
                  //create a new query in a queue
                  const baseQuery = deepclone(query);
                  const promise = fromPromise(this.sendDelayedQuery(baseQuery));
                  this.queue.set(queryCombineId, { baseQuery, promise });
                  this.cache.set(baseQuery, promise);
                  return promise;
              }
          },
          async sendDelayedQuery(query) {
              const reader = this.reader; // deref read before await so it's observed & memoized
              // sleep first so other queries can fill up baseQuery's select.value
              await sleep();
              const queryCombineId = this.calcCombineId(query);
              //after deleting from the queue nothing more can be added to the query
              this.queue.delete(queryCombineId);
              const response = await reader.read(query);
              return this.normalizeResponse(response, query);
          },

          _getDrillupCatalog(concepts = this.concepts) {
              const promises = [];
              const result = {};
              const drillup = "drill_up";

              for (const conceptKeys of this.availability.keyLookup.values()) {
                  if (conceptKeys.length == 1 && this.isEntityConcept(conceptKeys[0])) {
                      const conceptId = conceptKeys[0];
                      const concept = concepts.get(conceptId);
                      if (concept[drillup]) {
                          const dim = concept["domain"] || conceptId;
                          if (!result[dim]) result[dim] = {};
                          const drillups = JSON.parse(concept[drillup]);
                          const entityQuery = { 
                              select: {
                                  key: [conceptId],
                                  value: [...drillups]
                              },
                              from: "entities",
                              locale: this.locale,
                          };
                          promises.push(this.query(entityQuery).then(response => {
                              result[dim][conceptId] = [];

                              const res = response.forQueryKey();
                              result[dim][conceptId].push([Symbol.for(drillup), res]);
                              drillups.forEach(drillup => {
                                  result[dim][conceptId].push(...res.groupByWithMultiGroupMembership(drillup).filterGroups(( _, k) => {
                                      return k !== "";
                                  }, true).entries());
                              });
                              result[dim][conceptId] = new Map(result[dim][conceptId]);
                          }));
                      }
                  }
              }

              return fromPromise(Promise.all(promises).then(() => result));
          },

          enableDrillup: false,

          get drillupCatalog() {
              if (this.enableDrillup) {
                  return this._getDrillupCatalog();
              } else {
                  return fromPromise.resolve({});
              }
          },

          //.drilldown({dim: "geo", entity: "asia"}) // =>{country: ["chn", "ind", "idn" ..... ]}
          //.drilldown({dim: "geo", entity: "usa"}) // => {country: ["usa"]}
          //.drilldown({dim: "geo", entity: ["landlocked"]}) // => {country: ["afg", "rwa",  .... ]}
          //.drilldown({dim: "geo", entity: ["usa", "landlocked"]}) // => {country: ["afg", "rwa",  ...., "usa"]} (same plus USA)
          //.drilldown({dim: "geo", entity: ["asia", "landlocked"]}) // => {country:  [chn", "ind", "afg", "rwa",  .... ] } 
          
          drilldown(obj) {
              this.enableDrillup = true;

              const entities = Array.isArray(obj.entity) ? obj.entity : [obj.entity];
              const concept = this.concepts.get(obj.dim);
              const dim = concept.domain ? concept.domain : obj.dim;

              return this.drillupCatalog.then(c => {
                  const result = {}; 
                  for (const entitySet in c[dim]) {
                      const founded = [];
                      entities.forEach(e => {
                          if (c[dim][entitySet].has(e)) {
                              founded.push(...[...c[dim][entitySet].get(e).values()].map(v => v[entitySet]));
                          } else if (c[dim][entitySet].get(Symbol.for("drill_up")).has(e)){
                              founded.push(e);
                          }
                      });
                      if (founded.length) {
                          result[entitySet] = [...new Set(founded)].sort();
                      }
                  }                return Object.keys(result).length ? result : null;
              });
          },

          //.drillup({dim: "geo", entity: "usa"}) // => {world_4region: americas, landlocked: coastline, religion: christian ...}
          drillup(obj) {
              this.enableDrillup = true;

              const concept = this.concepts.get(obj.dim);
              const dim = concept.domain ? concept.domain : obj.dim;
              const drillup = "drill_up";

              const result = {};
              return this.drillupCatalog.then(c => {
                  for (const entitySet in c[dim]) {
                      const drillupValue = c[dim][entitySet].get(Symbol.for(drillup)).get(obj.entity);
                      Object.assign(result, drillupValue);
                      delete result[entitySet];
                      delete result[Symbol.for("key")];
                  }                return result;

              });

          },

          calcCombineId(query) {
              const clone = deepclone(query);
              delete clone.select.value;
              return stableStringifyObject(clone);
          },
          disposers: [],
          onCreate() {
              this.disposers.push(
                  mobx.reaction(() => this.state == 'fulfilled' ? this.drillupCatalog : {}, ()=>{})
              );
          },
          dispose() {
              let dispose;
              while (dispose = this.disposers.pop()) {
                  dispose();
              }
          }
      };

      return assign({}, functions, configurable, { config, id, type: type$1 });
  };

  dataSource.decorate = {
      // to prevent config.values from becoming observable
      // possibly paints with too broad a brush, other config might need to be deep later
      config: mobx.observable.shallow,
      // queue should be mutable by computed methods 
      // this is introducing state manipulation and makes these computed methods impure 
      // other solutions are welcome : ) 
      queue: mobx.observable.ref,
      cache: mobx.observable.ref
  };

  const dataSourceStore = createStore(dataSource);

  dataSourceStore.createAndAddType = function(type, readerObject) {
      this.addType(type, defaultDecorator({
          base: dataSource,
          functions: {
              get reader() {
                  // copy reader object (using original would only allow one datasource of this type)
                  const reader = Object.assign({}, readerObject);
                  reader.init(this.config || {});
                  return reader;
              }
          }
      }));
  };

  /**
   * 
   * @param {*} possibleRef 
   * @returns config Config object as described in reference config
   */
   function resolveRef(possibleRef, root = stores) {
      // not a ref
      if (!isReference(possibleRef))
          return { state: 'fulfilled', value: possibleRef }

      // handle config shorthand
      let ref = (isString(possibleRef.ref)) ? { path: possibleRef.ref } : possibleRef.ref;

      // invalid ref
      if (!ref.path) {
          console.warn("Invalid reference, expected string reference in ref or ref.path", possibleRef);
      }

      // model ref includes resolved defaults
      const result = resolveTreeRef(ref.path, root);
      result.value = transformModel(result.value, ref.transform);
      return result;
  }

  function isReference(possibleRef) {
      return isNonNullObject(possibleRef) && typeof possibleRef.ref != "undefined"
  }

  function resolveTreeRef(refStr, tree) {
      const ref = refStr.split('.');
      let prev;
      let node = tree;
      //walk the tree
      for (let i = 0; i < ref.length; i++) {
          let nextStep = ref[i];
          prev = node;
          //use get function where there is one, i.e. stores, otherwise assume it's an object
          node = prev.get?.(nextStep) ?? prev[nextStep];

          if (typeof node == "undefined") {
              console.warn("Couldn't resolve reference " + refStr);
              return null;
          }
      }

      return { 
          //prev state is needed for example when we get a ref to a concept
          //concept doesn't have state, so we problby want to know the state of dataConfig instead

          //and since it's a getter we don't read it immediately
          //this prevents circular computations from happening if we do it right away
          //for example between order and the size encodings
          //referring to the state of size --> getting state of size -->
          //size checks marker config resolving state --> which wants to know order state
          //fortunately we don't need to read the state when constucting the reference
          //therefore we can have it in a computed
          get state() { return node.state ?? prev.state ?? 'fulfilled' }, 
          value: node 
      }
  }

  function transformModel(model, transform) {
      switch (transform) {
          case "entityConcept":
              return mobx.observable({
                  get space() { return model.data.isConstant ? [] : [model.data.concept] },
                  get filter() {
                      return {
                          dimensions: {
                              [model.data.concept]: {
                                  [model.data.concept]: { $in: model.scale.domain }
                              }
                          }
                      }
                  },
                  get source() { return model.data.source },
                  get locale() { return model.data.locale }
              });
          case "entityConceptSkipFilter":
              return mobx.observable({
                  get space() { return model.data.isConstant ? [] : [model.data.concept] },
                  get source() { return model.data.source },
                  get locale() { return model.data.locale }
              });
          case "orderDirection":
              const dim = model.parent.space[0];
              return mobx.observable(
                  model.config.dimensions?.[dim]?.$or?.[0]?.[dim]?.$in || []
              ) 
          default:
              return model;
      }
  }

  /**
   * Finds a config which satisfies both marker.space and encoding.concept autoconfigs
   */
  const solveMethods = {};

  const configSolver = {
      addSolveMethod,
      configSolution,
      markerSolvingState,
      dataConfigSolvingState
  };

  function addSolveMethod(fn, name = fn.name) {
      solveMethods[name] = fn;
  }

  //configSolution can be requested by dataConfig of marker, of an encoding, or standalone
  function configSolution(dataConfig) {     
      if (dataConfig.marker) {
      // autoconfig needs to be solved on the marker level, because encoding solutions are intertwined
      // this is why we are checking for marker that is involved, both DC of enc and marker have a .marker
          if (dataConfig.hasEncodingMarker) {
              //if it's an encoding, grab the corresponding part of marker solution.
              //this would also trigger marker solution if it wasn't yet computed
              if (dataConfig.marker.data.configSolution)
                  return dataConfig.marker.data.configSolution.encodings[dataConfig.parent.name];
              else 
                  //or return undefined for no-data encoding without throwing an error
                  return { concept: undefined, space: undefined };
          } else {
              //or else: actually start solving autoconfig on a marker level
              return markerSolution(dataConfig);
          }
      } else {
          // stand-alone dataConfig, not a common case but helpful for tests
          return encodingSolution(dataConfig);
      }
  }


  function markerSolution(dataConfig) {
      const cfg = dataConfig.config;

      if (!dataConfig.parent.encoding)
          console.warn(`Can't get marker solution for a non-marker dataconfig.`);

      if (needsSpaceAutoCfg(dataConfig)) {

          if (!dataConfig.source) {
              console.warn(`Can't autoconfigure marker space without a source defined.`);
              return;
          }

          //the callback in third argument checks that whatever space candidate is suggested by autoConfigSpace,
          //it also has a solution for encodings
          return autoConfigSpace(dataConfig, undefined, space => findMarkerConfigForSpace(dataConfig, space))

      } else {
          //for whatever space is configured, find solutions for encoding
          return findMarkerConfigForSpace(dataConfig, cfg.space);
      }
  }


  // this function is used for both marker space and for encoding space
  function autoConfigSpace(dataConfig, extraOptions = {}, getFurtherResult) {
      // getFurtherResult for marker: is there also solution for encodings
      // getFurtherResult for encoding: can we find concept for this space

      const { markerSpaceCfg } = extraOptions;
      let availableSpaces;
      //get all the spaces a solution could be set to
      if (dataConfig.hasEncodingMarker && markerSpaceCfg) {
          //for encoding space under a known marker space: we need to match with marker space
          //start with getting all subsets of marker space, filter by availability
          availableSpaces = subsets(markerSpaceCfg)
              .filter(space => dataConfig.source.availability.keyLookup.has(createKeyStr(space)));
          availableSpaces = sortSpacesByPreference(availableSpaces);
          //add marker space itself too - as most preferable
          availableSpaces.unshift(markerSpaceCfg);
      } else {
          //for marker spaces: get from pure availability
          availableSpaces = Array.from(dataConfig.source.availability.keyLookup.values());
          availableSpaces = sortSpacesByPreference(availableSpaces);
      }

      //put candidates through some filters
      const solveFilterSpec = dataConfig.config.space?.filter || dataConfig.defaults.space?.filter;
      const solveFilter = createSpaceFilterFn(solveFilterSpec, dataConfig);
      const allowFilter = dataConfig.allow.space?.filter || (() => true);

      for (let space of availableSpaces) {
          let result;        
          if (!space.includes("concept") //hardcoded disallowing to have concept "concept" in space
              && solveFilter(space)
              && allowFilter(space)
              && (result = getFurtherResult(space))
          ) {
              //return the first satisfactory space because they are sorted
              return result
          }
      }
      
      console.warn("Could not autoconfig to a space which also satisfies further results for " + dataConfig.parent.id + ".", { 
          dataConfig,
          spaceCfg: dataConfig.config.space || dataConfig.defaults.space, 
          availableSpaces, 
          getFurtherResult });

      return { concept: undefined, space: undefined };
  }


  // 1-dim spaces go in back of the list, others: smallest spaces first
  function sortSpacesByPreference(spaces) {
      return spaces.sort((a, b) => a.length > 1 && b.length > 1 ? a.length - b.length : b.length - a.length); 
  }


  //this is called to try if a space candidate works or for a space that is set
  //even the explicitly configured concepts go through here because we need to know what concepts they are at
  //so we don't set other encs to the same concepts
  function findMarkerConfigForSpace(markerDataConfig, space) {
      let encodings = {};

      //track concepts used by previous encodgins so they are not used again
      let usedConcepts = new Set();
      let dataConfigResults = new Map(); 

      //every single encoding should have a compatible configuration, so that space would be good for marker
      let success = sortedEncodingEntries(markerDataConfig.parent.encoding).every(([name, enc]) => {

          // only one result per dataConfig, multiple encodings can have the same dataConfig (e.g. by reference)
          //if we already have results for a certain data config: return that from saved dataConfigResults
          let encResult = dataConfigResults.has(enc.data) 
              ? dataConfigResults.get(enc.data)
              : encodingSolution(enc.data, space, [...usedConcepts]);

          if (encResult) {
              dataConfigResults.set(enc.data, encResult);
              encodings[name] = encResult;
              usedConcepts.add(encResult.concept);
              return true;
          }
          return false;
      });

      return success ? { encodings, space } : undefined;
  }


  //sort encodings so that the autoconfig for them is stable
  function sortedEncodingEntries(encodingObject) {
      return [...Object.entries(encodingObject)]
          .sort(
              (a, b) => a[0].localeCompare(b[0])
          );
  }


  function encodingSolution(dataConfig, markerSpaceCfg, usedConcepts = []) {

      if (dataConfig.isConstant) 
          //nothing to solve
          return { concept: undefined, space: undefined };

      else if (needsSpaceAutoCfg(dataConfig)) 
          //same pattern with the callback as in markerSolution
          return autoConfigSpace(dataConfig, { usedConcepts, markerSpaceCfg }, space => {
              return findConceptForSpace(dataConfig, { usedConcepts, markerSpaceCfg }, space)
          })

      else if (needsConceptAutoCfg(dataConfig))

          return findConceptForSpace(dataConfig, { usedConcepts });

      else
          //no autoconfig needed
          //select and highlight end up in this branch becuase they are hard-configured on enc level
          return {
              space: "space" in dataConfig.config ? dataConfig.config.space : dataConfig.defaults.space,
              concept: "concept" in dataConfig.config ? dataConfig.config.concept : dataConfig.defaults.concept
          }    
  }


  // Add preconfigured often used solver methods 
  addSolveMethod(defaultConceptSolver);
  addSolveMethod(mostCommonDimensionProperty);
  addSolveMethod(selectUnusedConcept);

  /**
   * Tries to find encoding concept for a given space, encoding and partial solution which contains concepts to avoid.  
   * Should be called with encoding.data as `this`. 
   * Returns concept id which satisfies encoding definition (incl autoconfig) and does not overlap with partial solution.
   * @param {*} space 
   * @param {*} conceptCfg
   * @param {*} extraOptions.usedConcepts: array of concept ids to avoid in finding autoconfig solution
   * @returns {string} concept id
   */
  function findConceptForSpace(dataConfig, { usedConcepts = [] }, space) {
      let concept;
      const conceptCfg = dataConfig.config.concept || dataConfig.defaults.concept;
      space = space || dataConfig.config.space || dataConfig.defaults.space;

      //need to check it if we got here through autoconfig of space in encodingSolution() 
      if (needsConceptAutoCfg(dataConfig)) {
          const solveConcept = solveMethods[conceptCfg.solveMethod] || defaultConceptSolver;
          concept = solveConcept(space, dataConfig, usedConcepts);
      } else if (isReference(conceptCfg) || dataConfig.isConceptAvailableInSpace(space, conceptCfg)) {
          concept = conceptCfg;
      } 

      if (!concept) {
          // console.warn("Could not autoconfig concept for given space for " + dataConfig.parent.id  + ".", { dataConfig, space });
          return false;
      } 

      return { concept, space };
  }

  function defaultConceptSolver(space, dataConfig, usedConcepts) {

      const dataSource = dataConfig.source;
      const availability = dataSource.availability;
      const conceptCfg = dataConfig.config.concept || dataConfig.defaults.concept;

      const satisfiesFilter = conceptCfg.filter 
          ? createFilterFn(conceptCfg.filter)
          : () => true;

      //get all concepts available for a space
      const availableConcepts = availability.keyValueLookup.get(createKeyStr(space));
      if (!availableConcepts) 
          return;
      const filteredConcepts = [...availableConcepts.keys()]
          // exclude the ones such as "is--country", they won't get resolved
          .filter(concept => concept.substr(0,4) !== "is--")
          // get concept objects
          .map(dataSource.getConcept.bind(dataSource))
          // configurable filter
          .filter(satisfiesFilter);

      //select method can again be configured
      const selectMethod = solveMethods[conceptCfg.selectMethod] || selectUnusedConcept;
      return selectMethod({ concepts: filteredConcepts, dataConfig, usedConcepts, space })?.concept;
  }

  /**
   * Get the property that exists on most entity concepts in space.
   * Possibly limited by `allowedProperties` in the concept solving options.
   * Takes all properties of all entitity sets in a given space, pushes them into an array
   * then gets the mode of that array, i.e. most common value
   * Used only for labels
   * @param {*} space 
   * @param {*} dataConfig 
   * @returns 
   */
  //TODO: rename to mostCommonEntityPropertyForSpace
  function mostCommonDimensionProperty(space, dataConfig) {
      const dataSource = dataConfig.source;
      const kvLookup = dataSource.availability.keyValueLookup;
      const entitySpace = space.filter(dim => dataSource.isEntityConcept(dim));
      
      const conceptCfg = dataConfig.config.concept || dataConfig.defaults.concept;
      const allowedProperties = conceptCfg.allowedProperties;

      const occurences = [];
      for (let dim of entitySpace) {
          let concepts;
          const allProperties = kvLookup.get(createKeyStr([dim]));
          if (allProperties && allowedProperties) {
              concepts = allowedProperties.filter(c => allProperties.has(c));
          } else if (allProperties) {
              concepts = allProperties.keys();
          } else if (entitySpace.length === 1) {
              //dimension has no entity properties --> return dimension name itself if it's the only dimension
              concepts = [dim];
          } else {
              //otherwise setting concept to a single dim in a multidim situation would result
              //in ambiguity (i.e. "chn" label for "geo:chn gender:male" marker)
              //therefore we set concept to null and let the encoding be underconfigured
              //this situation can be handled later
              concepts = [null];
          }
          occurences.push(...concepts);
      }
      return mode(occurences);
  }


  function selectUnusedConcept({ concepts, usedConcepts }) {
      // first try unused concepts, otherwise, use already used concept
      return concepts.find(concept => !usedConcepts.includes(concept.concept)) || concepts[0];
  }

  function needsSpaceAutoCfg(dataConfig) {
      const cfg = dataConfig.config;
      const defaults = dataConfig.defaults;

      const explicitNoSpace = "space" in cfg && !cfg.space; //such as select, highlight encodings
      const defaultNeedsSolving = !cfg.space && needsSolving(defaults.space);

      return !dataConfig.isConstant 
          && !explicitNoSpace 
          && (needsSolving(cfg.space) || defaultNeedsSolving)
  }

  function needsConceptAutoCfg(dataConfig) {
      const cfg = dataConfig.config;
      const defaults = dataConfig.defaults;

      const isStandAloneDataConfig = !dataConfig.marker; //for tests
      const explicitNoConcept = "concept" in cfg && !cfg.concept; //such as select, highlight encodings
      const isEncodingDataConfig = dataConfig.hasEncodingMarker; //check we are on enc level
      const defaultNeedsSolving = !("concept" in cfg) && needsSolving(defaults.concept);
      
      return !dataConfig.isConstant 
          && !isReference(dataConfig.config.concept) //not even try to autoconfigure references (weird infinite loops)
          && !explicitNoConcept 
          && (needsSolving(cfg.concept)
          || ((isEncodingDataConfig || isStandAloneDataConfig) && defaultNeedsSolving));
  }

  //if it's a space then it's array, if it's object, then it's instructions to autoconfigure
  //if it's an array (for space) or a string (for concept) we know it's set by user
  function needsSolving(config) {
      return isNonNullObject(config) && !Array.isArray(config);
  }

  function needsAutoConfig(dataConfig) {
      return needsSpaceAutoCfg(dataConfig) || needsConceptAutoCfg(dataConfig);
  }

  function dataConfigSolvingState(dataConfig) {
      if (needsAutoConfig(dataConfig))
          return [dataConfig.source.conceptsState];
      else 
          return [];
  }

  function markerSolvingState(marker) {
      const dataConfigs = [marker.data];
      for (const enc of Object.values(marker.encoding)) { dataConfigs.push(enc.data); }    //if we need to autoconfigure space we need to wait concepts to be loaded first
      //which in turn will wait for availability...
      const states = dataConfigs.flatMap(dataConfigSolvingState);
      //here we combine states of all dataConfigs in marker and its encodings
      return combineStates(states);
  }

  const type = 'filter';

  function filter(...args) {
      return createModel(filter, ...args)
  }

  function cleanEmptyObjectsAndArrays(obj){

      function notEmpty(arg) {
          if (arg instanceof Date) return true;
          return !(arg == null || typeof arg === "object" && Object.keys(arg).length === 0 || Array.isArray(arg) && arg.length === 0);
      }

      if (Array.isArray(obj)){
          obj = obj.map( d => cleanEmptyObjectsAndArrays(d) ).filter(notEmpty);
      } else if (typeof obj === "object"){
          for (const objKey in obj) {
              obj[objKey] = cleanEmptyObjectsAndArrays(obj[objKey]);
              if (!notEmpty(obj[objKey])) delete obj[objKey];
          }
      }

      return obj;
  }
  filter.nonObservable = function (config, parent, id) {

      if (!("markers" in config)) config.markers = [];
      if (!("dimensions" in config)) config.dimensions = {};

      return {
          id,
          config,
          parent,
          type,
          get markers() {
              const cfg = resolveRef(this.config.markers).value || {};
              const markers = (mobx.isObservableArray(cfg)) ?
                  cfg.map(m => [m, true]) :
                  Object.entries(cfg);
              return new Map(markers);
          },
          get dimensions() {
              return mobx.toJS(this.config.dimensions) || {};
          },
          has(d) {
              return this.markers.has(this.getKey(d));
          },
          any() {
              return this.markers.size !== 0;
          },
          getPayload(d) {
              return this.markers.get(this.getKey(d));
          },
          set: mobx.action("setFilter", function(marker, payload) {
              if (Array.isArray(marker)) {
                  for (const el of marker) this.set(el);
                  return;
              }
              const key = this.getKey(marker);
              this.config.markers;
              if (payload) {
                  if (Array.isArray(this.config.markers)) {
                      this.config.markers = Object.fromEntries(this.config.markers.map(m => [m,true]));
                  }
                  this.config.markers[key] = configValue(payload);
              } else {
                  if (!Array.isArray(this.config.markers)) {
                      if (Object.keys(this.config.markers).length > 0) {
                          this.config.markers[key] = true;
                      } else {
                          this.config.markers = [key];
                      }
                  } else if (!this.config.markers.includes(key)) {
                      this.config.markers.push(key);
                  }
              }
          }),
          delete: mobx.action("deleteFilter", function(markerItem) {
              this.deleteFromMarkers(markerItem);
              this.deleteFromDimensionsAllINstatements(markerItem);
          }),
          clear: mobx.action("clearFilter", function() {
              this.config.markers = [];
          }),
          toggle: mobx.action("toggleFilter", function(marker) {
              if (this.has(marker))
                  return this.delete(marker);
              else 
                  return this.set(marker);
          }),
          deleteFromMarkers: mobx.action("deleteInMarkers", function(markerItem) {
              if (Array.isArray(markerItem)) {
                  for (const el of markerItem) this.deleteFromMarkers(el);
                  return;
              }
              const cfg = this.config.markers;
              const key = this.getKey(markerItem);
              if (Array.isArray(cfg)) {
                  removeOnce(cfg, key);
              } else {
                  delete cfg[key];
              }
              return !this.markers.has(key);
          }),
          addToDimensionsFirstINstatement: mobx.action("addInDimensions", function(markerItem, path) {
              if (Array.isArray(markerItem)) {
                  for (const el of markerItem) this.addToDimensionsFirstINstatement(el);
                  return;
              }
              const cfg = this.config.dimensions;
              const item = this.getKey(markerItem);
              let addedOnce = false;

              function findAndAddInArray(array, item){
                  const index = array.indexOf(item);
                  if (index == -1 && !addedOnce) {
                      array.push(item);
                      addedOnce = true;
                  }
              }

              function findAndAddInObject(obj, item, key) {
                  if (key === "$in")
                      findAndAddInArray(obj, item);
                  else if (Array.isArray(obj))
                      obj.forEach( d => findAndAddInObject(d, item) );
                  else if (typeof obj === "object")
                      for (const objKey in obj) findAndAddInObject(obj[objKey], item, objKey);
              }

              if (path) {
                  const inArray = path.reduce((a, p)=>{
                      if (a[p] == null) a[p] = ["$in", "$or", "$and", "$nin"].includes(p) ? [] : {};
                      return a[p];
                  }, cfg);
                  findAndAddInArray(inArray, item);
              } else {
                  findAndAddInObject(cfg, item);
              }
          }),
          deleteFromDimensionsFirstINstatement: mobx.action("deleteInDimensions", function(markerItem, path ) {
              if (Array.isArray(markerItem)) {
                  for (const el of markerItem) this.deleteFromDimensionsAllINstatements(el);
                  return;
              }
              const cfg = this.config.dimensions;
              const item = this.getKey(markerItem);

              //traverse object in search of an array containing markerItem

              function findAndRemoveInArray(array, item){
                  const index = array.indexOf(item);
                  if (index !== -1) array.splice(index, 1);
              }

              function findAndRemoveInObject(obj, item, key) {
                  if (key === "$in")
                      findAndRemoveInArray(obj, item);                
                  else if (Array.isArray(obj))
                      obj.forEach( d => findAndRemoveInObject(d, item) );
                  else if (typeof obj === "object")
                      for (const objKey in obj) findAndRemoveInObject(obj[objKey], item, objKey);
              }

              if (path) {
                  const inArray = path.reduce((a, p)=>{
                      if (a[p] == null) a[p] = ["$in", "$or", "$and", "$nin"].includes(p) ? [] : {};
                      return a[p];
                  }, cfg);
                  findAndRemoveInArray(inArray, item);
              } else {
                  findAndRemoveInObject(cfg, item);
              }
              cleanEmptyObjectsAndArrays(cfg);
          }),
          deleteFromDimensionsAllINstatements: mobx.action("deleteAllInDimensions", function(markerItem, statement = "$in") {
              if (Array.isArray(markerItem)) {
                  for (const el of markerItem) this.deleteFromDimensionsAllINstatements(el);
                  return;
              }
              const cfg = this.config.dimensions;
              const item = this.getKey(markerItem);

              //traverse object in search of an array containing markerItem

              function findAndRemoveInArray(array, item){
                  const index = array.indexOf(item);
                  if (index !== -1) array.splice(index, 1);
              }

              function findAndRemoveInObject(obj, item, key) {
                  if (key === statement)
                      findAndRemoveInArray(obj, item);                
                  else if (Array.isArray(obj))
                      obj.forEach( d => findAndRemoveInObject(d, item) );
                  else if (typeof obj === "object")
                      for (const objKey in obj) findAndRemoveInObject(obj[objKey], item, objKey);
              }

              findAndRemoveInObject(cfg, item);
              cleanEmptyObjectsAndArrays(cfg);
          }),
          getKey(d) {
              return isString(d) ? d : d[Symbol.for('key')];
          },
          whereClause(space) {
              let filter = {};

              // dimension filters
              const dimFilters = [];
              space.forEach(dim => {
                  if (this.dimensions[dim]) {
                      for (let prop in this.dimensions[dim]) {
                          if (prop == dim || space.length < 2) {
                              // don't include properties which are entity concepts in filter of entity query
                              // https://github.com/Gapminder/big-waffle/issues/52
                              if (space.length > 1 || !this.parent.source.isEntityConcept(prop))
                                  dimFilters.push({ [prop]: this.dimensions[dim][prop] });
                          } else { 
                              dimFilters.push({ [dim + '.' + prop]: this.dimensions[dim][prop] });
                          }
                      }
                  }
              });

              // specific marker filters
              const markerFilters = [];
              for (let [key, payload] of this.markers) {
                  const markerSpace = Object.keys(key);
                  if (arrayEquals(markerSpace, space)) {
                      markerFilters.push(key);
                  }
              }

              // combine dimension and marker filters
              if (markerFilters.length > 0) {
                  filter["$or"] = markerFilters;
                  if (dimFilters.length > 0) {
                      filter["$or"].push({ "$and": dimFilters });
                  }
              } else {
                  if (dimFilters.length > 0) {
                      // clean implicit $and
                      filter = deepmerge.all(dimFilters);
                  }
              }

              return filter;
          },
      }
  };

  const trailFilter = defaultDecorator({
      base: filter,
      renameProperties: {
          set: 'baseSet'
      },
      functions: {
          get encoding() {
              return this.parent.parent;
          },
          set: mobx.action("setTrailFilter", function(
              marker, 
              value = marker[this.encoding.groupDim] || this.encoding.frameEncoding.value, 
              limit = this.encoding.limits[this.getKey(marker)]
          ) {
              if (Array.isArray(marker)) {
                  for (let el of marker) this.set(el);
                  return;
              }
              const key = this.getKey(marker);
              if (!this.has(key) && !limit) {
                  // add unclamped to starts so limits computed gets recalculated (saves redundant one-off limit calc for this key)
                  this.baseSet(key, value);
                  limit = this.encoding.limits[key]; 
              }
              // set again if clamped is different from current
              const clamped = clamp(value, limit[0], limit[1]);
              this.baseSet(key, clamped);
          })
      }
  });

  const filterStore = createStore(filter, {
      trailFilter
  });

  function dataConfig(...args) {
      return createModel(dataConfig, ...args)
  }

  dataConfig.nonObservable = function(config, parent, id) {

      if (!('filter' in config)) config.filter = {};
      if (!('allow' in config)) config.allow = {};
      
      return {
          defaults: {
              filter: null,
              constant: null,
              concept: { filter: { concept_type: "measure" } },
              space: { /* solve from data */ },
              value: null,
              locale: null,
              source: null,
              domainDataSource: 'auto'
          },
          config,
          parent,
          id,
          type: 'dataConfig',
          isFullEntitySet(domain, entitySetValues = []) {
              return this.spaceCatalog.then(sc => {
                  if (!sc[domain]) return false;

                  const distinctValues = [...new Set(entitySetValues)];
                  const resultNames = [];
                  const properties = sc[domain].properties;
                  let inSetValuesCount;
                  for (const property in properties) {
                      if (properties[property].concept.concept_type == "entity_set") {
                          inSetValuesCount = 0;
                          for (const entityValue of properties[property].entities.keys()) {
                              if (distinctValues.includes(entityValue)) inSetValuesCount++;                            
                          }
                          if (inSetValuesCount == properties[property].entities.size) resultNames.push(property);
                      }
                  }

                  return resultNames.length ? resultNames.sort() : false;
              });
          },
          get allow() {
              return mobx.observable({
                  config: this.config.allow,
                  parent: this,
                  get space() {
                      return { 
                          filter: createSpaceFilterFn(this.config.space?.filter, this.parent)
                      }
                  },
                  get concept() {
                      return { 
                          filter: createConceptFilterFn(this.config.concept?.filter)
                      }
                  },
                  get source() {
                      return this.config.source;
                  }
              })
          },
          // it's possible to have an encoding without a marker in case of standalone enc (tests)
          get hasEncodingMarker() {
              return this.parent && this.parent.marker;
          },
          get marker() {
              if (this.hasEncodingMarker) {
                  return this.parent.marker;
              }
              if (this.parent) {
                  if (this.parent.marker) {
                      return this.parent.marker;
                  }
                  if (this.parent.encoding) {
                      return this.parent
                  }
              }
              return undefined;
          },
          get source() {
              const source = resolveRef(this.config.source).value;
              if (source)
                  return dataSourceStore.get(source, this)
              else {
                  if (this.hasEncodingMarker)
                      return this.parent.marker.data.source;
                  else
                      return null;
              }
          },
          get configSolution() {
              return configSolver.configSolution(this);
          },
          get space() {
              return this.configSolution.space;
          },
          get spaceCatalog() {
              return getConceptsCatalog(this.space, this, 1);
          },
          get commonSpace() {
              if (this.hasEncodingMarker)
                  return intersect(this.space, this.parent.marker.data.space);
              else if (!this.marker) // dataConfig used on its own
                  return this.space;
              console.warn('Cannot get data.commonSpace of Marker.data. Only meaningful on Encoding.data.');
          },
          get concept() {
              return resolveRef(this.configSolution.concept).value;
          },
          get conceptProps() { 
              return this.concept && this.source.getConcept(this.concept) 
          },
          get constant() {
              return resolveRef(this.config.constant).value ?? this.defaults.constant;
          },
          get isConstant() {
              return this.constant != null;
          },
          get hasOwnData() {
              return !!(this.source && this.concept && !this.conceptInSpace);
          },
          get conceptInSpace() {
              return this.concept && this.space && this.space.includes(this.concept);
          },
          isConceptAvailableInSpace(space, concept) {
              const dataSource = this.source;
              const availability = dataSource.availability;
              return space.includes(concept) || availability.keyValueLookup.get(createKeyStr(space))?.has(concept);
          },
          get filter() {
              const filter = resolveRef(this.config.filter).value;
              return filterStore.get(filter, this);
          },
          get locale() {
              if (this.config.locale)
                  return typeof this.config.locale == "string" ? this.config.locale : this.config.locale.id;
              else
                  return this.hasEncodingMarker ? this.parent.marker.data.locale || this.source?.locale : this.source?.locale;              
          },
          get availability() { return this.source.availability.data.map(kv => this.source.getConcept(kv.value)) },
          get domainDataSource() {
              let source = this.config.domainDataSource || this.defaults.domainDataSource;
              if (source === 'auto') {
                  source = this.hasOwnData
                      ? 'self'
                      : this.conceptInSpace
                          ? 'filterRequired'
                          : undefined;
              }
              return source;
          },
          get domainData() {
              const source = this.domainDataSource;
              const data = source === 'self' ? this.response
                  : this.hasEncodingMarker && this.parent.marker.transformedDataMaps.has(source) ? this.parent.marker.transformedDataMaps.get(source).get()
                  : source === 'markers' ? this.parent.marker.dataMap  
                  : this.response;

              return data;
          },
          get domain() {
              //trace();
              if (this.isConstant)
                  return isNumeric(this.constant) ? [this.constant, this.constant] : [this.constant];

              return this.calcDomain(this.domainData, this.conceptProps);
          },
          calcDomain(data, { concept, concept_type } = this.conceptProps) { 
              if (!data) return;
              // use rows api implemented by both group and df
              if (["measure","time"].includes(concept_type)) // continuous
                  return extent(data.rows(), concept);
              else // ordinal (entity_set, entity_domain, string)
                  return unique$1(data.rows(), concept); 
          },
          get configState() {
              return this.marker?.configState ?? combineStates(configSolver.dataConfigSolvingState(this));
          },
          get state() {
              const states = [ () => this.configState ];
              if (this.source) { states.push(() => this.source.conceptsState); } // conceptState needed for calcDomain()
              states.push(() => this.responseState);
              const state = combineStatesSequential(states);
              if (state == 'fulfilled' && this.domainDataSource == 'self') this.domain; 
              return state;
          },
          createQuery({ space = this.space, concept = this.concept, filter = this.filter, locale = this.locale, source = this.source } = {}) {
              const query = {};
              
              const keyStr = createKeyStr(space);
              
              //add isness for entity sets
              if(concept === this.concept && this.conceptIsEntitySetAndItsDomainIsInSpace) 
                  concept = [concept, "is--" + concept];

              concept = Array.isArray(concept) ? concept : [concept];
              concept = concept.filter(concept => {
                  return source.availability.keyValueLookup.get(keyStr)?.has(concept);
              });

              query.select = {
                  key: space.slice(), // slice to make sure it's a normal array (not mobx)
                  value: concept
              };
              query.from = (space.length === 1) ? "entities" : "datapoints";
              if (filter) {
                  if (Array.isArray(filter)) {
                      query.where = Object.assign(...filter.map(f => f.whereClause(query.select.key))); 
                  } else {
                      query.where = filter.whereClause(query.select.key);
                  }
              }
              if (locale) {
                  query.language = locale; 
              }
            
              return query;
          },
          get ddfQuery() {    
              return this.createQuery({ filter: [this.marker?.data?.filter, this.filter].filter(f => f != null) })
          },
          get response() {
              return this.responsePromise.value;
          },
          get responsePromise() {
              return this.fetchResponse();
          },
          get responseState() {
              if (!this.hasOwnData) {
                  return 'fulfilled';
              } else {
                  if (this.responsePromise.state == 'rejected')
                      throw this.responsePromise.value;
                  return this.responsePromise.state;
              }
          },
          get conceptIsEntitySetAndItsDomainIsInSpace() {
              //example: space ["geo"], concept: "world_4region"
              return this.concept && this.space && this.conceptProps.concept_type === "entity_set" && this.space.includes(this.conceptProps.domain);
          },
          responseAdaptorHack_MoveItToDSource(response){
              //this adapter handles situations such as getting world_4region property
              //of geos that are themselves world_4regions 
              // Jasper: you could have that as an extra layer in datasource even or smth
              // for any entity query to a domain, add all is--<sets> properties for that domain to the query,
              // and when result comes back add <set> properties for entities that have is--<set> TRUE
              // or do that just when you see the key is <domain> and one of the queried properties is a set in the domain.
              // more specific. so only add it if it's asked for :)

              if (this.conceptIsEntitySetAndItsDomainIsInSpace) {
                  response.raw.forEach(m => {
                      if(m[this.concept] == null && m["is--" + this.concept]) m[this.concept] = m[this.conceptProps.domain];
                  });
              }
              return response;
          },
          fetchResponse() {
              const promise = this.source.query(this.ddfQuery)
                  .then(this.responseAdaptorHack_MoveItToDSource.bind(this))
                  .then(response => response.forKey(this.commonSpace));
              return fromPromise(promise);
          },
          disposers: [],
          onCreate() {
              this.disposers.push(
                  mobx.reaction(
                      () => this.state == 'fulfilled' ? this.configSolution : {},
                      ({ space, concept }) => {
                          if (space && space != this.config.space && !arrayEquals(space, this.marker.data.space)) {
                              this.config.space = space;
                          }
                          if (concept && concept != this.config.concept) {
                              this.config.concept = concept;
                          }
                      },
                      {
                          name: 'loopback data-config-solver ' + this.parent?.id,
                          onError: (error) => this.internalErrors.push(error)
                      }
                  )
              );
          },
          internalErrors: [],
          dispose() { 
              for (const dispose of this.disposers) {
                  dispose();
              }
          }
      };
  };

  dataConfig.decorate = {
      space: mobx.computed.struct,
      commonSpace: mobx.computed.struct,
      // response: observable.ref
  };

  function entityPropertyDataConfig(...args) {
      return createModel(entityPropertyDataConfig, ...args)
  }

  entityPropertyDataConfig.nonObservable = function (cfg, parent) {

      if (!("concept" in cfg)) cfg.concept = { 
          solveMethod: 'mostCommonDimensionProperty', 
          allowedProperties: ['name', 'title']
      };

      const base = dataConfig.nonObservable(cfg, parent);

      return composeObj(base, {
          iterableResponse: false,
          get space() {
              return base.space?.filter(dim => !this.source.isTimeConcept(dim));
          },
          get queries() {
              const kvLookup = this.source.availability.keyValueLookup;
              return this.space
                  .filter(dim => kvLookup.get(dim)?.has(this.concept))
                  .map(dim => {
                      return this.createQuery({ space: [dim] });
                  });
          },
          isConceptAvailableInSpace(space, concept) {
              return true; // could check if there's availability for some space dimensions
          },
          lookups(response, concept) {
              const lookups = new Map();
              response.forEach(dimResponse => {
                  const { dim, data } = dimResponse;
                  const lookup = new Map();
                  lookups.set(dim, lookup);
                  for (const row of data.raw) {
                      lookup.set(row[dim], row[concept]);
                  }
              });
              return new Map([[concept, lookups]]);
          },
          get domain() {
              // could be an object with domain per dimension?
              return undefined;
          },
          fetchResponse() {
              const labelPromises = this.queries.map(query => this.source.query(query)
                  .then(data => ({ dim: query.select.key[0], data }))
              );
              const promise = Promise.all(labelPromises).then(response => {
                  const lookups = this.lookups(response, this.concept);
                  return DataFrame.fromLookups(lookups, this.commonSpace)
              });
              return fromPromise(promise);
          }
      })
  };
  entityPropertyDataConfig.decorate = dataConfig.decorate;

  function entityMembershipDataConfig(...args) {
      return createModel(entityMembershipDataConfig, ...args)
  }

  const defaults$8 = {
      exceptions: {}
  };

  entityMembershipDataConfig.nonObservable = function (cfg, parent) {

      const base = dataConfig.nonObservable(cfg, parent);

      return composeObj(base, {

          get exceptions() {
              //Exceptions:
              //For example, we want regions to all go in one facet, but countries to take one facet each:
              //[China], [USA], [Asia, Africa, Europe]
              //This is achieved by a config like so:
              // "facet_row": {
              //     data: {
              //       modelType: "entityMembershipDataConfig",
              //       space: ["geo"],
              //       concept: "is--",
              //       exceptions: {"is--country": "geo"},
              //     }
              //   },
              return new Map(Object.entries(this.config.exceptions || defaults$8.exceptions));
          },

          fetchResponse() {
              let promise;
              if (this.concept === "is--")
                  promise = this.spaceCatalog.then(spaceCatalog => {
                      const dim = this.space[0];

                      if(this.space.length > 1) 
                        console.warn(`DataConfig model of type entityMembershipDataConfig only supports one dimension,
                      but got configured to a multidimensional space:`, this.space.slice());

                      const isnessArray = [];

                      for (const [entityKey, entity] of spaceCatalog[dim].entities.entries()) {
                          let isness = Object.entries(entity)
                              .filter(([k,v]) => k.includes("is--") && v)
                              //support special cases
                              .map(([k,v]) => this.exceptions.has(k) ? entity[this.exceptions.get(k)] : k);
                              
                          //handle situation when entity is not included in any set
                          if (isness.length === 0) isness = ["is--" + dim];

                          isnessArray.push({[dim]: entity[dim], "is--": isness});
                      }
                      return DataFrame(isnessArray, [dim]);
                  });
              else
                  promise = this.source.query(this.ddfQuery)
                      .then(response => response.forKey(this.commonSpace));
              return fromPromise(promise);
          }
      })
  };
  entityMembershipDataConfig.decorate = dataConfig.decorate;

  const dataConfigStore = createStore(dataConfig, {
      entityPropertyDataConfig,
      entityMembershipDataConfig
  });

  const scales = {
      "linear": d3$1.scaleLinear,
      "log": d3$1.scaleLog,
      "genericLog": d3$1.scaleSymlog,
      "sqrt": d3$1.scaleSqrt,
      "ordinal": d3$1.scaleOrdinal,
      "point": d3$1.scalePoint,
      "band": d3$1.scaleBand,
      "time": d3$1.scaleUtc,
      "rank": d3$1.scaleLinear,
      "svg": d3$1.scaleIdentity,
  };

  const categoricalScaleTypes = ["ordinal", "band", "point", "rank", "svg"];
  const numericScaleTypes = ["linear", "log", "genericLog", "sqrt", "time"]; 
  function scale(...args) {
      return createModel(scale, ...args)
  }

  scale.nonObservable = function(config, parent) {
    
      function isArrayOneSided(array){
          if (!array) return false;
          if (array.length < 2) return true;
          return !(d3$1.min(array) <= 0 && d3$1.max(array) >= 0);
      }

      return {
          config,
          parent,
          name: 'scale',
          defaults: {
              allowedTypes: null,
              clamp: false,
              clampDomainToData: false,
              orderDomain: true,
              domain: [0, 1],
              range: [0, 1],
              numericType: 'linear',
              categoricalType: "point",
              zeroBaseline: false,
          },
          get zeroBaseline() {
              return (this.config.zeroBaseline ?? this.defaults.zeroBaseline) && !this.isDiscrete() && isArrayOneSided(this.data.domain);
          },
          get clamp() {
              return this.config.clamp ?? this.defaults.clamp;
          },
          get data() {
              return this.parent.data;
          },
          get orderDomain() {
              return this.config.orderDomain ?? this.defaults.orderDomain;
          },
          getScaleTypeWithoutLookingAtDomain() {
              const concept = this.data.conceptProps;
              let scaleType = null;
              let scale;
              if (scales[this.config.type]) {
                  scaleType = this.config.type;
              } else if (concept?.scales && (scale = JSON.parse(concept.scales).filter(s => !this.allowedTypes || this.allowedTypes.includes(s))[0]) && scales[scale]) {
                  scaleType = scale;            
              } else if (concept?.concept_type === "time") {
                  scaleType = "time";
              } else if (this.data.constant || concept && ["entity_domain", "entity_set", "string", "boolean"].includes(concept.concept_type)) {
                  scaleType = [...d3.intersection(this.allowedTypes, categoricalScaleTypes)][0] || this.defaults.categoricalType;
              } else {
                  scaleType = [...d3.intersection(this.allowedTypes, numericScaleTypes)][0] || this.defaults.numericType;
              }
              return scaleType;
          },
          get allowedTypes() {
              return this.config.allowedTypes ?? Object.keys(scales).filter(s => s !== "rank" || this.parent.config.modelType === "lane");
          },
          get type() {
              let scaleType = this.getScaleTypeWithoutLookingAtDomain();
              let allowedTypes = this.allowedTypes;
              
              if (scaleType == "log" && !isArrayOneSided(this.domain))
                  scaleType = "genericLog";

              if (allowedTypes && !allowedTypes.includes(scaleType))
                  console.warn('Scale type not in allowedTypes, please change scale type.', { scaleType, allowedTypes });
                  
              return scaleType;    
          },
          get d3Type() {
              return scales[this.type];
          },
          calcRange(domain = this.domain) {
              if (this.config.range != null)
                  return this.config.range;

              // default
              return this.defaults.range;
          }, 
          get range() {
              return this.calcRange();
          },
          get clampDomainToData() { return this.config.clampDomainToData ?? this.defaults.clampDomainToData },
          get isSameAsFrameEncScale() {
              const enc = this.parent;
              const marker = this.parent.marker;
              const frame = marker?.encoding?.frame;

              return enc.config.modelType !== "frame" && frame && enc.data.concept === frame.data.concept;
          },
          get domain() {
              let domain;
              if (this.config.domain) {
                  domain = this.config.domain
                      .map(v => parseConfigValue(v, this.data.conceptProps))
                      .map(v => this.clampDomainToData ? this.clampToDomain(v, this.data.domain) : v);
              } else if (this.data.isConstant) {
                  domain = [this.data.constant];
              } else if (this.isSameAsFrameEncScale) {
                  domain = this.parent.marker.encoding.frame.scale.domain;
              } else if (this.getScaleTypeWithoutLookingAtDomain() === "rank") {
                  domain = [0, this.parent.totalTrackNumber];
              } else if (this.data.domain) {
                  domain = this.data.domain;
                  // zeroBaseline can override the domain if defined and if data domain is one-sided
                  // by replacing the value closest to zero with zero
                  // use cases: forcing zero-based bar charts and bubble size
                  if (this.zeroBaseline) {
                      domain = [...domain];
                      const closestToZeroIdx = d3$1.leastIndex(domain.map(Math.abs));
                      domain[closestToZeroIdx] = 0;
                  } 
              } else {
                  domain = this.defaults.domain;
              }     
              return this.isDiscrete() && this.orderDomain ? [...domain].sort(sortDateSafe) : domain;
          },
          set domain(domain) {
              this.config.domain = domain;
          },
          clampToDomain(val, domain = this.domain) {
              if (this.isDiscrete())
                  return domain.includes(val) ? val : undefined;
              
              if (val < domain[0]) return domain[0];
              if (val > domain[1]) return domain[1];
              return val;
          },
          d3ScaleCreate() {
              const scale = scales[this.type]();
              if (this.type === "genericLog") ;
              if(scale.clamp) scale.clamp(this.clamp);
              return scale.domain(this.domain).range(this.range);
          },
          get d3Scale() {
              return this.d3ScaleCreate();
          },
          get zoomed() {
              return this.config.zoomed ? this.config.zoomed.map(c => parseConfigValue(c, this.data.conceptProps)) : this.domain;
          },
          set zoomed(zoomed) {
              this.config.zoomed = zoomed;
          },
          isDiscrete() {
              const scaleType = this.getScaleTypeWithoutLookingAtDomain();
              return categoricalScaleTypes.includes(scaleType);
          },
          domainIncludes(value, domain = this.domain) {
              if ([d3$1.scaleLinear, d3$1.scaleLog, d3$1.scaleSymlog, d3$1.scaleSqrt, d3$1.scaleUtc].includes(this.d3Type)) {
                  const [min, max] = domain;
                  return min <= value && value <= max;
              } else {
                  return domain.includes(value);
              }
          },
          disposers: [],
          onCreate() { },
          dispose() {
              for (let disposer of this.disposers) {
                  disposer();
              }
          }
      }
  };

  scale.decorate = {
      // allow setting an array to these properties, otherwise getting an infinite loop because values inside array won't be compared
      range: mobx.computed.struct,
      domain: mobx.computed.struct,
      zoomed: mobx.computed.struct,
      allowedTypes: mobx.computed.struct
  };

  const defaultConfig$7 = {
      palette: {},
  };

  const defaults$7 = {
      defaultPalettes: {
          "_continuous": {
            "_default": "#ffb600",
            "0": "#8c30e8", //"hsl(270, 80%, 55%)",
            "25": "#30a3e8", //"hsl(202.5, 80%, 55%)",
            "50": "#30e85e", //"hsl(135, 80%, 55%)",
            "75": "#e2c75a", //"hsl(48, 70%, 62%)",
            "100": "#e83030" //"hsl(0, 80%, 55%)"
          },
          "_ordinal": {
            "_default": "#aaa",
            "0": "#4cd843",
            "1": "#e83739",
            "2": "#ff7f00",
            "3": "#c027d4",
            "4": "#d66425",
            "5": "#0ab8d8",
            "6": "#bcfa83",
            "7": "#ff8684",
            "8": "#ffb04b",
            "9": "#f599f5",
            "10": "#f4f459",
            "11": "#7fb5ed"
          },
          "_constant": {
            "_default": "#ffb600"
          }
      },
  };

  function palette(config = {}, parent) {

      applyDefaults(config, defaultConfig$7);

      return {
          config,
          parent,
          get encoding() {
              return this.parent.parent;
          },
          get colorConceptProp() {
              const conceptProps = this.encoding.data.conceptProps;
              return conceptProps ? JSON.parse(this.encoding.data.conceptProps.color || "{}") : {};
          },
          get defaultPalettes() {
              return this.config.defaultPalettes || defaults$7.defaultPalettes;
          },
          get defaultPalette() {
              let palette;
              
              if (this.encoding.data.isConstant) {
                  //an explicit hex color constant #abc or #adcdef is provided
                  if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/.test(this.encoding.data.constant)) {
                      palette = { "_default": this.encoding.data.constant };
                  } else {
                      palette = deepclone(this.defaultPalettes["_constant"]);
                  }
              } else if (this.colorConceptProp.palette) {
                  //specific color palette from enc concept properties
                  palette = deepclone(this.colorConceptProp.palette);
              } else {
                  palette = deepclone(this.defaultPalettes[this.paletteType]);
              }
              
              return palette;
          },
          get paletteType() {
              //constant
              if (this.encoding.data.isConstant) return "_constant";
              //measure
              if (["time", "measure"].includes(this.encoding.data.conceptProps.concept_type)) return "_continuous";
              
              return "_ordinal";
          },
          get paletteLabels() {
              return this.colorConceptProp.paletteLabels;
          },
          get palette() {
              const obj = Object.assign({}, this.defaultPalette, this.config.palette); 
              
              //remove null values from the result of merging
              Object.keys(obj).forEach(key => {
                  if (!obj[key]) delete obj[key];
              });

              return obj;
          },
          get defaultColor() {
              return this.getColor("_default") || this.defaultPalettes[this.paletteType]["_default"];
          },
          get paletteDomain() {
              return Object.keys(this.palette).filter(f => f !== "_default").sort((a, b) => a - b);
          },
          get isUserSelectable() {
              return this.colorConceptProp.hasOwnProperty("selectable") ? this.colorConceptProp.selectable : true;
          },
          get shades() {
              return this.colorConceptProp.shades;
          },
          getColorShade({colorID, shadeID = "shade"}) {
              if (!colorID) 
                  return false;

              const color = this.palette[colorID];
              
              //a specific shade is available
              if (Array.isArray(color))
                  return color[this.shades[shadeID]];
              
              // if the resolved colr value is not an array (has only one shade) -- return it
              return shadeID === "shade" 
                  ? d3$1.rgb(palette[colorID] || this.parent.d3Scale(colorID)).darker(0.5).toString() 
                  : color;
          },
          getColor(key, palette = this.palette) {
              const color = palette[key];
              return Array.isArray(color) ? color[0] : color;
          },
          getColorByIndex(index, palette = this.palette) {
              const length = Object.keys(palette).filter(f => f !== "_default").length;
              const color = palette[index % length];
              return Array.isArray(color) ? color[0] : color;
          },
          setColor: mobx.action('setColor', function (value, pointer) {
              if(!this.parent.config.palette) this.parent.config.palette = {palette: {}};
              this.parent.config.palette.palette["" + pointer] = value ? d3$1.color(value).hex() : value;
          }),
          removeColor: mobx.action('removeColor', function (pointer) {
              if(this.config.palette.hasOwnProperty("" + pointer))
                  delete this.config.palette["" + pointer];
          })
      }
  }

  const defaults$6 = {
      categoricalType: "ordinal",
  };

  const colors = {
      schemeCategory10: d3$1.schemeCategory10
  };

  function color(...args) {
      return createModel(color, ...args)
  }

  color.nonObservable = function(config, parent) {
      
      const s = scale.nonObservable(config, parent);
      s.defaults = deepmerge(s.defaults, defaults$6);

      return assign(s, {
          calcRange(domain = this.domain) {
              const range = this.config.range;
              if (Array.isArray(range))
                  return range;
              
              if (isString(range) && colors[range])
                  return colors[range];

              const palette = this.palette;
              if (palette.paletteType == "_continuous") {
                  const scaleDomain = domain;
                  const singlePoint = (scaleDomain[1] - scaleDomain[0] == 0);

                  return palette.paletteDomain.map(m => palette.getColor(singlePoint ? palette.palette[palette.paletteDomain[0]] : m));
              }

              return domain.map((d, i) => {
                  return palette.getColor(d) || palette.getColorByIndex(i) || palette.defaultColor;
              });
          },

          get isPattern() {
              return !!(this.domain && this.domain.length && this.domain.some(color => color && color.length && color[0] == "<"));
          },

          get palette() {
              const config = resolveRef(this.config.palette).value || defaults$6.palette;
              return mobx.observable(palette(config, this));
          },

          get d3Scale() {

              const scale = this.d3ScaleCreate();
              let domain = scale.domain();

              if (this.palette.paletteType == "_continuous") { 
                  domain = this.palette.paletteDomain.map(m => +domain[0] + m / 100 * (domain[1] - domain[0]));
              }
              
              if (this.isDiscrete()) {
                  scale.unknown(this.palette.defaultColor);
              } else {
                  if (this.type === "log" || this.type === "genericLog") {
                      const limits = [domain[0], domain[domain.length - 1]];
                      const s = scale.copy()
                          .domain(limits)
                          .range(limits);
                      
                      domain = domain.map(d => s.invert(d));
                  }
                  
                  scale.interpolate(d3$1.interpolateRgb.gamma(2.2));
              }
              
              scale.domain(domain);
              return scale;
          }
      });
  };

  const defaults$5 = {
      clamp: true,
      extent: [0, 1],
      range: [0, 20],
      zeroBaseline: true,
      categoricalType: "point",
  };

  function size(...args) {
      return createModel(size, ...args)
  }

  size.nonObservable = function(config, parent) {

      const s = scale.nonObservable(config, parent);
      s.defaults = deepmerge(s.defaults, defaults$5);

      return assign(s, {
          get extent() {
              return this.config.extent || this.defaults.extent;
          },
          set extent(extent) {
              this.config.extent = extent;
          }
      });
  };

  const scaleStore = createStore(scale, {
      color,
      size,
  });

  //import { scaleLinear, scaleSqrt, scaleLog, scalePoint, scaleOrdinal, schemeCategory10, extent, set } from 'd3'

  const defaultConfig$6 = {
      scale: {},
      data: {}
  };

  function encoding(...args) {
      return createModel(encoding, ...args);
  } 

  encoding.nonObservable = function(config, parent, id) {
      //console.warn('creating new encoding', name, config);
      applyDefaults(config, defaultConfig$6);

      let currentDataConfig;

      const functions = {
          id, 
          get marker() {
              return this.parent;
          },
          get name() {
              if (this.marker)
                  return this.marker.getEncodingName(this);
              else 
                  return 'Unnamed'
          },
          get data() {
              const config = resolveRef(this.config.data).value;
              const dataConfig = dataConfigStore.get(config, this);
              if (currentDataConfig && dataConfig != currentDataConfig) {
                  currentDataConfig.dispose();
              }
              return currentDataConfig = dataConfig;
          },
          get transformFields() {
              return [];
          },
          get scale() {
              // console.warn('recalculating scale', this.name);
              const scale = resolveRef(this.config.scale).value;
              return scaleStore.get(scale, this);
          },
          get references() {
              return Object.fromEntries(Object.entries(this.config)
                  .filter(entry => isReference(entry[1]))
                  .map(([key, ref]) => [ key , resolveRef(ref) ] )
              );
          },
          get referenceState() {
              return combineStates(Object.values(this.references).map(ref => ref.state))
          },
          get state() {
              return combineStates([this.data.state, this.referenceState]);
          },

          dataMapBeforeTransform(transformName) {
              const transformations = this.marker.transformations;
              const fullTransformName = this.name + "." + transformName;
              const transformIndex = transformations.findIndex(tObj => tObj.name == fullTransformName);
              return this.marker.getTransformedDataMap(transformations[transformIndex - 1].name);
          },
          
          setWhich: mobx.action('setWhich', function(kv) {        
              const concept = isNonNullObject(kv.value) ? kv.value.concept : kv.value;
              
              if (kv.key) {
                  //check ds
                  if (isNonNullObject(kv.value)) {
                      if (this.marker && kv.value.dataSource == this.marker.config.data.source) {
                          delete this.config.data.source;
                      } else {
                          this.config.data.source = kv.value.dataSource;
                      }
                  }
      
                  this.config.data.concept = concept;
                  this.config.data.space = kv.key;
                  delete this.config.data.constant;
              } else {
                  this.config.data.constant = kv.value.concept;
                  delete this.config.data.concept;
                  //delete this.config.data.space;
              }
      
              this.config.scale.domain = null;
              this.config.scale.type = null;
              this.config.scale.zoomed = null;
              this.config.scale.palette = {};
          }),
          internalErrors: [],
          dispose() {
              for (const dispose of this.destructers) {
                  dispose();
              }
              this.data.dispose();
              this.scale.dispose();
          },
          destructers: [],
          
      };

      return assign({}, functions, configurable, { config, parent });
  };

  const defaultConfig$5 = {
      modelType: "frame",
      value: null,
      loop: false,
      data: {
          concept: {
              selectMethod: "selectFrameConcept"
          }
      },
      scale: {
          clampDomainToData: true
      }
  };

  const defaults$4 = {
      interpolate: true,
      extrapolate: false,
      playEmptyFrames: false,
      loop: false,
      playbackSteps: 1,
      speed: 100,
      interval: "year",
      splash: false
  };

  function frame(...args) {
      return createModel(frame, ...args);
  }

  frame.nonObservable = function(config, parent, id) {
      applyDefaults(config, defaultConfig$5);

      const functions = {
          get value() {
              let value;
      
              if (this.config.value != null) {
                  value = this.parseValue(this.config.value);
                  value = this.scale.clampToDomain(value);
              } else {
                  value = this.scale.domain.at(-1);
              }
              return value;
          },
          parseValue(value){
              if (typeof value === "number") value = "" + value;
              return parseConfigValue(value, this.data.conceptProps);
          },
          formatValue(value){
              return configValue(value, this.data.conceptProps);
          },
          get step() { return this.stepScale(this.value); },
          
          /**
           * Scale with frame values (e.g. years) as domain and step number (e.g. 0-15) as range.
           * Can't use 2 point linear scale as time is not completely linear (leap year/second etc)
           * @returns D3 scale
           */
          get stepScale() {
              const range = d3$1.range(0, this.stepCount);
              const scale = this.scale.d3Type(this.domainValues, range); 
      
              // fake clamped invert for ordinal scale
              // https://github.com/d3/d3/issues/3022#issuecomment-260254895
              if (!scale.invert) scale.invert = step => this.domainValues[step];
      
              return scale;
          },
          get playEmptyFrames() {
              return this.config.playEmptyFrames ?? defaults$4.playEmptyFrames;
          },
          /**
           * Key frame values limited to scale domain
           **/ 
          get domainValues() {
              const frameMap = this.marker.getTransformedDataMap("filterRequired");
              if (this.playEmptyFrames) {
                  const domain = frameMap.keyExtent();
                  return inclusiveRange(domain[0], domain[1], this.interval);
              } else {
                  let frameValues = [];
                  for (let frame of frameMap.values()) {
                      const frameValue = frame.values().next().value[this.name];
                      if (this.scale.domainIncludes(frameValue)) {
                          frameValues.push(frameValue);
                      } 
                  }
                  return frameValues
              }
          },
          get stepCount() {
              return this.domainValues.length;
          },
      
          // PLAYBACK
          get speed() { 
              if (this.immediate) return 0;
              return this.config.speed || defaults$4.speed 
          },
          get loop() { return this.config.loop || defaults$4.loop },
          get playbackSteps() { return this.config.playbackSteps || defaults$4.playbackSteps },
          immediate: false,
          playing: false,
          togglePlaying() {
              this.playing ?
                  this.stopPlaying() :
                  this.startPlaying();
          },
          startPlaying: mobx.action('startPlaying', function startPlaying() {
              this.setPlaying(true);
          }),
          stopPlaying: mobx.action('stopPlaying', function stopPlaying() {
              this.setPlaying(false);
          }),
          jumpToFirstFrame: mobx.action('jumpToFirstFrame', function jumpToFirstFrame() {
              this.setStep(0);
              this.immediate = this.playing;
          }),
          setPlaying: mobx.action('setPlaying', function setPlaying(playing) {
              this.playing = playing;
              if (playing) {
                  if (this.step == this.stepCount - 1) {
                      this.jumpToFirstFrame();
                  } else {
                      this.nextStep();
                  }
              }
          }),
          setExtrapolate: mobx.action('setExtrapolate', function setExtrapolate(extrapolate) {
              this.config.extrapolate = extrapolate;
          }),
          setSpeed: mobx.action('setSpeed', function setSpeed(speed) {
              speed = Math.max(0, speed);
              this.config.speed = speed;
          }),
          setValue: mobx.action('setValue', function setValue(value) {
              let concept = this.data.conceptProps;
              let parsed = this.parseValue(value);
              if (parsed != null) {
                  parsed = this.scale.clampToDomain(parsed);
              }
              this.config.value = configValue(parsed, concept);
          }),
          setStep: mobx.action('setStep', function setStep(step) {
              this.setValue(this.stepScale.invert(step));
          }),
          setValueAndStop: mobx.action('setValueAndStop', function setValueAndStop(value) {
              this.stopPlaying();
              this.setValue(value);
          }),
          setStepAndStop: mobx.action('setStepAndStop', function setStepAndStop(step) {
              this.stopPlaying();
              this.setStep(step);
          }),
          snap: mobx.action('snap', function snap() {
              this.setStep(Math.round(this.step));
          }),
          ceilKeyFrame() {
              return this.stepScale.invert(Math.ceil(this.step));
          },
          nextStep: mobx.action('update to next frame value', function nextStep() {
              if (this.playing && this.marker.state === FULFILLED) {
                  this.immediate = false;
                  let nxt = this.step + this.playbackSteps;
                  if (nxt < this.stepCount) {
                      this.setStep(nxt);
                  } else if (this.step == this.stepCount - 1) {
                      // on last frame
                      if (this.loop) {
                          this.jumpToFirstFrame();
                      } else {
                          this.stopPlaying();
                      }
                  } else {
                      // not yet on last frame, go there first
                      this.setStep(this.stepCount - 1); 
                  }
              }
          }),
      
          /**
           * Given an array of normalized marker-key strings, gives the extent/domain of each in the frameMap
           * @param {[string]} markerKeys
           * @returns 
           */
          markerLimits(markerKeys) {
              const frameMap = this.dataMapBeforeTransform("currentFrame");
              return frameMap.extentOfGroupKeyPerMarker(markerKeys)
          },
      
          // TRANSFORMS
          get transformationFns() {
              return {
                  'frameMap': this.frameMap.bind(this),
                  'interpolate': this.interpolateData.bind(this),
                  'extrapolate': this.extrapolateData.bind(this),
                  'currentFrame': this.currentFrame.bind(this)
              }
          },
          get transformFields() {
              return [this.name];
          },
      
          // FRAMEMAP TRANSFORM
          frameMap(df) {
              let frameMap = df.groupBy(this.name, this.rowKeyDims);
              // reindex framemap - add missing frames within domain
              // i.e. not a single defining encoding had data for these frame
              // reindexing also sorts frames
              return frameMap.reindexToKeyDomain(this.interval);
          },
          get rowKeyDims() {
              // remove frame concept from key if it's in there
              // e.g. <geo,year>,pop => frame over year => <year>-><geo>,year,pop 
              return relativeComplement([this.data.concept], this.data.space);
          },

          // interpolate transform
          get interpolate() { return this.config.interpolate ?? defaults$4.interpolate },
          interpolateData(frameMap) {
              if (frameMap.size == 0 || !this.interpolate) 
                  return frameMap;

              const newFrameMap = frameMap.copy();
              const encName = this.name;

              return newFrameMap.interpolateOverMembers({ 
                  fields: this.changeBetweenFramesEncodings,
                  frameField: encName,
                  frameCopyFields: this.encodingsThatCopyFrame.concat(this.data.concept),
                  interpolators: this.fieldCustomInterpolators
              });
          },
          get encodingsThatCopyFrame() {
              const enc = this.marker.encoding;
              return Object.keys(enc).filter(prop => 
                  enc[prop] != this 
                  && enc[prop].data.concept === this.data.concept
                  && enc[prop].data.space.includes(this.data.concept)
              );
          },
          get changeBetweenFramesEncodings() {
              const enc = this.marker.encoding;
              const encProps = Object.keys(enc).filter(prop => enc[prop] != this);
              if (!this.data.conceptInSpace)
                  return encProps;
              else
                  return encProps.filter(prop => {
                      return enc[prop].data.hasOwnData 
                          && enc[prop].data.space.includes(this.data.concept);
                  })
          },
          get fieldCustomInterpolators() {
              const enc = this.marker.encoding;
              return this.changeBetweenFramesEncodings.reduce((result, encName) => {
                  if(!["measure", "time"].includes(enc[encName].data?.conceptProps?.concept_type)
                      && !enc[encName].scale?.interpolate
                      && !enc[encName].data?.conceptProps?.interpolate){
                      //use zero order interpolation instead default d3.interpolate
                      result[encName] = stepBeforeInterpolator;
                  }
                  return result;
              }, {});
          },

          get interval() { 
              const interval = this.config.interval ?? this.data.conceptProps.concept;
              return POSSIBLE_INTERVALS.includes(interval) ? interval : defaults$4.interval;
          },

          // extrapolate transform
          get extrapolate() { return this.config.extrapolate ?? defaults$4.extrapolate },
          extrapolateData(frameMap) {
              if (frameMap.size == 0 || !this.extrapolate) 
                  return frameMap;

              // find which indexes will be the first and last after marker.filterRequired transform
              // needed to limit extrapolation to eventual filterRequired (feature request by Ola)
              // can't extrapolate áfter filterRequired as some partially filled markers will already be filtered out
              const hasDataForRequiredEncodings = frame => {
                  for (const marker of frame.values()) {
                      if (this.marker.requiredEncodings.every(enc => marker[enc] != null)) {
                          return true;
                      }
                  }
                  return false;
              };
              const requiredExtentIndices = frameMap.keyExtentIndices({
                  filter: hasDataForRequiredEncodings
              });

              const encName = this.name;

              return frameMap.extrapolateOverMembers({ 
                  fields: this.changeBetweenFramesEncodings,
                  sizeLimit: this.extrapolate,
                  indexLimit: requiredExtentIndices,
                  ammendNewRow: row => row[this.data.concept] = row[encName]
              });
          },

          // CURRENTFRAME TRANSFORM
          currentFrame(data) {
              if (data.size == 0) 
                  return DataFrame([], data.descendantKeys[0]);
      
              return data.has(this.frameKey) 
                  ? data.get(this.frameKey)
                  : this.scale.domainIncludes(this.value, this.data.domain) && this.interpolate
                      ? this.getInterpolatedFrame(data, this.step, this.stepsAround)
                      : DataFrame([], data.descendantKeys[0]);
      
          },
          get frameKey() {
              return createKeyFn([this.name])({ [this.name]: this.value }) // ({ [this.name]: this.value });
          },
          get fieldsToInterpolate() {
              return [this.name, this.data.concept, ...this.changeBetweenFramesEncodings, ...this.encodingsThatCopyFrame];
          },
          getInterpolatedFrame(df, step, stepsAround) {
              const keys = Array.from(df.keys());
              const [before, after] = stepsAround.map(step => df.get(keys[step]));
              return before.interpolateTowards(after, step % 1, this.fieldsToInterpolate, this.fieldCustomInterpolators);
          },
          get stepsAround() {
              return [Math.floor(this.step), Math.ceil(this.step)];
          },
          get framesAround() {
              return this.stepsAround.map(this.stepScale.invert);
          },
      
          /*
           * Compute the differential (stepwise differences) for the given field 
           * and return it as a new dataframe(group).
           * NOTE: this requires that the given df is interpolated.
           * USAGE: set a correct list of transformations on the __marker__
           * and then add/remove the string "differentiate" to the data of an 
           * encoding in that marker. For example:
           *   markers: {
           *      marker_destination: {
           *        encoding: {
           *           "x": {
           *             data: {
           *               concept: "displaced_population",
           *               transformations: ["differentiate"]
           *             }
           *           },
           *          ...
           *        },
           *        transformations: [
           *          "frame.frameMap",
           *          "x.differentiate",
           *          "filterRequired",
           *          "order.order",
           *          "trail.addTrails",
           *          "frame.currentFrame"
           *        ]
           * 
           */
          differentiate(df, xField) {
              let prevFrame;
              let result = DataFrameGroup([], df.key, df.descendantKeys);
              for (let [yKey, frame] of df) {
                  const newFrame = frame.copy();
                  for(let [key, row] of newFrame) {
                      const newRow = Object.assign({}, row);
                      const xValue = row[xField];
                      if (xValue !== undefined) {
                          newRow[xField] = prevFrame ? xValue - prevFrame.getByStr(key)[xField] : 0;
                      }
                      newFrame.set(newRow, key);
                  }
                  prevFrame = frame;
                  result.set(yKey, newFrame);
              }
              return result;
          },
          get state() {
              const states = [this.data.state, this.data.source.conceptsPromise.state];
              return combineStates(states);
          },
          onCreate() {
              // need reaction for timer as it has to set frame value
              // not allowed to call action (which changes state) from inside observable/computed, thus reaction needed
              const playbackDestruct = mobx.reaction(
                  // mention all observables (state & computed) which you want to be tracked
                  // if not tracked, they will always be recomputed, their values are not cached
                  () => { return { playing: this.playing, speed: this.speed } },
                  ({ playing, speed }) => {
                      clearInterval(this.playInterval);
                      if (playing) {
                          this.playInterval = setInterval(this.nextStep.bind(this), speed);
                      }
                  }, 
                  { 
                      name: "frame playback timer",
                      onError: error => this.internalErrors.push(error) 
                  }
              );
              this.destructers.push(playbackDestruct);
              const configLoopbackDestruct = mobx.reaction(
                  () => { 
                      const waitFor = this.marker || this;
                      if (waitFor.state == 'fulfilled') return this.value 
                  },
                  (value) => {
                      if (value && "value" in this.config && !equals(this.config.value, value)) {
                          this.config.value = configValue(value, this.data.conceptProps);
                      }
                  },
                  { 
                      name: "frame config loopback",
                      onError: error => this.internalErrors.push(error) 
                  }
              );
              this.destructers.push(configLoopbackDestruct);
              this.destructers.push(() => {
                  clearInterval(this.playInterval);
              });
          },
          get splash() { 
              return this.config.splash || defaults$4.splash;
          }
      };

      return assign(encoding.nonObservable(config, parent, id), functions);
  };

  frame.splashMarker = function splashMarker(marker) {
      const frame = marker.encoding.frame;
      if (frame?.splash && frame?.config.value) {
          const concept = resolveRef(frame.config.data.concept).value;
          if (typeof concept == "string") {
              let splashConfig = Vizabi.utils.deepclone(marker.config);
              const filterMerge = { data: { filter: { dimensions: { [concept]: { [concept]: 
                  frame.config.value 
              } } } } };
              splashConfig = Vizabi.utils.deepmerge(splashConfig, filterMerge);
              
              let splashMarker = Vizabi.marker(splashConfig, marker.id + '-splash');
              let proxiedMarker = markerWithFallback(marker, splashMarker);

              return { marker: proxiedMarker, splashMarker }
          } else {
              console.warn("Frame splash does not work with autoconfig concept. Please set frame.data.concept or disable splash.");
              return { marker };
          }
      } else {
          return { marker };
      }
  };
  frame.decorate = {
      changeBetweenFramesEncodings: mobx.computed.struct,
      encodingsThatCopyFrame: mobx.computed.struct
  };

  function markerWithFallback(marker, fallback) {
      return new Proxy(marker, {
          get: function(target, prop, receiver) {

              if (fallback && target.state == 'fulfilled') {
                  fallback.dispose();
                  fallback = undefined;
              }

              return fallback
                  ? fallback[prop]
                  : target[prop];
          }
      })
  }

  //instead of selecting an unused concept it selects a frame concept
  //gives preference to concepts in space that are of type time and measure
  //if there is no time or measure in space then check candidate concepts given by solveMethod
  //if notheing there either, then pick the last dimension of the space
  //it woud fail if space is an empty array
  configSolver.addSolveMethod(
      function selectFrameConcept({ concepts, space, dataConfig }) {
          const spaceConcepts = space.map(dim => dataConfig.source.getConcept(dim));
          return findTimeOrMeasure(spaceConcepts) || findTimeOrMeasure(concepts) || spaceConcepts[spaceConcepts.length - 1];
          
          function findTimeOrMeasure (concepts) {
              return concepts.find(c => c.concept_type == 'time') || concepts.find(c => c.concept_type == 'measure');
          }
      }
  );

  const defaultConfig$4 = {
      modelType: "selection",
      data: {
          concept: undefined,
          space: undefined
      }
  };

  const selection = defaultDecorator({
      base: encoding,
      defaultConfig: defaultConfig$4
  });

  const directions = {
      ascending: "ascending",
      descending: "descencding"
  };
  const defaults$3 = {
      direction: directions.ascending
  };

  const order = defaultDecorator({
      base: encoding,
      functions: {
          get direction() {
              return resolveRef(this.config.direction).value || defaults$3.direction;
          },
          get transformFields() {
              return this.data.isConstant ? [] : [this.name];
          },
          order(df) {
              if (this.data.isConstant)
                  return df;
              
              return df.order([{ [this.name]: this.direction }]);
          },
          get transformationFns() {
              return {
                  order: this.order.bind(this)
              }
          },
      }
  });

  const defaultConfig$3 = {
      data: {
          concept: undefined,
          space: undefined,
          filter: { 
              modelType: "trailFilter",
              markers: {}, 
          } 
      }
  };

  const defaults$2 = {
      show: true,
      updateStarts: true,
      frameEncoding: "frame"
  };
  function trail(...args) {
      return createModel(trail, ...args)
  }

  trail.nonObservable = function(config, parent, id) {

      applyDefaults(config, defaultConfig$3);

      const base = encoding.nonObservable(config, parent, id);
      let oldStarts = {};

      return assign(base, {
          get show() { 
              return typeof this.config.show == 'boolean' ? this.config.show : defaults$2.show
          },
          get groupDim() {
              return this.frameEncoding.data.concept;
          },
          get frameEncoding() {
              const frameEncoding = this.config.frameEncoding || defaults$2.frameEncoding;
              return this.marker.encoding[frameEncoding];
          },
          /**
           * For each trailed marker, get the min-max of the trail. 
           */
          get limits() {
              // get datamap that's also used as input for addTrails
              const group = this.dataMapBeforeTransform("addPreviousTrailHeads");
              return group.extentOfGroupKeyPerMarker(this.data.filter.markers.keys())
          },
          /**
           * Set trail start of every bubble to `value` if value is lower than current trail start
           */
          updateTrailStart: mobx.action('update trail start', function updateTrailStart(
              value = this.frameEncoding.value, 
              limits = this.limits
          ) {
              let key, min, max;
              for (key in this.starts) {
                  [min, max] = limits[key];
                  max = d3$1.min([max, this.starts[key]]);
                  this.data.filter.set(key, value, [min, max]);
              }
          }),
          /**
           * Object of parsed trail starts from config
           */
          get starts() {
              if (!this.updateStarts) return oldStarts;
              const starts = {};
              for (let [key, payload] of this.data.filter.markers) {
                  // need to clamp here too because starts may be invalid in user config or when switching data
                  const limits = this.limits[key];
                  if (limits.some(n => n == undefined))
                      continue; // skip starts that aren't even in data
                  const configValue = this.frameEncoding.parseValue(payload);
                  starts[key] = clamp(configValue, ...limits);
              }
              return oldStarts = starts;
          },
          /**
           * Can be set to false if frame value is likely to decrease frequently (e.g. dragging a timeslider).
           * Will temporarily not update starts and thus not trigger expensive addTrails operation.
           */
          get updateStarts() {
              return typeof this.config.updateStarts == 'boolean' ?  this.config.updateStarts : defaults$2.updateStarts;
          },
          setShow: mobx.action(function(show) {
              this.config.show = show;
              if (show === true) {
                  for (let key of this.data.filter.markers.keys()) 
                      this.data.filter.set(key);
              }
          }),
          get transformationFns() {
              return {
                  'addPreviousTrailHeads': this.addPreviousTrailHeads.bind(this),
                  'addTrails': this.addTrails.bind(this)
              }
          },
          /**
           * Trails are all sorted together at the position of their head.
           * So we first add heads, then we can order markers and then we can add the rest of the trail
           * @param {*} group 
           * @returns 
           */
          addPreviousTrailHeads(group) {
              const trailMarkerKeys = Object.keys(this.starts);
              if (trailMarkerKeys.length == 0 || !this.show)
                  return group;

              const newGroup = DataFrameGroup([], group.key, group.descendantKeys);
              const trailHeads = new Map();
              for (let [id, frame] of group) {
                  const keyObj = group.keyObject(frame);
                  const historicalTrails = new Set();
                  for (let trailMarkerKey of trailMarkerKeys) {
                      // current group doesn't have a head for this trail that has already passed
                      if (!frame.hasByStr(trailMarkerKey)) {
                          if (trailHeads.has(trailMarkerKey)) {
                              historicalTrails.add(trailMarkerKey);
                          }
                      } else {
                          const trailMarker = frame.getByStr(trailMarkerKey);
                          trailHeads.set(trailMarkerKey, trailMarker);
                      }
                  }

                  const newFrame = frame.copy();
                  for (let trailMarkerKey of historicalTrails) {
                      const trailHead = trailHeads.get(trailMarkerKey);
                      newFrame.set(trailHead);
                  }
                  newGroup.set(keyObj, newFrame);
              }
              return newGroup;
          },
          /**
           *  Per given marker, in whatever ordered group
           *  1. get markers from groups before its group (possibly starting at given group)
           *  2. add those markers to current group, with new key including original group (so no collission)
           * @param {*} group 
           */
          addTrails(group) {

              // can't use this.groupDim because circular dep this.marker.transformedDataMap
              const groupDim = group.key[0]; // supports only 1 dimensional grouping
              const markerKeys = Object.keys(this.starts);

              if (markerKeys.length == 0 || !this.show)
                  return group;

              // create trails
              const trails = new Map();
              for (let key of markerKeys) {
                  const trail = new Map();
                  trails.set(key, trail);
                  for (let [i, frame] of group) {
                      if (frame.hasByStr(key))
                          trail.set(i, assign({}, frame.getByStr(key)));
                  }
              }

              // add trails to groups
              const prop = groupDim;
              const newGroup = DataFrameGroup([], group.key, group.descendantKeys);
              const trailKeyDims = [...group.descendantKeys[0], prop];
              const trailKeyFn = createKeyFn(trailKeyDims);
              for (let [id, frame] of group) {
                  const keyObj = group.keyObject(frame);
                  const newFrame = DataFrame([], frame.key);
                  for (let [markerKey, markerData] of frame) {
                      // insert trails before its head marker
                      if (trails.has(markerKey)) {
                          const trail = trails.get(markerKey);
                          const trailStart = this.starts[markerKey];
                          const trailEnd = markerData[prop];
                          // add trail markers in ascending order
                          for (let [keyStr, trailMarker] of trail) {
                              const idx = trailMarker[prop];
                              if (idx < trailStart) continue;
                              // idx > trailEnd includes main bubble in trail as well (as opposed to >=).
                              // This creates duplicate trail head markers in key frames but allows easy interpolation logic
                              // for interpolated frames. Trail head is source for two interpolated bubbles, current frame and (trail head-1).
                              // Another solution would be to allow multiple keys per datapoint (e.g. geo-swe-frame-2000 AND geo-swe)
                              // and make interpolation interpolate for both keys.
                              if (idx > trailEnd) break;
                              const newKey = trailKeyFn(trailMarker);
                              const newData = Object.assign(trailMarker, {
                                  [Symbol.for('key')]: newKey,
                                  [Symbol.for('trailHeadKey')]: markerKey
                              });
                              newFrame.set(newData, newKey);
                          }
                      }
                      // (head) marker
                      newFrame.set(markerData, markerKey);
                  }
                  newGroup.set(keyObj, newFrame);
              }
              return newGroup;
          },
          onCreate() {
              const updateTrailDestruct = mobx.reaction(
                  // wait for marker state, as we need transformeddatamaps for limits
                  () => this.marker.state == 'fulfilled' ? this.frameEncoding.ceilKeyFrame() : false,
                  (value) => { if (value) this.updateTrailStart(value); }, 
                  { 
                      name: "updateTrailStart on frame value change",
                      onError: e => this.internalErrors.push(e)
                  }
              );
              this.destructers.push(updateTrailDestruct);
              const configLoopbackDestruct = mobx.reaction(
                  () => this.marker.state == 'fulfilled' ? this.starts : undefined,
                  (starts) => {
                      // this.starts may have excluded configured markers because they're not
                      // available in data. This loops that data-informed exclusion back to 
                      // config.
                      if (starts) {
                          const filter = this.data.filter;
                          for (let key of filter.markers.keys()) {
                              if (!(key in starts))
                                  filter.delete(key);
                          }
                      }
                  },
                  { 
                      name: "trail config loopback",
                      onError: e => this.internalErrors.push(e)
                  }
              );
              this.destructers.push(configLoopbackDestruct);
          }
      });
  };

  trail.decorate = {
      starts: mobx.computed.struct,
      limits: mobx.computed.struct
  };

  const defaultConfig$2 = {
      data: {
          concept: undefined,
          space: undefined
      }
  };

  const defaults$1 = {
      ncolumns: 1
  };

  const repeat = defaultDecorator({
      base: encoding,
      defaultConfig: defaultConfig$2,
      functions: {
          //["y1", "y2"], this is for special case when aliases are connected across rows-columns 
          get row() {
              return this.config.row;
          },
          //["x1", "x2"], this is for special case when aliases are connected across rows-columns 
          get column() {
              return this.config.column;
          },
          //["x", "y"], this is the blueprint that indicates which encodings need to be aliased
          //must be of length 2 for "row" and "column" to work
          get allowEnc() {
              if(!this.config.allowEnc) console.warn(`Repeater encoding is missine essential bit of config "allowEnc"`);
              return this.config.allowEnc;
          },
          //{x: x, y: y}, unfolds enc array of strings into an object
          get guessAliases() {
              return this.allowEnc.reduce((obj, value) => {
                  if (!this.marker.encoding[value]) value = this.marker.requiredEncodings.at(-1);
                  obj[value] = value;
                  return obj;
              }, {})
          },
          get useConnectedRowsAndColumns(){
            return !!this.config.useConnectedRowsAndColumns;
          },
          //[{x: x1, y: y1}, {x: x2, y: y1}]
          get rowcolumn() {
              if(this.config.rowcolumn) return this.config.rowcolumn;
              
              if(this.useConnectedRowsAndColumns){
                  //flatten row and column arrays into rowcolumn
                  const {allowEnc, row, column} = this;
                  const rowcolumn = [];
                  row.forEach(r => {
                      column.forEach(c => {
                          rowcolumn.push({[allowEnc[0]]: r, [allowEnc[1]]: c});
                      });
                  });
                  return rowcolumn;
              } else {
                  //try to guess aliases as defaults
                  return [this.guessAliases];
              }
          },
          //1, generic way: number of columns for wrapping
          get ncolumns() {
              return this.config.ncolumns || this.useConnectedRowsAndColumns && this.column.length || defaults$1.ncolumns;
          },
          get nrows() {
              return this.rowcolumn.length / this.ncolumns;
          },
          getName: function(d) {
              const hash = Object.keys(d)
                  .sort(d3$1.ascending)
                  .map(key => key + "-" + d[key])
                  .join("--");
              return `chart-repeated--${hash}`;
          },
          getRowIndex: function(i) {
              return Math.floor(i/this.ncolumns);
          },
          getColumnIndex: function(i) {
              return i % this.ncolumns;
          },
      }
  });

  const defaultConfig$1 = {
      data: {
          concept: undefined,
          space: undefined
      }
  };

  const aggregate = defaultDecorator({
      base: encoding,
      defaultConfig: defaultConfig$1,
      functions: {
          get grouping () { 
            return this.config.grouping ?? {};
          },
          get measures() {
            return this.config.measures ?? [];
          },
          aggregate(df) {
              const groupSizes = filterObject(this.grouping, 
                  (val, key) => df.key.includes(key) && val['grouping'] > 1
              );
              const measures = this.measures;

              if (Object.keys(groupSizes).length == 0) {
                return df;
              }

              let result = DataFrame([], df.key);
              for (const row of df.rows()) {
                  // new grouped key
                  const newKeyObj = pick(row, df.key);
                  for (const dim in groupSizes) {
                      const groupSize = groupSizes[dim]['grouping'];
                      newKeyObj[dim] = Math.floor(+row[dim] / groupSize) * groupSize;
                  }
                  const keyStr = result.keyFn(newKeyObj);
                  // sum if group already exists, otherwise create
                  if (result.hasByStr(keyStr)) {
                      const newRow = result.getByStr(keyStr);
                      measures.forEach(measure => newRow[measure] += row[measure]);
                  } else {
                      const newRow = assign({}, row, newKeyObj);
                      result.setByStr(keyStr, newRow);
                  }
              }
          
              return result;
          },
          get transformationFns() {
              return {
                  aggregate: this.aggregate.bind(this)
              }
          },
      }
      

  });

  const PADDING_RATIO = 0.1;
  const unique = (array, accessor) => [...new Set(array.map(accessor))];

  let trackLookup;

  const lane = defaultDecorator({
      base: encoding,
      functions: {
          get transformFields() {
              return this.data.isConstant ? [] : [this.name];
          },

          get firstDim() {
              return this.data.space[0];
          },

          lookupID(d) {
              const frameConcept = this.marker.encoding.frame.data.concept;
              return d[this.firstDim] + (this.data.space.includes(frameConcept) ? d[frameConcept].toISOString() : "");
          },

          get rollup() {
              const concept = this.data.concept;
              trackLookup = new Map();

              let total = 0;
              let runningTotal = 0;
              
              const addTrackValue = d => {
                  trackLookup.set(this.lookupID(d), d.track);
              };
              
              const rollup = d3.rollups(
                this.data.response || [],
                (a) => {
                  const array = a.map(([k, v]) => v);
        
                  const isDefined = !!array[0][concept];
                  const items = isDefined ? unique(array, (d) => d[this.firstDim]) : [];
                  total += items.length;
                  return {          
                    items,
                    values: array.map((d) => ({ track: isDefined? items.indexOf(d[this.firstDim]) : 0, ...d }))
                  };
        
                },
                ([k, v]) => v[this.data.concept]
              )
              .sort(([a], [b]) => this.comparator(a,b))
              .filter(([k])=>!!k)
              .map(([k,v]) => {
                v.values.forEach(d => d.track += runningTotal); 
                v.values.forEach(d => addTrackValue(d)); 
                const runningTotal_1 = runningTotal;
                const tickPosition = runningTotal_1 - Math.round(total * PADDING_RATIO / 2);
                runningTotal += v.items.length + Math.round(total * PADDING_RATIO);
          
                return {id: k, name: this.conceptEntities.get(k)?.name, min: runningTotal_1, max: runningTotal, tickPosition};
              });
        
              return rollup;
          },

          get totalTrackNumber() {
              return this.rollup.at(-1)?.max;
          },

          comparator(a, b) {
              return !a ? -1 : d3.ascending(this.conceptEntities.get(a)?.rank, this.conceptEntities.get(b)?.rank);
          },

          get placeholderEntities() {
              const entities = unique([...this.data.response.values()], d => d[this.data.concept]).filter(f => !!f);
              return new Map(entities.map(m => ([m, {name: m, rank: +m.replace(/\D/g,'')}])));
          },

          get conceptCatalogPromise() {
              return fromPromise(getConceptsCatalog([this.data.concept], this.data, 1))
          },

          get conceptEntities() {
              const empty = new Map();
              return this.conceptCatalogPromise.case({
                  fulfilled: v => v[this.data.concept].entities ? new Map(v[this.data.concept].entities) : this.placeholderEntities,
                  pending: () => empty,
                  rejected: (e) => empty
              })
          },

          addTrack(df) {
              if (this.scale.type !== "rank" || this.data.isConstant || !this.conceptEntities.size)
                  return df;
              this.rollup;
              const _df = DataFrameGroup([], df.key, df.descendantKeys);
              
              for (const [frame, dataSlice] of df){
                  const keyObj = df.keyObject(dataSlice);
                  const newDataSlice = DataFrame([], dataSlice.key);
                  for (const [key, row] of dataSlice) {
                      const newRow = assign({}, row);
                      newRow[this.data.concept] = row[this.name];
                      newRow[this.name] = trackLookup.get(this.lookupID(row));
                      newDataSlice.set(newRow, key);
                  }
                  _df.set(keyObj, newDataSlice);
              }
              return _df;
          },

          get state() {
              return combineStates(this.scale.type === "rank" ? 
                  [this.data.state, this.referenceState, this.conceptCatalogPromise.state]
                  :
                  [this.data.state, this.referenceState]
              );
          },

          get transformationFns() {
              return {
                  addTrack: this.addTrack.bind(this)
              }
          },
      }
  });

  const encodingStore = createStore(encoding, {
      frame,
      selection,
      order,
      trail,
      repeat,
      aggregate,
      lane
  });

  //encoding cache makes sure encodings are not recreated every time

  function encodingCache() {
      const cache = {};
      function fill(cfg, marker) {
          for (const prop in cfg) {
              if (!(prop in cache)) {
                  cache[prop] = encodingStore.get(cfg[prop], marker, prop);
              }
          }
      }
      function purge(cfg) {
          for (const prop of Object.keys(cache)) {
              if (!(prop in cfg)) {
                  cache[prop].dispose();
                  delete cache[prop];
              }
          }
      }
      return { 
          cache,
          update(cfg, marker) {
              fill(cfg, marker);
              purge(cfg);
              return cache;
          }
      }
  }

  const defaultConfig = {
      data: { },
      encoding: {},
  };

  const defaults = {
      requiredEncodings: [],
      transformations: [
          "aggregate.aggregate",
          "frame.frameMap",
          "frame.interpolate",
          "frame.extrapolate",
          "filterRequired", // after framemap so doesn't remove interpolatable rows
          "trail.addPreviousTrailHeads", // before ordering so trailheads get ordered
          "order.order", 
          "orderFacets.order",
          "x.addTrack",
          "y.addTrack",
          "trail.addTrails", // after ordering so trails stay together
          "frame.currentFrame" // final to make it quick
      ]
  };

  function marker(...args) {
      return createModel(marker, ...args);
  }

  marker.nonObservable = function(config, parent, id) {
      applyDefaults(config, defaultConfig);
      let currentDataConfig;

      const marker = { config, id };
      const functions = {
          on: function(prop, readyFn) {
              if (this.validProp(prop) && typeof readyFn == "function") {
                  const disposer = mobx.autorun(
                      () => this.state == 'fulfilled' && readyFn.call(this, this[prop])
                  );
                  this.getEventListenersMapFor(prop).set(readyFn, disposer);
              } else {
                  console.warn('Invalid "on" call');
              }
              return this;
          },
          off: function(prop, fn) {
              if (this.eventListeners.get(prop)?.has(fn)){
                  this.getEventListenersMapFor(prop).get(fn)(); // dispose
                  this.getEventListenersMapFor(prop).delete(fn); // delete
              }
              return this;
          },
          validProp(prop) {
              return prop in this;
          },
          eventListeners: new Map(),
          getEventListenersMapFor(prop) {
              if (!this.eventListeners.has(prop))
                  this.eventListeners.set(prop, new Map());
              return this.eventListeners.get(prop);
          },
          get data() {
              const datacfg = resolveRef(this.config.data).value;
              const dataConfig = dataConfigStore.get(datacfg, this);
              if (currentDataConfig && dataConfig != currentDataConfig) {
                  currentDataConfig.dispose();
              }
              return currentDataConfig = dataConfig;
          },
          encodingCache: encodingCache(),
          get encoding() {
              const validEncoding = config => config() && Object.keys(config()).length > 0;
              const configGetters = [
                  () => this.config.encoding, 
                  () => this.data.source.defaultEncoding
              ];
              let configGetter = configGetters.find(validEncoding);
              if (!configGetter) {
                  console.warn("No encoding found and marker data source has no default encodings");
                  configGetter = () => ({});
              }
              // clone cache so computed is invalidated
              return Object.assign({}, this.encodingCache.update(configGetter(), this));
          },
          // TODO: encodings should know the property they encode to themselves; not sure how to pass generically yet 
          getEncodingName(encoding) {
              for (let [name, enc] of Object.entries(this.encoding)) {
                  if (enc == encoding) return name;
              }
          },
          get configState() {
              return configSolver.markerSolvingState(this);
          },
          get references() {
              return Object.fromEntries(Object.entries(this.config)
                  .filter(entry => isReference(entry[1]))
                  .map(([key, ref]) => [ key , resolveRef(ref) ] )
              );
          },
          get referenceState() {
              //normal combineStates works in parallel (reads-triggers all states at once)
              return combineStates(Object.values(this.references).map(ref => ref.state))
          },
          get state() {
              //checking state should not send any queries before reference state and config state are resolved
              //Checks all states sequantially (only check-trigger next state if previous is fulfilled)
              const dataConfigSolverState = combineStatesSequential([() => this.referenceState, () => this.configState]);

              // observe (part of) the pipeline as long as state is observed to keep them cached
              if (dataConfigSolverState == 'fulfilled') {
                  if (this.encoding.frame?.changeBetweenFramesEncodings?.some(enc => this.encoding[enc].data.state !== 'fulfilled')) {
                      //trigger combining encoding data responses in dataMapCache
                      this.dataMapCache;
                  } else {
                      this.dataMap;
                  }
              }

              const encodingStates = [...Object.values(this.encoding)].map(enc => () => enc.state);
              const states = [() => dataConfigSolverState, ...encodingStates];
              return combineStatesSequential(states);
          },
          get availability() {
              const items = [];
              dataSourceStore.getAll().forEach(ds => {
                  ds.availability.data.forEach(kv => {
                      items.push({ key: kv.key, value: ds.getConcept(kv.value), source: ds });
                  });
              });
              return items;
          },
          get spaceAvailability() {
              const items = [];
              dataSourceStore.getAll().forEach(ds => {
                  ds.availability.keyLookup.forEach((val, key) => {
                      items.push(val);
                  });
              });
              return items;
          },
          get transformFields() {
              return new Set(
                  this.requiredEncodings.concat(
                      Object.values(this.encoding).map(enc => enc.transformFields).flat()
                  )
              );
          },
          get encodingByType() {

              const defining = [];
              let ammendWrite = []; // ammends by writing to object. Changes to encoding trigger pipeline, but pipeline is faster with direct writing.
              let ammendGet = []; // ammends by creating a getter. Allows changing config of encoding without triggering rest of pipeline.
              
              const transformFields = this.transformFields;

              for (const name of Object.keys(this.encoding)) {
                  const fn = this.ammendFnForEncoding(name);

                  if (fn === 'defining') {
                      defining.push(name);
                  } else if (typeof fn === 'function') {
                      if (transformFields.has(name)) {
                          ammendWrite.push(name);
                      } else {
                          ammendGet.push(name);
                      }
                  } 

              }
                     
              // optimization: if ammending shares response with defining just let fullJoin handle it
              if (defining.concat(ammendWrite).every(name => this.encoding[name].data.state == 'fulfilled')) {
                  const definingResponses = defining.map(name => this.encoding[name].data.response);
                  ammendWrite = ammendWrite.filter(name => {
                      const data = this.encoding[name].data;
                      if (data.hasOwnData && definingResponses.includes(data.response)) {
                          defining.push(name);
                          return false;
                      }
                      return true;
                  });
              }

              return {
                  defining,
                  ammendGet,
                  ammendWrite
              }
          },
          ammendFnForEncoding(name) {
              const required = this.requiredEncodings;
              const data = this.encoding[name].data;
              const concept = data.concept;

              if (concept === undefined && !data.isConstant)
                  return 'no-op';
              else if (data.isConstant) {
                  return row => data.constant;
              } else if (data.conceptInSpace) {
                  return row => row[concept];
              } else if (data.commonSpace.length < this.data.space.length
                  || data.iterableResponse === false
                  ) { 
                  // proper subset
                  return row => data.response.get(row)?.[concept];
              } else if (required.length > 0 && !required.includes(name)) {
                  // superset and not a required enc when required is used (otherwise it would be a defining)
                  return (row, key) => data.response.getByStr(key)?.[concept];
              } else {
                  return 'defining'; // defining encoding
              }
          },
          get encodingState() {
              const encs = [...this.encodingByType.defining, ...this.encodingByType.ammendWrite];
              return combineStates(encs.map(enc => this.encoding[enc].data.state));
          },
          // computed to cache calculation
          get dataMapCache() {
              // trace();

              // prevent recalculating on each encoding data coming in
              if (this.encodingState !== 'fulfilled')
                  return DataFrame([], this.data.space);

              //console.time('dataMapCache ' + this.id);

              // define markers (full join encoding data)
              const { defining, ammendWrite, ammendGet } = this.encodingByType;
              const joinConfigs = defining.map(name => this.joinConfig(this.encoding[name], name));
              let dataMap = fullJoin(joinConfigs, this.data.space);

              // ammend markers with getter
              // part of the optimisation to not redo the whole data pipeline 
              //ammending encodings are split in 2 groups: ammending with getter and ammending by writing
              //the once that use the getter won't trigger pipeline (constants, concepts in space)
              //the idea with getter is to postpone calculation or reading to a later point
              //in the standard bubble chart color is through the getter too
              //calcualtions are more expensive but we can postpone them
              for (const encName of ammendGet) {
                  for (const markerKey of dataMap.keys()) {
                      const row = dataMap.get(markerKey); 
                      let fallback;
                      Object.defineProperty(row, encName, {
                          get: () => this.ammendFnForEncoding(encName)(row, markerKey) ?? fallback,
                          set(value) {
                              fallback = value;
                          },
                          enumerable: true,
                          configurable: true
                      });
                  }
              }

              // ammend markers by writing
              //this is the faster way. doesn't have to go through a getter function
              //quicker access compared to reading from a getter
              //we do this when the values are computed in trasformation pipeline anyway
              //see getEncodingByType()

              //each enc has a field. if that field is included in transformFields array of a marker (which adds its own transformfileds and those of every encoding)
              //then it's a written encoding

              //if we change something that uses getter field then the whole pipele doesn't need to rerun
              const ammendFns = Object.fromEntries(ammendWrite.map(enc => [enc, this.ammendFnForEncoding(enc)]));
              for (const markerKey of dataMap.keys()) {
                  const row = dataMap.get(markerKey);
                  for (const name in ammendFns)
                      row[name] = ammendFns[name](row, markerKey);
              }
              
              //console.timeEnd('dataMapCache ' + this.id);
              return dataMap;
          },
          joinConfig(encoding, name) {
              return { 
                  projection: { 
                      [encoding.data.concept]: [ name ]
                  },
                  dataFrame: encoding.data.response
              }
          },
          get requiredEncodings() { 
              return mobx.toJS(this.config.requiredEncodings || defaults.requiredEncodings).filter(
                  enc => this.encoding[enc].data.hasOwnData
              ); 
          },
          filterRequired(data) {            
              this.requiredEncodings;
              return data
                  .filterNullish(this.requiredEncodings)
                  .filterGroups(group => group.size > 0, true);
          },
          differentiate(xField, data) {
              const frame = this.encoding.frame;
              return frame && this.encoding[xField] ? frame.differentiate(data, xField) : data
          },
          /**
           * transformationFns is an object 
           *  whose keys are transformation strings
           *  whose values are transformation functions
           */
          get transformationFns() {
              // marker transformation
              const transformations = {
                  "filterRequired": this.filterRequired.bind(this)
              };
              // encoding transformations
              for (let [name, enc] of Object.entries(this.encoding)) {
                  if (enc.transformationFns)
                      for (let [tName, t] of Object.entries(enc.transformationFns))
                          transformations[name + '.' + tName] = t;
                  if (Array.isArray(enc?.config?.data?.transformations)) {
                      for (let tName of enc.config.data.transformations) {
                          const fn = this[tName];
                          if (fn)
                              transformations[name + '.' + tName] = fn.bind(this, name);
                      }
                  }
              }
              return transformations;
          },
          /**
           * Transformations is an array of strings, referring to transformations defined on the marker or encodings
           * The array defines the order in which data will be transformed before being served.
           * If a function reference cannot be resolved, it will be skipped. No error will be thrown.
           * Encoding transformations are formatted "<encodingName>.<functionName>". E.g. "frame.currentFrame"
           * Marker transformations are formatted "<functionName>". E.g. "filterRequired"
           * This array of strings enables configuration of transformation order in a serializable format.
           */
          get transformations() {
              const transformations = this.config.transformations || defaults.transformations;
              const transformationFns = this.transformationFns;
              return transformations
                  .filter(tStr => tStr in transformationFns)
                  .map(tStr => ({
                          fn: this.transformationFns[tStr],
                          name: tStr
                  }));
          },
          /**
           * transformedDataMaps is a ES6 Map
           *  whose keys are transformation strings or "final" and
           *  whose values are DataFrames wrapped in a boxed mobx computed. 
           *      The DataFrame is a result of the transformation function applied to the previous DataFrame.  
           */
          // currently all transformation steps are cached in computed values. Computeds are great to prevent recalculations
          // of previous steps when config of one step changes. However, it uses memory. We might want this more configurable.
          get transformedDataMaps() {
              //trace();
              // returns boxed computed, whose value can be reached by .get()
              // if we'd call .get() in here (returning the value), each change would lead to applying all transformations
              // because transformedDataMaps() would be observering all stepResults
              // would be nice to find a way for transformedDataMaps to just return the value instead of a boxed computed
              const results = new Map();
              let stepResult = mobx.observable.box(this.dataMapCache, { deep: false });
              this.transformations.forEach(({name, fn}) => {
                  let prevResult = stepResult; // local reference for closure of computed
                  stepResult = mobx.computed(
                      () => {
                          //trace();
                          const previous = prevResult.get();
                          //const t0 = performance.now();
                          const result = fn(previous);
                          //const t1 = performance.now();
                          //pipelineTime += t1 - t0;
                          //console.log('Pipeline ' + fn.name + ':', t1-t0, 'Total:', pipelineTime);
                          return result;
                      }, 
                      { name }
                  );
                  results.set(name, stepResult);
              });
              results.set('final', stepResult);
              return results;
          },
          /**
           * Helper function to get values from transformedDataMaps. Used to prevent the awkward `.get(name).get()` syntax.
           */
          getTransformedDataMap(name) {
              if (this.transformedDataMaps.has(name))
                  return this.transformedDataMaps.get(name).get();
              console.warn("Requesting unknown transformed data name: ", name);
          },
          get dataMap() {
              //compute transformations backwards (pull data through trasformations)
              return this.transformedDataMaps.get('final').get();
          },
          get dataArray() {
              return this.dataMap?.toJSON();
          },
          getDataMapByFrameValue(value, transformedDataMap = 'filterRequired' ) {
              const frame = this.encoding.frame;
              if (!frame) return this.dataMap;
      
              const frameKey = createKeyFn([frame.name])({ [frame.name]: value });
              const data = this.getTransformedDataMap(transformedDataMap);
              return data.has(frameKey) ? 
                  data.get(frameKey)
                  :
                  getInterpolatedFrame(frame, data, value);
      
              function getInterpolatedFrame(frame, data, value) {
                  const step = frame.stepScale(value);
                  const stepsAround = [Math.floor(step), Math.ceil(step)];
                  return frame.getInterpolatedFrame(data, step, stepsAround);
              }
          },
          dispose() {
              // Need to dispose because reactions may not observe only locally. Through state -> dataConfig -> resolveRef they can indirectly observe stores.
              // https://mobx.js.org/reactions.html#mem-leak-example
              this.data.dispose();
              for (let enc of Object.values(this.encoding)) {
                  enc.dispose();
              }
          }
      };

      return assign(marker, functions, configurable);
  };

  marker.decorate = {
      encodingCache: mobx.observable.ref,
      encodingByType: mobx.computed.struct,
      requiredEncodings: mobx.computed.struct
  };

  const markerStore = createStore(marker);

  const stores = {
      markers: markerStore,
      dataSources: dataSourceStore,
      encodings: encodingStore
  };

  const vizabi = function(cfg) {
      const config = mobx.observable(cfg);

      const models = {};
      for (const storeName in config) {
          if (storeName in stores) {
              models[storeName] = stores[storeName].createMany(config[storeName]);
          } else {
              console.warn('Vizabi() was given an unknown store name: ', storeName);
          }
      }
      models.config = config;
      
      return models;

  };
  vizabi.versionInfo = { version: "1.31.6", build: 1719060427362, package: {"homepage":"http://vizabi.org","name":"@vizabi/core","description":"Vizabi core (data layer)"} };
  vizabi.utils = utils;
  vizabi.stores = stores;
  vizabi.dataSource = (cfg, id) =>{
      // shortcut giving data directly in array-object format: [{...},{...}]
      if (Array.isArray(cfg)) {
          cfg = {
              values: cfg
          };
      }

      return dataSourceStore.create(cfg, null, id);
  }; 
  vizabi.marker = (cfg, id) => {
      cfg = mobx.observable(cfg);
      return markerStore.create(cfg, null, id);
  };
  vizabi.encoding = (cfg, id) => {
      cfg = mobx.observable(cfg);
      return encodingStore.create(cfg, null, id);
  };
  vizabi.disposeAll = () => {
      for (let storeName in stores) {
          stores[storeName].disposeAll();
      }
  };
  vizabi.csvReader = csvReader;
  vizabi.inlineReader = inlineReader;

  return vizabi;

}));

// https://github.com/vizabi/@vizabi/shared-components#readme v1.40.0 build 1715955706435 Copyright 2024 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3'), require('mobx')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3', 'mobx'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VizabiSharedComponents = {}, global.d3, global.mobx));
})(window, (function (exports, d3, mobx) {
  // source https://github.com/encharm/Font-Awesome-SVG-PNG/tree/master/black/svg

  const ICON_PAINTBRUSH =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1615 0q70 0 122.5 46.5t52.5 116.5q0 63-45 151-332 629-465 752-97 91-218 91-126 0-216.5-92.5t-90.5-219.5q0-128 92-212l638-579q59-54 130-54zm-909 1034q39 76 106.5 130t150.5 76l1 71q4 213-129.5 347t-348.5 134q-123 0-218-46.5t-152.5-127.5-86.5-183-29-220q7 5 41 30t62 44.5 59 36.5 46 17q41 0 55-37 25-66 57.5-112.5t69.5-76 88-47.5 103-25.5 125-10.5z"/></svg>';
  const ICON_SEARCH =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1216 832q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 52-38 90t-90 38q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>';
  const ICON_CIRCLE =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1664 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"/></svg>';
  const ICON_EXPAND =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M883 1056q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23zm781-864v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45z"/></svg>';
  const ICON_ASTERISK =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1546 1050q46 26 59.5 77.5t-12.5 97.5l-64 110q-26 46-77.5 59.5t-97.5-12.5l-266-153v307q0 52-38 90t-90 38h-128q-52 0-90-38t-38-90v-307l-266 153q-46 26-97.5 12.5t-77.5-59.5l-64-110q-26-46-12.5-97.5t59.5-77.5l266-154-266-154q-46-26-59.5-77.5t12.5-97.5l64-110q26-46 77.5-59.5t97.5 12.5l266 153v-307q0-52 38-90t90-38h128q52 0 90 38t38 90v307l266-153q46-26 97.5-12.5t77.5 59.5l64 110q26 46 12.5 97.5t-59.5 77.5l-266 154z"/></svg>';
  const ICON_TRAILS =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M 1381.375 17.1875 C 1375.7825 17.176804 1370.1216 17.316078 1364.4375 17.5625 C 1273.4913 21.505489 1197.0982 57.199956 1135.2188 124.6875 C 1076.5961 188.62338 1047.6964 263.96059 1048.5312 350.65625 L 835.71875 433 C 797.77288 391.67699 749.96961 361.96416 692.3125 343.84375 C 604.96227 316.39162 520.95691 323.70366 440.25 365.8125 C 359.5432 407.92133 305.45225 472.64985 278 560 C 250.54783 647.35004 257.89117 731.38694 300 812.09375 C 342.10886 892.80075 406.83755 946.89147 494.1875 974.34375 C 576.9404 1000.3512 657.38873 994.58645 735.5625 957.09375 L 959.28125 1171.4375 L 972.375 1184.4062 C 966.2931 1198.3454 961.94845 1209.2226 959.34375 1217.0625 C 956.73915 1224.9024 953.7186 1236.224 950.25 1251.0312 L 711.03125 1285.1875 C 669.59175 1209.0324 607.72526 1157.2863 525.40625 1129.9375 C 438.51381 1101.0693 354.34933 1107.021 272.96875 1147.8125 C 191.58796 1188.6039 136.49335 1252.4513 107.625 1339.3438 C 78.756758 1426.2362 84.708528 1510.3694 125.5 1591.75 C 166.29138 1673.1307 230.1387 1728.2567 317.03125 1757.125 C 403.92369 1785.9933 488.05682 1780.0415 569.4375 1739.25 C 650.81799 1698.4587 705.94425 1634.6111 734.8125 1547.7188 C 737.41718 1539.8788 740.43763 1528.5573 743.90625 1513.75 L 983.125 1479.5938 C 1024.5644 1555.7487 1086.4309 1607.4948 1168.75 1634.8438 C 1255.6425 1663.7119 1339.8069 1657.7603 1421.1875 1616.9688 C 1502.5682 1576.1772 1557.6631 1512.3299 1586.5312 1425.4375 C 1615.3996 1338.5451 1609.4477 1254.4119 1568.6562 1173.0312 C 1527.8647 1091.6506 1464.0174 1036.5244 1377.125 1007.6562 C 1294.9259 980.34721 1214.5066 984.74084 1135.8438 1020.8125 L 1120.2812 1005.9062 L 898.0625 785.96875 C 902.79653 774.40321 906.33847 765.03422 908.5 758.15625 C 920.42249 720.22 925.7916 682.90194 924.59375 646.21875 L 1130.9688 566.34375 C 1141.2015 577.59424 1149.3796 586.0106 1155.4688 591.59375 C 1222.9566 653.47326 1302.1474 682.44278 1393.0938 678.5 C 1484.04 674.55731 1560.4642 638.83151 1622.3438 571.34375 C 1684.2232 503.85591 1713.1929 424.6337 1709.25 333.6875 C 1705.3072 242.74139 1669.5816 166.34819 1602.0938 104.46875 C 1538.8238 46.456824 1465.2625 17.347946 1381.375 17.1875 z "/></svg>';
  const ICON_LOCK =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M640 768h512v-192q0-106-75-181t-181-75-181 75-75 181v192zm832 96v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-192q0-184 132-316t316-132 316 132 132 316v192h32q40 0 68 28t28 68z"/></svg>';
  const ICON_UNLOCK =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1376 768q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-320q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45q0-106-75-181t-181-75-181 75-75 181v320h736z"/></svg>';
  const ICON_UNEXPAND =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M896 960v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45zm755-672q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23z"/></svg>';
  const ICON_AXES =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500"><path d="M430.25,379.655l-75.982-43.869v59.771H120.73V151.966h59.774l-43.869-75.983L92.767,0L48.898,75.983L5.029,151.966h59.775 v271.557c0,15.443,12.52,27.965,27.963,27.965h261.5v59.773l75.982-43.869l75.982-43.867L430.25,379.655z"/></svg>';
  const ICON_GEAR =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1152 896q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm512-109v222q0 12-8 23t-20 13l-185 28q-19 54-39 91 35 50 107 138 10 12 10 25t-9 23q-27 37-99 108t-94 71q-12 0-26-9l-138-108q-44 23-91 38-16 136-29 186-7 28-36 28h-222q-14 0-24.5-8.5t-11.5-21.5l-28-184q-49-16-90-37l-141 107q-10 9-25 9-14 0-25-11-126-114-165-168-7-10-7-23 0-12 8-23 15-21 51-66.5t54-70.5q-27-50-41-99l-183-27q-13-2-21-12.5t-8-23.5v-222q0-12 8-23t19-13l186-28q14-46 39-92-40-57-107-138-10-12-10-24 0-10 9-23 26-36 98.5-107.5t94.5-71.5q13 0 26 10l138 107q44-23 91-38 16-136 29-186 7-28 36-28h222q14 0 24.5 8.5t11.5 21.5l28 184q49 16 90 37l142-107q9-9 24-9 13 0 25 10 129 119 165 170 7 8 7 22 0 12-8 23-15 21-51 66.5t-54 70.5q26 50 41 98l183 28q13 2 21 12.5t8 23.5z"/></svg>';
  const ICON_STACK =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 54.849 54.849"><g><path d="M54.497,39.614l-10.363-4.49l-14.917,5.968c-0.537,0.214-1.165,0.319-1.793,0.319c-0.627,0-1.254-0.104-1.79-0.318     l-14.921-5.968L0.351,39.614c-0.472,0.203-0.467,0.524,0.01,0.716L26.56,50.81c0.477,0.191,1.251,0.191,1.729,0L54.488,40.33     C54.964,40.139,54.969,39.817,54.497,39.614z"/><path d="M54.497,27.512l-10.364-4.491l-14.916,5.966c-0.536,0.215-1.165,0.321-1.792,0.321c-0.628,0-1.256-0.106-1.793-0.321     l-14.918-5.966L0.351,27.512c-0.472,0.203-0.467,0.523,0.01,0.716L26.56,38.706c0.477,0.19,1.251,0.19,1.729,0l26.199-10.479     C54.964,28.036,54.969,27.716,54.497,27.512z"/><path d="M0.361,16.125l13.662,5.465l12.537,5.015c0.477,0.191,1.251,0.191,1.729,0l12.541-5.016l13.658-5.463     c0.477-0.191,0.48-0.511,0.01-0.716L28.277,4.048c-0.471-0.204-1.236-0.204-1.708,0L0.351,15.41     C-0.121,15.614-0.116,15.935,0.361,16.125z"/></g></svg>';
  const ICON_DRAG =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M896 384q-53 0-90.5 37.5t-37.5 90.5v128h-32v-93q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v429l-32-30v-172q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v224q0 47 35 82l310 296q39 39 39 102 0 26 19 45t45 19h640q26 0 45-19t19-45v-25q0-41 10-77l108-436q10-36 10-77v-246q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v32h-32v-125q0-40-25-72.5t-64-40.5q-14-2-23-2-46 0-79 33t-33 79v128h-32v-122q0-51-32.5-89.5t-82.5-43.5q-5-1-13-1zm0-128q84 0 149 50 57-34 123-34 59 0 111 27t86 76q27-7 59-7 100 0 170 71.5t70 171.5v246q0 51-13 108l-109 436q-6 24-6 71 0 80-56 136t-136 56h-640q-84 0-138-58.5t-54-142.5l-308-296q-76-73-76-175v-224q0-99 70.5-169.5t169.5-70.5q11 0 16 1 6-95 75.5-160t164.5-65q52 0 98 21 72-69 174-69z"/></svg>';
  const ICON_WARN =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.209 512.209"><path d="M507.345,439.683L288.084,37.688c-3.237-5.899-7.71-10.564-13.429-13.988c-5.705-3.427-11.893-5.142-18.554-5.142   s-12.85,1.718-18.558,5.142c-5.708,3.424-10.184,8.089-13.418,13.988L4.859,439.683c-6.663,11.998-6.473,23.989,0.57,35.98   c3.239,5.517,7.664,9.897,13.278,13.128c5.618,3.237,11.66,4.859,18.132,4.859h438.529c6.479,0,12.519-1.622,18.134-4.859   c5.62-3.23,10.038-7.611,13.278-13.128C513.823,463.665,514.015,451.681,507.345,439.683z M292.655,411.132   c0,2.662-0.91,4.897-2.71,6.704c-1.807,1.811-3.949,2.71-6.427,2.71h-54.816c-2.474,0-4.616-0.899-6.423-2.71   c-1.809-1.807-2.713-4.042-2.713-6.704v-54.248c0-2.662,0.905-4.897,2.713-6.704c1.807-1.811,3.946-2.71,6.423-2.71h54.812   c2.479,0,4.62,0.899,6.428,2.71c1.803,1.807,2.71,4.042,2.71,6.704v54.248H292.655z M292.088,304.357   c-0.198,1.902-1.198,3.47-3.001,4.709c-1.811,1.238-4.046,1.854-6.711,1.854h-52.82c-2.663,0-4.947-0.62-6.849-1.854   c-1.908-1.243-2.858-2.807-2.858-4.716l-4.853-130.47c0-2.667,0.953-4.665,2.856-5.996c2.474-2.093,4.758-3.14,6.854-3.14h62.809   c2.098,0,4.38,1.043,6.854,3.14c1.902,1.331,2.851,3.14,2.851,5.424L292.088,304.357z"/></svg>';
  const ICON_PIN =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M800 864v-448q0-14-9-23t-23-9-23 9-9 23v448q0 14 9 23t23 9 23-9 9-23zm672 352q0 26-19 45t-45 19h-429l-51 483q-2 12-10.5 20.5t-20.5 8.5h-1q-27 0-32-27l-76-485h-404q-26 0-45-19t-19-45q0-123 78.5-221.5t177.5-98.5v-512q-52 0-90-38t-38-90 38-90 90-38h640q52 0 90 38t38 90-38 90-90 38v512q99 0 177.5 98.5t78.5 221.5z"/></svg>';
  const ICON_QUESTION =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="17 17 483 483"> <circle stroke-width="40" cx="258.57" cy="258.57" r="220"/> <path d="M299.756,413.021v-61.78c0-3.003-0.966-5.472-2.896-7.401s-4.398-2.896-7.401-2.896h-61.78 c-3.003,0-5.47,0.965-7.4,2.896c-1.932,1.931-2.896,4.398-2.896,7.401v61.78c0,3.002,0.965,5.47,2.896,7.399 c1.931,1.931,4.396,2.896,7.4,2.896h61.779c3.003,0,5.472-0.967,7.401-2.896S299.756,416.021,299.756,413.021z"/> <path d="M382.128,196.789c0-18.877-5.952-36.36-17.856-52.449c-11.905-16.088-26.762-28.53-44.566-37.325 c-17.804-8.795-36.037-13.192-54.7-13.192c-52.127,0-91.919,22.845-119.377,68.537c-3.218,5.148-2.359,9.653,2.574,13.514 l42.474,32.177c1.502,1.287,3.54,1.931,6.114,1.931c3.433,0,6.115-1.287,8.044-3.861c11.369-14.587,20.594-24.454,27.672-29.603 c7.294-5.148,16.519-7.723,27.673-7.723c10.297,0,19.468,2.789,27.513,8.366c8.044,5.578,12.065,11.906,12.065,18.985 c0,8.151-2.146,14.694-6.437,19.628c-4.29,4.934-11.583,9.76-21.881,14.479c-13.514,6.006-25.901,15.284-37.164,27.834 c-11.263,12.549-16.894,26.01-16.894,40.382v11.583c0,3.004,0.965,5.472,2.896,7.401c1.931,1.93,4.396,2.896,7.4,2.896h61.779 c3.003,0,5.471-0.965,7.401-2.896c1.93-1.931,2.896-4.397,2.896-7.401c0-4.075,2.306-9.385,6.917-15.928 c4.612-6.542,10.458-11.852,17.537-15.927c6.863-3.861,12.119-6.918,15.768-9.171c3.646-2.252,8.579-6.008,14.802-11.263 c6.22-5.255,10.993-10.402,14.317-15.443c3.325-5.042,6.328-11.53,9.01-19.467C380.788,214.916,382.128,206.228,382.128,196.789z"/> </svg>';
  const ICON_CLOSE =
    '<svg class="vzb-icon vzb-icon-pin" viewBox="-150 -250 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1149 414q0 26 -19 45l-181 181l181 181q19 19 19 45q0 27 -19 46l-90 90q-19 19 -46 19q-26 0 -45 -19l-181 -181l-181 181q-19 19 -45 19q-27 0 -46 -19l-90 -90q-19 -19 -19 -46q0 -26 19 -45l181 -181l-181 -181q-19 -19 -19 -45q0 -27 19 -46l90 -90q19 -19 46 -19 q26 0 45 19l181 181l181 -181q19 -19 45 -19q27 0 46 19l90 90q19 19 19 46z"/></svg>';
  const ICON_PRESENTATION =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path id="flip-chart-1" d="M334.549,393.834l58.607,68.666h-45.096l-58.709-68.666H334.549z M240.333,462.5h34.333v-68.666h-34.333 V462.5z M360.5,153.5h-34.334v137.334H360.5V153.5z M121.566,462.5h45.113l58.709-68.666h-45.197L121.566,462.5z M206,273.666 h-34.333v17.168H206V273.666z M257.5,239.333h-34.333v51.5H257.5V239.333z M309,205h-34.334v85.834H309V205z M446.334,102h-17.168 v257.5H85.833V102H68.667V50.5h377.667V102z M394.834,102H120.167v223.166h274.667V102z"/></svg>';
  const ICON_ABOUT =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1088 1256v240q0 16-12 28t-28 12h-240q-16 0-28-12t-12-28v-240q0-16 12-28t28-12h240q16 0 28 12t12 28zm316-600q0 54-15.5 101t-35 76.5-55 59.5-57.5 43.5-61 35.5q-41 23-68.5 65t-27.5 67q0 17-12 32.5t-28 15.5h-240q-15 0-25.5-18.5t-10.5-37.5v-45q0-83 65-156.5t143-108.5q59-27 84-56t25-76q0-42-46.5-74t-107.5-32q-65 0-108 29-35 25-107 115-13 16-31 16-12 0-25-8l-164-125q-13-10-15.5-25t5.5-28q160-266 464-266 80 0 161 31t146 83 106 127.5 41 158.5z"/></svg>';
  const ICON_REPEAT =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M576 1376v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm0-384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm-512-768v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm-512-768v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm0-384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm128-320v1088q0 66-47 113t-113 47h-1344q-66 0-113-47t-47-113v-1088q0-66 47-113t113-47h1344q66 0 113 47t47 113z"/></svg>';
  const ICON_CURSORARROW =
    '<svg class="vzb-icon" viewBox="-200 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1389 1043q31 30 14 69-17 40-59 40h-382l201 476q10 25 0 49t-34 35l-177 75q-25 10-49 0t-35-34l-191-452-312 312q-19 19-45 19-12 0-24-5-40-17-40-59v-1504q0-42 40-59 12-5 24-5 27 0 45 19z"/></svg>';
  const ICON_CURSORPLUS =
    '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1088 800v64q0 13-9.5 22.5t-22.5 9.5h-224v224q0 13-9.5 22.5t-22.5 9.5h-64q-13 0-22.5-9.5t-9.5-22.5v-224h-224q-13 0-22.5-9.5t-9.5-22.5v-64q0-13 9.5-22.5t22.5-9.5h224v-224q0-13 9.5-22.5t22.5-9.5h64q13 0 22.5 9.5t9.5 22.5v224h224q13 0 22.5 9.5t9.5 22.5zm128 32q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 53-37.5 90.5t-90.5 37.5q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>';
  const ICON_CURSORMINUS =
    '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1088 800v64q0 13-9.5 22.5t-22.5 9.5h-576q-13 0-22.5-9.5t-9.5-22.5v-64q0-13 9.5-22.5t22.5-9.5h576q13 0 22.5 9.5t9.5 22.5zm128 32q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 53-37.5 90.5t-90.5 37.5q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>';
  const ICON_HUNDREDPERCENT =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg"><g transform="translate(18 11)"><text transform="scale(0.9 1)" x="0" y="0">100</text><text transform="scale(0.6 1)" class="percent" x="0" y="0">%</text></g></svg>';
  const ICON_PERCENT =
    '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1408 1280q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm-768-768q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm1024 768q0 159-112.5 271.5t-271.5 112.5-271.5-112.5-112.5-271.5 112.5-271.5 271.5-112.5 271.5 112.5 112.5 271.5zm-96-1088q0 20-13 38l-1056 1408q-19 26-51 26h-160q-26 0-45-19t-19-45q0-20 13-38l1056-1408q19-26 51-26h160q26 0 45 19t19 45zm-672 320q0 159-112.5 271.5t-271.5 112.5-271.5-112.5-112.5-271.5 112.5-271.5 271.5-112.5 271.5 112.5 112.5 271.5z"/></svg>';
  const ICON_SIDE =
    '<svg class="vzb-icon" viewBox="-120 -1540 1792 1792" xmlns="http://www.w3.org/2000/svg"><path transform="rotate(-90) scale(1.2)" d="M1024 448q0 -26 -19 -45l-448 -448q-19 -19 -45 -19t-45 19l-448 448q-19 19 -19 45t19 45t45 19h896q26 0 45 -19t19 -45zM1024 832q0 -26 -19 -45t-45 -19h-896q-26 0 -45 19t-19 45t19 45l448 448q19 19 45 19t45 -19l448 -448q19 -19 19 -45z"/></svg>';
  const ICON_CURSORHAND =
    '<svg class="vzb-icon" viewBox="0 -1540 1792 1792" xmlns="http://www.w3.org/2000/svg"><path transform="scale(1,-1)" d="M880 1408q-46 0 -79 -33t-33 -79v-656h-32v528q0 46 -33 79t-79 33t-79 -33t-33 -79v-528v-256l-154 205q-38 51 -102 51q-53 0 -90.5 -37.5t-37.5 -90.5q0 -43 26 -77l384 -512q38 -51 102 -51h688q34 0 61 22t34 56l76 405q5 32 5 59v498q0 46 -33 79t-79 33t-79 -33t-33 -79v-272h-32v528q0 46 -33 79t-79 33t-79 -33t-33 -79v-528h-32v656q0 46 -33 79t-79 33zM880 1536q68 0 125.5 -35.5t88.5 -96.5q19 4 42 4q99 0 169.5 -70.5t70.5 -169.5v-17q105 6 180.5 -64t75.5 -175v-498q0 -40 -8 -83l-76 -404q-14 -79 -76.5 -131t-143.5 -52h-688q-60 0 -114.5 27.5t-90.5 74.5l-384 512q-51 68 -51 154q0 106 75 181t181 75q78 0 128 -34v434q0 99 70.5 169.5t169.5 70.5q23 0 42 -4q31 61 88.5 96.5t125.5 35.5z"/></svg>';
  const ICON_ANGLEDOUBLELEFT =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z"/></svg>';
  const ICON_FORECAST =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><g><path d="M560.7,775.2c-8.5,8.4-17.2,17.1-26,25.8C418,917.8,327.5,1039.9,231.9,1209.3c-72.9,129.4-131,262.4-172.5,395.4l171.8,53.7c37.8-120.9,90.8-242.3,157.5-360.7c43.8-77.7,85.9-143.7,128.7-201.7c43.7-59.3,91-114.2,144.6-167.7c11.3-11.3,22.2-22.2,33-32.8L560.7,775.2z"/><path d="M973.7,461.9c-21.4,12.1-43.4,24.8-66.1,38.5c-56.1,33.7-103.4,65.5-145.8,97.2l114.5,139.2c36.3-26.8,76.5-53.6,124-82.1c23.6-14.2,46.3-27.3,68.4-39.7L973.7,461.9z"/><path d="M1448.9,252.3c-37.1,13.4-75.2,27.2-111.3,40.9c-37.6,14.2-76.7,29.6-118,47.2l71.7,165.1c36.5-15.5,72.9-29.8,110.1-44c33.7-12.8,69.4-25.8,104.4-38.4L1448.9,252.3z"/></g></svg>';
  const ICON_ELLIPSIS_V =
    '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><g><path d="M1088 1248v192q0 40-28 68t-68 28h-192q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h192q40 0 68 28t28 68zm0-512v192q0 40-28 68t-68 28h-192q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h192q40 0 68 28t28 68zm0-512v192q0 40-28 68t-68 28h-192q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h192q40 0 68 28t28 68z"/></g></svg>';

  var iconset = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ICON_PAINTBRUSH: ICON_PAINTBRUSH,
    ICON_SEARCH: ICON_SEARCH,
    ICON_CIRCLE: ICON_CIRCLE,
    ICON_EXPAND: ICON_EXPAND,
    ICON_ASTERISK: ICON_ASTERISK,
    ICON_TRAILS: ICON_TRAILS,
    ICON_LOCK: ICON_LOCK,
    ICON_UNLOCK: ICON_UNLOCK,
    ICON_UNEXPAND: ICON_UNEXPAND,
    ICON_AXES: ICON_AXES,
    ICON_GEAR: ICON_GEAR,
    ICON_STACK: ICON_STACK,
    ICON_DRAG: ICON_DRAG,
    ICON_WARN: ICON_WARN,
    ICON_PIN: ICON_PIN,
    ICON_QUESTION: ICON_QUESTION,
    ICON_CLOSE: ICON_CLOSE,
    ICON_PRESENTATION: ICON_PRESENTATION,
    ICON_ABOUT: ICON_ABOUT,
    ICON_REPEAT: ICON_REPEAT,
    ICON_CURSORARROW: ICON_CURSORARROW,
    ICON_CURSORPLUS: ICON_CURSORPLUS,
    ICON_CURSORMINUS: ICON_CURSORMINUS,
    ICON_HUNDREDPERCENT: ICON_HUNDREDPERCENT,
    ICON_PERCENT: ICON_PERCENT,
    ICON_SIDE: ICON_SIDE,
    ICON_CURSORHAND: ICON_CURSORHAND,
    ICON_ANGLEDOUBLELEFT: ICON_ANGLEDOUBLELEFT,
    ICON_FORECAST: ICON_FORECAST,
    ICON_ELLIPSIS_V: ICON_ELLIPSIS_V
  });

  /* eslint no-prototype-builtins: "off" */

  const d3json = function (path, callback) {
    d3.json(path)
      .then(response => callback(null, response))
      .catch(error => callback(error));
  };

  const d3text = function (path, callback) {
    d3.text(path)
      .then(response => callback(null, response))
      .catch(error => callback(error));
  };

  /*
   * Check if value A is in +- proximity of value B
   * @param {Number} a
   * @param {Number} b
   * @param {Number} tolerance
   * @returns {Boolean} true if values are approximately equal or false otherwise
   */
  const approxEqual = function (a, b, tolerance) {
    tolerance = tolerance || 0;
    if (b > 0) {
      return (1 - tolerance) * b <= a && a <= b * (1 + tolerance);
    } else if (b < 0) {
      return (1 + tolerance) * b <= a && a <= b * (1 - tolerance);
    }
    return Math.abs(a) <= tolerance;
  };

  /*
   * prints out a string like this "AUTOCONFIG: axis_x choses armed_conflicts_internal from data to be WHICH"
   */
  const printAutoconfigResult = (function (mdl) {
    console.info(
      "AUTOCONFIG: " + mdl._name
      + (mdl.isHook() ? " of " + mdl._parent._name : "")
      + " choses " + (mdl.dim || mdl.which)
      + " from " + (mdl.dataSource ? mdl.dataSource._name : "<DATA SOURCE MISSING!>")
      + " to be " + (mdl._type === "entities" || mdl._type === "time" ? "DIM" : "WHICH")
    );
  });

  /*
   * returns unique id with optional prefix
   * @param {String} prefix
   * @returns {String} id
   */
  const uniqueId = (function () {
    let id = 0;
    return function (p) {
      return p ? p + (id += 1) : id += 1;
    };
  })();

  /*
   * checks whether obj is a DOM element
   * @param {Object} obj
   * @returns {Boolean}
   * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
   */
  const isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };

  /*
   * checks whether obj is an Array
   * @param {Object} target
   * @returns {Boolean}
   * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
   */
  const isArray = Array.isArray || (target => Object.prototype.toString.call(target) === "[object Array]");

  /*
   * checks whether obj is an object
   * @param {Object} obj
   * @returns {Boolean}
   * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
   */
  const isObject = function (obj) {
    const type = typeof obj;
    return type === "object" && !!obj;
  };

  /*
   * checks whether arg is a date
   * @param {Object} arg
   * @returns {Boolean}
   */
  const isDate = function (arg) {
    return arg instanceof Date;
  };

  /*
   * checks whether arg is a string
   * @param {Object} arg
   * @returns {Boolean}
   */
  const isString = value => typeof value === "string";

  /*
   * checks whether arg is a NaN
   * @param {*} arg
   * @returns {Boolean}
   * from lodash: https://github.com/lodash/lodash/blob/master/lodash.js
   */
  const isNaN$1 = function (arg) {
    // A `NaN` primitive is the only number that is not equal to itself
    return isNumber(arg) && arg !== +arg;
  };

  const isEmpty = function (obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
  };

  /*
   * checks whether arg is a number. NaN is a number too
   * @param {*} arg
   * @returns {Boolean}
   * from lodash: https://github.com/lodash/lodash/blob/master/lodash.js
   * dependencies are resolved and included here
   */
  const isNumber = function (arg) {
    return typeof arg === "number" || !!arg && typeof arg === "object" && Object.prototype.toString.call(arg) ===
      "[object Number]";
  };

  /*
   * checks whether obj is a plain object {}
   * @param {Object} obj
   * @returns {Boolean}
   */
  const isPlainObject = function (obj) {
    return obj !== null && Object.prototype.toString.call(obj) === "[object Object]";
  };

  /*
   * checks whether two arrays are equal
   * @param {Array} a
   * @param {Array} b
   * @returns {Boolean}
   */
  const arrayEquals = function (a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;
    for (let i = 0; i < a.length; ++i) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  };

  const deepArrayEquals = function (a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;
    for (let i = 0; i < a.length; ++i) {
      if (isPlainObject(a[i]) && isPlainObject(b[i])) {
        if (!comparePlainObjects(a[i], b[i])) return false;
      } else if (a[i] !== b[i]) return false;
    }
    return true;
  };

  /**
   * Object Comparison
   *
   * http://stamat.wordpress.com/2013/06/22/javascript-object-comparison/
   *
   * No version
   *
   * @param a
   * @param b
   * @returns {boolean} if objects are equal
   */
  const comparePlainObjects = function (a, b) {

    //Returns the object's class, Array, Date, RegExp, Object are of interest to us
    const getClass = function (val) {
      return Object.prototype.toString.call(val)
        .match(/^\[object\s(.*)\]$/)[1];
    };

    //Defines the type of the value, extended typeof
    const whatis = function (val) {

      if (val === undefined) {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }

      let type = typeof val;

      if (type === "object") {
        type = getClass(val).toLowerCase();
      }

      if (type === "number") {
        return val.toString().indexOf(".") > 0 ?
          "float" :
          "integer";
      }

      return type;
    };

    const compare = function (a, b) {
      if (a === b) {
        return true;
      }
      for (const i in a) {
        if (b.hasOwnProperty(i)) {
          if (!equal(a[i], b[i])) {
            return false;
          }
        } else {
          return false;
        }
      }

      for (const i in b) {
        if (!a.hasOwnProperty(i)) {
          return false;
        }
      }
      return true;
    };

    const compareArrays = function (a, b) {
      if (a === b) {
        return true;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equal(a[i], b[i])) {
          return false;
        }
      }
      return true;
    };

    const _equal = {};
    _equal.array = compareArrays;
    _equal.object = compare;
    _equal.date = function (a, b) {
      return a.getTime() === b.getTime();
    };
    _equal.regexp = function (a, b) {
      return a.toString() === b.toString();
    };

    /**
     * Are two values equal, deep compare for objects and arrays.
     * @param a {any}
     * @param b {any}
     * @return {boolean} Are equal?
     */
    const equal = function (a, b) {
      if (a !== b) {
        const atype = whatis(a);
        const btype = whatis(b);

        if (atype === btype) {
          return _equal.hasOwnProperty(atype) ? _equal[atype](a, b) : a == b;
        }

        return false;
      }

      return true;
    };

    return compare(a, b);
  };


  const getViewportPosition = function (element) {
    let xPosition = 0;
    let yPosition = 0;

    while (element) {
      xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
      yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
      element = element.offsetParent;
    }

    return {
      x: xPosition,
      y: yPosition
    };
  };


  /*
   * transforms a string into a validated fload value
   * @param {string} string to be transformed
   */
  const strToFloat = function (string) {
    return +string.replace(/[^\d.-]/g, "");
  };

  /*
   * loops through an object or array
   * @param {Object|Array} obj object or array
   * @param {Function} callback callback function
   * @param {Object} ctx context object
   */
  const forEach = function (obj, callback, ctx) {
    if (!obj) {
      return;
    }
    let i, size;
    if (isArray(obj)) {
      size = obj.length;
      for (i = 0; i < size; i += 1) {
        const result = callback.apply(ctx, [obj[i], i]);
        if (result === false) {
          break;
        }
      }
    } else {
      const keys = Object.keys(obj);
      size = keys.length;
      for (i = 0; i < size; i += 1) {
        const result = callback.apply(ctx, [obj[keys[i]], keys[i]]);
        if (result === false) {
          break;
        }
      }
    }
  };

  /*
   * extends an object
   * @param {Object} destination object
   * @returns {Object} extented object
   */
  const extend = function (dest) {
    //objects to overwrite dest are next arguments
    const objs = Array.prototype.slice.call(arguments, 1);
    //loop through each obj and each argument, left to right
    forEach(objs, (obj) => {
      forEach(obj, (value, k) => {
        if (obj.hasOwnProperty(k)) {
          dest[k] = value;
        }
      });
    });
    return dest;
  };

  // Deep extend and helper functions
  // https://github.com/unclechu/node-deep-extend/blob/master/lib/deep-extend.js

  function isSpecificValue(val) {
    return Boolean((
      val instanceof Date
      || val instanceof RegExp
    ));
  }

  function cloneSpecificValue(val) {
    if (val instanceof Date) {
      return new Date(val.getTime());
    } else if (val instanceof RegExp) {
      return new RegExp(val);
    }
    throw new Error("Unexpected situation");
  }

  /**
   * Recursive cloning array.
   */
  function deepCloneArray(arr) {
    const clone = [];
    forEach(arr, (item, index) => {
      if (typeof item === "object" && item !== null) {
        if (isArray(item)) {
          clone[index] = deepCloneArray(item);
        } else if (isSpecificValue(item)) {
          clone[index] = cloneSpecificValue(item);
        } else {
          clone[index] = deepExtend({}, item);
        }
      } else {
        clone[index] = item;
      }
    });
    return clone;
  }

  /**
   * Extening object that entered in first argument.
   *
   * Returns extended object or false if have no target object or incorrect type.
   *
   * If you wish to clone source object (without modify it), just use empty new
   * object as first argument, like this:
   *   deepExtend({}, yourObj_1, [yourObj_N]);
   */
  const deepExtend = function (/*obj_1, [obj_2], [obj_N]*/) {
    if (arguments.length < 1 || typeof arguments[0] !== "object") {
      return false;
    }

    if (arguments.length < 2) {
      return arguments[0];
    }

    const target = arguments[0];

    const lastArgIsBool = typeof arguments[arguments.length - 1] === "boolean";
    const overwriteByEmpty = lastArgIsBool && arguments[arguments.length - 1];
    // convert arguments to array and cut off target object
    const args = Array.prototype.slice.call(arguments, 1, (lastArgIsBool ? -1 : arguments.length));

    let val, src;

    forEach(args, obj => {
      // skip argument if it is array or isn't object
      if (typeof obj !== "object" || isArray(obj)) {
        return;
      }

      forEach(Object.getOwnPropertyNames(obj), key => {
        src = target[key]; // source value
        val = obj[key]; // new value

        // recursion prevention
        if (val === target) ; else if (typeof val !== "object" || val === null || val._data) {
          target[key] = val;

          // just clone arrays (and recursive clone objects inside)
        } else if (isArray(val)) {
          target[key] = deepCloneArray(val);

          // custom cloning and overwrite for specific objects
        } else if (isSpecificValue(val)) {
          target[key] = cloneSpecificValue(val);

          // overwrite by new value if source isn't object or array
        } else if (typeof src !== "object" || src === null || isArray(src)) {
          target[key] = deepExtend({}, val);

          // new value is empty object
        } else if (overwriteByEmpty && isEmpty(val)) {
          target[key] = {};

          // source value and new value is objects both, extending...
        } else {
          target[key] = deepExtend(src, val, overwriteByEmpty);
        }
      });
    });

    return target;
  };

  /*
   * merges objects instead of replacing
   * @param {Object} destination object
   * @returns {Object} merged object
   */
  const merge = function (dest) {

    // objects to overwrite dest are next arguments
    const objs = Array.prototype.slice.call(arguments, 1);

    // loop through each obj and each argument, left to right
    forEach(objs, (obj) => {
      forEach(obj, (value, k) => {
        if (obj.hasOwnProperty(k)) {
          if (dest.hasOwnProperty(k)) {
            if (!isArray(dest[k])) {
              dest[k] = [dest[k]];
            }
            dest[k].push(value);
          } else {
            dest[k] = value;
          }
        }
      });
    });
    return dest;

  };

  /*
   * clones an object (shallow copy)
   * @param {Object} src original object
   * @param {Array} arr filter keys
   * @returns {Object} cloned object
   */
  const clone = function (src, arr, exclude) {
    if (isArray(src)) {
      return src.slice(0);
    }
    const clone = {};
    forEach(src, (value, k) => {
      if ((arr && arr.indexOf(k) === -1) || (exclude && exclude.indexOf(k) !== -1)) {
        return;
      }
      if (src.hasOwnProperty(k)) {
        clone[k] = value;
      }
    });
    return clone;
  };

  /*
   * deep clones an object (deep copy)
   * @param {Object} src original object
   * @returns {Object} cloned object
   */
  const deepClone = function (src) {
    let clone = {};
    if (isArray(src)) clone = [];

    forEach(src, (value, k) => {
      if (isObject(value) || isArray(value)) {
        clone[k] = deepClone(value);
      } else {
        clone[k] = value;
      }
    });
    return clone;
  };

  /*
   * Prints message to timestamp
   * @param {Arr} arr
   * @param {Object} el
   */
  const without = function (arr, el) {
    const idx = arr.indexOf(el);
    if (idx !== -1) {
      arr.splice(idx, 1);
    }
    return arr;
  };

  /*
   * unique items in an array
   * @param {Array} arr original array
   * @param {Function} func optional evaluation function
   * @returns {Array} unique items
   * Based on:
   * http://stackoverflow.com/questions/1960473/unique-values-in-an-array
   */
  const unique = (array, map = data => data) => {
    const uniqueValues = {};

    return array.filter(item => {
      const value = map(item);

      if (uniqueValues.hasOwnProperty(value)) {
        return false;
      }

      uniqueValues[value] = 1;

      return true;
    });
  };

  /*
   * unique items in an array keeping the last item
   * @param {Array} arr original array
   * @param {Function} func optional evaluation function
   * @returns {Array} unique items
   * Based on the previous method
   */
  const uniqueLast = function (arr, func) {
    const u = {};
    const a = [];
    if (!func) {
      func = function (d) {
        return d;
      };
    }
    for (let i = 0, l = arr.length; i < l; i += 1) {
      const key = func(arr[i]);
      if (u.hasOwnProperty(key)) {
        a.splice(u[key], 1); //remove old item from array
      }
      a.push(arr[i]);
      u[key] = a.length - 1;
    }
    return a;
  };

  /*
   * returns first value that passes the test
   * @param {Array} arr original collection
   * @returns {Function} func test function
   */
  const find = function (arr, func) {
    let found;
    forEach(arr, i => {
      if (func(i)) {
        found = i;
        return false; //break
      }
    });
    return found;
  };

  /*
   * filters an array based on object properties
   * @param {Array} arr original array
   * @returns {Object} filter properties to use as filter
   */
  const filter = function (arr, filter) {
    let index = -1;
    const length = arr.length;
    let resIndex = -1;
    const result = [];
    const keys = Object.keys(filter);
    const s_keys = keys.length;
    let i;
    let f;
    while ((index += 1) < length) {
      const value = arr[index];
      let match = true;
      for (i = 0; i < s_keys; i += 1) {
        f = keys[i];
        if (!value.hasOwnProperty(f) || value[f] !== filter[f]) {
          match = false;
          break;
        }
      }
      if (match) {
        result[resIndex += 1] = value;
      }
    }
    return result;
  };

  /*
   * filters an array based on object properties.
   * Properties may be arrays determining possible values
   * @param {Array} arr original array
   * @returns {Object} filter properties to use as filter
   */
  const filterAny = function (arr, filter, wildcard) {
    let index = -1;
    const length = arr.length;
    let resIndex = -1;
    const result = [];
    const keys = Object.keys(filter);
    const s_keys = keys.length;
    let i, f;
    while ((index += 1) < length) {
      const value = arr[index];
      //normalize to array
      let match = true;
      for (i = 0; i < s_keys; i += 1) {
        f = keys[i];
        if (!value.hasOwnProperty(f) || !matchAny(value[f], filter[f], wildcard)) {
          match = false;
          break;
        }
      }
      if (match) {
        result[resIndex += 1] = value;
      }
    }
    return result;
  };

  /*
   * checks if the value matches the comparison value or any in array
   * compare may be an determining possible values
   * @param value original value
   * @param compare value or array
   * @param {String} wildc wildcard value
   * @returns {Boolean} try
   */
  const matchAny = function (values, compare, wildc) {
    //normalize value
    if (!isArray(values)) values = [values];
    if (!wildc) wildc = "*"; //star by default
    let match = false;
    for (let e = 0; e < values.length; e++) {
      const value = values[e];

      if (!isArray(compare) && value == compare) {
        match = true;
        break;
      } else if (isArray(compare)) {
        let found = -1;
        for (let i = 0; i < compare.length; i++) {
          const c = compare[i];
          if (!isArray(c) && (c == value || c === wildc)) {
            found = i;
            break;
          } else if (isArray(c)) { //range
            const min = c[0];
            const max = c[1] || min;
            if (value >= min && value <= max) {
              found = i;
              break;
            }
          }
        }
        if (found !== -1) {
          match = true;
          break;
        }
      }
    }
    return match;
  };

  /**
   * prevent scrolling parent scrollable elements for 2 second when element scrolled to end
   * @param node
   */

  const preventAncestorScrolling = function (element) {
    let preventScrolling = false;
    element.on("mousewheel", function (event) {
      const scrollTop = this.scrollTop;
      const scrollHeight = this.scrollHeight;
      const height = element.node().offsetHeight;
      const delta = event.wheelDelta;
      const up = delta > 0;
      const prevent = function () {
        event.stopPropagation();
        event.preventDefault();
        event.returnValue = false;
        return false;
      };

      const scrollTopTween = function (scrollTop) {
        return function () {
          const _this = this;
          const i = d3.interpolateNumber(this.scrollTop, scrollTop);
          return function (t) {
            _this.scrollTop = i(t);
          };
        };
      };
      if (!up) {
        // Scrolling down
        if (-delta > scrollHeight - height - scrollTop && scrollHeight != height + scrollTop) {
          element.transition().delay(0).duration(0).tween("scrolltween", scrollTopTween(scrollHeight));
          //freeze scrolling on 2 seconds on bottom position
          preventScrolling = true;
          setTimeout(() => {
            preventScrolling = false;
          }, 2000);
        } else if (scrollTop == 0) { //unfreeze when direction changed
          preventScrolling = false;
        }
      } else if (up) {
        // Scrolling up
        if (delta > scrollTop && scrollTop > 0) { //
          //freeze scrolling on 2 seconds on top position
          element.transition().delay(0).duration(0).tween("scrolltween", scrollTopTween(0));
          preventScrolling = true;
          setTimeout(() => {
            preventScrolling = false;
          }, 2000);
        } else if (scrollHeight == height + scrollTop) { //unfreeze when direction changed
          preventScrolling = false;
        }
      }
      if (preventScrolling) {
        return prevent();
      }
    });
  };

  /*
   * Converts radius to area, simple math
   * @param {Number} radius
   * @returns {Number} area
   */
  const radiusToArea = function (r) {
    return r * r * Math.PI;
  };

  /*
   * Computes hypotenuse of a right triangle, given the catheti
   * @param {Number} x
   * @param {Number} y
   * @returns {Number} square root of sum of the squares of x and y
   */
  const hypotenuse = function (x, y) {
    return Math.sqrt(x * x + y * y);
  };

  /*
   * Computes cathetus of a right triangle, given the hypotenuse and cathetus
   * @param {Number} h
   * @param {Number} c
   * @returns {Number} square root of difference of the squares of h and c
   */
  const cathetus = function (h, c) {
    return Math.sqrt(h * h - c * c);
  };

  /*
   * Converts area to radius, simple math
   * @param {Number} area
   * @returns {Number} radius
   */
  const areaToRadius = function (a) {
    return Math.sqrt(a / Math.PI);
  };

  /*
   * Prints message to timestamp
   * @param {String} message
   */
  const timeStamp = function (message) {
    if (console && typeof console.timeStamp === "function") {
      console.timeStamp(message);
    }
  };

  /*
   * Prints warning
   * @param {String} message
   */
  const warn = function (message) {
    message = Array.prototype.slice.call(arguments)
      .map(m => m instanceof Object ? JSON.stringify(m, null, 4) : m)
      .join(" ");
    if (console && typeof console.warn === "function") {

      console.warn(message);
    }
    // "return true" is needed to find out if a parent function is exited with warning
    // example:
    // myfunction = function() { if(brokenstuff) return utils.warn("broken stuff found") }
    // if(myfunction()) return; // stopped execution after myfunction finds broken stuff
    // ... or moving on
    return true;
  };

  /*
   * Prints message for group
   * @param {String} message
   */
  const groupCollapsed = function (message) {
    message = Array.prototype.slice.call(arguments).join(" ");
    if (console && typeof console.groupCollapsed === "function") {
      console.groupCollapsed(message);
    }
  };

  /*
   * Prints end of group
   * @param {String} message
   */
  const groupEnd = function () {
    if (console && typeof console.groupEnd === "function") {
      console.groupEnd();
    }
  };

  /*
   * Prints error
   * @param {String} message
   */
  const error = function (err) {
    if (console && typeof console.error === "function") {
      if (err.stack) {
        console.error(err.stack);
      } else {
        console.error(err);
      }
      if (arguments.length > 1) {
        console.error.apply(this, Array.prototype.slice.call(arguments, 1));
      }
    }
  };

  /*
   * Count the number of decimal numbers
   * @param {Number} number
   */
  const countDecimals = function (number) {
    if (Math.floor(number.valueOf()) === number.valueOf()) {
      return 0;
    }
    return number.toString().split(".")[1].length || 0;
  };

  /*
   * Adds class to DOM element
   * @param {Element} el
   * @param {String} className
   */
  const addClass = function (el, className) {
    if (el.classList) {
      el.classList.add(className);
    } else {
      //IE<10
      el.className += " " + className;
    }
  };

  /*
   * Remove class from DOM element
   * @param {Element} el
   * @param {String} className
   */
  const removeClass = function (el, className) {
    if (el.classList) {
      el.classList.remove(className);
    } else {
      //IE<10
      el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"),
        " ");
    }
  };

  /*
   * Adds or removes class depending on value
   * @param {Element} el
   * @param {String} className
   * @param {Boolean} value
   */
  const classed = function (el, className, value) {
    if (value === true) {
      addClass(el, className);
    } else if (value === false) {
      removeClass(el, className);
    } else {
      return hasClass(el, className);
    }
  };

  /*
   * Checks whether a DOM element has a class or not
   * @param {Element} el
   * @param {String} className
   * @return {Boolean}
   */
  const hasClass = (el, className) => (
    el.classList ?
      el.classList.contains(className) :
      new RegExp("(^| )" + className + "( |$)", "gi").test(el.className)
  );

  /*
   * Throttles a function
   * @param {Function} func
   * @param {Number} ms duration
   * @return {Function}
   * Function recallLast was added to prototype of returned function.
   * Call Function.recallLast() - immediate recall func with last saved arguments,
   *                              else func will be called automaticly after ms duration
   */
  const throttle = function (func, ms) {

    let throttled = false;
    let savedArgs;
    let savedThis;
    let nextTime;

    const __recallLast = function () {
      if (throttled) {
        throttled = false;
        func.apply(savedThis, savedArgs);
      }
    };

    const wrapper = function () {

      if (nextTime > Date.now()) {
        throttled = true;
        savedArgs = arguments;
        savedThis = this;
        return;
      }

      nextTime = Date.now() + ms;
      throttled = false;

      func.apply(this, arguments);

      setTimeout(() => {
        __recallLast();
      }, ms);

    };

    wrapper.recallLast = __recallLast;

    return wrapper;
  };


  /*
   * Returns keys of an object as array
   * @param {Object} arg
   * @returns {Array} keys
   */
  const keys = function (arg) {
    return Object.keys(arg);
  };

  /*
   * returns the values of an object in an array format
   * @param {Object} obj
   * @return {Array}
   */
  const values = function (obj) {
    const arr = [];
    const keys = Object.keys(obj);
    const size = keys.length;
    for (let i = 0; i < size; i += 1) {
      arr.push(obj[keys[i]]);
    }
    return arr;
  };


  /*
   * Computes the minumum value in an array
   * @param {Array} arr
   */
  const arrayMin = function (arr) {
    return arr.reduce((p, v) => (p < v ? p : v));
  };

  /*
   * Computes the minumum value in an array
   * @param {Array} arr
   */
  const arrayMax = function (arr) {
    return arr.reduce((p, v) => (p > v ? p : v));
  };

  /*
   * Computes the mean of an array
   * @param {Array} arr
   */
  const arrayMean = function (arr) {
    return arraySum(arr) / arr.length;
  };

  /*
   * Computes the sum of an array
   * @param {Array} arr
   */
  const arraySum = function (arr) {
    return arr.reduce((a, b) => a + b);
  };

  /*
   * Computes the median of an array
   * @param {Array} arr
   */
  const arrayMedian = arr => {
    arr = arr.sort((a, b) => a - b);
    const middle = Math.floor((arr.length - 1) / 2);

    return arr.length % 2 ?
      arr[middle] :
      (arr[middle] + arr[middle + 1]) / 2;
  };

  /*
   * Returns the last value of array
   * @param {Array} arr
   */
  const arrayLast = function (arr) {
    if (!arr.length) return null;
    return arr[arr.length - 1];
  };

  /*
   * Returns the resulting object of the difference between two objects
   * @param {Object} obj2
   * @param {Object} obj1
   * @returns {Object}
   */
  const diffObject = function (obj2, obj1) {
    const diff = {};
    forEach(obj1, (value, key) => {
      if (!obj2.hasOwnProperty(key) && isPlainObject(value)) {
        diff[key] = diffObject({}, value);
      }
    });
    forEach(obj2, (value, key) => {
      if (!obj1.hasOwnProperty(key)) {
        diff[key] = value;
      } else if (value !== obj1[key]) {
        if (isPlainObject(value) && isPlainObject(obj1[key])) {
          if (isEmpty(value)) {
            if (!isEmpty(obj1[key])) {
              diff[key] = {};
            }
          } else {
            const d = diffObject(value, obj1[key]);
            if (Object.keys(d).length > 0) {
              diff[key] = d;
            }
          }
        } else if (!isArray(value) || !isArray(obj1[key]) || !deepArrayEquals(value, obj1[key])) {
          diff[key] = value;
        }
      }
    });
    return diff;
  };

  /*
   * Defers a function
   * @param {Function} func
   */
  const defer = function (func) {
    setTimeout(func, 1);
  };

  /*
   * Defers a function
   * @param {Function} func
   */
  const delay = function (delay) {
    return new Promise(resolve => setTimeout(resolve, delay));
  };

  const clearDelay = function (delayId) {
    return clearTimeout(delayId);
  };

  /*
   * Creates a hashcode for a string or array
   * @param {String|Array} str
   * @return {Number} hashCode
   */
  const hashCode = function (str) {
    if (!isString(str)) {
      str = JSON.stringify(str);
    }
    let hash = 0;
    const size = str.length;
    let c;
    if (size === 0) {
      return hash;
    }
    for (let i = 0; i < size; i += 1) {
      c = str.charCodeAt(i);
      hash = (hash << 5) - hash + c;
      hash &= hash; // Convert to 32bit integer
    }
    return hash.toString();
  };


  /*
   * Converts D3 nest array into the object with key-value pairs, recursively
   * @param {Array} arr - array like this [{key: k, values: [a, b, ...]}, {...} ... {...}]
   * @return {Object} object like this {k: [a, b, ...], ...}
   */
  //
  const nestArrayToObj = function (arr) {
    if (!arr || !arr.length || !arr[0].key) return arr;
    const res = {};
    for (let i = 0; i < arr.length; i++) {
      res[arr[i].key] = nestArrayToObj(arr[i].values);
    }
    return res;
  };

  const nestArrayToObjWithFlatKeys = function (arr, res = {}, keys, key = "") {
    if (!arr || !arr.length || !arr[0].key) {
      if (keys) {
        keys += "]";
        !res[keys] && (res[keys] = {});
        res[keys][key] = arr;
      } else {
        res[key] = arr;
      }
      return arr;
    }
    if (key) keys = keys ? keys + "," + JSON.stringify(key) : ("[" + JSON.stringify(key));
    for (let i = 0; i < arr.length; i++) {
      nestArrayToObjWithFlatKeys(arr[i].values || arr[i].value, res, keys, arr[i].key);
    }
    return res;
  };

  const nestArrayToValues = function (arr, res = []) {
    if (!arr || !arr.length || !arr[0].key) {
      res.push(...arr);
      return;
    }
    for (let i = 0; i < arr.length; i++) {
      nestArrayToValues(arr[i].values || arr[i].value, res);
    }
    return res;
  };

  const interpolateVector = function () {

  };

  /*
   * Performs an ajax request
   * @param {Object} options
   * @param {String} className
   * @return {Boolean}
   */
  const ajax = function (options) {
    const request = new XMLHttpRequest();
    request.open(options.method, options.url, true);
    if (options.method === "POST" && !options.json) {
      request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
    } else if (options.method === "POST" && options.json) {
      request.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
    }
    request.onload = function () {
      if (request.status >= 200 && request.status < 400) {
        // Success!
        const data = options.json ? JSON.parse(request.responseText) : request.responseText;
        if (options.success) {
          options.success(data);
        }
      } else {
        if (options.error) {
          options.error();
        }
      }
    };
    request.onerror = function () {
      if (options.error) {
        options.error();
      }
    };
    request.send(options.data);
  };

  /*
   * Performs a GET http request
   */
  const get = function (url, pars, success, error, json) {
    pars = pars || [];
    forEach(pars, (value, key) => {
      pars.push(key + "=" + value);
    });
    url = pars.length ? url + "?" + pars.join("&") : url;
    ajax({
      method: "GET",
      url,
      success,
      error,
      json
    });
  };

  /*
   * Performs a POST http request
   */
  const post = function (url, pars, success, error, json) {
    ajax({
      method: "POST",
      url,
      success,
      error,
      json,
      data: pars
    });
  };

  /**
   * Make function memoized
   * @param {Function} fn
   * @returns {Function}
   */
  const memoize = function (fn) {
    return function () {
      const args = Array.prototype.slice.call(arguments);
      let hash = "";
      let i = args.length;
      let currentArg = null;

      while (i--) {
        currentArg = args[i];
        hash += (currentArg === Object(currentArg)) ? JSON.stringify(currentArg) : currentArg;
        fn.memoize || (fn.memoize = {});
      }

      return (hash in fn.memoize) ? fn.memoize[hash] : fn.memoize[hash] = fn.apply(this, args);
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  const debounce = function (func, wait, immediate) {
    let timeout;
    return function () {
      const context = this;
      const args = arguments;
      const later = function () {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  };

  const isTouchDevice = function () {
    return !!("ontouchstart" in document.documentElement);
  };

  //return a pruneed tree
  const pruneTree = function (tree, filterCallback) {
    const filteredTree = {};
    let filteredChildrens = [];
    if (tree.hasOwnProperty("children")) {
      filteredChildrens = tree.children.map(childrenTree => pruneTree(childrenTree, filterCallback)).filter(childrenTree => Object.keys(childrenTree).length !== 0);
    }
    if (filteredChildrens.length != 0 || filterCallback(tree)) {
      //copy all the properties to the new tree
      forEach(tree, (value, key) => {
        filteredTree[key] = value;
      });
    }
    if (filteredChildrens.length != 0) {
      filteredTree["children"] = filteredChildrens;
    }
    return filteredTree;
  };

  const eachTree = function (tree, filterCallback, parentTree) {
    if (tree.hasOwnProperty("children")) {
      tree.children.forEach(childrenTree => eachTree(childrenTree, filterCallback, tree));
    }
    filterCallback(tree, parentTree);
  };

  const setIcon = function (element, icon) {
    const svgIcon = element.node().ownerDocument.importNode(
      new DOMParser().parseFromString(icon, "application/xml").documentElement,
      true
    );
    svgIcon.setAttribute("width", "0px");
    svgIcon.setAttribute("height", "0px");

    element.selectAll(".svg-icon").remove();
    element.node().appendChild(svgIcon);
    return element;
  };

  //http://stackoverflow.com/questions/26049488/how-to-get-absolute-coordinates-of-object-inside-a-g-group
  function makeAbsoluteContext(element, svgDocument) {
    return function (x, y) {
      const offset = svgDocument.getBoundingClientRect();
      const matrix = element.getScreenCTM();
      return {
        x: (matrix.a * x) + (matrix.c * y) + matrix.e - offset.left,
        y: (matrix.b * x) + (matrix.d * y) + matrix.f - offset.top
      };
    };
  }


  /***
   thenBy.js
   Copyright 2013 Teun Duynstee
   https://github.com/Teun/thenBy.js/blob/master/thenBy.module.js

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   */
  function firstBy() {

    function identity(v) {
      return v;
    }

    function ignoreCase(v) {
      return typeof (v) === "string" ? v.toLowerCase() : v;
    }

    function makeCompareFunction(f, opt) {
      opt = typeof (opt) === "number" ? {direction: opt} : opt || {};
      if (typeof (f) !== "function") {
        const prop = f;
        // make unary function
        f = function (v1) {
          return v1[prop] ? v1[prop] : "";
        };
      }
      if (f.length === 1) {
        // f is a unary function mapping a single item to its sort score
        const uf = f;
        const preprocess = opt.ignoreCase ? ignoreCase : identity;
        f = function (v1, v2) {
          return preprocess(uf(v1)) < preprocess(uf(v2)) ? -1 : preprocess(uf(v1)) > preprocess(uf(v2)) ? 1 : 0;
        };
      }
      if (opt.direction === -1) return function (v1, v2) {
        return -f(v1, v2);
      };
      return f;
    }

    /* adds a secondary compare function to the target function (`this` context)
     which is applied in case the first one returns 0 (equal)
     returns a new compare function, which has a `thenBy` method as well */
    function tb(func, opt) {
      const x = typeof (this) === "function" ? this : false;
      const y = makeCompareFunction(func, opt);
      const f = x ? function (a, b) {
        return x(a, b) || y(a, b);
      }
        : y;
      f.thenBy = tb;
      return f;
    }

    return tb;
  }

  function transform(node) {

    const {a, b, c, d, e, f} = node.transform.baseVal.consolidate().matrix;

    return (function (a, b, c, d, e, f) {
      let scaleX = Math.sqrt(a * a + b * b);
      let scaleY = Math.sqrt(c * c + d * d);
      let skewX = a * c + b * d;
      if (scaleX) a /= scaleX, b /= scaleX;
      if (skewX) c -= a * skewX, d -= b * skewX;
      if (scaleY) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * Math.PI / 180,
        skewX: Math.atan(skewX) * Math.PI / 180,
        scaleX,
        scaleY
      };
    })(a, b, c, d, e, f);
  }

  const capitalize = string => string.slice(0, 1).toUpperCase() + string.slice(1).toLowerCase();

  // http://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
  const isMobileOrTablet = (agent = navigator.userAgent || navigator.vendor || window.opera) => /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent.substr(0, 4));

  function getKey(d, keysArray) {
    let key = d[keysArray[0]];
    for (let i = 1, j = keysArray.length; i < j; i++) {
      key = key + "," + d[keysArray[i]];
    }
    return key;
  }

  const isFunction = value => typeof value === "function";


  /**
   * This is helper for getting some deep props in object. It's added to remove code like
   * this.show[dimension]
   *   && this.show[dimension]["$in"]
   *   && this.show[dimension]["$in"].indexOf(d[dimension]) !== -1;
   * when you need to get (+check) nested properties.

   * @param {context} object The root object where we start to look for the props
   * @param {Array} props Names of properties for nesting
   * @param {*} defaultValue Default value that will be returned if there is no such properties in object
   * @returns {property} The property we're looking for or a default value

   * Usage:
   * const object = { one: { two: "your value" } };
   * utils.getProp(object, ["one", "two"]); // "your value"
   */
  const getProp = (object, props, defaultValue) => {
    for (let prop of Array.isArray(props) ? props : [props]) {
      if (object.hasOwnProperty(prop)) {
        object = object[prop];
      } else {
        return defaultValue;
      }
    }
    return object;
  };

  const px2num = pixels => (
    isString(pixels) && pixels.endsWith("px") ?
      parseFloat(pixels) :
      console.warn(`Strange pixels value: ${pixels}`) || pixels
  );

  const replaceNumberSpacesToNonBreak = numString => numString ? numString.replace(/\d{1,3}(?: \d{3})+(?=\W)/g, match => match.replace(/ /g, "\xa0")) : numString;

  const getSubtitle = (title, shortTitle) => {
    let subtitle = (title ?? "").replace(shortTitle, "");
    if (subtitle[0] === ",") subtitle = subtitle.slice(1);
    const regexpResult = /^\((.*)\)$|.*/.exec(subtitle.trim());
    return regexpResult[1] || regexpResult[0] || "";
  };

  const getBrowserDetails = () => {

    const nAgt = navigator.userAgent;
    let browserName = navigator.appName;
    let fullVersion = "" + parseFloat(navigator.appVersion);
    let majorVersion = parseInt(navigator.appVersion, 10);
    let nameOffset, verOffset, ix;
    const isElectron = navigator.userAgent.toLowerCase().indexOf(" electron/") > -1;

    // In Opera, the true version is after "Opera" or after "Version"
    if ((verOffset = nAgt.indexOf("Opera")) != -1) {
      browserName = "Opera";
      fullVersion = nAgt.substring(verOffset + 6);
      if ((verOffset = nAgt.indexOf("Version")) != -1)
        fullVersion = nAgt.substring(verOffset + 8);
    }
    // In MSIE, the true version is after "MSIE" in userAgent
    else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
      browserName = "Microsoft Internet Explorer";
      fullVersion = nAgt.substring(verOffset + 5);
    }
    // In Chrome, the true version is after "Chrome"
    else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
      browserName = "Chrome";
      fullVersion = nAgt.substring(verOffset + 7);
    }
    // In Safari, the true version is after "Safari" or after "Version"
    else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
      browserName = "Safari";
      fullVersion = nAgt.substring(verOffset + 7);
      if ((verOffset = nAgt.indexOf("Version")) != -1)
        fullVersion = nAgt.substring(verOffset + 8);
    }
    // In Firefox, the true version is after "Firefox"
    else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
      browserName = "Firefox";
      fullVersion = nAgt.substring(verOffset + 8);
    }
    // In most other browsers, "name/version" is at the end of userAgent
    else if ((nameOffset = nAgt.lastIndexOf(" ") + 1) <
      (verOffset = nAgt.lastIndexOf("/"))) {
      browserName = nAgt.substring(nameOffset, verOffset);
      fullVersion = nAgt.substring(verOffset + 1);
      if (browserName.toLowerCase() == browserName.toUpperCase()) {
        browserName = navigator.appName;
      }
    }
    // trim the fullVersion string at semicolon/space if present
    if ((ix = fullVersion.indexOf(";")) != -1)
      fullVersion = fullVersion.substring(0, ix);
    if ((ix = fullVersion.indexOf(" ")) != -1)
      fullVersion = fullVersion.substring(0, ix);

    majorVersion = parseInt("" + fullVersion, 10);
    if (isNaN$1(majorVersion)) {
      fullVersion = "" + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
    }

    return (isElectron ? "Electron " : "") + browserName + " " + majorVersion + " (" + fullVersion + ")";
  };

  const normaliseLink = input => {
    if (!input) return input;
    if (input.indexOf("http://") === 0 || input.indexOf("https://") === 0) return input;
    if (input.indexOf("//") === 0) return "http://" + input.slice(2);
    return "http://" + input;
  };

  const getOSname = () => {
    let OSName = "Unknown";
    if (window.navigator.userAgent.indexOf("Windows NT 10.0") != -1) OSName = "Windows 10";
    if (window.navigator.userAgent.indexOf("Windows NT 6.2") != -1) OSName = "Windows 8";
    if (window.navigator.userAgent.indexOf("Windows NT 6.1") != -1) OSName = "Windows 7";
    if (window.navigator.userAgent.indexOf("Windows NT 6.0") != -1) OSName = "Windows Vista";
    if (window.navigator.userAgent.indexOf("Windows NT 5.1") != -1) OSName = "Windows XP";
    if (window.navigator.userAgent.indexOf("Windows NT 5.0") != -1) OSName = "Windows 2000";
    if (window.navigator.userAgent.indexOf("Mac") != -1) OSName = "Mac/iOS";
    if (window.navigator.userAgent.indexOf("X11") != -1) OSName = "UNIX";
    if (window.navigator.userAgent.indexOf("Linux") != -1) OSName = "Linux";

    return OSName;
  };

  // d3.rebind (v3) - Copies a variable number of methods from source to target.
  const rebind = function(target, source) {
    let i = 1, method;
    const n = arguments.length;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };

  // Method is assumed to be a standard D3 getter-setter:
  // If passed with no arguments, gets the value.
  // If passed with arguments, sets the value and returns the target.
  function d3_rebind(target, source, method) {
    return function() {
      const value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }

  var _LegacyUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    d3json: d3json,
    d3text: d3text,
    approxEqual: approxEqual,
    printAutoconfigResult: printAutoconfigResult,
    uniqueId: uniqueId,
    isElement: isElement,
    isArray: isArray,
    isObject: isObject,
    isDate: isDate,
    isString: isString,
    isNaN: isNaN$1,
    isEmpty: isEmpty,
    isNumber: isNumber,
    isPlainObject: isPlainObject,
    arrayEquals: arrayEquals,
    deepArrayEquals: deepArrayEquals,
    comparePlainObjects: comparePlainObjects,
    getViewportPosition: getViewportPosition,
    strToFloat: strToFloat,
    forEach: forEach,
    extend: extend,
    deepExtend: deepExtend,
    merge: merge,
    clone: clone,
    deepClone: deepClone,
    without: without,
    unique: unique,
    uniqueLast: uniqueLast,
    find: find,
    filter: filter,
    filterAny: filterAny,
    matchAny: matchAny,
    preventAncestorScrolling: preventAncestorScrolling,
    radiusToArea: radiusToArea,
    hypotenuse: hypotenuse,
    cathetus: cathetus,
    areaToRadius: areaToRadius,
    timeStamp: timeStamp,
    warn: warn,
    groupCollapsed: groupCollapsed,
    groupEnd: groupEnd,
    error: error,
    countDecimals: countDecimals,
    addClass: addClass,
    removeClass: removeClass,
    classed: classed,
    hasClass: hasClass,
    throttle: throttle,
    keys: keys,
    values: values,
    arrayMin: arrayMin,
    arrayMax: arrayMax,
    arrayMean: arrayMean,
    arraySum: arraySum,
    arrayMedian: arrayMedian,
    arrayLast: arrayLast,
    diffObject: diffObject,
    defer: defer,
    delay: delay,
    clearDelay: clearDelay,
    hashCode: hashCode,
    nestArrayToObj: nestArrayToObj,
    nestArrayToObjWithFlatKeys: nestArrayToObjWithFlatKeys,
    nestArrayToValues: nestArrayToValues,
    interpolateVector: interpolateVector,
    ajax: ajax,
    get: get,
    post: post,
    memoize: memoize,
    debounce: debounce,
    isTouchDevice: isTouchDevice,
    pruneTree: pruneTree,
    eachTree: eachTree,
    setIcon: setIcon,
    makeAbsoluteContext: makeAbsoluteContext,
    firstBy: firstBy,
    transform: transform,
    capitalize: capitalize,
    isMobileOrTablet: isMobileOrTablet,
    getKey: getKey,
    isFunction: isFunction,
    getProp: getProp,
    px2num: px2num,
    replaceNumberSpacesToNonBreak: replaceNumberSpacesToNonBreak,
    getSubtitle: getSubtitle,
    getBrowserDetails: getBrowserDetails,
    normaliseLink: normaliseLink,
    getOSname: getOSname,
    rebind: rebind
  });

  const STATUS = {
    INIT: "init", 
    PENDING: "pending", 
    READY: "fulfilled", 
    ERROR: "rejected"
  };

  function injectIndexes(array) {
    return array.map((m, i) => Object.assign({}, m, {i}));
  }

  function isEntityConcept(concept = {}) {
    return ["entity_set", "entity_domain"].includes(concept.concept_type);
  }

  function getSpaceName(enc, space){
    if(!space) space = enc.data.space;
    if(!isArray(space)) space = [space];
    return space.map(m => enc.data.source.getConcept(m).name).join(", ");
  }

  function getConceptNameCompliment(enc) {
    const dims = enc.data.filter.dimensions;
    if(!dims) Promise.resolve("");

    return requestEntityNames(enc.data.source, Object.keys(dims))
      .then(response => {
        
        return response.map(({data,dim}) => {
          const value = dims[dim][dim];
          //const prefix = getSpaceName(enc, dim);
          return /*prefix + ": " +*/ data.raw.find(f => f[dim]==value).name;
        }).join(", ");
      });
  }

  function requestEntityNames(datasource, dims) {
    if(!isArray(dims)) dims = [dims];

    const promises = dims.map(dim => {
      return datasource.query({
        select: {
          key: [dim],
          value: ["name"]
        },
        from: "entities"
      }).then(data => {
        return { data, dim };
      });
    });

    return Promise.all(promises);
  }

  function getConceptName(enc, localise) {
    const cp = enc.data.conceptProps;

    if (enc.data.isConstant) 
      return localise("indicator/" + enc.data.constant + "/" + enc.scale.modelType);

    return cp.name || cp.concept || localise(enc.name);
  }

  function getConceptShortName(enc, localise) {
    const cp = enc.data.conceptProps;

    if (enc.data.isConstant) 
      return localise("indicator/" + enc.data.constant + "/" + enc.scale.modelType);
      
    return cp.name_short || getConceptName(enc, localise);
  }

  function getConceptNameMinusShortName(enc, localise) {
    const name = getConceptName(enc, localise);
    const shortName = getConceptShortName(enc, localise);

    if (enc.data.isConstant) 
      return name;

    let result = name.replace(shortName,"");

    //remove leading comma if present
    if (result[0] === ",") result = result.slice(1);

    result = result.trim();

    //remove brackets if string starts with "(" and ends with ")"
    const regexpResult = /^\((.*)\)$|.*/.exec(result);
    return regexpResult[1] || regexpResult[0] || "";
  }

  function getConceptUnit(enc) {
    const cp = enc.data.conceptProps;
    return cp && cp.unit || "";
  }

  function getDefaultStateTree(defaultState, component) {
    const _defaultState = getChildrenDefaultState(defaultState, component.DEFAULT_UI);
    component.children.forEach(child => {
      if (child.name) {
        _defaultState[child.name] = getDefaultStateTree(_defaultState[child.name], child);
      } else {
        deepExtend(_defaultState, getDefaultStateTree(_defaultState, child));
      }
    });
    return _defaultState;
  }

  function getChildrenDefaultState(parent, children) {
    const cloneChildren = deepClone(children);
    return deepExtend(cloneChildren, parent);
  }

  function clearEmpties(obj) {
    for (const key in obj) {
      if (!obj[key] || typeof obj[key] !== "object" || obj[key] instanceof Date) {
        continue; // If null or not an object, skip to the next iteration
      }

      // The property is an object
      clearEmpties(obj[key]); // <-- Make a recursive call on the nested object
      if (Object.keys(obj[key]).length === 0) {
        delete obj[key]; // The object had no properties, so delete that property
      }
    }
    return obj;
  }

  function mergeInTarget(target, source, blocks = [], keystack = "") {
    for (const key in source) {
      if (typeof source[key] === "object" && !Array.isArray(source[key]) && source[key] !== null) {
        //if an object exists in target and it's not declared a block
        if ( target[key] && !blocks.some(s => (keystack + "." + key).endsWith(s)) ) {
          //recursively merge that object in target, pass on possible blocks and increment the keystack
          mergeInTarget(target[key], source[key], blocks, keystack + "." + key);
        } else {
          //create new object by cloning from source
          target[key] = deepExtend({}, source[key]);
        }
      } else {
        //replace target prop with one from the source
        target[key] = source[key];
      }
    }
    return target;
  }

  function replaceProps(target, source) {
    for (const key in target) {
      if (typeof target[key] === "object" && !Array.isArray(target[key]) && target[key] !== null) {
        replaceProps(target[key], source[key] || {});
      } else {
        if (typeof source[key] !== "undefined") {
          target[key] = source[key];
        } else {
          delete target[key];
        }
      }
    }
    return target;
  }

  /**
   * Recursively walks through forConfig and tries to match corresponding parts of againstConfig
   * Returns a value from 0 to 1 that shows how similar are the two given configs
   * @param {Object} forConfig 
   * @param {Object} againstConfig 
   * @param {String} specialKeySubstring 
   * @returns {Number} similaryty score from 0 to 1
   */
  function computeObjectsSimilarityScore(forConfig, againstConfig, specialKeySubstring = ""){
    function isThereASpecialKeySubstringInBoth(a, b, specialKeySubstring) {
      return specialKeySubstring
        && Object.keys(a).find(f => f.includes(specialKeySubstring))
        && Object.keys(b).find(f => f.includes(specialKeySubstring));
    }
    function compare(a, b) {
      let score = 0;
      let total = 0;
      for (const key in a) {
        if (typeof a[key] === "object" && !Array.isArray(a[key]) && a[key] != null && b[key] != null) {
          const deeper = compare(a[key], b[key]);
          score += deeper.score;
          total += deeper.total;
        } else {
          if (a[key] == b[key]) score ++;
          else if (a[key] != null && b[key] != null) score += 0.5;
          else if (isThereASpecialKeySubstringInBoth(a, b, specialKeySubstring)) score += 0.1;
          total++;
        }
      }
      return {score, total};
    }
    const result = compare(forConfig, againstConfig);
    return result.score / result.total;
  }

  var _Utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    STATUS: STATUS,
    injectIndexes: injectIndexes,
    isEntityConcept: isEntityConcept,
    getSpaceName: getSpaceName,
    getConceptNameCompliment: getConceptNameCompliment,
    requestEntityNames: requestEntityNames,
    getConceptName: getConceptName,
    getConceptShortName: getConceptShortName,
    getConceptNameMinusShortName: getConceptNameMinusShortName,
    getConceptUnit: getConceptUnit,
    getDefaultStateTree: getDefaultStateTree,
    getChildrenDefaultState: getChildrenDefaultState,
    clearEmpties: clearEmpties,
    mergeInTarget: mergeInTarget,
    replaceProps: replaceProps,
    computeObjectsSimilarityScore: computeObjectsSimilarityScore
  });

  function axisSmart$1(_orient) {

    return (function d3_axis_smart(_super) {

      const VERTICAL = "vertical axis";
      const HORIZONTAL = "horizontal axis";
      const X = "labels stack side by side";
      const Y = "labels stack top to bottom";

      const OPTIMISTIC = "optimistic approximation: labels have different lengths";
      const PESSIMISTIC = "pessimistic approximation: all labels have the largest length";
      const DEFAULT_LOGBASE = 10;

      function onlyUnique(value, index, self) {
        return self.indexOf(value) === index;
      }

      function axis(g) {
        const checkDmn = axis.scale().domain();
        const checkRng = axis.scale().range();
        if (!checkDmn.length || !checkRng.length || [...checkDmn, ...checkRng].some(s => s == null || isNaN(s))) {    
          //this catches null, undefined, NaN, Invalid date, but accepts 0 and ""
          highlightValue = null;
          return warn(`axisSmart() skips action because of bad domain ${checkDmn} or range ${checkRng} of the attached scale`);
        }

        if (highlightValue != null) {
          axis.highlightValueRun(g);
          return;
        }

        // measure the width and height of one digit
        const widthSampleG = g.append("g").attr("class", "tick widthSampling");
        const widthSampleT = widthSampleG.append("text").text("0M");
        if (!options.cssMargin) options.cssMargin = {};
        options.cssMargin.top = widthSampleT.style("margin-top");
        options.cssMargin.bottom = widthSampleT.style("margin-bottom");
        options.cssMargin.left = widthSampleT.style("margin-left");
        options.cssMargin.right = widthSampleT.style("margin-right");
        options.widthOfOneDigit = widthSampleT.node().getBBox().width * 0.5;
        options.heightOfOneDigit = widthSampleT.node().getBBox().height;
        widthSampleG.remove();

        // run label factory - it will store labels in tickValues property of axis
        axis.labelFactory(options);

        // construct the view (d3 constructor is used)
        let transition = null;
        if (options.transitionDuration > 0) {
          _super(transition = g.transition().duration(options.transitionDuration));
        } else {
          _super(g);
        }

        //remove axis d3v4 hardcoded attributes
        g.attr("fill", null);
        g.attr("font-size", null);
        g.attr("font-family", null);
        g.attr("text-anchor", null);

        //identify the orientation of axis and the direction of labels
        const orient = axis.orient() == "top" || axis.orient() == "bottom" ? HORIZONTAL : VERTICAL;
        const dimension = (orient == HORIZONTAL && axis.pivot() || orient == VERTICAL && !axis.pivot()) ? Y : X;

        //add an invisible element that would represent hovered value
        g.selectAll(".vzb-axis-value")
          .data([null])
          .enter().call(selection => {
            selection.append("g")
              .attr("class", "vzb-axis-value")
              .classed("vzb-hidden", true)
              .append("text")
              .each(function() {
                const textEl = d3.select(this);
                textEl.classed("stroke", true);
                if (!textEl.style("paint-order").length) {
                  textEl.clone().classed("stroke", false);
                }
              });
            selection.append("g")
              .attr("class", "vzb-axis-value vzb-axis-value-shadow")
              .style("opacity", 0)
              .append("text");
          });

        // patch the label positioning after the view is generated
        const padding = axis.tickPadding();
        g.selectAll("text")
          .each(function() {
            if (axis.pivot() == null) return;

            const view = d3.select(this);
            view.attr("transform", "rotate(" + (axis.pivot() ? -90 : 0) + ")");
            view.style("text-anchor", options.textAnchor || (dimension == X ? "middle" : "end"));
            view.attr("x", dimension == X ? (orient == VERTICAL ? -padding : 0) : -padding);
            view.attr("y", dimension == X ? (orient == VERTICAL ? 0 : padding) : 0);
            view.attr("dx", dimension == X ? (orient == VERTICAL ? padding : 0) : 0);
            view.attr("dy", dimension == X ? (orient == VERTICAL ? -padding : ".72em") : ".32em");
          });

        //apply label repositioning: first and last visible values would shift away from the borders
        if (axis.repositionLabels() != null) {
          const patchLabelsPosition = () => {
            g.selectAll(".tick")
              .each(function(d) {
                const view = d3.select(this).select("text");
                const shift = axis.repositionLabels()[d] || { x: 0, y: 0 };
                view.attr("x", +view.attr("x") + shift.x);
                view.attr("y", +view.attr("y") + shift.y);
              });
          };
          transition ? transition.on("end", () => patchLabelsPosition()) : patchLabelsPosition();
        }

        //hide axis labels that are outside the available viewport
        const scale = axis.scale();
        if (options.viewportLength) {
          g.selectAll(".tick")
            .classed("vzb-hidden", d => scale(d) < 0 || scale(d) > options.viewportLength);
        }

        // add minor ticks. if none exist add an empty array
        if (axis.tickValuesMinor() == null) axis.tickValuesMinor([]);
        let minorTicks = g.selectAll(".tick-minor").data(tickValuesMinor);
        minorTicks.exit().remove();
        minorTicks = minorTicks.enter().append("line")
          .attr("class", "tick-minor")
          .merge(minorTicks);

        const tickLengthOut = axis.tickSizeMinor().outbound;
        const tickLengthIn = axis.tickSizeMinor().inbound;

        //hide minor ticks that are outside the available viewport (when axis is zoomed ticks may stick out)
        if (options.viewportLength) {
          minorTicks
            .classed("vzb-hidden", d => scale(d) < 0 || scale(d) > options.viewportLength);
        }

        minorTicks
          .attr("y1", orient == HORIZONTAL ? (axis.orient() == "top" ? 1 : -1) * tickLengthIn : scale)
          .attr("y2", orient == HORIZONTAL ? (axis.orient() == "top" ? -1 : 1) * tickLengthOut : scale)
          .attr("x1", orient == VERTICAL ? (axis.orient() == "right" ? -1 : 1) * tickLengthIn : scale)
          .attr("x2", orient == VERTICAL ? (axis.orient() == "right" ? 1 : -1) * tickLengthOut : scale);

        //adjust axis rake
        g.selectAll("path").remove();
        let rake = g.selectAll(".vzb-axis-line").data([0]);
        rake.exit().remove();
        rake = rake.enter().append("line")
          .attr("class", "vzb-axis-line")
          .merge(rake);

        if (options.viewportLength) {
          rake
            .attr("x1", orient == VERTICAL ? 0 : -1)
            .attr("x2", orient == VERTICAL ? 0 : options.viewportLength)
            .attr("y1", orient == HORIZONTAL ? 0 : 0)
            .attr("y2", orient == HORIZONTAL ? 0 : options.viewportLength);
        } else {
          //TODO: this will not work for the "ordinal" scaleType
          rake
            .attr("x1", orient == VERTICAL ? 0 : d3.min(scale.range()) - (options.bump || 0) - 1)
            .attr("x2", orient == VERTICAL ? 0 : d3.max(scale.range()) + (options.bump || 0))
            .attr("y1", orient == HORIZONTAL ? 0 : d3.min(scale.range()) - (options.bump || 0))
            .attr("y2", orient == HORIZONTAL ? 0 : d3.max(scale.range()) + (options.bump || 0));
        }
      }


      axis.highlightValueRun = function(g) {

        //if viewport is defined and HL value is outside then behave as reset HL
        if (options.viewportLength && highlightValue != "none" && (
          axis.scale()(highlightValue) > options.viewportLength ||
          axis.scale()(highlightValue) < 0
        )) highlightValue = "none";

        //identify the orientation of axis and the direction of labels
        const orient = axis.orient() == "top" || axis.orient() == "bottom" ? HORIZONTAL : VERTICAL;
        const dimension = (orient == HORIZONTAL && axis.pivot() || orient == VERTICAL && !axis.pivot()) ? "y" : "x";
        const pivot = axis.pivot() ? -1 : 1;

        //set content and visibility of HL value
        g.select(".vzb-axis-value")
          .classed("vzb-hidden", highlightValue == "none");
        g.select(".vzb-axis-value-shadow").select("text")
          .text(highlightValue == "none" ? "" : options.formatter(highlightValue));

        let bbox;
        const o = {};

        if (highlightValue != "none") {
          // measure its width and height for collision resolving
          bbox = g.select(".vzb-axis-value-shadow").node().getBBox();

          // clone a known options object (because we don't want to overwrite widthOfOneDigit / heightOfOneDigit in the original one
          o.bump = options.bump;
          o.formatter = options.formatter;
          o.viewportLength = options.viewportLength;
          o.toolMargin = options.toolMargin;
          o.cssMargin = options.cssMargin;
          o.widthOfOneDigit = bbox[axis.pivot() ? "height" : "width"] / (options.formatter(highlightValue).length);
          o.heightOfOneDigit = bbox[axis.pivot() ? "width" : "height"];
        }

        // this will give additive shifting for the hovered value in case it sticks out a little outside viewport
        const hlValueShift = (highlightValue == "none" ? { x: 0, y: 0 } :
          repositionLabelsThatStickOut([highlightValue], o, orient, axis.scale(), dimension)[highlightValue])[dimension];

        // this function will help to move the hovered value to the right place
        const getTransform = function() {
          return highlightValue == "none" ? "translate(0,0)" :
            "translate("
              + (orient == HORIZONTAL ? axis.scale()(highlightValue) + hlValueShift * pivot : 0) + ","
              + (orient == VERTICAL ? axis.scale()(highlightValue) + hlValueShift * pivot : 0)
              + ")";
        };

        // this function will help to compute opacity for the axis labels that would overlap with the HL label
        const getOpacity = function(d, t, view) {
          if (highlightValue == "none") return 1;

          const wh = orient == HORIZONTAL ? "width" : "height";
          const shift = ((axis.repositionLabels() || {})[d] || { x: 0, y: 0 })[dimension];

          // opacity depends on the collision between label's boundary boxes
          return axis.hlOpacityScale()(
            // this computes the distance between the box centers, this is a 1-d problem because all labels are along the axis
            // shifts of labels that stick out from the viewport are also taken into account
            Math.abs(axis.scale()(d) + shift * pivot - axis.scale()(highlightValue) -  hlValueShift * pivot)
            // this computes the sides of boundary boxes, each has a half-size to reduce the distance between centers
            - view.getBBox()[wh] / 2 - bbox[wh] / 2
          );
        };

        // apply translation of the HL value and opacity of tick labels
        if (highlightTransDuration) {
          g.select(".vzb-axis-value")
            .transition()
            .duration(highlightTransDuration)
            .ease(d3.easeLinear)
            .attr("transform", getTransform);

          g.select(".vzb-axis-value")
            .selectAll("text")
            .interrupt("text" + (highlightValue == "none" ? "on" : "off"))
            .transition("text" + (highlightValue == "none" ? "off" : "on"))
            .delay(highlightTransDuration)
            .text(highlightValue == "none" ? "" : options.formatter(highlightValue));

          g.selectAll(".tick:not(.vzb-hidden)").each(function(d, t) {
            d3.select(this).select("text")
              .transition()
              .duration(highlightTransDuration)
              .ease(d3.easeLinear)
              .style("opacity", getOpacity(d, t, this));
          });

        } else {
          g.select(".vzb-axis-value")
            .interrupt()
            .attr("transform", getTransform);

          g.select(".vzb-axis-value")
            .selectAll("text")
            .interrupt("texton").interrupt("textoff")
            .text(highlightValue == "none" ? "" : options.formatter(highlightValue));

          g.selectAll(".tick:not(.vzb-hidden)").each(function(d, t) {
            d3.select(this).select("text")
              .interrupt()
              .style("opacity", getOpacity(d, t, this));
          });

        }

        highlightValue = null;
      };


      let hlOpacityScale = d3.scaleLinear().domain([0, 5]).range([0, 1]).clamp(true);
      axis.hlOpacityScale = function(arg) {
        if (!arguments.length) return hlOpacityScale;
        hlOpacityScale = arg;
        return axis;
      };

      let highlightValue = null;
      axis.highlightValue = function(arg) {
        if (!arguments.length) return highlightValue;
        highlightValue = arg;
        return axis;
      };

      let highlightTransDuration = 0;
      axis.highlightTransDuration = function(arg) {
        if (!arguments.length) return highlightTransDuration;
        highlightTransDuration = arg;
        return axis;
      };

      let repositionLabels = null;
      axis.repositionLabels = function(arg) {
        if (!arguments.length) return repositionLabels;
        repositionLabels = arg;
        return axis;
      };

      let pivot = false;
      axis.pivot = function(arg) {
        if (!arguments.length) return pivot;
        pivot = !!arg;
        return axis;
      };

      let tickValuesMinor = [];
      axis.tickValuesMinor = function(arg) {
        if (!arguments.length) return tickValuesMinor;
        tickValuesMinor = arg;
        return axis;
      };

      let tickSizeMinor = {
        outbound: 0,
        inbound: 0
      };
      axis.tickSizeMinor = function(arg1, arg2) {
        if (!arguments.length) return tickSizeMinor;
        tickSizeMinor = {
          outbound: arg1,
          inbound: arg2 || 0
        };
        meow("setting", tickSizeMinor);
        return axis;
      };

      let options = {};
      axis.labelerOptions = function(arg) {
        if (!arguments.length) return options;
        options = arg;
        return axis;
      };

      axis.METHOD_REPEATING = "repeating specified powers";
      axis.METHOD_DOUBLING = "doubling the value";

      axis.labelFactory = function(options) {
        if (options == null) options = {};

        //catch explicit tick settings (only used for the swimming lane scale for now)
        if (options.ticks) 
          return axis
            .tickValues(options.ticks)
            .tickValuesMinor(options.ticksMinor || [])
            .pivot(options.pivot || false)
            .tickFormat(options.formatter)
            .repositionLabels(options.repositionLabels);

        //catch unknown scale type
        if (options.scaleType != "linear" &&
          options.scaleType != "time" &&
          options.scaleType != "genericLog" &&
          options.scaleType != "log" &&
          options.scaleType != "ordinal") {
          return axis.ticks(options.limitMaxTickNumber)
            .tickFormat(null)
            .tickValues(null)
            .tickValuesMinor(null)
            .pivot(null)
            .repositionLabels(null);
        }
        if (options.scaleType == "ordinal") return axis;

        if (options.logBase == null) options.logBase = DEFAULT_LOGBASE;
        if (options.stops == null) options.stops = [1, 2, 5, 3, 7, 4, 6, 8, 9];


        if (options.removeAllLabels == null) options.removeAllLabels = false;

        if (options.formatter == null) options.formatter = axis.tickFormat() ?
          axis.tickFormat() : function(d) { return d + ""; };
        options.cssLabelMarginLimit = 5; //px

        if (options.cssMargin == null) options.cssMargin = {};
        if (options.cssMargin.left == null || parseInt(options.cssMargin.left) < options.cssLabelMarginLimit)
          options.cssMargin.left = options.cssLabelMarginLimit + "px";
        if (options.cssMargin.right == null || parseInt(options.cssMargin.right) < options.cssLabelMarginLimit)
          options.cssMargin.right = options.cssLabelMarginLimit + "px";
        if (options.cssMargin.top == null || parseInt(options.cssMargin.top) < options.cssLabelMarginLimit)
          options.cssMargin.top = options.cssLabelMarginLimit + "px";
        if (options.cssMargin.bottom == null || parseInt(options.cssMargin.bottom) < options.cssLabelMarginLimit)
          options.cssMargin.bottom = options.cssLabelMarginLimit + "px";
        if (options.toolMargin == null) options.toolMargin = {
          left: 30,
          bottom: 30,
          right: 30,
          top: 30
        };
        if (options.bump == null) options.bump = 0;
        if (options.viewportLength == null) options.viewportLength = 0;

        if (options.pivotingLimit == null) options.pivotingLimit = options.toolMargin[this.orient()];

        if (options.showOuter == null) options.showOuter = false;
        if (options.limitMaxTickNumber == null) options.limitMaxTickNumber = 0; //0 is unlimited

        const orient = this.orient() == "top" || this.orient() == "bottom" ? HORIZONTAL : VERTICAL;

        if (options.isPivotAuto == null) options.isPivotAuto = orient == VERTICAL;

        if (options.cssFontSize == null) options.cssFontSize = "13px";
        if (options.widthToFontsizeRatio == null) options.widthToFontsizeRatio = 0.75;
        if (options.heightToFontsizeRatio == null) options.heightToFontsizeRatio = 1.20;
        if (options.widthOfOneDigit == null) options.widthOfOneDigit =
          parseInt(options.cssFontSize) * options.widthToFontsizeRatio;
        if (options.heightOfOneDigit == null) options.heightOfOneDigit =
          parseInt(options.cssFontSize) * options.heightToFontsizeRatio;
        if (options.fitIntoScale == null || options.fitIntoScale == "pessimistic") options.fitIntoScale = PESSIMISTIC;
        if (options.fitIntoScale == "optimistic") options.fitIntoScale = OPTIMISTIC;


        meow("********** " + orient + " **********");

        const domain = axis.scale().domain();
        const range = axis.scale().range();
        const lengthRange = Math.abs(range[range.length - 1] - range[0]);

        const min = d3.min([domain[0], domain[domain.length - 1]]);
        const max = d3.max([domain[0], domain[domain.length - 1]]);
        const bothSidesUsed = ((options.scaleType == "linear" ? min < 0 : min <= 0) && max >= 0) && options.scaleType != "time";

        let tickValues = options.showOuter ? [min, max] : [];
        let tickValuesMinor = []; //[min, max];
        let ticksNumber = 5;

        function getBaseLog(x, base) {
          if (x == 0 || base == 0) {
            return 0;
          }
          if (base == null) base = options.logBase;
          return Math.log(x) / Math.log(base);
        }

        // estimate the longest formatted label in pixels
        const estLongestLabelLength =
          //take 17 sample values and measure the longest formatted label
          d3.max(d3.range(min, max, (max - min) / 17).concat(max).map(d => options.formatter(d).replace(".", "").length)) * options.widthOfOneDigit + parseInt(options.cssMargin.left);

        const pivot = options.isPivotAuto && (
          (estLongestLabelLength > options.pivotingLimit) && (orient == VERTICAL)
          ||
          !(estLongestLabelLength > options.pivotingLimit) && !(orient == VERTICAL)
        );

        const labelsStackOnTop = (orient == HORIZONTAL && pivot || orient == VERTICAL && !pivot);


        // conditions to remove labels altogether
        const labelsJustDontFit = (!labelsStackOnTop && options.heightOfOneDigit > options.pivotingLimit);
        if (options.removeAllLabels) return axis.tickValues([]);

        // return a single tick if have only one point in the domain
        if (min == max) return axis.tickValues([min]).ticks(1).tickFormat(options.formatter);


        // LABELS FIT INTO SCALE
        // measure if all labels in array tickValues can fit into the allotted lengthRange
        // approximationStyle can be OPTIMISTIC or PESSIMISTIC
        // in optimistic style the length of every label is added up and then we check if the total pack of symbols fit
        // in pessimistic style we assume all labels have the length of the longest label from tickValues
        // returns TRUE if labels fit and FALSE otherwise
        const labelsFitIntoScale = function(tickValues, lengthRange, approximationStyle, rescalingLabels) {
          if (tickValues == null || tickValues.length <= 1) return true;
          if (approximationStyle == null) approximationStyle = PESSIMISTIC;

          if (labelsStackOnTop) {
            //labels stack on top of each other. digit height matters
            return lengthRange >
              tickValues.length * (
                options.heightOfOneDigit +
              parseInt(options.cssMargin.top) +
              parseInt(options.cssMargin.bottom)
              );
          }

          //labels stack side by side. label width matters
          const marginsLR = parseInt(options.cssMargin.left) + parseInt(options.cssMargin.right);
          const maxLength = d3.max(tickValues.map(d => options.formatter(d).length));

          // log scales need to rescale labels, so that 9 takes more space than 2
          if (rescalingLabels == "log") {
            // sometimes only a fragment of axis is used. in this case we want to limit the scope to that fragment
            // yes, this is hacky and experimental
            lengthRange = Math.abs(axis.scale()(d3.max(tickValues)) - axis.scale()(d3.min(tickValues)));

            return lengthRange >
              d3.sum(tickValues.map(d => (
                options.widthOfOneDigit * (approximationStyle == PESSIMISTIC ? maxLength : options.formatter(
                  d).length) + marginsLR
              )
              // this is a logarithmic rescaling of labels
              * (1 + Math.log(d.toString().replace(/([0.])/g, "")[0]) / Math.LN10)));

          }

          return lengthRange >
            tickValues.length * marginsLR + (approximationStyle == PESSIMISTIC ?
              options.widthOfOneDigit * tickValues.length * maxLength : 0) + (approximationStyle == OPTIMISTIC ?
              options.widthOfOneDigit * (
                tickValues.map(d => options.formatter(d)).join("").length
              ) : 0);
        };


        // COLLISION BETWEEN
        // Check is there is a collision between labels ONE and TWO
        // ONE is a value, TWO can be a value or an array
        // returns TRUE if collision takes place and FALSE otherwise
        const collisionBetween = function(one, two) {
          if (two == null || two.length == 0) return false;
          if (!(two instanceof Array)) two = [two];

          for (let i = 0; i < two.length; i++) {
            if (
              one != two[i] && one != 0 &&
              Math.abs(axis.scale()(one) - axis.scale()(two[i])) <
              (labelsStackOnTop ?
                (options.heightOfOneDigit) :
                (options.formatter(one).length + options.formatter(two[i]).length) * options.widthOfOneDigit / 2
              )
            ) return true;

          }
          return false;
        };

        if (options.scaleType == "genericLog" || options.scaleType == "log") {
          const eps = axis.scale().constant ? axis.scale().constant() : 0;

          const spawnZero = bothSidesUsed ? [0] : [];

          // check if spawn positive is needed. if yes then spawn!
          const spawnPos = max < eps ? [] : (
            d3.range(
              Math.floor(getBaseLog(Math.max(eps, min))),
              Math.ceil(getBaseLog(max)),
              1)
              .concat(Math.ceil(getBaseLog(max)))
              .map(d => Math.pow(options.logBase, d))
          );

          // check if spawn negative is needed. if yes then spawn!
          const spawnNeg = min > -eps ? [] : (
            d3.range(
              Math.floor(getBaseLog(Math.max(eps, -max))),
              Math.ceil(getBaseLog(-min)),
              1)
              .concat(Math.ceil(getBaseLog(-min)))
              .map(d => -Math.pow(options.logBase, d))
          );


          // automatic chosing of method if it's not explicitly defined
          if (options.method == null) {
            const coverage = bothSidesUsed ?
              Math.max(Math.abs(max), Math.abs(min)) / eps :
              Math.max(Math.abs(max), Math.abs(min)) / Math.min(Math.abs(max), Math.abs(min));
            options.method = 10 <= coverage && coverage <= 1024 ? this.METHOD_DOUBLING : this.METHOD_REPEATING;
          }


          //meow('spawn pos/neg: ', spawnPos, spawnNeg);


          if (options.method == this.METHOD_DOUBLING) {
            let doublingLabels = [];
            if (bothSidesUsed) tickValues.push(0);
            const avoidCollidingWith = [].concat(tickValues);

            // start with the smallest abs number on the scale, rounded to nearest nice power
            //var startPos = max<eps? null : Math.pow(options.logBase, Math.floor(getBaseLog(Math.max(eps,min))));
            //var startNeg = min>-eps? null : -Math.pow(options.logBase, Math.floor(getBaseLog(Math.max(eps,-max))));

            const startPos = max < eps ? null : 4 * spawnPos[Math.floor(spawnPos.length / 2) - 1];
            const startNeg = min > -eps ? null : 4 * spawnNeg[Math.floor(spawnNeg.length / 2) - 1];

            //meow('starter pos/neg: ', startPos, startNeg);

            if (startPos) {
              for (let l = startPos; l <= max; l *= 2) doublingLabels.push(l);
            }
            if (startPos) {
              for (let l = startPos / 2; l >= Math.max(min, eps); l /= 2) doublingLabels.push(l);
            }
            if (startNeg) {
              for (let l = startNeg; l >= min; l *= 2) doublingLabels.push(l);
            }
            if (startNeg) {
              for (let l = startNeg / 2; l <= Math.min(max, -eps); l /= 2) doublingLabels.push(l);
            }

            doublingLabels = doublingLabels
              .sort(d3.ascending)
              .filter(d => min <= d && d <= max);

            tickValuesMinor = tickValuesMinor.concat(doublingLabels);

            doublingLabels = groupByPriorities(doublingLabels, false); // don't skip taken values

            const tickValues_1 = tickValues;
            for (let j = 0; j < doublingLabels.length; j++) {

              // compose an attempt to add more axis labels
              const trytofit = tickValues_1.concat(doublingLabels[j])
                .filter(d => !collisionBetween(d, avoidCollidingWith))
                .filter(onlyUnique);

              // stop populating if labels don't fit
              if (!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "none")) break;

              // apply changes if no blocking instructions
              tickValues = trytofit;
            }
          }


          if (options.method == this.METHOD_REPEATING) {

            let spawn = spawnZero.concat(spawnPos).concat(spawnNeg).sort(d3.ascending);

            options.stops.forEach((stop) => {
              tickValuesMinor = tickValuesMinor.concat(spawn.map(d => d * stop));
            });

            spawn = groupByPriorities(spawn);
            const avoidCollidingWith = spawnZero.concat(tickValues);

            let stopTrying = false;

            options.stops.forEach((stop, i) => {
              if (i == 0) {
                for (let j = 0; j < spawn.length; j++) {

                  // compose an attempt to add more axis labels
                  const trytofit = tickValues
                    .concat(spawn[j].map(d => d * stop))
                    // throw away labels that collide with "special" labels 0, min, max
                    .filter(d => !collisionBetween(d, avoidCollidingWith))
                    .filter(d => min <= d && d <= max)
                    .filter(onlyUnique);

                  // stop populating if labels don't fit
                  if (!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "none")) break;

                  // apply changes if no blocking instructions
                  tickValues = trytofit;
                }

                // flatten the spawn array
                spawn = [].concat(...spawn);
              } else {
                if (stopTrying) return;

                // compose an attempt to add more axis labels
                const trytofit = tickValues
                  .concat(spawn.map(d => d * stop))
                  .filter(d => min <= d && d <= max)
                  .filter(onlyUnique);

                // stop populating if the new composition doesn't fit
                if (!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "log")) {
                  stopTrying = true;
                  return;
                }
                // stop populating if the number of labels is limited in options
                if (tickValues.length > options.limitMaxTickNumber && options.limitMaxTickNumber != 0) {
                  stopTrying = true;
                  return;
                }

                // apply changes if no blocking instructions
                tickValues = trytofit;
              }
            });


          } //method


        } //logarithmic


        if (options.scaleType == "linear" || options.scaleType == "time") {
          if (bothSidesUsed) tickValues.push(0);
          const avoidCollidingWith = [].concat(tickValues);

          if (labelsStackOnTop) {
            ticksNumber = Math.max(Math.floor(lengthRange / (options.heightOfOneDigit + parseInt(options.cssMargin.top))), 2);
          } else {
            ticksNumber = Math.max(Math.floor(lengthRange / estLongestLabelLength), 2);
          }

          // limit maximum ticks number
          if (options.limitMaxTickNumber != 0 && ticksNumber > options.limitMaxTickNumber) ticksNumber = options.limitMaxTickNumber;

          let addLabels = axis.scale().ticks(ticksNumber)
            .sort(d3.ascending)
            .filter(d => min <= d && d <= max);

          tickValuesMinor = tickValuesMinor.concat(addLabels);

          addLabels = groupByPriorities(addLabels, false);

          const tickValues_1 = tickValues;
          for (let j = 0; j < addLabels.length; j++) {

            // compose an attempt to add more axis labels
            const trytofit = tickValues_1.concat(addLabels[j])
              .filter(d => !collisionBetween(d, avoidCollidingWith))
              .filter(onlyUnique);

            // stop populating if labels don't fit
            if (!labelsFitIntoScale(trytofit, lengthRange, options.fitIntoScale, "none")) break;

            // apply changes if no blocking instructions
            tickValues = trytofit;
          }

          tickValues = tickValues //.concat(addLabels)
            .filter(d => !collisionBetween(d, avoidCollidingWith))
            .filter(onlyUnique);


        }


        if (tickValues != null && tickValues.length < 2 && !bothSidesUsed) {
          //remove min tick if min, max ticks have collision between them
          tickValues = Math.abs(axis.scale()(min) - axis.scale()(max)) < (labelsStackOnTop ?
            (options.heightOfOneDigit) :
            (options.formatter(min).length + options.formatter(max).length) * options.widthOfOneDigit) ? [max] : [min, max];
          if (tickValues.length == 1 && (options.scaleType == "linear" || options.scaleType == "time")) {
            tickValuesMinor = [];
          }
        }

        if (tickValues != null && tickValues.length <= 3 && bothSidesUsed) {
          if (!collisionBetween(0, [min, max])) {
            tickValues = [min, 0, max];
          } else {
            tickValues = [min, max];
          }
        }

        if (tickValues != null) tickValues.sort((a, b) => (orient == HORIZONTAL ? -1 : 1) * (axis.scale()(b) - axis.scale()(a)));

        if (labelsJustDontFit) tickValues = [];
        tickValuesMinor = tickValuesMinor.filter(d => tickValues.indexOf(d) == -1 && min <= d && d <= max);


        meow("final result", tickValues);

        return axis
          .ticks(ticksNumber)
          .tickFormat(options.formatter)
          .tickValues(tickValues)
          .tickValuesMinor(tickValuesMinor)
          .pivot(pivot)
          .repositionLabels(
            repositionLabelsThatStickOut(tickValues, options, orient, axis.scale(), labelsStackOnTop ? "y" : "x")
          );
      };


      // GROUP ELEMENTS OF AN ARRAY, SO THAT...
      // less-prio elements are between the high-prio elements
      // Purpose: enable adding axis labels incrementally, like this for 9 labels:
      // PRIO 1: +--------, concat result: +-------- first we show only 1 label
      // PRIO 2: ----+---+, concat result: +---+---+ then we add 2 more, that are maximally spaced
      // PRIO 3: --+---+--, concat result: +-+-+-+-+ then we fill spaces with 2 more labels
      // PRIO 4: -+-+-+-+-, concat result: +++++++++ then we fill the remaing spaces and show all labels
      // exception: zero jumps to the front, if it's on the list
      // example1: [1 2 3 4 5 6 7] --> [[1][4 7][2 3 5 6]]
      // example2: [1 2 3 4 5 6 7 8 9] --> [[1][5 9][3 7][2 4 6 8]]
      // example3: [-4 -3 -2 -1 0 1 2 3 4 5 6 7] --> [[0][-4][2][-1 5][-3 -2 1 3 4 6 7]]
      // inputs:
      // array - the source array to be processed. Only makes sense if sorted
      // removeDuplicates - return incremental groups (true, default), or return concatinated result (false)
      // returns:
      // the nested array
      function groupByPriorities(array, removeDuplicates) {
        if (removeDuplicates == null) removeDuplicates = true;

        const result = [];
        const taken = [];

        //zero is an exception, if it's present we manually take it to the front
        if (array.indexOf(0) != -1) {
          result.push([0]);
          taken.push(array.indexOf(0));
        }

        for (let k = array.length; k >= 1; k = k < 4 ? k - 1 : k / 2) {
          // push the next group of elements to the result
          result.push(array.filter((d, i) => {
            if (i % Math.floor(k) == 0 && (taken.indexOf(i) == -1 || !removeDuplicates)) {
              taken.push(i);
              return true;
            }
            return false;
          }));
        }

        return result;
      }


      // REPOSITION LABELS THAT STICK OUT
      // Purpose: the outer labels can easily be so large, they stick out of the allotted area
      // Example:
      // Label is fine:    Label sticks out:    Label sticks out more:    Solution - label is shifted:
      //      12345 |           1234|                123|5                   12345|
      // _______.   |      _______. |           _______.|                 _______.|
      //
      // this is what the function does on the first step (only outer labels)
      // on the second step it shifts the inner labels that start to overlap with the shifted outer labels
      //
      // requires tickValues array to be sorted from tail-first
      // tail means left or bottom, head means top or right
      //
      // dimension - which dimension requires shifting
      // X if labels stack side by side, Y if labels stack on top of one another
      //
      // returns the array of recommended {x,y} shifts

      function repositionLabelsThatStickOut(tickValues, options, orient, scale, dimension) {
        if (!tickValues) return null;
        const result = {};

        // make an abstraction layer for margin sizes
        // tail means left or bottom, head means top or right
        const margin =
          orient == VERTICAL ? {
            head: options.toolMargin.top,
            tail: options.toolMargin.bottom
          } : {
            head: options.toolMargin.right,
            tail: options.toolMargin.left
          };

        let range = scale.range();
        let bump = options.bump;

        //when a viewportLength is given: adjust outer VISIBLE tick values
        //this is helpful when the scaled is zoomed, so labels don't get truncated by a viewport svg
        if (options.viewportLength) {
          //remove invisible ticks from the array
          tickValues = tickValues.filter(d => scale(d) >= 0 && scale(d) <= options.viewportLength);
          //overwrite the available range with viewport limits. direction doesn't matter because we take min-max later anyway
          range = [0, options.viewportLength];
          //reset the bump because zoomed axis has no bump
          bump = 0;
        }

        // STEP 1:
        // for outer labels: avoid sticking out from the tool margin
        tickValues.forEach((d, i) => {
          if (i != 0 && i != tickValues.length - 1) return;

          // compute the influence of the axis head
          let repositionHead = Math.min(margin.head, options.widthOfOneDigit * 0.5) + bump
            + (orient == HORIZONTAL ? 1 : 0) * d3.max(range)
            - (orient == HORIZONTAL ? 0 : 1) * d3.min(range)
            + (orient == HORIZONTAL ? -1 : 1) * scale(d)
            - (dimension == "x") * options.formatter(d).length * options.widthOfOneDigit / 2
            - (dimension == "y") * options.heightOfOneDigit / 2
            // we may consider or not the label margins to give them a bit of spacing from the edges
            - (dimension == "x") * parseInt(options.cssMargin.right)
            - (dimension == "y") * parseInt(options.cssMargin.top);

          // compute the influence of the axis tail
          let repositionTail = Math.min(margin.tail, options.widthOfOneDigit * 0.5) + bump
            + (orient == VERTICAL ? 1 : 0) * d3.max(range)
            - (orient == VERTICAL ? 0 : 1) * d3.min(range)
            + (orient == VERTICAL ? -1 : 1) * scale(d)
            - (dimension == "x") * options.formatter(d).length * options.widthOfOneDigit / 2
            - (dimension == "y") * options.heightOfOneDigit / 2
            // we may consider or not the label margins to give them a bit of spacing from the edges
            - (dimension == "x") * parseInt(options.cssMargin.left)
            - (dimension == "y") * parseInt(options.cssMargin.bottom);

          // apply limits in order to cancel repositioning of labels that are good
          if (repositionHead > 0) repositionHead = 0;
          if (repositionTail > 0) repositionTail = 0;

          // add them up with appropriate signs, save to the axis
          result[d] = { x: 0, y: 0 };
          result[d][dimension] = (dimension == "y" && orient == VERTICAL ? -1 : 1) * (repositionHead - repositionTail);
        });


        // STEP 2:
        // for inner labels: avoid collision with outer labels
        tickValues.forEach((d, i) => {
          if (i == 0 || i == tickValues.length - 1) return;

          // compute the influence of the head-side outer label
          let repositionHead =
            // take the distance between head and the tick at hand
            Math.abs(scale(d) - scale(tickValues[tickValues.length - 1]))

            // substract the shift of the head TODO: THE SIGN CHOICE HERE MIGHT BE WRONG. NEED TO TEST ALL CASES
            - (dimension == "y") * (orient == HORIZONTAL ? -1 : 1) * result[tickValues[tickValues.length - 1]][dimension]
            - (dimension == "x") * (orient == HORIZONTAL ? 1 : -1) * result[tickValues[tickValues.length - 1]][dimension]

            // substract half-length of the overlapping labels
            - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(d).length
            - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(tickValues[tickValues.length - 1]).length
            - (dimension == "y") * options.heightOfOneDigit * 0.7 //TODO remove magic constant - relation of actual font height to BBox-measured height

            // we may consider or not the label margins to give them a bit of spacing from the edges
            - (dimension == "x") * parseInt(options.cssMargin.left)
            - (dimension == "y") * parseInt(options.cssMargin.bottom);

          // compute the influence of the tail-side outer label
          let repositionTail =
            // take the distance between tail and the tick at hand
            Math.abs(scale(d) - scale(tickValues[0]))

            // substract the shift of the tail TODO: THE SIGN CHOICE HERE MIGHT BE WRONG. NEED TO TEST ALL CASES
            - (dimension == "y") * (orient == VERTICAL ? -1 : 1) * result[tickValues[0]][dimension]
            - (dimension == "x") * (orient == VERTICAL ? 1 : -1) * result[tickValues[0]][dimension]

            // substract half-length of the overlapping labels
            - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(d).length
            - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(tickValues[0]).length
            - (dimension == "y") * options.heightOfOneDigit * 0.7 //TODO remove magic constant - relation of actual font height to BBox-measured height

            // we may consider or not the label margins to give them a bit of spacing from the edges
            - (dimension == "x") * parseInt(options.cssMargin.left)
            - (dimension == "y") * parseInt(options.cssMargin.bottom);

          // apply limits in order to cancel repositioning of labels that are good
          if (repositionHead > 0) repositionHead = 0;
          if (repositionTail > 0) repositionTail = 0;

          // add them up with appropriate signs, save to the axis
          result[d] = { x: 0, y: 0 };
          result[d][dimension] = (dimension == "y" && orient == VERTICAL ? -1 : 1) * (repositionHead - repositionTail);
        });


        return result;
      } // function repositionLabelsThatStickOut()


      axis.copy = function() {
        return d3_axis_smart(d3["axis" + capitalize(_orient)]());
      };

      axis.orient = function() {
        if (!arguments.length) return _orient;
        return axis;
      };

      return rebind(axis, _super,
        "scale", "ticks", "tickArguments", "tickValues", "tickFormat",
        "tickSize", "tickSizeInner", "tickSizeOuter", "tickPadding"
      );


      function meow() {
        if (!axis.labelerOptions().isDevMode) return;
        console.info(...arguments);
      }

    })(d3["axis" + capitalize(_orient)]());

  }

  //d3.svg.collisionResolver

  function collisionResolver$1() {
    return (function collision_resolver() {
      const DURATION = 300;
      let labelHeight = 0;
      // MAINN FUNCTION. RUN COLLISION RESOLVER ON A GROUP g
      function resolver(g) {
        if (selector == null) {
          console.warn("D3 collision resolver stopped: missing a CSS slector");
          return;
        }
        if (height == null) {
          console.warn("D3 collision resolver stopped: missing height of the canvas");
          return;
        }
        if (value == null) {
          console.warn(
            "D3 collision resolver stopped: missing pointer within data objects. Example: value = 'valueY' ");
          return;
        }
        if (KEY == null) {
          console.warn("D3 collision resolver stopped: missing a key for data. Example: key = 'geo' ");
          return;
        }
        if (!g.node()) {
          console.warn("D3 collision resolver stopped: missing the target DOM element", g);
          return;
        }
        labelHeight = g.node().getBBox().height * 0.8;
        //actually reposition the labels
        const data = g.filter(d => filter(d, time))
          .sort((x, y) => d3.ascending(x.valueY, y.valueY))
          .data();
        const keys = {};
        for (let i = 0; i < data.length - 1; i++) {
          const first = data[i];
          const second = data[i + 1];
          if (!first.shiftY) first.shiftY = 0;
          second.shiftY = 0;
          if ((second.valueY - first.valueY - first.shiftY) >= labelHeight) continue;
          let upperAvailable = 0;
          // calculate available space above first element
          if (first.valueY > labelHeight) {
            if (i == 0) {
              upperAvailable = Math.min(labelHeight, first.valueY);
            } else if (first.valueY - data[i - 1].valueY + data[i - 1].shiftY > labelHeight) {
              upperAvailable = Math.min(labelHeight, first.valueY - data[i - 1].valueY + data[i - 1].shiftY);
            }
          }
          first.upperAvailable = upperAvailable;
          let underAvailable = 0;
          // calculate available space under second element
          if (second.valueY < height) {
            if (i == data.length - 2) {
              underAvailable = Math.min(labelHeight, height - second.valueY);
            } else if (data[i + 2].valueY - second.valueY > labelHeight) {
              underAvailable = Math.min(labelHeight, data[i + 2].valueY - second.valueY);
            }
          }
          second.underAvailable = underAvailable;
          const neededSpace = labelHeight - (second.valueY - first.valueY - first.shiftY);
          keys[first[KEY]] = {};
          keys[second[KEY]] = {};
          if (upperAvailable >= neededSpace / 2 && underAvailable >= neededSpace / 2) {
            first.shiftY = -neededSpace / 2;
            second.shiftY = neededSpace / 2;
          } else if (upperAvailable >= neededSpace / 2) {
            second.shiftY = underAvailable;
            first.shiftY = -Math.min(upperAvailable, neededSpace - underAvailable);
          } else if (underAvailable >= neededSpace / 2) {
            first.shiftY -= upperAvailable;
            second.shiftY = Math.min(underAvailable, neededSpace - upperAvailable);
          } else {
            first.shiftY = -upperAvailable;
            second.shiftY = underAvailable;
          }
          keys[first[KEY]].valueY = first.valueY + first.shiftY;
          keys[second[KEY]].valueY = second.valueY + second.shiftY;
        }
        g.each(function(d) {
          if (keys[d[KEY]] && keys[d[KEY]].valueY) {
            d3.select(this).selectAll(selector).transition().duration(DURATION).attr("transform", "translate(0," +
              keys[d[KEY]].valueY + ")");
          }
        });
      }

      // GETTERS AND SETTERS

      let selector = null;
      resolver.selector = function(arg) {
        if (!arguments.length)
          return selector;
        selector = arg;
        return resolver;
      };
      let height = null;
      resolver.height = function(arg) {
        if (!arguments.length)
          return height;
        height = arg;
        return resolver;
      };
      let scale = d3.scaleLinear()
        .domain([0, 1])
        .range([0, 1]);
      resolver.scale = function(arg) {
        if (!arguments.length)
          return scale;
        scale = arg;
        return resolver;
      };
      let value = null;
      resolver.value = function(arg) {
        if (!arguments.length)
          return value;
        value = arg;
        return resolver;
      };
      let time = null;
      resolver.time = function(arg) {
        if (!arguments.length)
          return time;
        time = arg;
        return resolver;
      };
      let filter = function() { return true; };
      resolver.filter = function(arg) {
        if (!arguments.length)
          return filter;
        filter = arg;
        return resolver;
      };
      let fixed = null;
      resolver.fixed = function(arg) {
        if (!arguments.length)
          return fixed;
        fixed = arg;
        return resolver;
      };
      let handleResult = null;
      resolver.handleResult = function(arg) {
        if (!arguments.length)
          return handleResult;
        handleResult = arg;
        return resolver;
      };
      let KEY = null;
      resolver.KEY = function(arg) {
        if (!arguments.length)
          return KEY;
        KEY = arg;
        return resolver;
      };
      return resolver;
    })();
  }

  class TextEllipsis$1 {
    constructor(context) {
      this.context = context;
      this.interact = this._createInteract();
    }

    setTooltip(tooltip) {
      this.tooltip = tooltip;
    }

    _createInteract() {
      const _this = this;
      return {
        mouseOver(event) {
          const mouse = d3.pointer(event, _this.context.element.node());
          _this._setTooltip(d3.select(event.target).attr("data-text"), mouse[0], mouse[1]);
        },
        mouseOut() {
          _this._setTooltip();
        },
        tap() {

        }
      };
    }

    _setTooltip(tooltipText, x, y) {
      if (tooltipText) {

        //position tooltip
        this.tooltip.classed("vzb-hidden", false)
        //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
          .selectAll("text")
          .text(tooltipText);

        const contentBBox = this.tooltip.select("text").node().getBBox();
        if (x - contentBBox.width < 0) {
          x += contentBBox.width + 5; // corrective to the block Radius and text padding
        } else {
          x -= 5; // corrective to the block Radius and text padding
        }
        if (y - contentBBox.height < 0) {
          y += contentBBox.height;
        } else {
          y -= 11; // corrective to the block Radius and text padding
        }

        this.tooltip.attr("transform", "translate(" + x + "," + y + ")");

        this.tooltip.selectAll("rect")
          .attr("width", contentBBox.width + 8)
          .attr("height", contentBBox.height * 1.2)
          .attr("x", -contentBBox.width - 4)
          .attr("y", -contentBBox.height * 0.85)
          .attr("rx", contentBBox.height * 0.2)
          .attr("ry", contentBBox.height * 0.2);

      } else {
        this.tooltip.classed("vzb-hidden", true);
      }
    }

    clear(selection) {
      selection.attr("data-text", null);
    }

    wrap(_this, width) {
      const textEl = d3.select(_this);

      const abs = Math.abs;
      let initialText = textEl.attr("data-text");
      if (!initialText) {
        initialText = textEl.text();
        textEl.attr("data-text", initialText);
      }
      textEl.text(initialText);
      let text = initialText;
      let textLength = text.length;
      let textWidth = textEl.node().getComputedTextLength();

      while (width - textWidth <= 0 && text !== "") {
        text = (textWidth >= width) ? text.slice(0, -abs(textLength * 0.5)) : initialText.slice(0, abs(textLength * 0.5));
        textEl.text(text + "…");
        textWidth = textEl.node().getComputedTextLength();
        textLength = text.length;
      }

      if (text !== initialText) {
        if (text === "") {
          textEl.text(initialText[0]);
        }
        textEl
          .on("mouseover.tooltip", this.interact.mouseOver)
          .on("mouseout.tooltip", this.interact.mouseOut)
          .style("pointer-events", "all");
      } else {
        textEl
          .on("mouseover.tooltip", null)
          .on("mouseout.tooltip", null)
          .style("pointer-events", null);
      }
    }

  }

  function detectTouchEvent(element, onTap, onLongTap) {
    var start;
    var coordX;
    var coordY;
    var namespace = onTap ? ".onTap" : ".onLongTap";
    d3.select(element)
      .on("touchstart" + namespace, function(event) {
        start = event.timeStamp;
        coordX = event.changedTouches[0].screenX;
        coordY = event.changedTouches[0].screenY;
      })
      .on("touchend" + namespace, function(event, d) {
        coordX = Math.abs(coordX - event.changedTouches[0].screenX);
        coordY = Math.abs(coordY - event.changedTouches[0].screenY);
        if (coordX < 5 && coordY < 5) {
          if (event.timeStamp - start < 500)
            return onTap ? onTap(event, d) : undefined;
          return onLongTap ? onLongTap(event, d) : undefined;
        } else return undefined;
      });
  }

  //d3.selection.prototype.onTap
  var onTap = function(callback) {
    return this.each(function() {
      detectTouchEvent(this, callback);
    });
  };

  //d3.selection.prototype.onLongTap
  var onLongTap = function(callback) {
    return this.each(function() {
      detectTouchEvent(this, null, callback);
    });
  };

  d3.selection.prototype.onTap = onTap;
  d3.selection.prototype.onLongTap = onLongTap;

  const versionInfo = {version: "1.40.0", build: 1715955706435, package: {"contributors":[{"name":"Jasper","url":"https://github.com/jheeffer"},{"name":"Angie","url":"https://github.com/angieskazka"},{"name":"Dima","url":"https://github.com/dab2000"},{"name":"Ola","url":"https://github.com/olarosling"}],"author":{"name":"Gapminder Foundation","url":"https://www.gapminder.org","email":"info@gapminder.org"},"homepage":"https://github.com/vizabi/@vizabi/shared-components#readme","name":"@vizabi/shared-components","description":"Vizabi shared components"}};
  const Icons = iconset;
  const Utils = _Utils;
  const LegacyUtils = _LegacyUtils;
  const axisSmart = axisSmart$1;
  const collisionResolver = collisionResolver$1;
  const TextEllipsis = TextEllipsis$1;

  class BaseService {

    isService() {return true;}

    constructor(config = {}){
      this.config = config;
      this.setup();
    }

    deconstruct() {}
    setup() {}
  }

  const FALLBACK_PATH = "./assets/locale/";
  const FALLBACK_ID = "en";
  const RTL_CSS_CLASS = "vzb-rtl";

  class _LocaleService extends BaseService {

    static DEFAULTS = {
      id: FALLBACK_ID,
      path: FALLBACK_PATH,
      placeholder: "body",
      shortNumberFormat: true
    }

    setup(){
      this.status = STATUS.INIT;
      this.path = this.config.path || this.constructor.DEFAULTS.path;
      this.resolve = this.config.resolve;
      this.placeholder = this.config.placeholder || this.constructor.DEFAULTS.placeholder;
      this.element = d3.select(this.placeholder);
      this.content = {};

      this.removeLoadFileAutorun = mobx.autorun(this._loadFile.bind(this), {name: "Locale.js: _loadFile()"});
      this.removeApplyRTL = mobx.autorun(this._applyRTL.bind(this), {name: "Locale.js: _applyRTL()"});
    }

    get id() {
      return this.config.id || this.constructor.DEFAULTS.id;
    }

    get shortNumberFormat() {
      return this.config.shortNumberFormat ?? this.constructor.DEFAULTS.shortNumberFormat;
    }

    set id(id) {
      mobx.runInAction(() => {
        this.config.id = id;
        this.config.Vizabi.stores.dataSources.getAll().forEach(e => e.config.locale = id);
      });
    }

    set shortNumberFormat(shortNumberFormat) {
      this.config.shortNumberFormat = shortNumberFormat;
    }

    deconstruct(){
      this.removeLoadFileAutorun();
      super.deconstruct();
    }

    _applyRTL() {
      if (this.status !== STATUS.READY) return;
      this.element.classed(RTL_CSS_CLASS, this.isRTL());
    }

    _resolveReader(id) {
      if (this.resolve?.[id] && isObject(this.resolve?.[id])) {
        return Promise.resolve(this.resolve?.[id]);
      }
      const path = this.resolve?.[id] ? this.resolve?.[id] : (this.path + id + ".json");
      return d3.json(path);
    }

    _loadFile(){
      this.status = STATUS.PENDING;

      const readers = [this._resolveReader(this.id)];
      if (this.id != FALLBACK_ID && !this.content[FALLBACK_ID]) {
        readers.push(this._resolveReader(FALLBACK_ID));
      }
      Promise.all(readers)
        .then((content) => {
          this.content[this.id] = content[0];
          if (content[1]) this.content[FALLBACK_ID] = content[1];
          this._initFormatters();
          this.status = STATUS.READY;
        })
        .catch((error) => {
          this.state = STATUS.ERROR;
          throw error;
        });
    }

    _initFormatters(){
      this.numberF = function (x,  options) {
          
        // share works like rounded if set to SHARE, but multiplies by 100 and suffixes with "%"
        // percent works like rounded if set to PERCENT, but suffixes with "%"
        const SHARE = "share";
        const PERCENT = "percent";
        const NOSUFFIX = "nosuffix";
        const EPSILON = 0.00000000000001;

        if (options === SHARE) x *= 100;
    
        if (Math.abs(x) < EPSILON) return "0";
    
        const format = "~r"; //rounded format. use "f" for fixed, ~ trims insignificant trailing zeros
        const prec = 3; //round to so many significant digits
    
        let suffix = "";
        if (options === NOSUFFIX) return d3.format("." + prec + format)(x);
    
        //---------------------
        // BEAUTIFIERS GO HOME!
        // don't break formatting please
        //---------------------
        // the tiny constant compensates epsilon-error when doing logarithms
        /* eslint-disable */
        switch (Math.floor(Math.log(Math.abs(x)) / Math.LN10 + EPSILON)) {
          case -13: x *= 1000000000000; suffix = "p"; break; //0.1p
          case -10: x *= 1000000000; suffix = "n"; break; //0.1n
          case -7: x *= 1000000; suffix = "µ"; break; //0.1µ
          case -6: x *= 1000000; suffix = "µ"; break; //1µ
          case -5: x *= 1000000; suffix = "µ"; break; //10µ
          case -4: break; //0.0001
          case -3: break; //0.001
          case -2: break; //0.01
          case -1: break; //0.1
          case 0:  break; //1
          case 1:  break; //10
          case 2:  break; //100
          case 3:  break; //1000
          case 4:  x /= 1000; suffix = "k"; break; //10k
          case 5:  x /= 1000; suffix = "k"; break; //100k
          case 6:  x /= 1000000; suffix = "M"; break; //1M
          case 7:  x /= 1000000; suffix = "M"; break; //10M
          case 8:  x /= 1000000; suffix = "M"; break; //100M
          case 9:  x /= 1000000000; suffix = "B"; break; //1B
          case 10: x /= 1000000000; suffix = "B"; break; //10B
          case 11: x /= 1000000000; suffix = "B"; break; //100B
          case 12: x /= 1000000000000; suffix = "TR"; break; //1TR
          case 13: x /= 1000000000000; suffix = "TR"; break; //10TR
          case 14: x /= 1000000000000; suffix = "TR"; break; //100TR
          //use the D3 SI formatting for the extreme cases
          default: return (d3.format("." + prec + "s")(x)).replace("G", "B");
        }
        /* eslint-enable */
    
        let formatted = d3.format("." + prec + format)(x);
    
        // use manual formatting for the cases above
        return (formatted + suffix + (options === PERCENT || options === SHARE ? "%" : ""));
      };

      this.longNumberF = d3.formatLocale({
        decimal: ".",
        thousands: " ", //short space
        grouping: [3],
      }).format(",.3~r");

      this.dateF = {
        year: d3.utcFormat("%Y"),
        month: d3.utcFormat("%Y-%m"),
        day: d3.utcFormat("%Y-%m-%d"),
        week: d3.utcFormat("%Yw%V"),
        quarter: d3.utcFormat("%Yq%q")
      };

      this.stringF = function(string){
        //the inline conditionals are needed because some translation files are stuck in cache 
        //and don't have the "dictionary" object but have strings in the root instead
        let translated = this.content[this.id].dictionary? this.content[this.id].dictionary[string] : this.content[this.id][string];
        if (translated || translated === "") return translated;
        translated = this.content[FALLBACK_ID].dictionary? this.content[FALLBACK_ID].dictionary[string] : this.content[FALLBACK_ID][string];
        if (translated || translated === "") return translated;
        return string;
      };
    }
    
    getFormattedNumber(arg) {
      return this.shortNumberFormat ? this.numberF(arg) : this.longNumberF(arg);
    }

    getFormattedDate(arg, dateIntervalSize) {
      return this.dateF[dateIntervalSize](arg);
    }
    
    getUIstring(arg) {
      return this.stringF(arg);
    }

    auto(dateIntervalSize = "year"){
      return (function(arg){
        // null, NaN and undefined are bypassing any formatter
        if (!arg && arg !== 0 && arg !== "") return arg;
        if (typeof arg === "number") return this.getFormattedNumber(arg);
        if (arg instanceof Date) return this.getFormattedDate(arg, dateIntervalSize);
        if (typeof arg === "string") return this.getUIstring(arg);
      }).bind(this);
    }

    isRTL(){
      return !!this.content[this.id].rtl;
    }
  }

  const LocaleService = mobx.decorate(_LocaleService, {
    "id": mobx.computed,
    "shortNumberFormat": mobx.computed,
    "status": mobx.observable
  });

  class CapitalVizabiService extends BaseService {

    setup(){
      this.Vizabi = this.config.Vizabi;
    }

    deconstruct() {
      delete this.Vizabi;
    }
  }

  const PROFILES = [
    {
      id: "LARGE",
      min_width: 900,
      min_height: 520
    },
    {
      id: "MEDIUM",
      min_width: 600,
      min_height: 400
    },
    {
      id: "SMALL",
      min_width: 1,
      min_height: 1
    }
  ];

  const CSS_PLACEHOLDER_CLASS = "vzb-tool";
  const CSS_CLASS_PREFIX = "vzb-";
  const CSS_LANDSCAPE_CLASS = "vzb-landscape";
  const CSS_PORTRAIT_CLASS = "vzb-portrait";
  const CSS_PROJECTOR_CLASS = "vzb-presentation";

  class _LayoutService extends BaseService {

    static DEFAULTS = {
      projector: false,
      placeholder: "body"
    }

    setup(){
      this.name = "layout";
      this.status = STATUS.INIT;
      this.width = 1;
      this.height = 1;
      this.size = this.getSize();
      this.profile = "SMALL";
      this.placeholder = this.config.placeholder || this.constructor.DEFAULTS.placeholder;
      this.hGrid = [];
      this.element = d3.select(this.placeholder)
        .classed(CSS_PLACEHOLDER_CLASS, true);
      this._resizeHandler();

      const resizeHandler = this._resizeHandler.bind(this);
      window.addEventListener("resize", resizeHandler);
      this.removeListener = function() {
        window.removeEventListener("resize", resizeHandler);
      };

      this.removeProjectorListener = mobx.autorun(() => {
        this.setProjector.bind(this)();
      }, {name: "Layout.js: setProjector()"});
    }

    deconstruct(){
      this.removeProjectorListener();
      this.removeListener();
      super.deconstruct();
    }

    get projector() {
      return this.config.projector || this.constructor.DEFAULTS.projector;
    }

    set projector(projector) {
      this.config.projector = projector;
    }

    getSize() {
      const { width, height } = this;
      return { width, height };
    }

    _resizeHandler(){
      mobx.action("Layout.js: _resizeHandler()", ()=>{
        this.width = this.element.node().clientWidth;
        this.height = this.element.node().clientHeight;
        const profile = PROFILES.find(p => (this.width >= p.min_width && this.height >= p.min_height));

        if (!profile) {
          this.profile = "SMALL";
          this.status = STATUS.ERROR;
          console.warn(`
          Layout service: nothing should be rendered, because
          placeholder ${this.placeholder} has display:none or is too little: ${this.width} x ${this.height} px
        `);
        } else {
          this.element.classed(CSS_CLASS_PREFIX + this.profile.toLowerCase(), false);
          this.profile = profile.id;
          this.element.classed(CSS_CLASS_PREFIX + this.profile.toLowerCase(), true);
          this.element.classed(CSS_LANDSCAPE_CLASS, this.width > this.height);
          this.element.classed(CSS_PORTRAIT_CLASS, !(this.width > this.height));
          
          this.status = STATUS.READY;
        }
        this.size = this.getSize();
      })();
    }

    getProfileConstants(normalConstants = {}, forProjector = {}, positionInFacet){
      const result = this.projector
        ? deepExtend({}, normalConstants[this.profile] || {}, forProjector[this.profile] || {})
        : deepExtend({}, normalConstants[this.profile] || {});
      if(positionInFacet){
        if(!positionInFacet.row.first) result.margin.top = (result.margin.betweenRow * 0.5) || 2;
        if(!positionInFacet.row.last) result.margin.bottom = (result.margin.betweenRow * 0.5) || 2;
        if(!positionInFacet.column.first) result.margin.left = (result.margin.betweenColumn * 0.5) || 2;
        if(!positionInFacet.column.last) result.margin.right = (result.margin.betweenColumn * 0.5) || 2;
      }
      return result;
    }

    setProjector() {
      this.element.classed(CSS_PROJECTOR_CLASS, this.projector);
      this.size = this.getSize();
    }

    setHGrid(value) {
      mobx.action(() => {
        this.hGrid = value;
      })();
    }
  }

  const LayoutService = mobx.decorate(_LayoutService, {
    "size": mobx.observable.ref, //reference watches when new object is created
    "hGrid": mobx.observable,
    "projector": mobx.computed,
    "width": mobx.observable,
    "height": mobx.observable,
    "profile": mobx.observable,
    "status": mobx.observable
  });

  function ui(defaults = {}, config = {}, baseConfig = {}) {
    const _ui = {};
    const defaultKeys = Object.getOwnPropertyNames(defaults);
    const configKeys = Object.getOwnPropertyNames(config);
    const baseConfigKeys = Object.getOwnPropertyNames(baseConfig);

    for (let key of new Set([...defaultKeys, ...configKeys, ...baseConfigKeys])) {
      if (typeof defaults[key] !== "function" && (isPlainObject(config[key]) || isPlainObject(baseConfig[key]) || isPlainObject(defaults[key]))) {
        if (!config[key]) mobx.extendObservable(config, {[key] : {}});
                  
        _ui[key] = ui(defaults[key], config[key], baseConfig[key]);
      } else {
        const descriptor = {
          get() {
            return (typeof config[key] !== "undefined") ? config[key] : 
              (typeof baseConfig[key] !== "undefined") ? baseConfig[key] : 
                typeof defaults[key] === "function" ? deepClone(defaults[key]()) : defaults[key];
          },
          set(value) {
            if (typeof config[key] !== "undefined" && value == defaults[key]) {
              if (Object.getOwnPropertyDescriptor(config, key) && Object.getOwnPropertyDescriptor(config, key).configurable) 
                delete config[key];
            } else {
              config[key] = value;
            }
          },
          enumerable: true,
          configurable: true
        };
        Object.defineProperty(_ui, key, descriptor);
      }
    }
    return mobx.observable(_ui);
  }

  // export function ui2(defaults = {}, config, parentConfig = {}) {
  //     const _ui = {};
  //     const defaultKeys = Object.keys(defaults);
  //     const configKeys = Object.keys(config);
  //     const parentConfigKeys = Object.keys(config);

  //     for (let key of new Set([...defaultKeys, ...configKeys, ...parentConfigKeys])) {
  //         const descriptor = {
  //             get() {
  //                 if (utils.isPlainObject(config[key]) || utils.isPlainObject(config[key])) {
  //                     return ui2(defaults[key], config[key] || (config[key] = {}), parentConfig[key]);
  //                 }
  //                 return (typeof config[key] !== "undefined") ? config[key] : 
  //                     (typeof parentConfig[key] !== "undefined") ? parentConfig[key] : defaults[key];
  //             },
  //             set(value) { config[key] = value },
  //             enumerable: true,
  //             configurable: true
  //         };
  //         Object.defineProperty(_ui, key, descriptor);
  //     }
  //     return observable(_ui);
  // }

  class _BaseComponent {

    constructor({placeholder, model, services, subcomponents, template, id, parent, root, name, ui, default_ui = {}, state, options }){
      this.id = id || "c0";
      //this.status = STATUS.INIT;
      this.template = template || "";
      this.subcomponents = subcomponents || [];
      this.services = services || {};
      this.model = model;
      this.state = state || {};
      this.parent = parent || null;
      this.children = [];
      this.root = root || this;
      this.name = name || "";
      this.options = options || {};

      this.reactions = new Map();

      //append the template to placeholder
      const scope = this.parent && this.parent.element ? this.parent.element : d3; //d3 would search global scope
      this.element = scope.select(placeholder).html(this.template);
      if(!this.element.node()) console.warn(`
      Vizabi component ${this.constructor.name} id: ${this.id} name: ${this.name} 
      can't find placeholder to render: 
      ${placeholder} 
      Please check that placeholder exists and is correctly specified in the component initialisation.
    `, this);

      this.DEFAULT_UI = deepExtend(default_ui, deepExtend(deepExtend({}, this.constructor.DEFAULT_UI), default_ui));

      this.ui = this.setupUI(this.DEFAULT_UI, ui);

      this.subcomponents.forEach( (comp, index) => {
        if(!comp.type) {
          console.error(`
          Was unable to find a subcomponent "${comp.name}"
          while building a component tree in parent "${this.name}".
          This can be due to a misconfiguration, error in parent "subcomponents" definitions
          or that subcomponent in question isn't registered or available to code. Hard to tell...
        `, comp);
        } else {
          const subcomponent = new comp.type({
            placeholder: comp.placeholder,
            model: comp.model || this.model,
            services: this.services,
            id: this.id + "-" + index,
            parent: this,
            root: this.root,
            ui: this.getUI(comp, ui),
            default_ui: comp.default_ui || this.getUI(comp, default_ui),
            state: comp.state,
            name: comp.name,
            template: comp.template,
            options: comp.options,
          });
          this.children.push(subcomponent);
        }
      });

      this.setup(this.options);
      this.addReaction(this.draw);
      this.addReaction(this.loading, true);
      this.addReaction(this.resize);
    }

    getUI(comp, ui) {
      const name = comp.name;
      if (name && !ui[name]) ui[name] = {};
      return name ? ui[name] : ui;
    }

    setupUI(defaults, ui$1, baseUI) {
      return ui(defaults, ui$1, baseUI);
    }

    addReaction(method, ignoreStatus){
      if(!method) return warn("Basecomponent: addReaction() method not found", method);
      if(!this.reactions.has(method)){
        this.reactions.set(method, 
          mobx.autorun(() => {
            if(ignoreStatus || this.status === STATUS.READY) method.bind(this)();
          }, {
            name: method.name, 
            onError: (err) => {
              this.element.classed("vzb-loading-data", false);
              this.error(err);
            }
          })
        );
      }
    }
    removeReaction(method){
      if(this.reactions.has(method)){
        //kill mobx autoruns and reactions
        this.reactions.get(method)();
        this.reactions.delete(method);
      }
    }
    removeAllReactions(){
      this.reactions.forEach((_disposer, method) => this.removeReaction(method));
    }

    findChild({name, id, type}){
      if (name && this.name === name || id && this.id === id || type && this.constructor.name === type) return this;
      for (const c of this.children) {
        const find = c.findChild({name, id, type});
        if (find) return find;
      }
      return false;
    }

    deconstruct(){
      // deconstruct and remove subcomponents
      if (this.children.length) {
        this.children.forEach(c => {
          c.deconstruct(); 
          c = void 0;
        });
      }
      this.removeAllReactions();
      // deconstruct and remove services
      if (this.root == this){
        Object.values(this.services).forEach(s => {
          s.deconstruct();
          s = void 0;
        });
      }
    }

    get status() {
      const dependencies = Object.values(this.services).map((m)=>m.status)
        .concat(this.children.map((m)=>m.status))
        .concat(this.model.state);

      if (dependencies.every(dep => dep === STATUS.READY || dep == undefined))
        return STATUS.READY;
      else if (dependencies.some(dep => dep === STATUS.ERROR))
        return STATUS.ERROR;
      else
        return STATUS.PENDING;
    }

    setup() {}
    draw() {}
    loading() {
      if (this.options.showLoading)
        this.element.classed("vzb-loading-data", this.status == STATUS.PENDING);
    }
    error(err) {console.warn(err);}
    resize() {}
  }

  _BaseComponent.DEFAULT_UI = {};

  const BaseComponent = mobx.decorate(_BaseComponent, {
    //"status": observable,
    "status": mobx.computed,
    "state": mobx.observable
  });

  class _AddGeo extends BaseComponent {

    constructor(config){
      config.template = `
      <div class="vzb-addgeo-button"></div>
      </div>
    `;
      config.subcomponents = [];
     
      super(config);
    }

    setup(options) {
      const _this = this;

      this.DOM = {
        button: this.element.select(".vzb-addgeo-button"),
      };

      this.DOM.button.on("click", () => {
        const markerControls = _this.root
          .findChild({name: "markercontrols"});
        if (!markerControls) return;      

        if ((_this.root.services.layout.profile !== "LARGE" || _this.root
          .findChild({name: "buttons"}).ui.sidebarCollapse) && !markerControls.isOpen)
        {
          markerControls.parent.toggleDialogOpen("markercontrols");
        }

        markerControls.element.select(".vzb-search").each(function() {
          this.value = "add ";
          this.dispatchEvent(new Event("input"));
          const _this = this;
          d3.select(this).style("background", "lightgreen")
            .transition().duration(1000).ease(d3.easeCubicOut)
            .style("background", "#fff");
          setTimeout(()=> {
            _this.setSelectionRange(_this.value.length, _this.value.length);
            _this.focus();
          }, 250);
        });
              
      });

      this.PROFILE_CONSTANTS = options.PROFILE_CONSTANTS;
      this.PROFILE_CONSTANTS_FOR_PROJECTOR = options.PROFILE_CONSTANTS_FOR_PROJECTOR;
      this.xAlign = options.xAlign;
      this.yAlign = options.yAlign;
    }

    draw(){
      this.localise = this.services.locale.auto();
      this.addReaction(this.updateSize);
      this.addReaction(this.redraw);
    }
    
    redraw(){
      this.DOM.button.text(this.localise("buttons/addgeo"));
    }


    updateSize() {
      this.services.layout.size; //watch

      this.profileConstants = this.services.layout.getProfileConstants(this.PROFILE_CONSTANTS, this.PROFILE_CONSTANTS_FOR_PROJECTOR);

      const {
        margin,
        dy,
        dx,
      } = this.profileConstants;

      this.element.style("top", this.yAlign == "top" ? margin.top + (dy||0) + "px" : null);
      this.element.style("bottom", this.yAlign == "bottom" ? margin.bottom + (dy||0) + "px" : null);
      this.element.style("left", this.xAlign == "left" ? margin.left + (dx||0) + "px" : null);
      this.element.style("right", this.xAlign == "right" ? margin.right + (dx||0) + "px" : null);
    }

  }

  const AddGeo = mobx.decorate(_AddGeo, {
  });

  /*!
   * VIZABI BUBBLE SIZE slider
   * Reusable bubble size slider
   */

  const OPTIONS$6 = {
    EXTENT_MIN: 0,
    EXTENT_MAX: 1,
    BAR_WIDTH: 6,
    THUMB_HEIGHT: 20,
    THUMB_STROKE_WIDTH: 4,
    INTRO_DURATION: 250,
    ROUND_DIGITS: 2,
    value: "extent",
    setValueFunc: null,
    submodel: null,
    submodelFunc: null,

    PROFILE_CONSTANTS: {
      SMALL: {
      },
      MEDIUM: {
      },
      LARGE: {
      }
    },

    PROFILE_CONSTANTS_FOR_PROJECTOR: {
      SMALL: {
      },
      MEDIUM: {
      },
      LARGE: {
      }
    }
  };

  class BrushSlider extends BaseComponent {
    constructor (config) {
      config.template = `
      <div class="vzb-slider-holder">
        <svg class="vzb-slider-svg">
          <g class="vzb-slider-wrap">
            <g class="vzb-slider">
            </g>
          </g>
        </svg>
      </div>  
    `;

      super(config);

      this._setModel = throttle(this._setModel, 50);
    }

    setup(_options) {
      this.type = this.type || "brushslider";

      this.DOM = {
        sliderSvg: this.element.select(".vzb-slider-svg"),
        sliderWrap: this.element.select(".vzb-slider-wrap"),
        slider: this.element.select(".vzb-slider")
      };
      this.DOM.slider.classed("vzb-slider-" + this.constructor.name.toLowerCase(), true);
    
      const options = this.options = deepExtend(deepExtend({}, OPTIONS$6), _options || {});

      this.value = options.value;
      this.submodel = options.submodel;
      this.submodelFunc = options.submodelFunc;
      this.setValueFunc = options.setValueFunc;

      this.padding = this._getPadding();
      
      this.rescaler = d3.scaleLinear()
        .domain([options.EXTENT_MIN, options.EXTENT_MAX])
        .clamp(true);

      this.brushEventListeners = this._getBrushEventListeners();

      this.brush = d3.brushX()
        .extent([[0, 0], [0, 0]])
        .handleSize(this._getHandleSize())
        .on("start", this.brushEventListeners.start)
        .on("brush", this.brushEventListeners.brush)
        .on("end", this.brushEventListeners.end);

      this.DOM.sliderThumbs = this.DOM.slider.selectAll(".handle")
        .data([{ type: "w" }, { type: "e" }], d => d.type)
        .enter().append("svg").attr("class", d => "handle handle--" + d.type + " " + d.type)
        .classed("vzb-slider-thumb", true);

      this._createThumbs(
        this.DOM.sliderThumbs.append("g")
          .attr("class", "vzb-slider-thumb-badge")
      );

      this.DOM.slider
        .call(this.brush);

      const barWidth = options.BAR_WIDTH;

      this.DOM.slider.selectAll(".selection,.overlay")
        .attr("height", barWidth)
        .attr("rx", barWidth * 0.25)
        .attr("ry", barWidth * 0.25)
        .attr("transform", "translate(0," + (-barWidth * 0.5) + ")");

    }
    
    get MDL() {
      return {
        model: this._getModel()
      };
    }

    draw() {
      this.localise = this.services.locale.auto();
      if(this.element.classed("vzb-hidden")) return;
      if(this._updateLayoutProfile()) return;

      this.addReaction(this._updateSize);
      this.addReaction(this._updateView);
    }

    _updateLayoutProfile(){
      this.services.layout.size;

      this.profileConstants = this.services.layout.getProfileConstants(this.options.PROFILE_CONSTANTS, this.options.PROFILE_CONSTANTS_FOR_PROJECTOR);
      this.height = (this.element.node().clientHeight) || 0;
      this.width = (this.element.node().clientWidth) || 0;
      if (!this.height || !this.width) return warn("Slider _updateProfile() abort: container is too little or has display:none");
    }

    _getPadding() {
      const halfThumbHeight = this.options.THUMB_HEIGHT * 0.5;

      return {
        top: this.options.BAR_WIDTH * 0.5,
        left: halfThumbHeight,
        right: halfThumbHeight,
        bottom: halfThumbHeight + this.options.THUMB_STROKE_WIDTH
      };
    }
    
    _getHandleSize() {
      return this.options.THUMB_HEIGHT + this.options.BAR_WIDTH * 2;
    }

    _getComponentWidth() {
      const width = this.element.node().offsetWidth - this.padding.left - this.padding.right;
      return width < 0 ? 0 : width;
    }

    _getComponentHeight() {
      return this.options.BAR_WIDTH;
    }

    _getBrushEventListeners() {
      const _this = this;

      return {
        start: (event) => {
          if (_this.nonBrushChange || !event.sourceEvent) return;

          this._savedSelection = event.selection;
          this._setFromExtent(false, false, false);
        },
        brush: (event) => {
          if (this.nonBrushChange || !event.sourceEvent) return;

          this._savedSelection = event.selection;
          this._setFromExtent(true, false, false); // non persistent change
        },
        end: (event) => {
          if (this.nonBrushChange || !event.sourceEvent) return;

          if (event.selection === null) {
            this.DOM.slider.call(this.brush.move, this._savedSelection);
          }
          this._setFromExtent(true, true); // force a persistent change
          this._savedSelection = void 0;
        }
      };
    }

    _createThumbs(thumbsEl) {
      const barWidth = this.options.BAR_WIDTH;
      const halfThumbHeight = this.options.THUMB_HEIGHT * 0.5;
      thumbsEl.append("path")
        .attr("d", "M" + (halfThumbHeight + barWidth) + " " + (halfThumbHeight + barWidth * 1.5) + "l" + (-halfThumbHeight) + " " + (halfThumbHeight * 1.5) + "h" + (halfThumbHeight * 2) + "Z");
    }

    _updateThumbs() {
    }

    _updateSize() {
      this.services.layout.size;

      const svgWidth = this._getComponentWidth() + this.padding.left + this.padding.right;

      this.DOM.sliderSvg
        .attr("height", this._getComponentHeight() + this.padding.top + this.padding.bottom)
        .attr("width", svgWidth);
      this.DOM.sliderWrap
        .attr("transform", this.services.locale.isRTL() ? "translate(" + (svgWidth - this.padding.right) + "," + this.padding.top + ") scale(-1,1)" :
          "translate(" + this.padding.left + "," + this.padding.top + ")");
    
      this._updateRescaler();
    }

    _updateRescaler() {
      const componentWidth = this._getComponentWidth();
      this.rescaler.range([0, componentWidth]);
    }

    _getModel() {
      if (this.submodelFunc) {
        return this.submodelFunc.call(this.model);
      } else if (this.submodel) {
        const model = getProp(this, this.submodel.split("."));
        if (!model) console.error(`Slider inside ${this.parent.name || this.parent.constructor.name} was not able to access part of model ${this.submodel}`);
        return model;
      } else {
        return this.model;
      }
    }

    _setBrushExtent() {
      return this.brush.extent([[0, 0], [this._getComponentWidth(), this._getComponentHeight()]]);
    }

    _updateView() {
      this.services.layout.size;
      const value = this.MDL.model[this.value];

      if (!value && value!==0 && value!==false) 
        console.error(`Slider inside ${this.parent.name || this.parent.constructor.name} was unable to access value ${this.value} in its model`);

      this.DOM.slider.call(this._setBrushExtent());
      const extent = this._valueToExtent(value) || [this.options.EXTENT_MIN, this.options.EXTENT_MAX];
      this._moveBrush(extent);
      this._updateThumbs(extent);
    }

    _moveBrush(s) {
      const _s = s.map(this.rescaler);
      this.nonBrushChange = true;
      this.DOM.slider.call(this.brush.move, [_s[0], _s[1]]);
      this.nonBrushChange = false;
      this._setFromExtent(false, false, false);
    }

    _valueToExtent(value) {
      return value;
    }

    _extentToValue(extent) {
      return extent;
    }

    /**
     * Prepares setting of the current model with the values from extent.
     * @param {boolean} set model
     * @param {boolean} force force firing the change event
     * @param {boolean} persistent sets the persistency of the change event
     */
    _setFromExtent(setModel, force, persistent) {
      let s = d3.brushSelection(this.DOM.slider.node());
      if (!s) return;
      s = [this.rescaler.invert(s[0]), this.rescaler.invert(s[1])];
      this._updateThumbs(s);
      if (setModel) this._setModel(s, force, persistent);
    }

    /**
     * Sets the current value in model. avoid updating more than once in framerate
     * @param {number} value
     * @param {boolean} force force firing the change event
     * @param {boolean} persistent sets the persistency of the change event
     */
    _setModel(value) {
      const roundDigits = this.options.ROUND_DIGITS;
      value = [+value[0].toFixed(roundDigits), +value[1].toFixed(roundDigits)];
      if (this.setValueFunc) {
        this.MDL.model[this.setValueFunc](this._extentToValue(value));
      } else {
        this.MDL.model[this.value] = this._extentToValue(value);
      }
    }

  }

  const decorated$f = mobx.decorate(BrushSlider, {
    "MDL": mobx.computed
  });

  const CollectionMixin$2 = superClass => class extends superClass {
    //static _collection = {};
    static add(name, addedClass) {
      this._collection[name] = addedClass;
    }
    static get(name) { return CollectionMixin$2._collection[name];}
  };

  CollectionMixin$2._collection = {};

  class Button extends CollectionMixin$2(BaseComponent) {
    constructor (config) {
      super(config);

      const {title, icon, func, required, statebind, statebindfunc, ignoreSize} = config;
      this.title = title;
      this.icon = icon;
      this.func = func;
      this.required = required;
      this.statebind = statebind;
      this.statebindfunc = statebindfunc;
      this.ignoreSize = ignoreSize;
    }
  }

  Button.BaseClass = Button;

  const CollectionMixin$1 = superClass => class extends superClass {
    //static _collection = {};
    static add(name, addedClass) {
      CollectionMixin$1._collection[name] = addedClass;
    }
    static get(name) { return CollectionMixin$1._collection[name];}
  };

  CollectionMixin$1._collection = {};

  class Chart extends CollectionMixin$1(BaseComponent) {}

  const CIRCLE_RADIUS = 6;

  function updateRainbowLegend(isVisible) {
    const DOM = this.DOM;
    
    //Hide rainbow element if showing minimap or if color is discrete
    DOM.rainbowHolder.classed("vzb-hidden", !isVisible);
    if (!isVisible) return;
    
    const localise = this.localise;
    const colorModel = this.MDL.color.scale;
    const gradientWidth = DOM.rainbow.node().getBoundingClientRect().width;
    const paletteKeys = colorModel.palette.paletteDomain.map(parseFloat);
    const paletteLabels = colorModel.palette.paletteLabels;
    const cScale = colorModel.d3Scale.copy();
      
    const marginLeft = parseInt(DOM.rainbow.style("left"), 10) || 0;
    const marginRight = parseInt(DOM.rainbow.style("right"), 10) || marginLeft;
    
    let domain, range, paletteMax;
    
    if (paletteLabels) {
      domain = paletteLabels.map(val => parseFloat(val));
      paletteMax = d3.max(domain);
      range = domain.map(val => val / paletteMax * gradientWidth);
    } else {
      domain = cScale.domain();
      paletteMax = d3.max(paletteKeys);
      range = paletteKeys.map(val => val / paletteMax * gradientWidth);
    }

    const labelsAxis = axisSmart$1("bottom");
    const labelScale = cScale.copy()
      .interpolate(d3.interpolate)
      .range(range);

    const edgeDomain = d3.extent(domain);

    const domainScale = labelScale.copy()
      .domain(edgeDomain)
      .range(edgeDomain);

    const paletteScaleLinear = d3.scaleLinear()
      .domain(edgeDomain)
      .range([0, 100]);

    updateLabelScale();
    updateRainbowCanvas();
    updateSubtitle();

    if (DOM.rainbowLegend.style("display") !== "none")
      updateColorStops();


    function updateLabelScale(){

      DOM.labelScaleSVG.style("width", marginLeft + gradientWidth + marginRight + "px");
      DOM.labelScaleG.attr("transform", "translate(" + marginLeft + ",2)");
      
      labelsAxis
        .scale(labelScale)
        .tickSizeOuter(5)
        .tickPadding(8)
        .tickSizeMinor(3, -3)
        .labelerOptions({
          scaleType: colorModel.type,
          toolMargin: {
            right: marginRight,
            left: marginLeft
          },
          showOuter: false,
          formatter: localise,
          bump: marginLeft,
          cssFontSize: "8px",
          fitIntoScale: paletteLabels ? "optimistic" : null
        });

      DOM.labelScaleG.call(labelsAxis);
    }


    function updateRainbowCanvas(){
      DOM.rainbow
        .style("top", 3 + CIRCLE_RADIUS + "px");

      DOM.rainbowCanvas
        .attr("width", gradientWidth)
        .attr("height", 1)
        .style("width", gradientWidth + "px")
        .style("height", "100%");

      const context = DOM.rainbowCanvas.node().getContext("2d");
      const image = context.createImageData(gradientWidth, 1);
      for (let i = 0, j = -1, c; i < gradientWidth; ++i) {
        c = d3.rgb(cScale(labelScale.invert(i)));
        image.data[++j] = c.r;
        image.data[++j] = c.g;
        image.data[++j] = c.b;
        image.data[++j] = 255;
      }
      context.putImageData(image, 0, 0);

    }
    
    
    function updateSubtitle(){
      const conceptProps = colorModel.parent.data.conceptProps;
      const subtitle = getSubtitle(conceptProps.name, conceptProps.name_short);
    
      DOM.subtitleText
        .classed("vzb-hidden", subtitle == "")
        .text(subtitle);

      DOM.subtitleReset
        .text(localise("buttons/reset"))
        .classed("vzb-hidden", !Object.keys(colorModel.palette.config.palette).length)
        .on("click", () => {
          mobx.runInAction(()=>{
            Object.keys(colorModel.palette.config.palette)
              .forEach(d => colorModel.palette.removeColor(d));
          });
        });
    }


    function updateColorStops(){

      DOM.rainbowLegend
        .style("width", gradientWidth + "px")
        .style("left", (marginLeft - CIRCLE_RADIUS) + "px")
        .style("top", "3px");

      DOM.labelScale.selectAll(".vzb-axis-value text")
        .attr("dy", "1.5em");

      DOM.rainbowLegendEventArea
        .style("width", gradientWidth + "px")
        .style("top", 3 + CIRCLE_RADIUS + "px")
        .style("left", CIRCLE_RADIUS + "px")
        .on("mousemove", function(event) {
          highlightValue(labelScale.invert(d3.pointer(event)[0]));
        })
        .on("mouseleave", () => highlightValue("none"))
        .on("dblclick", function(event) {
          let x = d3.pointer(event)[0];
          x = x <= (CIRCLE_RADIUS * 2) ? CIRCLE_RADIUS * 2 : x >= (gradientWidth - CIRCLE_RADIUS * 2) ? gradientWidth - CIRCLE_RADIUS * 2 : x;
          const newValue = labelScale.invert(x);
          const color = cScale(newValue);
          const paletteKey = getPaletteKey(newValue);
          colorModel.palette.setColor(color, paletteKey);
        });

      if (!d3.extent(domain).includes(0)) {
        //find tick with zero
        DOM.labelScaleG.selectAll(".tick text")
          .filter(function() { return d3.select(this).text() === "0"; })
          .style("cursor", "pointer")
          .on("dblclick", () => {
            const color = cScale(0);
            const paletteKey = getPaletteKey(0);
            colorModel.palette.setColor(color, paletteKey);
          });
      }

      const value0 = d3.min(domain) < 0 && d3.max(domain) > 0 ? labelScale(0) : null;
      const colorStops = domain.map((val, i) => ({ 
        val, 
        i, 
        value0,
        isEdgePoint: i === 0 || i === domain.length - 1,
        color: cScale.range()[i],
        paletteKey: paletteKeys[i],
        xMin: i - 1 < 0 ? 1 : labelScale(domain[i - 1]) + CIRCLE_RADIUS * 2,
        xMax: i + 1 >= domain.length ? gradientWidth - 1 : labelScale(domain[i + 1]) - CIRCLE_RADIUS * 2
      }));
        

      let dblclick = false;
      let lastClickId;

      let rainbowLegendCircles = DOM.rainbowLegend.selectAll(".vzb-cl-rainbow-legend-circle")
        .data(colorStops, d => d.i);
      rainbowLegendCircles.exit().remove();
      rainbowLegendCircles = rainbowLegendCircles.enter().append("div")
        .attr("class", "vzb-cl-rainbow-legend-circle")
        .style("width", 2 * CIRCLE_RADIUS + "px")
        .style("height", 2 * CIRCLE_RADIUS + "px")
        .style("border", "1px solid #000")
        .each(function(){
          d3.select(this).append("input")
            .attr("type", "color");
        })
        .merge(rainbowLegendCircles);
          
      rainbowLegendCircles
        .style("border-radius", d => d.isEdgePoint ? null : (CIRCLE_RADIUS + "px"))
        .call(dragCircles())
        .on("mouseenter", d => {
          highlightValue(d.val);
        })
        .on("mouseleave", () => {
          highlightValue("none");
        })
        .on("click", function(){
          const input = d3.select(this).select("input").node();
          lastClickId = setTimeout(() => {
            if (!dblclick){
              input.click();
            } else {
              clearTimeout(lastClickId);
              dblclick = false;
            }
          }, 500);
        })
        .on("dblclick", function(event, d){
          dblclick = true;
          if (d.isEdgePoint) return;
          removeColor(d.paletteKey);
        })
        .each(function(d) {
          d3.select(this).select("input").property("value", d.color)
            .on("click", (event)=>{event.stopPropagation();})
            .on("input", function(){
              const value = d3.select(this).property("value");
              setColor(value, d.paletteKey);
            });
          d3.select(this).style("left", (d.x = labelScale(d.val)) + "px");
        });
    }


    function dragCircles() {
      return d3.drag()
        .on("start", function start(event) {

          const circle = d3.select(this);
          let dragged = false;

          circle.classed("dragging", true);

          event.on("drag", drag).on("end", end);

          function drag(event, d) {
            if (d.isEdgePoint) return;
            if (event.x < 0) return;
            if (event.x > gradientWidth) return;
            if (event.x < d.xMin || event.x > d.xMax) return;
            if (!dragged && event.dx !== 0) dragged = true;

            d.x = event.x;
            if (d.value0 !== null) {
              d.x = (d.x < d.value0 - 3 || d.x > d.value0 + 3) ? d.x : d.value0;
            }

            circle.style("left", d.x + "px");

            if (dragged) {
              const newValue = labelScale.invert(d.x);
              const paletteKey = getPaletteKey(newValue);
              highlightValue(newValue);

              if(d.paletteKey !== paletteKey){
                replaceColor(d.color, d.paletteKey, paletteKey);                
                d.val = newValue;
                d.paletteKey = paletteKey;
              }
            }
          }

          function end() {
            circle.classed("dragging", false);
          }
        });
    }


    function getPaletteKey(value){
      return Math.round(+paletteScaleLinear(domainScale(value)));
    }


    function highlightValue(value){
      DOM.labelScaleG.call(labelsAxis.highlightValue(value));
    }


    function setColor(value, key){
      colorModel.palette.setColor(value, key);
    }


    function removeColor(key){
      if (colorModel.palette.defaultPalette[key])
        colorModel.palette.setColor(null, key);    
      else 
        colorModel.palette.removeColor(key);  
    }


    function replaceColor(value, oldKey, newKey){
      mobx.runInAction(()=>{
        removeColor(oldKey);
        setColor(value, newKey);
      });
    }
  }

  /*!
   * VIZABI BUBBLE COLOR LEGEND COMPONENT
   */

  function isTrailBubble(d){
    return !!d[Symbol.for("trailHeadKey")];
  }

  function euclideanColorDistance0to1(color1 = "#fff", color2 = "#fff"){
    const {r: r1, g: g1, b: b1} = d3.color(color1);
    const {r: r2, g: g2, b: b2} = d3.color(color2);
    const max = 255, norm = Math.sqrt(3 * max ** 2);
    return Math.sqrt(Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2)) / norm;
  }

  class ColorLegend extends BaseComponent {
    constructor(config) {
      config.template = `
      <div class="vzb-cl-outer">
        <div class="vzb-cl-holder">
          <div class="vzb-cl-minimap">
            <svg>
              <g></g>
            </svg>
          </div>

          <div class="vzb-cl-colorlist vzb-hidden"></div>

          <div class="vzb-cl-rainbow-holder vzb-hidden">
            <div class="vzb-cl-rainbow">
              <canvas></canvas>
            </div>

            <div class="vzb-cl-rainbow-legend">
              <div class="vzb-cl-rainbow-legend-eventarea"></div>
            </div>

            <div class="vzb-cl-labelscale">
              <svg>
                <g></g>
              </svg>
            </div>

            <div class="vzb-cl-subtitle">
              <span class="vzb-cl-subtitle-text"></span>
              <span class="vzb-cl-subtitle-reset"></span>
            </div>
          </div>
          
          <span class="vzb-cl-more-hint vzb-hidden">click for more options</span>

          <div class="vzb-cl-select-dialog vzb-hidden">
            <div class="vzb-cl-select-dialog-title"></div>
            <div class="vzb-cl-select-dialog-close"></div>
          </div>
      </div>
    `;

      super(config);
    }

    setup(options) {
      this.DOM = {
        wrapper: this.element.select(".vzb-cl-holder"),
      };

      this.DOM.minimap = this.DOM.wrapper.select(".vzb-cl-minimap");
      this.DOM.minimapSVG = this.DOM.minimap.select("svg");
      this.DOM.minimapG = this.DOM.minimapSVG.select("g");

      this.DOM.listColors = this.DOM.wrapper.select(".vzb-cl-colorlist");

      this.DOM.rainbowHolder = this.DOM.wrapper.select(".vzb-cl-rainbow-holder");
      this.DOM.rainbow = this.DOM.rainbowHolder.select(".vzb-cl-rainbow");
      this.DOM.rainbowCanvas = this.DOM.rainbow.select("canvas");
      this.DOM.rainbowLegend = this.DOM.rainbowHolder.select(".vzb-cl-rainbow-legend");
      this.DOM.rainbowLegendEventArea = this.DOM.rainbowLegend.select(".vzb-cl-rainbow-legend-eventarea");

      this.DOM.labelScale = this.DOM.rainbowHolder.select(".vzb-cl-labelscale");
      this.DOM.labelScaleSVG = this.DOM.labelScale.select("svg");
      this.DOM.labelScaleG = this.DOM.labelScaleSVG.select("g");
      this.DOM.subtitleDiv = this.DOM.rainbowHolder.select(".vzb-cl-subtitle");
      this.DOM.subtitleText = this.DOM.subtitleDiv.select(".vzb-cl-subtitle-text");
      this.DOM.subtitleReset = this.DOM.subtitleDiv.select(".vzb-cl-subtitle-reset");

      this.legendModelName = options.legendModelName;
      this.colorModelName = options.colorModelName;
    
      this._initSelectDialog();
    }


    get MDL() {
      return {
        color: this.model.encoding[this.colorModelName],
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted,
        superHighlighted: this.model.encoding.superhighlighted,
        legend: this.root.model.markers[this.legendModelName]
      };
    }

    draw() {
      this.localise = this.services.locale.auto();
     
      if (this._legendHasOwnModel() && !this._isLegendModelReady()) return;

      this.KEY = Symbol.for("key");
      this.canShowMap = this.MDL.legend && this._canShowMap();
      this.which = this.MDL.color.data.constant || this.MDL.color.data.concept;

      this.addReaction(this._updateView);
      this.addReaction(this._translateSelectDialog);
      this.addReaction(this.closeSelectDialogOnConceptChange);
    }

    _legendHasOwnModel() {
      return this.MDL.legend
        && !this.MDL.color.data.isConstant 
        && isEntityConcept(this.MDL.color.data.conceptProps);
    }

    _isLegendModelReady() {
      return this.MDL.legend.state == STATUS.READY;
    }

    _canShowMap() {
      if(!this._legendHasOwnModel()) return false;
      const dataArray = this.MDL.legend.dataArray;
      return dataArray.length > 0 && dataArray.every(d => d.map);
    }

    _updateView() {
      if (this._legendHasOwnModel() && !this._isLegendModelReady()) return;

      const individualColors = false;
      this._updateListLegend(this.MDL.color.scale.isDiscrete() && !this.canShowMap && !individualColors && !this.MDL.color.scale.isPattern);
      this._updateMinimapLegend(this.MDL.color.scale.isDiscrete() && this.canShowMap);
      updateRainbowLegend.bind(this)(!this.MDL.color.scale.isDiscrete());
    }

    _updateListLegend(isVisible) {
      this.DOM.listColors.classed("vzb-hidden", !isVisible);
      if (!isVisible) return;

      const _this = this;
      const cScale = this.MDL.color.scale.d3Scale;

      let colorOptionsArray = [];

      if (this._legendHasOwnModel() && this._isLegendModelReady() && !this.MDL.color.data.isConstant) {
        colorOptionsArray = this.MDL.legend.dataArray;
      } else {
        colorOptionsArray = cScale.domain().map(value => {
          const result = {};
          result[this.which] = value;
          return result;
        });
      }

      let colorOptions = this.DOM.listColors.selectAll(".vzb-cl-option")
        .data(unique(colorOptionsArray, d => d[this.which]), d => d[this.which]);

      colorOptions.exit().remove();

      colorOptions = colorOptions.enter().append("div").attr("class", "vzb-cl-option")
        .each(function() {
          d3.select(this).append("div").attr("class", "vzb-cl-color-sample");
          d3.select(this).append("div").attr("class", "vzb-cl-color-legend");
        })
        .on("mouseover", (event, d) => this._interact().mouseover(d))
        .on("mouseout", () => this._interact().mouseout())
        .on("click", (event, d) => {
          this._bindSelectDialogItems(d);
          this.DOM.selectDialog.classed("vzb-hidden", false);
        })
        .merge(colorOptions);

      colorOptions.each(function(d) {
        const cvalue = cScale(d[_this.which]);
        const isTooBright = euclideanColorDistance0to1(cvalue, "#fff") < 0.3;

        d3.select(this).select(".vzb-cl-color-sample")
          .style("background-color", cvalue)
          .style("border", `1px solid ${isTooBright ? "black" : cvalue}`);
        //Apply names to color legend entries if color is a property
        let label = d["name"];
        if (!label && label !== 0) label = d[_this.which];
        if (_this.MDL.color.data.isConstant) label = _this.localise("indicator/_default/color");
        d3.select(this).select(".vzb-cl-color-legend").text(label);
      });
    }

    _updateMinimapLegend(isVisible) {
      this.DOM.minimap.classed("vzb-hidden", !isVisible);
      if (!isVisible) return;

      if (!this._isLegendModelReady()) return;

      const cScale = this.MDL.color.scale.d3Scale;

      const tempdivEl = this.DOM.minimap.append("div").attr("class", "vzb-temp");

      this.DOM.minimapSVG.attr("viewBox", null);
      this.DOM.minimapSVG.selectAll("g").remove();
      this.DOM.minimapG = this.DOM.minimapSVG.append("g");
      this.DOM.minimapG.selectAll("path")
        .data(this.MDL.legend.dataArray, d => d[this.KEY])
        .enter().append("path")
        .on("mouseover", (event, d) => this._interact().mouseover(d))
        .on("mouseout", () => this._interact().mouseout())
        .on("click", (event, d) => {
          this._bindSelectDialogItems(d);
          this.DOM.selectDialog.classed("vzb-hidden", false);
        })
        .each(function(d) {
          let shapeString = d["map"].trim();

          //check if shape string starts with svg tag -- then it's a complete svg
          if (shapeString.slice(0, 4) == "<svg") {
            //append svg element from string to the temporary div
            tempdivEl.html(shapeString);
            //replace the shape string with just the path data from svg
            //TODO: this is not very resilient. potentially only the first path will be taken!
            shapeString = tempdivEl.select("svg").select("path").attr("d");
          }

          d3.select(this)
            .attr("d", shapeString)
            .style("fill", cScale(d["color"]))
            .append("title").text(d["name"]);

          tempdivEl.html("");
        });

      const gbbox = this.DOM.minimapG.node().getBBox();
      this.DOM.minimapSVG.attr("viewBox", "0 0 " + gbbox.width * 1.05 + " " + gbbox.height * 1.05);
      tempdivEl.remove();

    }

    _interact() {
      const _this = this;

      return {
        mouseover(d) {
          _this.DOM.moreOptionsHint.classed("vzb-hidden", false);

          const concept = _this.MDL.color.data.concept;
          const colorMdlName = _this.MDL.color.name;
          
          const selectArray = _this.model.dataArray?.filter(f => f[colorMdlName] == d[concept]);

          if (!selectArray) return;

          _this.root.ui?.chart?.superhighlightOnMinimapHover && _this.MDL.superHighlighted ?
            _this.MDL.superHighlighted.data.filter.set(selectArray) :
            _this.MDL.highlighted.data.filter.set(selectArray);
        },

        mouseout() {
          _this.DOM.moreOptionsHint.classed("vzb-hidden", true);

          _this.root.ui?.chart?.superhighlightOnMinimapHover && _this.MDL.superHighlighted ?
            _this.MDL.superHighlighted.data.filter.clear() :
            _this.MDL.highlighted.data.filter.clear();
        },
        clickToShow(d) {
          if (!isEntityConcept(_this.MDL.color.data.conceptProps)) return;

          const filter = _this.model.data.filter;
          const colorSpace = _this.model.encoding.color.data.space;
          const concept = _this.MDL.color.data.concept;
          
          filter.config.dimensions[colorSpace][concept] = d[concept];
        },
        clickToSelect(d) {
          //experimentally removed this limitation, because discovered that the "string" concept property works too
          //this is especially useful for CSV-only data because there are no entity props linking to other entities, just strings
          // if (!isEntityConcept(_this.MDL.color.data.conceptProps)) return;

          const concept = _this.MDL.color.data.concept;
          const colorMdlName = _this.MDL.color.name;
          const selectedFilter = _this.MDL.selected.data.filter;
          
          const selectArray = _this.model.dataArray?.filter(f => !isTrailBubble(f) && f[colorMdlName] == d[concept]);
          
          if (!selectArray) return;

          if (selectArray.every(d => selectedFilter.has(d)))
            mobx.runInAction(() => selectedFilter.delete(selectArray));
          else
            mobx.runInAction(() => selectedFilter.set(selectArray));        
        }
      };
    }

    _initSelectDialog() {
      this.DOM.moreOptionsHint = this.DOM.wrapper.select(".vzb-cl-more-hint");

      this.DOM.selectDialog = this.DOM.wrapper.select(".vzb-cl-select-dialog");
      this.DOM.selectDialogTitle = this.DOM.selectDialog.select(".vzb-cl-select-dialog-title");

      this.DOM.selectDialogClose = this.DOM.selectDialog.select(".vzb-cl-select-dialog-close");
      this.DOM.selectDialogClose
        .html(ICON_CLOSE)
        .on("click", () => this._closeSelectDialog());

      this.DOM.selectAllButton = this.DOM.selectDialog.append("div")
        .attr("class", "vzb-cl-select-dialog-item vzb-clickable");

      this.DOM.removeElseButton = this.DOM.selectDialog.append("div")
        .attr("class", "vzb-cl-select-dialog-item vzb-clickable");

      this.DOM.editColorButton = this.DOM.selectDialog.append("div")
        .attr("class", "vzb-cl-select-dialog-item vzb-cl-select-dialog-item-moreoptions");
      this.DOM.editColorButton.append("label")
        .attr("class", "vzb-clickable")
        .attr("for", "vzb-cl-select-dialog-color-" + this.id);
      this.DOM.editColorButton.append("input")
        .attr("type", "color")
        .attr("class", "vzb-invisible")
        .attr("id", "vzb-cl-select-dialog-color-" + this.id);
      this.DOM.editColorButton.append("span")
        .attr("class", "vzb-clickable");

      this.DOM.editColorButtonTooltip = this.DOM.editColorButton.append("div")
        .attr("class", "vzb-cl-select-dialog-item-tooltip");
    }

    _translateSelectDialog() {
      const t = this.localise;
      this.DOM.moreOptionsHint.text(t("hints/color/more"));
      this.DOM.selectAllButton.text("✅ " + t("dialogs/color/select-all"));
      this.DOM.removeElseButton.text("🗑️ " + t("dialogs/color/remove-else"));
      this.DOM.editColorButton.select("label").text("🎨 " + t("dialogs/color/edit-color"));
      this.DOM.editColorButton.select("span").text(t("buttons/reset"));
      this.DOM.editColorButtonTooltip.text(t("dialogs/color/edit-color-blocked-hint"));
    }
    
    closeSelectDialogOnConceptChange(){
      this.MDL.color.data.concept;
      this._closeSelectDialog();
    }

    _closeSelectDialog() {
      this.DOM.selectDialog.classed("vzb-hidden", true);
    }

    _bindSelectDialogItems(d) {
      const _this = this;
      this.DOM.selectDialogTitle.text(d.name);

      this.DOM.selectAllButton
        //experimentally removed this limitation, because discovered that the "string" concept property works too
        //this is especially useful for CSV-only data because there are no entity props linking to other entities, just strings
        //.classed("vzb-cl-select-dialog-item-disabled", !isEntityConcept(this.MDL.color.data.conceptProps))
        .on("click", () => {
          this._interact().clickToSelect(d);
          this._closeSelectDialog();
        });

      this.DOM.removeElseButton
        .classed("vzb-cl-select-dialog-item-disabled", !isEntityConcept(this.MDL.color.data.conceptProps))
        .on("click", () => {
          this._interact().clickToShow(d);
          this._closeSelectDialog();
        });

      const isColorSelectable = this.MDL.color.scale.palette.isUserSelectable;
      this.DOM.editColorButtonTooltip.classed("vzb-hidden", isColorSelectable);
      this.DOM.editColorButton.select("span").classed("vzb-hidden", !isColorSelectable);
      this.DOM.editColorButton.classed("vzb-cl-select-dialog-item-disabled", !isColorSelectable);
      
      if (isColorSelectable){
        const colorScaleModel = this.MDL.color.scale;
        const concept = this.MDL.color.data.concept;
        const target = this.MDL.color.data.isConstant ? "_default" : d[concept];
        const colorOld = colorScaleModel.palette.getColor(target);
        const colorDef = colorScaleModel.palette.getColor(target, colorScaleModel.palette.defaultPalette);
        this.DOM.editColorButton.select("input")
          .property("value", colorOld)
          .on("input", function(){
            const value = d3.select(this).property("value");
            colorScaleModel.palette.setColor(value, target);
          })
          .on("change", function(){
            _this._closeSelectDialog();
          });

        //reset color
        this.DOM.editColorButton.select("span")
          .classed("vzb-hidden", colorOld == colorDef)
          .style("color", colorDef)
          .on("click", function(){
            colorScaleModel.palette.removeColor(target);
            _this._closeSelectDialog();
          });
      }
    }
  }

  const decorated$e = mobx.decorate(ColorLegend, {
    "MDL": mobx.computed
  });

  /*!
   * VIZABI BUTTONLIST
   * Reusable buttonlist component
   */

  //default existing buttons
  const class_active$2 = "vzb-active";
  const class_hidden = "vzb-hidden";
  const class_active_locked = "vzb-active-locked";
  const class_unavailable = "vzb-unavailable";

  class ButtonList extends BaseComponent {

    constructor(config) {

      super(config);
    } 

    setup() {

      this._available_buttons = {
        "find": {
          title: "buttons/find",
          icon: "search",
          required: false
        },
        "markercontrols": {
          title: "buttons/markercontrols",
          icon: "search",
          required: false
        },
        "show": {
          title: "buttons/show",
          icon: "asterisk",
          required: false
        },
        "moreoptions": {
          title: "buttons/more_options",
          icon: "gear",
          required: true
        },
        "colors": {
          title: "buttons/colors",
          icon: "paintbrush",
          required: false
        },
        "mapcolors": {
          title: "buttons/mapcolors",
          icon: "paintbrush",
          required: false
        },
        "size": {
          title: "buttons/size",
          icon: "circle",
          required: false
        },
        "zoom": {
          title: "buttons/zoom",
          icon: "cursorPlus",
          required: false
        },
        "fullscreen": {
          title: "buttons/expand",
          icon: "expand",
          func: this.toggleFullScreen.bind(this),
          required: true
        },
        "trails": {
          title: "buttons/trails",
          icon: "trails",
          func: this.toggleBubbleTrails.bind(this),
          required: false,
          statebind: "MDL.trail.show",
          statebindfunc: this.setBubbleTrails.bind(this)
        },
        "forecast": {
          title: "buttons/forecast",
          icon: "forecast",
          func: this.toggleTimeForecast.bind(this),
          required: false,
          statebind: "MDL.frame.showForecast",
          statebindfunc: this.setTimeForecast.bind(this)
        },
        "lock": {
          title: "buttons/lock",
          icon: "lock",
          func: this.toggleBubbleLock.bind(this),
          required: false,
          statebind: "root.ui.chart.lockNonSelected",
          statebindfunc: this.setBubbleLock.bind(this)
        },
        "inpercent": {
          title: "buttons/inpercent",
          icon: "percent",
          func: this.toggleInpercent.bind(this),
          required: false,
          statebind: "root.ui.chart.inpercent",
          statebindfunc: this.setInpercent.bind(this)
        },
        "presentation": {
          title: "buttons/presentation",
          icon: "presentation",
          func: this.togglePresentationMode.bind(this),
          required: false,
          statebind: "root.ui.presentation",
          statebindfunc: this.setPresentationMode.bind(this)
        },
        "sidebarcollapse": {
          title: "buttons/sidebar_collapse",
          icon: "angleDoubleLeft",
          func: this.toggleSidebarCollapse.bind(this),
          required: true,
          statebind: "root.ui.buttons.sidebarCollapse",
          statebindfunc: this.setSidebarCollapse.bind(this),
          ignoreSize: true
        },
        "about": {
          title: "buttons/about",
          icon: "about",
          required: false
        },
        "repeat": {
          title: "buttons/repeat",
          icon: "repeat",
          required: false
        },
        "axes": {
          title: "buttons/axes",
          icon: "axes",
          required: false
        },
        "axesmc": {
          title: "buttons/axesmc",
          icon: "axes",
          required: false
        },
        "stack": {
          title: "buttons/stack",
          icon: "stack",
          required: false
        },
        "side": {
          title: "buttons/side",
          icon: "side",
          required: false
        },
        "sided": {
          title: "buttons/sided",
          icon: "side",
          func: this.toggleSided.bind(this),
          statebind: "root.model",
          statebindfunc: this.setSided.bind(this),
          required: false
        },
        "_default": {
          title: "Button",
          icon: "asterisk",
          required: false
        }
      };

      this._active_comp = false;

      this.validatePopupButtons(this.root.ui.buttons.buttons, this.root.ui.dialogs.dialogs);

      this.element.selectAll("div").remove();

      //store body overflow
      this._prev_body_overflow = document.body.style.overflow;

      //TODO: maybe do the initial state setting here for all buttons
      if(this.root.ui.buttons.buttons.includes("sidebarcollapse")) this.setSidebarCollapse();
    }

    draw() {
      this.MDL = {
        frame: this.model.encoding.frame
      };
      this.localise = this.services.locale.auto();

      this._dialogs = this.root.findChild({type: "Dialogs"});
      if(!this._dialogs) console.warn("Buttonlist was unable to find a subcomponent of type 'Dialogs' in root component. Could be that index.js of a tool is lacking a configuration.");

      const button_expand = (this.root.ui.dialogs.dialogs || {}).sidebar || [];
      const button_list = [].concat(this.root.ui.buttons.buttons);
      this._addButtons(button_list, button_expand);
      this.addReaction(this._localiseButtons);
      this.addReaction(this._toggleButtons);
      this.addReaction(this._bindButtonState);

    }

    _bindButtonState() {
      this.root.ui.buttons.buttons.forEach(buttonId => {
        const button = this._available_buttons[buttonId];
        if (button) {
          if (button.statebind) {
            this.addReaction(() => {
              button.statebindfunc(buttonId, getProp(this, button.statebind.split(".")));
            });
          } else {
            this.addReaction(() => {
              const dialog = this._dialogs.findChild({ name: buttonId});
              if (!dialog) return;
              const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + buttonId + "']");
              btn.classed(class_active$2, dialog.getOpen());
            });
          }
        }
      });
      //dispose reaction
      this.reactions.get(this._bindButtonState)();
    }

    proceedClick(id) {
      const _this = this;
      const btn_config = _this._available_buttons[id];

      if (btn_config && btn_config.func) {
        btn_config.func(id);
      } else {
        this._dialogs.toggleDialogOpen(id);
      }
    }

    validatePopupButtons(buttons, dialogs) {
      const _this = this;

      const popupDialogs = dialogs.popup;
      const popupButtons = buttons.filter(d => (_this._available_buttons[d] && !_this._available_buttons[d].func));
      for (let i = 0, j = popupButtons.length; i < j; i++) {
        if (popupDialogs.indexOf(popupButtons[i]) == -1) {
          return error('Buttonlist: bad buttons config: "' + popupButtons[i] + '" is missing in popups list');
        }
      }
      return false; //all good
    }

    /*
     * reset buttons show state
     */
    _showAllButtons() {
      // show all existing buttons
      const buttons = this.element.selectAll(".vzb-buttonlist-btn");
      buttons.each(function() {
        const button = d3.select(this);
        button.style("display", "");
      });
    }

    _localiseButtons() {
      const _this = this;
      this.services.locale.id;
      this.element.selectAll("span[data-localise]").each(function() {
        const view = d3.select(this);
        view.text(_this.localise(view.attr("data-localise")));
      });
    }

    /*
    * determine which buttons are shown on the buttonlist
    */
    _toggleButtons() {
      this.services.layout.size;

      const _this = this;
      const root = this.root.element;

      //HERE
      const button_expand = (this.root.ui.dialogs.dialogs || {}).sidebar || [];
      _this._showAllButtons();

      const buttons = this.element.selectAll(".vzb-buttonlist-btn");

      const not_required = [];
      const required = [];

      let button_width = 80;
      let button_height = 80;
      let container_width = this.element.node().getBoundingClientRect().width;
      let container_height = this.element.node().getBoundingClientRect().height;
      let buttons_width = 0;
      let buttons_height = 0;

      buttons.filter(d => !d.ignoreSize).each(function(d) {
        const button_data = d;
        const button = d3.select(this);
        const expandable = button_expand.indexOf(button_data.id) !== -1;
        const button_margin = { top: parseInt(button.style("margin-top")), right: parseInt(button.style("margin-right")), left: parseInt(button.style("margin-left")), bottom: parseInt(button.style("margin-bottom")) };
        button_width = button.node().getBoundingClientRect().width + button_margin.right + button_margin.left;
        button_height = button.node().getBoundingClientRect().height + button_margin.top + button_margin.bottom;

        if (!button.classed(class_hidden)) {
          if (!expandable || _this.services.layout.profile !== "LARGE" || _this.ui.sidebarCollapse) {
            buttons_width += button_width;
            buttons_height += button_height;
            //sort buttons between required and not required buttons.
            // Not required buttons will only be shown if there is space available
            if (button_data.required) {
              required.push(button);
            } else {
              not_required.push(button);
            }
          } else {
            button.style("display", "none");
          }
        }
      });
      const width_diff = buttons_width - container_width;
      const height_diff = buttons_height - container_height;
      let number_of_buttons = 1;

      //check if container is landscape or portrait
      // if portrait small or large with expand, use width
      if (root.classed("vzb-large") && root.classed("vzb-dialog-expand-true")
      || root.classed("vzb-small") && root.classed("vzb-portrait")) {
        //check if the width_diff is small. If it is, add to the container
        // width, to allow more buttons in a way that is still usable
        if (width_diff > 0 && width_diff <= 10) {
          container_width += width_diff;
        }
        number_of_buttons = Math.floor(container_width / button_width) - required.length;
        if (number_of_buttons < 0) {
          number_of_buttons = 0;
        }
      // else, use height
      } else {
        //check if the width_diff is small. If it is, add to the container
        // width, to allow more buttons in a way that is still usable
        if (height_diff > 0 && height_diff <= 10) {
          container_height += height_diff;
        }
        number_of_buttons = Math.floor(container_height / button_height) - required.length;
        if (number_of_buttons < 0) {
          number_of_buttons = 0;
        }
      }
      //change the display property of non required buttons, from right to
      // left
      not_required.reverse();
      const hiddenButtons = [];
      for (let i = 0, j = not_required.length - number_of_buttons; i < j; i++) {
        not_required[i].style("display", "none");
        hiddenButtons.push(not_required[i].attr("data-btn"));
      }

      // const evt = {};
      // evt["hiddenButtons"] = hiddenButtons;
      // _this.trigger("toggle", evt);
      this.element.dispatch("custom-togglebuttons", 
        { detail: { hiddenButtons } });

    }

    /*
     * adds buttons configuration to the components and template_data
     * @param {Array} button_list list of buttons to be added
     */
    _addButtons(button_list, button_expand) {
      const _this = this;
      this._components_config = [];
      const details_btns = [];
      if (!button_list.length) return;
      //add a component for each button
      for (let i = 0; i < button_list.length; i++) {

        const btn = button_list[i];
        const btn_config = this._available_buttons[btn];

        //add template data
        const d = (btn_config) ? btn : "_default";
        const details_btn = clone(this._available_buttons[d]);
        if (d == "_default") {
          details_btn.title = "buttons/" + btn;
        }
        details_btn.id = btn;
        details_btn.icon = iconset["ICON_" + details_btn.icon.toUpperCase()];
        details_btns.push(details_btn);
      }

      this.element.selectAll("button").data(details_btns)
        .enter().append("button")
        .attr("class", d => {
          let cls = "vzb-buttonlist-btn";
          if (button_expand.length > 0) {
            if (button_expand.indexOf(d.id) > -1) {
              cls += " vzb-dialog-side-btn";
            }
          }

          return cls;
        })
        .attr("data-btn", d => d.id)
        .html(btn => `
        <span class='vzb-buttonlist-btn-icon fa'>${btn.icon}</span>
        <span class='vzb-buttonlist-btn-title'>
          <span data-localise='${btn.title}'></span>
        </span>
      `);

      const buttons = this.element.selectAll(".vzb-buttonlist-btn");

      //clicking the button
      buttons.on("click", function(event) {

        event.preventDefault();
        event.stopPropagation();

        const id = d3.select(this).attr("data-btn");
        _this.proceedClick(id);
      });

    }


    scrollToEnd() {
      let target = 0;
      const parent = this.root.element;

      if (parent.classed("vzb-portrait") && parent.classed("vzb-small")) {
        if (this.model.state.marker.select.length > 0) target = this.element.node().scrollWidth;
        this.element.node().scrollLeft = target;
      } else {
        if (this.model.state.marker.select.length > 0) target = this.element.node().scrollHeight;
        this.element.node().scrollTop = target;
      }
    }


    /*
     * RESIZE:
     * Executed whenever the container is resized
     * Ideally, it contains only operations related to size
     */
    resize() {
      //TODO: what to do when resizing?
      if (!this.element.selectAll) return warn("buttonlist resize() aborted because element is not yet defined");

      //toggle presentaion off is switch to 'small' profile
      if (this.services.layout.profile === "SMALL" && this.services.layout.projector) {
        this.togglePresentationMode();
      }
    }

    setButtonActive(id, boolActive) {
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

      btn.classed(class_active$2, boolActive);
    }

    setButtonUnavailable(id, boolUnavailable) {
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

      btn.classed(class_unavailable, boolUnavailable);
    }

    toggleSidebarCollapse() {
      this.ui.sidebarCollapse = !this.ui.sidebarCollapse;
      this.setSidebarCollapse();
      this.services.layout._resizeHandler();
    }

    setSidebarCollapse() {
      this.root.element.classed("vzb-dialog-expand-true", !this.ui.sidebarCollapse);
    }

    toggleBubbleTrails() {
      if (this.model.encoding) {
        const trail = this.model.encoding.trail;
        trail.setShow(!trail.show);
      }
      this.setBubbleTrails();
    }
    setBubbleTrails() {
      if (!this.model.encoding) return;
      const trail = this.model.encoding.trail;
      if (!trail) return;
      const id = "trails";
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
      if (!btn.node()) return warn("setBubbleTrails: no button '" + id + "' found in DOM. doing nothing");
      btn.classed(class_active_locked, trail.show);
      const anySelected = this.model.encoding.selected.data.filter.any();
      btn.classed(class_hidden, !anySelected);
    }
    toggleTimeForecast() {
      this.root.ui.chart.showForecast = !this.root.ui.chart.showForecast;
      this.setTimeForecast();
    }
    setTimeForecast() {
      const showForecast = this.root.ui.chart.showForecast;
      if (!showForecast && showForecast !== false) return;
      const id = "forecast";
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
      if (!btn.node()) return warn("setBubbleTrails: no button '" + id + "' found in DOM. doing nothing");

      btn.classed(class_active_locked, showForecast);
      btn.classed(class_hidden, !this.root.ui.chart.endBeforeForecast);
    }
    toggleBubbleLock() {
      const active = (this.root.ui.chart || {}).lockActive;

      if (!this.model.encoding.selected.data.filter.any() && !active) return;

      let locked = this.root.ui.chart.lockNonSelected;
      const time = this.model.encoding.frame.value;
      locked = locked ? 0 : this.localise(time);
      this.root.ui.chart.lockNonSelected = locked;

      this.setBubbleLock();
    }
    setBubbleLock() {
      let locked = (this.root.ui.chart || {}).lockNonSelected;
      const active = (this.root.ui.chart || {}).lockActive;
      const unavailable = (this.root.ui.chart || {}).lockUnavailable || false;
      if (!locked && locked !== 0) return;

      if (locked !== 0 && this.model.encoding.selected.data.filter.any() && !active) {
        locked = this.root.ui.chart.lockNonSelected = 0;
      }

      const id = "lock";
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
      if (!btn.node()) return warn("setBubbleLock: no button '" + id + "' found in DOM. doing nothing");

      //btn.classed(class_unavailable, !this.model.encoding.selected.data.filter.any() && !active);
      btn.classed(class_unavailable, unavailable);
      if (typeof active === "undefined") {
        btn.classed(class_hidden, !this.model.encoding.selected.data.filter.any());
      } else {
        btn.classed(class_hidden, !active);
      }

      btn.classed(class_active_locked, locked);

      btn.select(".vzb-buttonlist-btn-icon")
        .html(iconset[locked ? "ICON_LOCK" : "ICON_UNLOCK"]);

      btn.select(".vzb-buttonlist-btn-title>span").text(
        locked ? locked : this.localise("buttons/lock")
      )
        .attr("data-vzb-translate", locked ? null : "buttons/lock");
    }
    toggleInpercent() {
      this.root.ui.chart.inpercent = !this.root.ui.chart.inpercent;
      this.setInpercent();
    }
    setInpercent() {
      if (typeof ((this.root.ui.chart || {}).inpercent) === "undefined") return;
      const id = "inpercent";
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

      btn.classed(class_active_locked, this.root.ui.chart.inpercent);
    }
    toggleSided() {
      const sideConcept = this.model.encoding.side.config.defaultConcept;
      const space = this.model.data.space;
      mobx.runInAction(() => {
        if (space.includes(sideConcept)) {
          this.model.config.data.space = space.toSpliced(space.indexOf(sideConcept), 1);
          this.model.encoding.side.config.data.constant = "_default";
          this.model.encoding.side.config.data.concept = null;
        } else {
          this.model.config.data.space = [...space, sideConcept];
          this.model.encoding.side.config.data.concept = sideConcept;
          this.model.encoding.side.config.data.constant = null;
        }
      });
    }
    setSided(model) {
      const id = "sided";
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
      const sideConcept = this.model.encoding.side.config.defaultConcept;
      const space = this.model.data.space;
      btn.classed(class_active_locked, space.includes(sideConcept));
    }
    togglePresentationMode() {
      this.services.layout.projector = !this.services.layout.projector;
      this.setPresentationMode();
    }
    setPresentationMode() {
      const id = "presentation";
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

      btn.classed(class_active_locked, this.services.layout.projector);
    }
    toggleFullScreen(id, emulateClick) {

      if (!window) return;

      let component = this;
      //let pholder = component.placeholder;
      let pholder = component.root.element.node();
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
      const fs = !this.ui.fullscreen;
      const body_overflow = (fs) ? "hidden" : this._prev_body_overflow;


      //TODO: figure out a way to avoid fullscreen resize delay in firefox
      if (fs) {
        this.resizeInExitHandler = false;
        launchIntoFullscreen(pholder);
        subscribeFullscreenChangeEvent.call(this, this.toggleFullScreen.bind(this, id, true));
      } else {
        this.resizeInExitHandler = !emulateClick;
        exitFullscreen.call(this);
      }

      this.ui.fullscreen = fs;
      btn.classed(class_active_locked, fs);

      btn.select(".vzb-buttonlist-btn-icon").html(iconset[fs ? "ICON_UNEXPAND" : "ICON_EXPAND"]);

      btn.select(".vzb-buttonlist-btn-title").text(
        this.localise("buttons/" + (fs ? "unexpand" : "expand"))
      )
        .attr("data-vzb-translate", "buttons/" + (fs ? "unexpand" : "expand"));

      //restore body overflow
      document.body.style.overflow = body_overflow;

      if (!this.resizeInExitHandler) this.services.layout._resizeHandler();
    }

  }

  ButtonList.DEFAULT_UI = {
    buttons: ["fullscreen"],
    sidebarCollapse: false
  };

  function isFullscreen() {
    if (!window) return false;
    if (window.document.webkitIsFullScreen !== undefined)
      return window.document.webkitIsFullScreen;
    if (window.document.mozFullScreen !== undefined)
      return window.document.mozFullScreen;
    if (window.document.msFullscreenElement !== undefined)
      return window.document.msFullscreenElement;

    return false;
  }

  function exitHandler(emulateClickFunc) {
    if (!isFullscreen()) {
      removeFullscreenChangeEvent.call(this);
      if (!this.resizeInExitHandler) {
        emulateClickFunc();
      } else {
        this.services.layout._resizeHandler();
      }
    }
  }

  function subscribeFullscreenChangeEvent(exitFunc) {
    if (!window) return;
    const doc = window.document;

    this.exitFullscreenHandler = exitHandler.bind(this, exitFunc);
    doc.addEventListener("webkitfullscreenchange", this.exitFullscreenHandler, false);
    doc.addEventListener("mozfullscreenchange", this.exitFullscreenHandler, false);
    doc.addEventListener("fullscreenchange", this.exitFullscreenHandler, false);
    doc.addEventListener("MSFullscreenChange", this.exitFullscreenHandler, false);
  }

  function removeFullscreenChangeEvent() {
    const doc = window.document;

    doc.removeEventListener("webkitfullscreenchange", this.exitFullscreenHandler);
    doc.removeEventListener("mozfullscreenchange", this.exitFullscreenHandler);
    doc.removeEventListener("fullscreenchange", this.exitFullscreenHandler);
    doc.removeEventListener("MSFullscreenChange", this.exitFullscreenHandler);
  }

  function launchIntoFullscreen(elem) {
    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.msRequestFullscreen) {
      elem.msRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen && allowWebkitFullscreenAPI()) {
      elem.webkitRequestFullscreen();
    }
  }

  function exitFullscreen() {
    if (document.exitFullscreen && document.fullscreenElement) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen && allowWebkitFullscreenAPI()) {
      document.webkitExitFullscreen();
    } else {
      removeFullscreenChangeEvent.call(this);
      this.resizeInExitHandler = false;
    }
  }

  function allowWebkitFullscreenAPI() {
    return !(navigator.vendor && navigator.vendor.indexOf("Apple") > -1 &&
      navigator.userAgent && !navigator.userAgent.match("CriOS"));
  }

  class DataNotes extends BaseComponent {

    constructor(config) {
      super(config);
    }


    setup() {
      this.state = {
      };

      this.DOM = {

      };


      this.hidden = true;
      this.showNotes = false;
      this.pinned = false;
      this.left = 0;
      this.top = 0;
      this.encoding = null;


      this.element.classed("vzb-hidden", this.hidden);
      this.element.append("div")
        .html(ICON_CLOSE)
        .on("click", (event) => {
          event.stopPropagation();
          this.close();
        })
        .select("svg")
        .attr("width", "0px")
        .attr("height", "0px")
        .attr("class", "vzb-data-notes-close")
        .classed("vzb-hidden", true);

      this.element.append("div")
        .attr("class", "vzb-data-notes-body vzb-dialog-scrollable");

      this.element.append("div")
        .attr("class", "vzb-data-notes-link");


    }
    
    draw() {
      this.localise = this.services.locale.auto();
      
      this.addReaction(this.setValues);
      this.addReaction(this.resize);
    }

    resize(){
      this.services.layout.size;
      this.close();
    }

    setEncoding(enc) {
      this.encoding = enc;
      this.setValues();
      return this;
    }

    setValues() {
      if (!this.encoding) return;
      const { description, source_url, source } = this.encoding.data.conceptProps;

      this.element.select(".vzb-data-notes-body")
        .classed("vzb-hidden", !description)
        .text(replaceNumberSpacesToNonBreak(description));

      const label = this.localise("hints/source");
      this.element.select(".vzb-data-notes-link")
        .classed("vzb-hidden", !source_url)
        .html("<span>" + (source ? (label + ": ") : "") 
          + '<a href="' + normaliseLink(source_url) + '" target="_blank">' + (source ? source : label) 
          + "</a></span>");

      this.showNotes = source_url || description;
    }

    setPos(_left, _top, force) {
      this.left = _left;
      this.top = _top;
      if (this.pinned && !force) return this;
      const parentHeight = this.parent.element.node().offsetHeight;
      const width = this.element.node().offsetWidth;
      const height = this.element.node().offsetHeight;
      let leftMove;
      let topMove;
      let leftPos = this.left - width;
      let topPos = this.top;
      if (leftPos < 10) {
        leftPos = 10;
        leftMove = true;
      }
      if ((topPos + height + 10) > parentHeight) {
        topPos = parentHeight - height - 10;
        topMove = true;
      }

      if (leftMove && topMove) {
        topPos = this.top - height - 30;
      }

      this.element.style("top", topPos + "px");
      this.element.style("left", leftPos + "px");

      return this;
    }

    pin(arg) {
      if (this.hidden) return this;
      this.pinned = !this.pinned;
      if (arg != null) this.pinned = arg;
      this.element.select(".vzb-data-notes-close").classed("vzb-hidden", !this.pinned);
      this.element.classed("vzb-data-notes-pinned", this.pinned);
      this.element.select(".vzb-data-notes-body").node().scrollTop = 0;

      return this.showNotes ?
        this.setPos(this.left, this.top, true) :
        this.hide();
    }

    toggle(arg) {
      if (this.pinned) return this;
      if (arg == null) arg = !this.hidden;
      this.hidden = arg;
      this.element.classed("vzb-hidden", this.hidden || !this.showNotes);
      return this;
    }

    show() {
      return this.toggle(false);
    }

    hide() {
      return this.toggle(true);
    }

    close() {
      if (!this.hidden) {
        this.pin(false).hide();
      }
    }  

  }

  class DateTimeBackground extends BaseComponent {

    setup(conditions) {
      this.DOM = {
        svg: this.element.append("svg"),
      };
      this.DOM.group = this.DOM.svg.append("g");
      this.DOM.textEl = this.DOM.group.append("text").style("font-size", "20px");
      this.DOM.sampleTextEl = this.DOM.group.append("text").style("font-size", "20px").style("opacity", 0);
      
      this.element.classed("vzb-datetime-background", true);

      this.width = 0;
      this.height = 0;
      this.topOffset = 0;
      this.leftOffset = 0;
      this.bottomOffset = 0;
      this.rightOffset = 0;
      this.textWidth = 0;
      this.textHeight = 0;
      this.widthRatio = 0.9;
      this.heightRatio = 0.9;
      this.xAlign = "center";
      this.yAlign = "center";

      if (conditions) this.setConditions(conditions);
    }

    updateLayoutProfile(){
      this.services.layout.size; //watch

      //this.profileConstants = this.services.layout.getProfileConstants(PROFILE_CONSTANTS, PROFILE_CONSTANTS_FOR_PROJECTOR, this.state.positionInFacet);
      this.height = this.element.node().clientHeight || 0;
      this.width = this.element.node().clientWidth || 0;

      if (!this.height || !this.width) return warn("Chart _updateProfile() abort: container is too little or has display:none");
    }

    setConditions(conditions) {
      if (!isNaN(parseFloat(conditions.rightOffset)) && isFinite(conditions.rightOffset))
        this.rightOffset = conditions.rightOffset;
      
      if (!isNaN(parseFloat(conditions.leftOffset)) && isFinite(conditions.leftOffset))
        this.leftOffset = conditions.leftOffset;
      
      if (!isNaN(parseFloat(conditions.topOffset)) && isFinite(conditions.topOffset))
        this.topOffset = conditions.topOffset;
      
      if (!isNaN(parseFloat(conditions.bottomOffset)) && isFinite(conditions.bottomOffset))
        this.bottomOffset = conditions.bottomOffset;
      
      if (conditions.xAlign)
        this.xAlign = conditions.xAlign;
      
      if (conditions.yAlign)
        this.yAlign = conditions.yAlign;
      
      if (!isNaN(parseFloat(conditions.widthRatio)) && conditions.widthRatio > 0 && conditions.widthRatio <= 1)
        this.widthRatio = conditions.widthRatio;
      
      if (!isNaN(parseFloat(conditions.heightRatio)) && conditions.heightRatio > 0 && conditions.heightRatio <= 1)
        this.heightRatio = conditions.heightRatio;
      
      return this;
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame
      };
    }

    get duration(){
      //smooth animation is needed when playing, except for the case when time jumps from end to start
      if(!this.MDL.frame || !this.MDL.frame.playing) return 0;
      this.frameValue_1 = this.frameValue;
      this.frameValue = this.MDL.frame.value;
      return this.frameValue > this.frameValue_1 ? this.MDL.frame.speed : 0;
    }

    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);

      if (this.updateLayoutProfile()) return; //return if exists with error

      this.addReaction(this.updateText);
      this.addReaction(this.updateSize);
    }

    updateText() {
      this.setText(this.MDL.frame.value, this.duration);    
    }

    updateSize() {
      this.services.layout.size; //watch
      this._resizeText();
    }

    resizeText(width, height, topOffset, leftOffset) {
      this.width = parseInt(width, 10) || 0;
      this.height = parseInt(height, 10) || 0;

      if (topOffset) {
        this.topOffset = topOffset;
      }
      if (leftOffset) {
        this.leftOffset = leftOffset;
      }

      this._resizeText();
    }

    setText(text, delay = 0) {
      const {
        textEl,
        sampleTextEl
      } = this.DOM;

      text = this.localise(text);

      const callback = () => {
        sampleTextEl.text(text);
        this._resizeText();
        textEl.text(text);
      };

      const clear = () => {
        clearTimeout(this._text.timeout);
        delete this._text;
      };

      if (!delay) {
        if (this._text) {
          clear();
        }
        callback();
      } else {
        if (this._text) {
          this._text.callback();
          clear();
        }
        this._text = {
          callback,
          timeout: setTimeout(() => {
            callback();
            clear();
          }, delay)
        };
      }

      return this;
    }


    _resizeText() {
      const {
        textEl,
        sampleTextEl
      } = this.DOM;

      const bbox = sampleTextEl.node().getBBox();
      if (!bbox.width || !bbox.height || !this.width || !this.height) return this;

      // method from http://stackoverflow.com/a/22580176
      const widthTransform = this.width * this.widthRatio / bbox.width;
      const heightTransform = this.height * this.heightRatio / bbox.height;
      this.scalar = Math.min(widthTransform, heightTransform);
      textEl.attr("transform", "scale(" + this.scalar + ")");

      this.textHeight = bbox.height * this.scalar;
      this.textWidth = bbox.width * this.scalar;

      switch (this.yAlign) {
      case "bottom": textEl.attr("dy", ".325em"); break;
      case "center": textEl.attr("dy", ".325em"); break;
      case "top": textEl.attr("dy", "0"); break;
      }

      this.DOM.group.attr("transform", "translate(" + this._getLeftOffset() + "," + this._getTopOffset() + ")");

      return this;
    }

    _getLeftOffset() {
      switch (this.xAlign) {
      case "right":
        return this.width - this.textWidth / 2 - this.rightOffset;
      case "left":
        return this.textWidth / 2 + this.leftOffset;
      default :
        return this.width / 2;
      }
    }

    _getTopOffset() {
      switch (this.yAlign) {
      case "top":
        return this.textHeight / 2 + this.topOffset;
      case "bottom":
        return this.height - this.textHeight / 2 - this.bottomOffset;
      default :
        return this.height / 2;
      }
    }

  }

  const decorated$d = mobx.decorate(DateTimeBackground, {
    "MDL": mobx.computed,
    "duration": mobx.computed
  });

  function key(d) {return d[Symbol.for("key")];}

  const PROFILE_CONSTANTS$3 = {
    SMALL: {
      minLabelTextSize: 7,
      maxLabelTextSize: 21,
      defaultLabelTextSize: 12,
      closeCrossSize: 16 * 1.2,
      labelLeashCoeff: 0.4
    },
    MEDIUM: {
      minLabelTextSize: 7,
      maxLabelTextSize: 30,
      defaultLabelTextSize: 15,
      closeCrossSize: 20 * 1.2,
      labelLeashCoeff: 0.3
    },
    LARGE: {
      minLabelTextSize: 6,
      maxLabelTextSize: 48,
      defaultLabelTextSize: 20,
      closeCrossSize: 22 * 1.2,
      labelLeashCoeff: 0.2
    }
  };

  const PROFILE_CONSTANTS_FOR_PROJECTOR$3 = {
    MEDIUM: {
      minLabelTextSize: 15,
      maxLabelTextSize: 35,
      defaultLabelTextSize: 15,
      closeCrossSize: 26 * 1.2,
      labelLeashCoeff: 0.3
    },
    LARGE: {
      minLabelTextSize: 20,
      maxLabelTextSize: 55,
      defaultLabelTextSize: 20,
      closeCrossSize: 32 * 1.2,
      labelLeashCoeff: 0.2
    }
  };

  const OPTIONS$5 = {
    LABELS_CONTAINER_CLASS: "",
    LINES_CONTAINER_CLASS: "",
    LINES_CONTAINER_SELECTOR: "",
    CSS_PREFIX: "",
    SUPPRESS_HIGHLIGHT_DURING_PLAY: true
  };

  class Labels extends BaseComponent {

    setup(options){
      this.context = this.parent;

      this._xScale = null;
      this._yScale = null;
      this._closeCrossHeight = 0;
      this.labelSizeTextScale = null;
      
      this.cached = {};
      this.label = this.LABEL(this);

      this.options = extend({}, OPTIONS$5);
      if(options) this.setOptions(options);
      this.label.setCssPrefix(this.options.CSS_PREFIX);

      this.labelsContainer = this.context.element.select("." + this.options.LABELS_CONTAINER_CLASS);
      this.linesContainer = this.context.element.select("." + this.options.LINES_CONTAINER_CLASS);
      this.tooltipEl = this.labelsContainer
        .append("g").attr("class", this.options.CSS_PREFIX + "-tooltip");
    }

    setOptions(newOptions) {
      extend(this.options, newOptions);
    }

    get MDL() { 
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected.data.filter,
        highlighted: this.model.encoding.highlighted.data.filter,
        size: this.model.encoding.size,
        size_label: this.model.encoding.size_label,
        color: this.model.encoding.color,
        label: this.model.encoding.label
      };
    }

    draw() {
      this.addReaction(this._updateLayoutProfile);
      this.addReaction(this.selectDataPoints);
      this.addReaction(this.updateSizeTextScale);
      this.addReaction(this.updateLabelSizeLimits);
      this.addReaction(this.updateLabelsOnlyTextSize);
      this.addReaction(this.updateCloseCrossHeight);
      this.addReaction(this.updateTooltipFontSize);
    }

    updateLabelSizeLimits() {
      if (!this.MDL.size_label) return;

      this.services.layout.size;

      const extent = this.MDL.size_label.scale.extent || [0, 1];

      const minLabelTextSize = this.profileConstants.minLabelTextSize;
      const maxLabelTextSize = this.profileConstants.maxLabelTextSize;
      const minMaxDelta = maxLabelTextSize - minLabelTextSize;

      this.minLabelTextSize = Math.max(minLabelTextSize + minMaxDelta * extent[0], minLabelTextSize);
      this.maxLabelTextSize = Math.max(minLabelTextSize + minMaxDelta * extent[1], minLabelTextSize);

      if (this.MDL.size_label.data.isConstant) {
        // if(!this.MDL.size_label.which) {
        //   this.maxLabelTextSize = this.profileConstants.defaultLabelTextSize;
        //   this.MDL.size_label.set({'domainMax': (this.maxLabelTextSize - minLabelTextSize) / minMaxDelta, 'which': '_default'});
        //   return;
        // }
        if (extent[1] === null) {
          this.minLabelTextSize = this.maxLabelTextSize = this.profileConstants.defaultLabelTextSize;
        } else {
          this.minLabelTextSize = this.maxLabelTextSize;
        }
      }

      this.labelSizeTextScale.range([this.minLabelTextSize, this.maxLabelTextSize]);
    }

    updateSizeTextScale() {

      //scales
      if (this.MDL.size_label) {
        this.labelSizeTextScale = this.MDL.size_label.scale.d3Scale;
      }
    }

    setScales(xScale, yScale) {
      this._xScale = xScale;
      this._yScale = yScale;
    }

    updateCloseCrossHeight() {
      this.services.layout.size;
      const closeCrossHeight = this.profileConstants.closeCrossSize;

      if (this._closeCrossHeight != closeCrossHeight) {
        this._closeCrossHeight = closeCrossHeight;
        if (this.entityLabels)
          this.updateLabelCloseGroupSize(this.entityLabels.selectAll("." + this.options.CSS_PREFIX + "-label-x"), this._closeCrossHeight);
      }
    }

    xScale(x) {
      return this._xScale ? this._xScale(x) : (x * this.context.width);
    }

    yScale(y) {
      return this._yScale ? this._yScale(y) : (y * this.context.height);
    }

    selectDataPoints() {
      const _this = this;
      const _cssPrefix = this.options.CSS_PREFIX;

      //const select = _this.model.dataArray.filter(d => this.MDL.selected.has(d));
      const select = [...this.MDL.selected.markers.keys()]
        .filter(key => _this.model.dataMap.hasByStr(key))
        .map(selectedKey => ({[Symbol.for("key")]: selectedKey}));
      this.entityLabels = this.labelsContainer.selectAll("." + _cssPrefix + "-entity")
        .data(select, key);
      this.entityLines = this.linesContainer.selectAll("g.entity-line." + _cssPrefix + "-entity")
        .data(select, key);

      this.entityLabels.exit()
        .each(d => {
          if (_this.cached[key(d)] != null) {
            _this.cached[key(d)] = void 0;
          }
        })
        .remove();
      this.entityLines.exit()
        .remove();

      this.entityLines = this.entityLines
        .enter().insert("g", function(d) {
          return this.querySelector("." + _this.options.LINES_CONTAINER_SELECTOR_PREFIX + CSS.escape(key(d)));
        })
        .attr("class", (d) => _cssPrefix + "-entity entity-line line-" + key(d))
        .each(function() {
          _this.label.line(d3.select(this));
        })
        .merge(this.entityLines)
        .classed("vzb-hidden", !this.ui.enabled);

      this.entityLabels = this.entityLabels
        .enter().append("g")
        .attr("class", (d) => _cssPrefix + "-entity label-" + key(d))
        .each(function(d) {
          _this.cached[key(d)] = { _new: true };
          _this.label(d3.select(this));
        })
        .merge(this.entityLabels)
        .classed("vzb-hidden", !this.ui.enabled);
    
      Object.keys(this.ui.offset).forEach(key => {
        if (!this.MDL.selected.has(key)) {
          delete this.ui.offset[key];
        }
      });
    }

    showCloseCross(d, show) {
      //show the little cross on the selected label
      this.entityLabels
        .filter(f => d ? key(f) == key(d) : true)
        .select("." + this.options.CSS_PREFIX + "-label-x")
        .classed("vzb-transparent", !show || isTouchDevice());
    }

    highlight(d, highlight) {
      let labels = this.entityLabels;
      if (!labels) return;
      if (d) {
        labels = labels.filter(f => d ? key(f) == key(d) : true);
      }
      labels.classed("vzb-highlighted", highlight);
    }

    updateLabel(d, cache, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {
      const _this = this;
      if (key(d) == this.dragging) return;

      const _cssPrefix = this.options.CSS_PREFIX;

      // only for selected entities
      if (this.MDL.selected.has(d)  && this.entityLabels != null) {
        if (this.cached[key(d)] == null) this.selectDataPoints();

        const cached = this.cached[key(d)];
        if (cache) extend(cached, cache);


        if (cached.scaledS0 == null || cached.labelX0 == null || cached.labelY0 == null) { //initialize label once
          this._initNewCache(cached, valueX, valueY, valueS, valueC, valueL, valueLST);
        }

        if (cached.labelX_ == null || cached.labelY_ == null) {
          const labelOffset = this.ui.offset[key(d)];
          cached.labelOffset = (labelOffset && labelOffset.slice(0)) || [0, 0];
        }

        const brokenInputs = !cached.labelX0 && cached.labelX0 !== 0 || !cached.labelY0 && cached.labelY0 !== 0 || !cached.scaledS0 && cached.scaledS0 !== 0;

        const lineGroup = this.entityLines.filter(f => key(f) == key(d));
        // reposition label
        this.entityLabels.filter(f => key(f) == key(d))
          .each(function() {

            const labelGroup = d3.select(this);

            if (brokenInputs) {
              labelGroup.classed("vzb-invisible", brokenInputs);
              lineGroup.classed("vzb-invisible", brokenInputs);
              return;
            }

            const text = labelGroup.selectAll("." + _cssPrefix + "-label-content")
              .text(valueL || cached.labelText);

            _this._updateLabelSize(d, null, labelGroup, valueLST, text);

            _this.positionLabel(d, null, this, duration, showhide, lineGroup);
          });
      }
    }

    _initNewCache(cached, valueX, valueY, valueS, valueC, valueL, valueLST) {
      if (valueS || valueS === 0) cached.scaledS0 = areaToRadius(this.context.sScale(valueS));
      cached.valueS0 = valueS;
      cached.labelX0 = valueX;
      cached.labelY0 = valueY;
      cached.labelText = valueL;
      cached.valueLST = valueLST;
      cached.scaledC0 = valueC != null ? this.context.cScale(valueC) : this.context.COLOR_WHITEISH;
    }



    setTooltip(d, tooltipText, tooltipCache, labelValues) {
      if (tooltipText) {
        let position = 0;
        const _cssPrefix = this.options.CSS_PREFIX;
        this.tooltipEl.raise().text(null);
        this.label(this.tooltipEl, true);
        if (d) {
          const cache = {};
          this._initNewCache(cache, labelValues.valueX, labelValues.valueY, labelValues.valueS, labelValues.valueC, "", labelValues.valueLST);
          this.tooltipEl
            .classed(this.options.CSS_PREFIX + "-tooltip", false)
            .classed(this.options.CSS_PREFIX + "-entity", true)
            .selectAll("." + _cssPrefix + "-label-content")
            .text(labelValues.labelText);
          this._updateLabelSize(d, cache, this.tooltipEl, labelValues.valueLST);
          position = this.positionLabel(d, cache, this.tooltipEl.node(), 0, null, this.tooltipEl.select(".lineemptygroup"));
        }
        this.tooltipEl
          .classed(this.options.CSS_PREFIX + "-entity", false)
          .classed(this.options.CSS_PREFIX + "-tooltip", true)
          .selectAll("." + _cssPrefix + "-label-content")
          .text(tooltipText);
        this._updateLabelSize(d, tooltipCache, this.tooltipEl, null);
        this.positionLabel(d, tooltipCache, this.tooltipEl.node(), 0, null, this.tooltipEl.select(".lineemptygroup"), position);
      } else {
        this.tooltipEl.text(null);
      }
    }

    updateTooltipFontSize() {
      this.services.layout.size;
      this.tooltipEl.style("font-size", this.profileConstants.defaultLabelTextSize);
    }

    _updateLabelSize(d, cache, labelGroup, valueLST, text) {
      const _this = this;
      const cached = cache || _this.cached[key(d)];


      const _cssPrefix = this.options.CSS_PREFIX;

      const labels = this.root.ui.chart.labels;
      labelGroup.classed("vzb-label-boxremoved", labels.removeLabelBox);

      const _text = text || labelGroup.selectAll("." + _cssPrefix + "-label-content");

      if (_this.labelSizeTextScale) {
        if (valueLST != null) {
          const range = _this.labelSizeTextScale.range();
          const fontSize = range[0] + Math.sqrt((_this.labelSizeTextScale(valueLST) - range[0]) * (range[1] - range[0]));
          _text.attr("font-size", fontSize + "px");
          cached.fontSize = fontSize;
          if (!cached.initFontSize) cached.initFontSize = fontSize;
        } else {
          _text.attr("font-size", null);
          cached.fontSize = parseFloat(_text.style("font-size"));
          if (!cached.initFontSize) cached.initFontSize = cached.fontSize;
        }
      } else {
        cached.fontSize = parseFloat(_text.style("font-size"));
        if (!cached.initFontSize) cached.initFontSize = cached.fontSize;
      }

      let contentBBox;
      //if (!cached.initTextBBox) {
      //turn off stroke because ie11/edge return stroked bounding box for text
      _text.style("stroke", "none");
      cached.initTextBBox = _text.node().getBBox();
      _text.style("stroke", null);
      contentBBox = cached.textBBox = {
        width: cached.initTextBBox.width,
        height: cached.initTextBBox.height
      };
      //}

      const scale = 1;//cached.fontSize / cached.initFontSize;

      cached.textBBox.width = cached.initTextBBox.width * scale;
      cached.textBBox.height = cached.initTextBBox.height * scale;

      contentBBox = cached.textBBox;

      const rect = labelGroup.selectAll("rect");

      if (!cached.textWidth || cached.textWidth != contentBBox.width) {
        cached.textWidth = contentBBox.width;

        const labelCloseHeight = _this._closeCrossHeight || contentBBox.height;

        const isRTL = _this.services.locale.isRTL();
        const labelCloseGroup = labelGroup.select("." + _cssPrefix + "-label-x")
          .attr("transform", "translate(" + (isRTL ? -contentBBox.width - 4 : 4) + "," + (-contentBBox.height * 0.85) + ")");

        this.updateLabelCloseGroupSize(labelCloseGroup, labelCloseHeight);

        //cache label bound rect for reposition
        const rectBBox = cached.rectBBox = {
          x: -contentBBox.width - 4,
          y: -contentBBox.height * 0.85,
          width: contentBBox.width + 8,
          height: contentBBox.height * 1.2
        };
        cached.rectOffsetX = rectBBox.width + rectBBox.x;
        cached.rectOffsetY = rectBBox.height + rectBBox.y;

        rect.attr("width", rectBBox.width)
          .attr("height", rectBBox.height)
          .attr("x", rectBBox.x)
          .attr("y", rectBBox.y)
          .attr("rx", contentBBox.height * 0.2)
          .attr("ry", contentBBox.height * 0.2);
      }

      const glowRect = labelGroup.select(".vzb-label-glow");
      if (glowRect.attr("stroke") !== cached.scaledC0) {
        glowRect.attr("stroke", cached.scaledC0);
      }
    }

    updateLabelCloseGroupSize(labelCloseGroup, labelCloseHeight) {
      labelCloseGroup.select("circle")
        .attr("cx", /*contentBBox.height * .0 + */ 0)
        .attr("cy", 0)
        .attr("r", labelCloseHeight * 0.5);

      labelCloseGroup.select("svg")
        .attr("x", -labelCloseHeight * 0.5)
        .attr("y", labelCloseHeight * -0.5)
        .attr("width", labelCloseHeight)
        .attr("height", labelCloseHeight);

    }

    updateLabelsOnlyTextSize() {
      const _this = this;
      this.MDL.size_label.scale.extent;
      this.services.layout.size;

      mobx.runInAction(() => {
        this.entityLabels.each(function(d) {
          _this._updateLabelSize(d, null, d3.select(this), _this.model.dataMap.getByStr(d[Symbol.for("key")]).size_label);
          if (_this.cached[key(d)]._new) return;
          const lineGroup = _this.entityLines.filter(f => key(f) == key(d));
          _this.positionLabel(d, null, this, 0, null, lineGroup);
        });
      });
    }

    updateLabelOnlyPosition(d, index, cache) {
      const _this = this;
      const cached = this.cached[key(d)];
      if (cache) extend(cached, cache);

      const lineGroup = _this.entityLines.filter(f => key(f) == key(d));

      this.entityLabels.filter(f => key(f) == key(d))
        .each(function() {
          _this.positionLabel(d, null, this, 0, null, lineGroup);
        });
    }

    updateLabelOnlyColor(d, index, cache) {
      const _this = this;
      const cached = this.cached[key(d)];
      if (cache) extend(cached, cache);

      const labelGroup = _this.entityLabels.filter(f => key(f) == key(d));

      _this._updateLabelSize(d, null, labelGroup, null);

    }

    positionLabel(d, cache, context, duration, showhide, lineGroup, position) {
      if (key(d) == this.dragging) return;
      
      const cached = cache || this.cached[key(d)];

      const lockPosition = (position || position === 0);
      const hPos = (position || 0) & 1;
      const vPos = ((position || 0) & 2) >> 1;
      let hPosNew = 0;
      let vPosNew = 0;
      const viewWidth = this.context.width;
      const viewHeight = this.context.height;

      const resolvedX0 = this.xScale(cached.labelX0);
      const resolvedY0 = this.yScale(cached.labelY0);

      const offsetX = cached.rectOffsetX;
      const offsetY = cached.rectOffsetY;

      if (!cached.labelOffset) cached.labelOffset = [0, 0];

      cached.labelX_ = cached.labelOffset[0] || (-cached.scaledS0 * 0.75 - offsetX) / viewWidth;
      cached.labelY_ = cached.labelOffset[1] || (-cached.scaledS0 * 0.75 - offsetY) / viewHeight;

      //check default label position and switch to mirror position if position
      //does not bind to visible field
      let resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
      let resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
      if (cached.labelOffset[0] + cached.labelOffset[1] == 0) {
        if ((!lockPosition && (resolvedY - cached.rectBBox.height + offsetY <= 0)) || vPos) { // check top
          vPosNew = 1;
          cached.labelY_ = (cached.scaledS0 * 0.75 + cached.rectBBox.height - offsetY) / viewHeight;
          resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
        }
        //  else if (resolvedY + 10 > viewHeight) { //check bottom
        //   cached.labelY_ = (viewHeight - 10 - resolvedY0) / viewHeight;
        //   resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
        // }

        if ((!lockPosition && (resolvedX - cached.rectBBox.width + offsetX <= 0)) || hPos) { //check left
          hPosNew = 1;
          cached.labelX_ = (cached.scaledS0 * 0.75 + cached.rectBBox.width - offsetX) / viewWidth;
          resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
          if (resolvedX > viewWidth) {
            hPosNew = 0;
            vPosNew = (vPosNew == 0 && (resolvedY0 - offsetY * 0.5 - cached.scaledS0) < cached.rectBBox.height) ? 1 : vPosNew;
            cached.labelY_ = vPosNew ? -offsetY * 0.5 + cached.rectBBox.height + cached.scaledS0 : -offsetY * 1.5 - cached.scaledS0;
            cached.labelY_ /= viewHeight;
            resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
            cached.labelX_ = (cached.rectBBox.width - offsetX - resolvedX0) / viewWidth;
            resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
          }

        }
        //  else if (resolvedX + 15 > viewWidth) { //check right
        //   cached.labelX_ = (viewWidth - 15 - resolvedX0) / viewWidth;
        //   resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
        // }
      }

      if (lockPosition) {
        let topCornerCase = false;
        if (resolvedX - cached.rectBBox.width + offsetX <= 0) {
          const deltaX = resolvedX0 - cached.rectBBox.width;
          const deltaY = deltaX > 0 ? cathetus(cached.scaledS0, deltaX) : cached.scaledS0;
          resolvedY = vPosNew ?
            resolvedY0 + cached.rectBBox.height - offsetY * 0.5 + deltaY
            :
            resolvedY0 - offsetY * 1.5 - deltaY;
          if (resolvedY - cached.rectBBox.height < 0) {
            topCornerCase = true;
          }
        }
        if (resolvedY - cached.rectBBox.height + offsetY <= 0) {
          const deltaY = resolvedY0 - cached.rectBBox.height;
          const deltaX = deltaY > 0 ? cathetus(cached.scaledS0, deltaY) : cached.scaledS0;
          resolvedX = hPosNew ?
            resolvedX0 + cached.rectBBox.width + deltaX
            :
            resolvedX0 - offsetX * 2 - deltaX;
          if (resolvedX - cached.rectBBox.width < 0 || resolvedX > viewWidth) {
            topCornerCase = true;
          }
        }
        if (topCornerCase) {
          vPosNew++;
          const deltaX = resolvedX0 - cached.rectBBox.width;
          resolvedY = resolvedY0 + cached.rectBBox.height - offsetY * 0.5 + (deltaX > 0 ? cathetus(cached.scaledS0, deltaX) : cached.scaledS0);
        }
      }

      this.label._repositionLabels(d, cache, context, resolvedX, resolvedY, resolvedX0, resolvedY0, duration, showhide, lineGroup);

      return vPosNew * 2 + hPosNew;
    }

    _updateLayoutProfile(){
      this.services.layout.size;

      this.profileConstants = this.services.layout.getProfileConstants(PROFILE_CONSTANTS$3, PROFILE_CONSTANTS_FOR_PROJECTOR$3);
      this.height = (this.element.node().clientHeight) || 0;
      this.width = (this.element.node().clientWidth) || 0;
      if (!this.height || !this.width) return warn("Chart _updateProfile() abort: container is too little or has display:none");
    }





    LABEL(context) {

      return (function d3_label() {

        const _this = context;

        let _cssPrefix;
        label.setCssPrefix = function(cssPrefix) {
          _cssPrefix = cssPrefix;
          return label;
        };

        const labelDragger = d3.drag()
          .on("start", event => {
            event.sourceEvent.stopPropagation();
          })
          .on("drag", function(event, d) {
            if (!_this.ui.dragging) return;
            if (!_this.dragging) _this.dragging = key(d);
            const cache = _this.cached[key(d)];
            cache.labelFixed = true;

            const viewWidth = _this.context.width;
            const viewHeight = _this.context.height;

            cache.labelX_ += event.dx / viewWidth;
            cache.labelY_ += event.dy / viewHeight;

            const resolvedX = _this.xScale(cache.labelX0) + cache.labelX_ * viewWidth;
            const resolvedY = _this.yScale(cache.labelY0) + cache.labelY_ * viewHeight;

            const resolvedX0 = _this.xScale(cache.labelX0);
            const resolvedY0 = _this.yScale(cache.labelY0);

            const lineGroup = _this.entityLines.filter(f => key(f) == key(d));

            label._repositionLabels(d, null, this, resolvedX, resolvedY, resolvedX0, resolvedY0, 0, null, lineGroup);
          })
          .on("end", (event, d) => {
            if (_this.dragging) {
              const cache = _this.cached[key(d)];
              _this.dragging = null;
              cache.labelOffset[0] = cache.labelX_;
              cache.labelOffset[1] = cache.labelY_;
              //marker model is a wrong place to save those, maybe labels ui is a better place
              //in form of this.ui.offset = {"geo-afg":[dx, dy]} 
              //_this.model.setLabelOffset(d, [cache.labelX_, cache.labelY_]);
              _this.ui.offset = Object.assign(_this.ui.offset, {[key(d)]: [cache.labelX_, cache.labelY_]});
              //_this.ui.offset[key(d)] = [cache.labelX_, cache.labelY_];
              //_this.ui.offset = {[key(d)]: [cache.labelX_, cache.labelY_]};
            }
          });

        function label(container, isTooltip) {

          container
            .each(function(d) {
              const view = d3.select(this);

              // Ola: Clicking bubble label should not zoom to countries boundary #811
              // It's too easy to accidentally zoom
              // This feature will be activated later, by making the label into a "context menu" where users can click Split, or zoom,.. hide others etc....

              view.append("rect")
                .attr("class", "vzb-label-glow")
                .attr("filter", `url(#vzb-glow-filter-${_this.parent.id})`);
              view.append("rect")
                .attr("class", "vzb-label-fill vzb-tooltip-border");
              //          .on("click", function(event, d) {
              //            //default prevented is needed to distinguish click from drag
              //            if(event.defaultPrevented) return;
              //
              //            var maxmin = _this.cached[key(d)].maxMinValues;
              //            var radius = utils.areaToRadius(_this.sScale(maxmin.valueSmax));
              //            _this._panZoom._zoomOnRectangle(_this.element,
              //              _this.xScale(maxmin.valueXmin) - radius,
              //              _this.yScale(maxmin.valueYmin) + radius,
              //              _this.xScale(maxmin.valueXmax) + radius,
              //              _this.yScale(maxmin.valueYmax) - radius,
              //              false, 500);
              //          });

              const text = view.append("text").attr("class", _cssPrefix + "-label-content stroke");
              if (!view.style("paint-order").length) {
                view.insert("text", `.${_cssPrefix}-label-content`)
                  .attr("class", _cssPrefix + "-label-content " + _cssPrefix + "-label-shadow vzb-noexport");

                text.classed("stroke", false);
              }

              if (!isTooltip) {
                const cross = view.append("g").attr("class", _cssPrefix + "-label-x vzb-transparent");
                setIcon(cross, ICON_CLOSE);

                cross.insert("circle", "svg");

                cross.select("svg")
                  .attr("class", _cssPrefix + "-label-x-icon")
                  .attr("width", "0px")
                  .attr("height", "0px");

                cross.on("click", event => {
                  //default prevented is needed to distinguish click from drag
                  if (event.defaultPrevented) return;
                  event.stopPropagation();
                  _this.MDL.highlighted.delete(d);
                  _this.MDL.selected.delete(d);
                });
              }

            });

          if (!isTooltip) {
            container
              .call(labelDragger)
              .on("mouseenter", function(event, d) {
                if (isTouchDevice() || _this.dragging) return;
                _this.MDL.highlighted.set(d);
                // hovered label should be on top of other labels: if "a" is not the hovered element "d", send "a" to the back
                _this.entityLabels.sort((a) => key(a) != key(d) ? -1 : 1);
                d3.select(this).selectAll("." + _cssPrefix + "-label-x")
                  .classed("vzb-transparent", false);
              })
              .on("mouseleave", function(event, d) {
                if (isTouchDevice() || _this.dragging) return;
                _this.MDL.highlighted.delete(d);
                d3.select(this).selectAll("." + _cssPrefix + "-label-x")
                  .classed("vzb-transparent", true);
              })
              .on("click", function(event, d) {
                if (!isTouchDevice()) return;
                const cross = d3.select(this).selectAll("." + _cssPrefix + "-label-x");
                const hidden = cross.classed("vzb-transparent");
                if (hidden) {
                  // hovered label should be on top of other labels: if "a" is not the hovered element "d", send "a" to the back
                  _this.entityLabels.sort((a) => key(a) != key(d) ? -1 : 1);
                  _this.showCloseCross(null, false);
                }
                cross.classed("vzb-transparent", !hidden);
                if (!_this.options.SUPPRESS_HIGHLIGHT_DURING_PLAY || !_this.MDL.frame.playing) {
                  if (hidden) {
                    _this.MDL.highlighted.set(d);
                  } else {
                    _this.MDL.highlighted.delete(d);
                  }
                }
              });
          }

          return label;
        }

        label.line = function(container) {
          container.append("line").attr("class", _cssPrefix + "-label-line");
        };


        label._repositionLabels = _repositionLabels;
        function _repositionLabels(d, _cache, labelContext, _X, _Y, _X0, _Y0, duration, showhide, lineGroup) {

          const cache = _cache || _this.cached[key(d)];

          const labelGroup = d3.select(labelContext);

          //protect label and line from the broken data
          const brokenInputs = !_X && _X !== 0 || !_Y && _Y !== 0 || !_X0 && _X0 !== 0 || !_Y0 && _Y0 !== 0;
          if (cache.brokenInputs || brokenInputs) {
            cache.brokenInputs = brokenInputs;
            labelGroup.classed("vzb-invisible", brokenInputs);
            lineGroup.classed("vzb-invisible", brokenInputs);
            return;
          }

          const viewWidth = _this.context.width;
          const viewHeight = _this.context.height;
          const rectBBox = cache.rectBBox;
          const height = rectBBox.height;
          const offsetX = cache.rectOffsetX;
          const offsetY = cache.rectOffsetY;

          //apply limits so that the label doesn't stick out of the visible field
          if (_X + rectBBox.x <= 0) { //check left
            _X = -rectBBox.x;
            cache.labelX_ = (_X - _this.xScale(cache.labelX0)) / viewWidth;
          } else if (_X + offsetX > viewWidth) { //check right
            _X = viewWidth - offsetX;
            cache.labelX_ = (_X - _this.xScale(cache.labelX0)) / viewWidth;
          }
          if (_Y + rectBBox.y <= 0) { // check top
            _Y = -rectBBox.y;
            cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
          } else if (_Y + offsetY > viewHeight) { //check bottom
            _Y = viewHeight - offsetY;
            cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
          }
          // if (_Y - height * 0.75 <= 0) { // check top
          //   _Y = height * 0.75;
          //   cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
          // } else if (_Y + height * 0.35 > viewHeight) { //check bottom
          //   _Y = viewHeight - height * 0.35;
          //   cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
          // }

          if (duration == null) duration = _this.context.duration;
          if (cache._new) {
            duration = 0;
            delete cache._new;
          }
          if (duration) {
            if (showhide && !d.hidden) {
              //if need to show label

              labelGroup.classed("vzb-invisible", d.hidden);
              labelGroup
                .attr("transform", "translate(" + _X + "," + _Y + ")")
                .style("opacity", 0)
                .transition().duration(duration).ease(d3.easeExp)
                .style("opacity", 1)
              //i would like to set opactiy to null in the end of transition.
              //but then fade in animation is not working for some reason
                .on("interrupt", () => {
                  labelGroup
                    .style("opacity", 1);
                });
              lineGroup.classed("vzb-invisible", d.hidden);
              lineGroup
                .attr("transform", "translate(" + _X + "," + _Y + ")")
                .style("opacity", 0)
                .transition().duration(duration).ease(d3.easeExp)
                .style("opacity", 1)
              //i would like to set opactiy to null in the end of transition.
              //but then fade in animation is not working for some reason
                .on("interrupt", () => {
                  lineGroup
                    .style("opacity", 1);
                });

            } else if (showhide && d.hidden) {
              //if need to hide label

              labelGroup
                .style("opacity", 1)
                .transition().duration(duration).ease(d3.easeExp)
                .style("opacity", 0)
                .on("end", () => {
                  labelGroup
                    .style("opacity", 1) //i would like to set it to null. but then fade in animation is not working for some reason
                    .classed("vzb-invisible", d.hidden);
                });
              lineGroup
                .style("opacity", 1)
                .transition().duration(duration).ease(d3.easeExp)
                .style("opacity", 0)
                .on("end", () => {
                  lineGroup
                    .style("opacity", 1) //i would like to set it to null. but then fade in animation is not working for some reason
                    .classed("vzb-invisible", d.hidden);
                });

            } else {
              // just update the position

              labelGroup
                .transition().duration(duration).ease(d3.easeLinear)
                .attr("transform", "translate(" + _X + "," + _Y + ")");
              lineGroup
                .transition().duration(duration).ease(d3.easeLinear)
                .attr("transform", "translate(" + _X + "," + _Y + ")");
            }

          } else {
            labelGroup
              .interrupt()
              .attr("transform", "translate(" + _X + "," + _Y + ")")
              .transition();
            lineGroup
              .interrupt()
              .attr("transform", "translate(" + _X + "," + _Y + ")")
              .transition();
            if (showhide) labelGroup.classed("vzb-invisible", d.hidden);
            if (showhide) lineGroup.classed("vzb-invisible", d.hidden);
          }

          const diffX1 = _X0 - _X;
          const diffY1 = _Y0 - _Y;
          const textBBox = cache.textBBox;
          let diffX2 = -textBBox.width * 0.5;
          let diffY2 = -height * 0.2;
          const labels = _this.root.ui.chart.labels;

          const bBox = labels.removeLabelBox ? textBBox : rectBBox;

          const FAR_COEFF = _this.profileConstants.labelLeashCoeff || 0;

          const lineHidden = circleRectIntersects({ x: diffX1, y: diffY1, r: cache.scaledS0 },
            { x: diffX2, y: diffY2, width: (bBox.height * 2 * FAR_COEFF + bBox.width), height: (bBox.height * (2 * FAR_COEFF + 1)) });
          lineGroup.select("line").classed("vzb-invisible", lineHidden);
          if (lineHidden) return;

          if (labels.removeLabelBox) {
            const angle = Math.atan2(diffX1 - diffX2, diffY1 - diffY2) * 180 / Math.PI;
            const deltaDiffX2 = (angle >= 0 && angle <= 180) ? (bBox.width * 0.5) : (-bBox.width * 0.5);
            const deltaDiffY2 = (Math.abs(angle) <= 90) ? (bBox.height * 0.55) : (-bBox.height * 0.45);
            diffX2 += Math.abs(diffX1 - diffX2) > textBBox.width * 0.5 ? deltaDiffX2 : 0;
            diffY2 += Math.abs(diffY1 - diffY2) > textBBox.height * 0.5 ? deltaDiffY2 : (textBBox.height * 0.05);
          }

          const longerSideCoeff = Math.abs(diffX1) > Math.abs(diffY1) ? Math.abs(diffX1) : Math.abs(diffY1);
          lineGroup.select("line").style("stroke-dasharray", "0 " + (cache.scaledS0) + " " + ~~(longerSideCoeff) * 2);

          if (duration) {
            lineGroup.selectAll("line")
              .transition().duration(duration).ease(d3.easeLinear)
              .attr("x1", diffX1)
              .attr("y1", diffY1)
              .attr("x2", diffX2)
              .attr("y2", diffY2);
          } else {
            lineGroup.selectAll("line")
              .interrupt()
              .attr("x1", diffX1)
              .attr("y1", diffY1)
              .attr("x2", diffX2)
              .attr("y2", diffY2)
              .transition();
          }

        }

        /*
        * Adapted from
        * http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection
        *
        * circle {
        *  x: center X
        *  y: center Y
        *  r: radius
        * }
        *
        * rect {
        *  x: center X
        *  y: center Y
        *  width: width
        *  height: height
        * }
        */
        function circleRectIntersects(circle, rect) {
          const circleDistanceX = Math.abs(circle.x - rect.x);
          const circleDistanceY = Math.abs(circle.y - rect.y);
          const halfRectWidth = rect.width * 0.5;
          const halfRectHeight = rect.height * 0.5;

          if (circleDistanceX > (halfRectWidth + circle.r)) { return false; }
          if (circleDistanceY > (halfRectHeight + circle.r)) { return false; }

          if (circleDistanceX <= halfRectWidth) { return true; }
          if (circleDistanceY <= halfRectHeight) { return true; }

          const cornerDistance_sq = Math.pow(circleDistanceX - halfRectWidth, 2) +
                              Math.pow(circleDistanceY - halfRectHeight, 2);

          return (cornerDistance_sq <= Math.pow(circle.r, 2));
        }

        return label;
      })();
    }
  }


  Labels.DEFAULT_UI = {
    offset: () => ({}),
    enabled: true,
    dragging: true,
    removeLabelBox: false
  };

  const decorated$c = mobx.decorate(Labels, {
    "MDL": mobx.computed
  });

  function getFacetId(d) {
    return d;
  }

  function firstLastOrMiddle$1(index, total) {
    return { first: index === 0, last: index + 1 === total };
  }
  class _Facet extends BaseComponent {

    setup(options) {
      this.direction = this.options.direction || "row";   
      super.setup(options);
    }

    get MDL() {
      return this.model;
    }


    loading() {
      //this.addReaction(this.addRemoveSubcomponents, true);
    }

    draw() {

      if (this.updateLayoutProfile()) return; //return if exists with error
      this.addReaction(this.addRemoveSubcomponents);
      this.addReaction(this.updatePositionInRepeat);
      this.addReaction(this.updateSize);
    }

    updatePositionInRepeat() {
      this.children.forEach(child => child.state.positionInRepeat = this.state.positionInRepeat);
    }

    getDataForSubcomponent(id) {
      return [...this.data.get(id).values()];
    }

    sortFacets(map){
      return new Map([...map].sort((a, b) => {
        if (a[0].includes("is--")) return -1;
        if (b[0].includes("is--")) return 1;
      }));
    }

    get data() {
      const encoding = "facet_" + this.direction; 
      return this.sortFacets(this.model.dataMap.groupByWithMultiGroupMembership(encoding));
    }

    howManyFacets() {
      return this.data.size;
    }

    isRowDirection() {
      return this.direction == "row";
    }

    get maxValues() {
      let result;
      mobx.runInAction(() => { //prevent observing of this.data
        result = [...this.data.keys()].map(k => [k, null]);
      });
      return mobx.observable.map(result);
    }

    getScaleDomainForSubcomponent(id) {
      if (id)
        return this.maxValues.get(id) || 0;
      else
        return d3.sum(this.maxValues.values());
    }

    updateLayoutProfile() {
      this.services.layout.size; //watch

      this.profileConstants = this.services.layout.getProfileConstants(
        this.options.facetedComponent.PROFILE_CONSTANTS , 
        this.options.facetedComponent.PROFILE_CONSTANTS_FOR_PROJECTOR
      );
      this.height = this.element.node().clientHeight || 0;
      this.width = this.element.node().clientWidth || 0;

      if (!this.height || !this.width) return warn("Chart _updateProfile() abort: container is too little or has display:none");
    }

    propagateInteractivity(callback){
      this.children.forEach(chart => callback(chart));
    }

    get largetstFacetId(){
      if(this.ui.inpercent){
        return [...this.maxValues.keys()].at(-1);
      } else {
        const largest = {k: null, v: 0};
        [...this.maxValues.entries()].forEach(([k,v]) => {if(v > largest.v) {largest.v = v; largest.k = k;}});
        return largest.k;
      }
    }

    updateSize() {
      this.services.layout.size; //watch
      this.services.layout.projector; //watch
      this.ui.inpercent;

      const isRowDirection = this.isRowDirection();
      const facetKeys = [...this.maxValues.keys()];
      const domainParts = [...this.maxValues.values()];
      const {
        margin,
        minHeight = 1,
        minWidth = 1
      } = this.profileConstants;

      const minPx = (isRowDirection ? minHeight : minWidth);
      const betweenPx = (isRowDirection ? margin.betweenRow : margin.betweenColumn) || 0;
      const totalPx = (isRowDirection ? (this.height - margin.top - margin.bottom) : (this.width - margin.left - margin.right)) - betweenPx * (facetKeys.length - 1);

      const getUpdateStr = () => JSON.stringify(facetKeys) + JSON.stringify(domainParts) + minPx + totalPx + this.ui.inpercent;
      if(getUpdateStr() === this.resizeUpdateString) return;
      this.resizeUpdateString = getUpdateStr();

      let rangeParts = domainParts.map(() => null);

      if (this.ui.inpercent){
        const domainPartsSum = d3.sum(domainParts);
        this.scaleRange = totalPx / domainParts.length < minPx ? minPx : totalPx / domainParts.length;
        rangeParts = domainParts.map(domain => Math.round(totalPx * domain / domainPartsSum));
      } else {
        let maxIter = 5;
        let unallocatedDomain, unallocatedRange, residual = totalPx, allChartsSmall = false;
        const proportion = i => unallocatedRange * domainParts[i] / unallocatedDomain;   

        for(let iterate = 0; iterate < maxIter && residual > 1 && !allChartsSmall; iterate++){
          unallocatedRange = totalPx - d3.sum(rangeParts.filter(f => f == minPx));
          unallocatedDomain = d3.sum(domainParts.filter((f, i) => rangeParts[i] != minPx)); 
          rangeParts = rangeParts.map((r, i) => (r == minPx || proportion(i) < minPx) ? minPx : Math.floor(proportion(i)));
          allChartsSmall = rangeParts.every(e => e == minPx);
          residual = d3.sum(rangeParts) - totalPx;
        }
        
        const wastedHelperScale = d3.scaleLinear().domain([0, d3.max(domainParts)]).range([0, d3.max(rangeParts)]);
        const wastedRange = d3.sum(rangeParts.map((r, i) => r - wastedHelperScale(domainParts[i])));  
        this.scaleRange = totalPx - wastedRange;
      }

      const last = this.howManyFacets() - 1;
      const first = 0;
      const dominantMargin = {
        first: isRowDirection ? margin.top : margin.left,
        last: isRowDirection ? margin.bottom : margin.right
      };
      const non_dominantMargin = {
        first: !isRowDirection ? margin.top : margin.left,
        last: !isRowDirection ? margin.bottom : margin.right
      };
      
      const templateString = {
        dominant: rangeParts
          .map((rangePart, i) => ""
            + `[start_${i}]` 
            + (i == first ? ` ${dominantMargin.first}px ` : ` ${betweenPx * 0.5}px `)
            + ` ${rangePart || 1}px `
            + (i == last ? ` ${dominantMargin.last}px ` : ` ${betweenPx * 0.5}px `)
            + `[end_${i}]`
          )
          .join(" 0px "),
        non_dominant: ""
          + `[start_0]`
          + ` ${non_dominantMargin.first}px `
          + ` 1fr `
          + ` ${non_dominantMargin.last}px `
          + `[end_0]`
      };

      this.element
        .style("grid-template-columns", templateString[isRowDirection ? "non_dominant" : "dominant"])
        .style("grid-template-rows", templateString[isRowDirection ? "dominant" : "non_dominant"]);

      this.rangePartsHash = rangeParts.join(",");
    }

    addRemoveSubcomponents() {
      const { facetedComponentCssClass } = this.options;

      const facetKeys = [...this.data.keys()];

      if(JSON.stringify(facetKeys) === this.facetKeysString) return;
      this.facetKeysString = JSON.stringify(facetKeys);

      const isRowDirection = this.isRowDirection();

      mobx.runInAction(() => {
        let sections = this.element.selectAll(".vzb-facet-inner")
          .data(facetKeys, getFacetId);

        sections.exit()
          .each(d => this.removeSubcomponent(d))
          .remove();

        sections.enter().append("div")
          .attr("class", "vzb-facet-inner")
          //add an intermediary div with null datum to prevent unwanted data inheritance to subcomponent
          //https://stackoverflow.com/questions/17846806/preventing-unwanted-data-inheritance-with-selection-select
          .each(function (d) {
            d3.select(this).append("div")
              .datum(null)
              .attr("class", () => `${facetedComponentCssClass} vzb-${getFacetId(d)}`);
          })
          .each((d, i) => this.addSubcomponent(d, i))
          .merge(sections)
          .style("grid-row-start", (d, i) => "start_" + (isRowDirection ? i : 0))
          .style("grid-row-end", (d, i) => "end_" + (isRowDirection ? i : 0))
          .style("grid-column-start", (d, i) => "start_" + (isRowDirection ? 0 : i))
          .style("grid-column-end", (d, i) => "end_" + (isRowDirection ? 0 : i))

          .classed("vzb-facet-row-first", d => this.getPosition(facetKeys.indexOf(d)).row.first)
          .classed("vzb-facet-row-last", d => this.getPosition(facetKeys.indexOf(d)).row.last)
          .classed("vzb-facet-column-first", d => this.getPosition(facetKeys.indexOf(d)).column.first)
          .classed("vzb-facet-column-last", d => this.getPosition(facetKeys.indexOf(d)).column.last)
          .each((d) => {
            this.findChild({ name: getFacetId(d) }).state.positionInFacet = this.getPosition(facetKeys.indexOf(d));
          });

        this.services.layout._resizeHandler();
      });
    }

    getPosition(i) {
      const isRowDirection = this.isRowDirection();
      const ncolumns = isRowDirection ? 1 : [...this.data.keys()].length;
      const nrows =  isRowDirection ? [...this.data.keys()].length : 1;
      const result = {
        row: firstLastOrMiddle$1(isRowDirection ? i : 0, nrows),
        column: firstLastOrMiddle$1(isRowDirection ? 0 : i, ncolumns)
      };

      result.row.start = (result.row.first ? 0 : (i + 1)) + 1; //+1 is correction for 1-based numbers in css vs 0-based in array index
      result.row.end = (result.row.last ? (nrows + 2) : (i + 2)) + 1;
      result.column.start = (result.column.first ? 0 : (i + 1)) + 1; //+1 is correction for 1-based numbers in css vs 0-based in array index
      result.column.end = (result.column.last ? (ncolumns + 2) : (i + 2)) + 1;

      return result;
    }

    addSubcomponent(d, index) {
      const { facetedComponent } = this.options;
      const name = getFacetId(d);

      const subcomponent = new facetedComponent({
        id: this.id + "-" + index,
        placeholder: ".vzb-" + name,
        model: this.model,
        name,
        parent: this,
        root: this.root,
        state: {
          alias: this.state.alias,
          positionInRepeat: this.state.positionInRepeat
        },
        services: this.services,
        ui: this.ui,
        default_ui: this.DEFAULT_UI
      });
      this.children.push(subcomponent);
    }


    removeSubcomponent(d) {
      const subcomponent = this.findChild({ name: getFacetId(d) });
      if (subcomponent) {
        subcomponent.deconstruct();
        const index = this.children.indexOf(subcomponent);
        if (index >= 0) this.children.splice(index, 1);
      }
    }
  }

  _Facet.DEFAULT_UI = {
  };

  const Facet = mobx.decorate(_Facet, {
    "MDL": mobx.computed,
    "data": mobx.computed,
    "scaleRange": mobx.observable,
    "maxValues": mobx.computed,
    "largetstFacetId": mobx.computed,
    "rangePartsHash": mobx.observable
  });

  let hidden$2 = true;
  const HIDE_WHEN_SMALLER_THAN = 100; //px
  class _DataWarning extends BaseComponent {
    constructor(config) {
      config.template = `
      <div class="vzb-data-warning-background"></div>
      <div class="vzb-data-warning-box">
        <div class="vzb-data-warning-link"></div>
        <div class="vzb-data-warning-title"></div>
        <div class="vzb-data-warning-body vzb-dialog-scrollable"></div>
      </div>
    `;

      super(config);
    }

    setup() {
      this.DOM = {
        background: this.element.select(".vzb-data-warning-background"),
        container: this.element.select(".vzb-data-warning-box"),
        icon: this.element.select(".vzb-data-warning-link"),
        close: this.element.select(".vzb-data-warning-close"),
        title: this.element.select(".vzb-data-warning-title"),
        body: this.element.select(".vzb-data-warning-body"),
        button: this.root.element.select(this.options.button)
      };
      
      this.element.classed("vzb-hidden", true);

      this.setupDialog();
      this.setupTiggerButton();
      this.setOptions();
    }

    setupDialog() {
      this.DOM.background
        .on("click", () => {
          this.toggle(true);
        });

      this.DOM.container.append("div")
        .html(ICON_CLOSE)
        .on("click", () => {
          this.toggle();
        })
        .select("svg")
        .attr("width", "0px")
        .attr("height", "0px")
        .attr("class", "vzb-data-warning-close");

      this.DOM.icon.html(ICON_WARN)
        .append("div");
    }

    setupTiggerButton() {
      if(!this.DOM.button.size()) return warn("quit setupTiggerButton of DataWarning because no button provided");
      
      setIcon(this.DOM.button, ICON_WARN)
        .append("text")
        .attr("text-anchor", "end")
        .on("click", () => {
          this.toggle();
        })
        .on("mouseover", () => {
          this.updateButtonOpacity(1);
        })
        .on("mouseout", () => {
          this.updateButtonOpacity();
        });
    }

    get MDL(){
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected
      };
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.updateUIstrings);
      this.addReaction(this.updateButtonOpacityScale);
      this.addReaction(this.updateButtonOpacity);
      this.addReaction(this.updateButtonPosition);
    }

    updateUIstrings(){
      if (this.DOM.button) this.DOM.button.select("text")
        .text(this.localise("hints/dataWarning"));

      this.DOM.icon.select("div")
        .text(this.localise("hints/dataWarning"));

      const title = this.localise("datawarning/title/" + this.root.name);
      this.DOM.title.html(title)
        .classed("vzb-hidden", !title || title == ("datawarning/title/" + this.root.name));

      this.DOM.body.html(this.localise("datawarning/body/" + this.root.name));
    }

    toggle(arg) {
      if (arg == null) arg = !hidden$2;
      hidden$2 = arg;
      this.element.classed("vzb-hidden", hidden$2);

      this.root.children.forEach(c => {
        c.element.classed("vzb-blur", c != this && !hidden$2);
      });
    }

    updateButtonOpacityScale() {
      this.wScale = this.MDL.frame.scale.d3Scale.copy()
        .domain(this.ui.doubtDomain.map(m => this.MDL.frame.parseValue("" + m)))
        .range(this.ui.doubtRange)
        .clamp(true);
    }

    updateButtonOpacity(opacity) {
      if(!this.DOM.button.size()) return warn("quit updateButtonOpacity of DataWarning because no button provided");

      if (opacity == null) opacity = this.wScale(this.MDL.frame.value);
      if (this.MDL.selected.data.filter.any()) opacity = 1;
      this.DOM.button.style("opacity", opacity);
    }

    updateButtonPosition() {
      if(!this.DOM.button.size()) return warn("quit updateButtonPosition of DataWarning because no button provided");
      const {vertical, horizontal, width, height, wLimit} = this;
      const {top, bottom, left, right} = this;

      // reset font size to remove jumpy measurement
      const dataWarningText = this.DOM.button.select("text")
        .style("font-size", null);

      // reduce font size if the caption doesn't fit
      let warnBB = dataWarningText.node().getBBox();
      const dataWarningWidth = warnBB.width + warnBB.height * 3;
      if (wLimit > 0 && dataWarningWidth > wLimit) {
        const font = parseInt(dataWarningText.style("font-size")) * wLimit / dataWarningWidth;
        dataWarningText.style("font-size", font + "px");
      }

      // position the warning icon
      warnBB = dataWarningText.node().getBBox();
      this.DOM.button.select("svg")
        .attr("width", warnBB.height * 0.75)
        .attr("height", warnBB.height * 0.75)
        .attr("x", -warnBB.width - warnBB.height * 1.2)
        .attr("y", -warnBB.height * 0.65);

      // position the whole group
      warnBB = this.DOM.button.node().getBBox();
      this.DOM.button
        .classed("vzb-hidden", this.services.layout.projector || wLimit && wLimit < HIDE_WHEN_SMALLER_THAN)
        .attr("transform", `translate(${
        horizontal == "left" ? (left + warnBB.width) : (width - right)
      }, ${
        vertical == "top" ? (top + warnBB.height) : (height - bottom)
      })`);
    }

    setOptions({
      //container size
      width = 0,
      height = 0,
      //alignment
      vertical = "top", 
      horizontal = "right", 
      //margins
      top = 0,
      bottom = 0,
      left = 0,
      right = 0,
      //size limit
      wLimit = null
    } = {}) {
      mobx.runInAction(() => {
        this.vertical = vertical;
        this.horizontal = horizontal;
        this.width = width;
        this.height = height;
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
        this.wLimit = wLimit || width;
      });
    }

  }

  _DataWarning.DEFAULT_UI = {
    doubtDomain: [],
    doubtRange: []
  };

  //export default BubbleChart;
  const DataWarning = mobx.decorate(_DataWarning, {
    "MDL": mobx.computed,
    "vertical": mobx.observable, 
    "horizontal": mobx.observable, 
    "width": mobx.observable, 
    "height": mobx.observable, 
    "top": mobx.observable, 
    "bottom": mobx.observable, 
    "left": mobx.observable, 
    "right": mobx.observable, 
    "wLimit": mobx.observable
  });

  /*!
   * VIZABI DIALOG
   * Reusable Dialog component
   */

  const PROFILE_CONSTANTS$2 = {
    SMALL: {},
    MEDIUM: {},
    LARGE: {}
  };


  const PROFILE_CONSTANTS_FOR_PROJECTOR$2 = {
    SMALL: {},
    MEDIUM: {},
    LARGE: {}
  };


  const CollectionMixin = superClass => class extends superClass {
    //static _collection = {};
    static add(name, addedClass) {
      CollectionMixin._collection[name] = addedClass;
    }
    static get(name) { return CollectionMixin._collection[name];}
  };

  CollectionMixin._collection = {};

  class Dialog extends CollectionMixin(BaseComponent) {
    constructor(config) {

      super(config);
    } 

    setup() {
      this.DOM = {
        dialog: this.element.select(".vzb-dialog-modal"),
        title: this.element.select(".vzb-dialog-modal>.vzb-dialog-title"),
        buttons: d3.select(this.element.selectAll(".vzb-dialog-modal>.vzb-dialog-buttons").nodes().pop()),
        content: this.element.select(".vzb-dialog-modal > .vzb-dialog-content"),
        dragHandler: this.element.select("[data-click='dragDialog']"),
        pinIcon: this.element.select("[data-click='pinDialog']")
      };
      this.transitionEvents = ["webkitTransitionEnd", "transitionend", "msTransitionEnd", "oTransitionEnd"];

      this.state["opened"] = false;

      const _this = this;

      this.DOM.dragHandler.html(ICON_DRAG);
      this.DOM.pinIcon.html(ICON_PIN);
      this.DOM.pinIcon.on("click", () => {
        this.setPin(!this.getPin());
      });

      const dg = dialogDrag(this.element, this.root.element, 10);
      const dragBehavior = d3.drag()
        .on("start", (event) => {
          const topPos = _this.element.node().offsetTop;
          _this.element.style("top", topPos + "px");
          _this.element.style("bottom", "auto");
          _this.element.dispatch("custom-dragstart");
          dg.dragStart(event);
        })
        .on("drag", (event) => {
          _this.element.dispatch("custom-drag");
          dg.drag(event);
        })
        .on("end", () => {
          _this.rightPos = _this.element.style("right");
          _this.topPos = _this.element.style("top");
          _this.element.dispatch("custom-dragend");
        });
      this.DOM.dragHandler.call(dragBehavior);
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted
      };
    }


    draw() {
      this.localise = this.services.locale.auto();

      this._localiseDialogTexts();

      if (this._updateLayoutProfile()) return; //return if exists with error
      this.addReaction(this._pinButtonUpdate);
      this.addReaction(this._updateSize);
    }

    resize() {
      
    }

    _localiseDialogTexts() {
      const _this = this;
      this.element.selectAll("span[data-localise]").each(function() {
        const view = d3.select(this);
        view.text(_this.localise(view.attr("data-localise")));
      });
    }

    _updateLayoutProfile(){
      this.services.layout.size;

      this.profileConstants = this.services.layout.getProfileConstants(PROFILE_CONSTANTS$2, PROFILE_CONSTANTS_FOR_PROJECTOR$2);
      this.height = this.element.node().clientHeight || 0;
      this.width = this.element.node().clientWidth || 0;
      if (!this.height || !this.width) return warn("Dialog _updateProfile() abort: container is too little or has display:none");
    }

    _updateSize() {
      this.services.layout.size;
      
      if (this.element.classed("vzb-top-dialog")) {
        this.element.classed("notransition", true);

        const profile = this.services.layout.profile;

        if (profile !== "SMALL") {
          const chartWidth = this.root.element.node().offsetWidth || 0;
          const chartHeight = this.root.element.node().offsetHeight || 0;
          const dialogWidth = parseInt(this.element.style("width"), 10) || 0;
          const dialogHeight = parseInt(this.element.style("height"), 10) || 0;

          const dialogRight = parseInt(this.rightPos, 10);
          const dialogTop = parseInt(this.topPos, 10);
          const dialogRightMargin = parseInt(this.element.style("margin-right"), 10) || 0;
          if (isNumber(dialogRight) && dialogRight > chartWidth - dialogWidth - dialogRightMargin) {
            if (this.rightPos) {
              this.rightPos = (chartWidth - dialogWidth - dialogRightMargin) + "px";
              if (this.isOpen) this.element.style("right", this.rightPos);
            }
          }
          if (isNumber(dialogTop) && isNumber(dialogHeight) && dialogTop >= 0 && dialogTop > chartHeight - dialogHeight) {
            if (this.topPos) {
              this.topPos = ((chartHeight - dialogHeight) > 0 ? (chartHeight - dialogHeight) : 0)  + "px";
              if (this.isOpen) this.element.style("top", this.topPos);
            }
          }

          if (this.topPos && (profile === "LARGE" && this.root.element.classed("vzb-dialog-expand-true"))) {
            this.element.style("bottom", "auto");
          }

          if (this.root.element.classed("vzb-landscape")) ;
          //this.element.style('top', this.topPos);
          this.DOM.dialog.style("max-height", "");
        } else {
          this.rightPos = "";
          this.topPos = "";
          this.element.attr("style", "");
          // var totalHeight = this.root.element.offsetHeight;
          // if(this.root.element.classed('vzb-portrait')) totalHeight = totalHeight - 50;
          // this.DOM.dialog.style('max-height', (totalHeight - 10) + 'px');
        }

        this.DOM.dragHandler.classed("vzb-hidden", profile === "SMALL");
        this.DOM.pinIcon.classed("vzb-hidden", profile === "SMALL");

        this._setMaxHeight();
      }
    }

    _setMaxHeight() {
      let totalHeight = this.root.element.node().offsetHeight;
      const profile = this.services.layout.profile;
      if (profile !== "SMALL") {
        if (!this.topPos && (profile === "LARGE" && this.root.element.classed("vzb-dialog-expand-true"))) {
          const dialogBottom = parseInt(this.element.style("bottom"), 10);
          totalHeight -= dialogBottom;
        } else {
          const topPos = this.topPos ? parseInt(this.topPos, 10) : this.element.node().offsetTop;
          totalHeight -= topPos;
        }
      } else {
        totalHeight = this.root.element.classed("vzb-portrait") ? totalHeight - 50 : totalHeight - 10;
      }

      this.DOM.dialog.style("max-height", totalHeight + "px");

      //set 'max-height' to content for IE11
      const contentHeight = totalHeight - this.DOM.title.node().offsetHeight - ((this.DOM.buttons.node() || {}).offsetHeight || 0);
      this.DOM.content.style("max-height", contentHeight + "px");
    }

    beforeOpen() {
      const _this = this;

      this.transitionEvents.forEach(event => {
        _this.element.on(event, _this._transitionEnd.bind(_this, event));
      });

      this.element.classed("notransition", true);

      this.element.style("top", ""); // issues: 369 & 442
      this.element.style("bottom", ""); // issues: 369 & 442

      if (this.topPos && this.services.layout.profile === "LARGE" && this.root.element.classed("vzb-dialog-expand-true")) {
        const topPos = this.element.node().offsetTop;
        this.element.style("top", topPos + "px"); // issues: 369 & 442
        this.element.style("bottom", "auto"); // issues: 369 & 442
      } else if (this.services.layout.profile !== "SMALL") ;

      this.element.node().offsetTop;
      this.element.classed("notransition", false);

      if (this.services.layout.profile === "SMALL") {
        this.element.style("top", ""); // issues: 369 & 442
      } else if (this.root.element.classed("vzb-landscape")) ;

    }

    /**
     * User has clicked to open this dialog
     */
    open() {
      this.isOpen = true;
      if (this.services.layout.profile !== "SMALL") {
        if (this.topPos) {
          this.element.style("top", this.topPos);
          this.element.style("right", this.rightPos);
        }
      }
    }

    beforeClose() {
      //issues: 369 & 442
      if (this.root.element.classed("vzb-portrait") && this.services.layout.profile === "SMALL") {
        this.element.style("top", "auto"); // issues: 369 & 442
      }
      if (this.services.layout.profile === "LARGE" && this.root.element.classed("vzb-dialog-expand-true")) {
        this.topPos0 = this.topPos ? (this.element.node().parentNode.offsetHeight - this.element.node().offsetHeight) + "px" : "";
      }
      this.element.classed("notransition", false);
      this.element.node().offsetHeight; // trigger a reflow (flushing the css changes)
    }

    /**
     * User has closed this dialog
     */
    close() {
      //issues: 369 & 442
      if (!(this.root.element.classed("vzb-portrait") && this.services.layout.profile === "SMALL")) {
        this.element.style("top", ""); // issues: 369 & 442
        this.element.style("right", ""); // issues: 369 & 442
      }

      if (this.services.layout.profile === "LARGE" && this.root.element.classed("vzb-dialog-expand-true")) {
        this.element.style("top", this.topPos0);
        this.element.style("right", "");
      }
      this.isOpen = false;
      //this.trigger("close");
    }

    _transitionEnd() {
      const _this = this;

      this.transitionEvents.forEach(event => {
        _this.element.on(event, null);
      });
      if (this.isOpen) {
        this.element.classed("notransition", true);
      }
    }

    setOpen(state) {
      this.ui.opened = state;
    }

    getOpen() {
      return this.ui.opened;
    }

    setPin(state) {
      this.ui.pinned = state;
    }

    getPin() {
      return this.ui.pinned;
    }

    _pinButtonUpdate() {
      this.element.classed("pinned", this.getPin());
    }  
  }

  Dialog.DEFAULT_UI = {
    opened: false,
    pinned: false
  };

  const decorated$b = mobx.decorate(Dialog, {
    "MDL": mobx.computed
  });

  function dialogDrag(element, container, xOffset) {
    let posX, posY, divTop, divRight, marginRight, marginLeft, xOffsetRight, xOffsetLeft, eWi, eHe, cWi, cHe, diffX, diffY;

    return {
      move(x, y) {
        element.style("right", x + "px");
        element.style("top", y + "px");
      },

      dragStart(evt) {
        if (!isTouchDevice()) {
          posX = evt.sourceEvent.clientX;
          posY = evt.sourceEvent.clientY;
        } else {
          const touchCoord = d3.pointer(evt, container.node());
          posX = touchCoord[0][0];
          posY = touchCoord[0][1];
        }
        divTop = parseInt(element.style("top")) || 0;
        divRight = parseInt(element.style("right")) || 0;
        marginLeft = parseInt(element.style("margin-left")) || 0;
        marginRight = parseInt(element.style("margin-right")) || 0;
        xOffsetLeft = Math.min(xOffset, marginLeft);
        xOffsetRight = Math.min(xOffset, marginRight);
        eWi = (parseInt(element.style("width"), 10) + marginLeft - xOffsetLeft) || 0;
        eHe = parseInt(element.style("height"), 10) || 0;
        cWi = (container.node().offsetWidth - marginRight) || 0;
        cHe = container.node().offsetHeight || 0;
        diffX = posX + divRight;
        diffY = posY - divTop;
      },

      drag(evt) {
        if (!isTouchDevice()) {
          posX = evt.sourceEvent.clientX;
          posY = evt.sourceEvent.clientY;
        } else {
          const touchCoord = d3.pointer(evt, container.node());
          posX = touchCoord[0][0];
          posY = touchCoord[0][1];
        }
        let aX = -posX + diffX,
          aY = posY - diffY;
        if (aX < -xOffsetRight) aX = -xOffsetRight;
        if (aY < 0) aY = 0;
        if (aX + eWi > cWi) aX = cWi - eWi;
        if (aY + eHe > cHe) aY = cHe - eHe;

        this.move(aX, aY);
      }
    };
  }

  let hidden$1 = true;
  class _ErrorMessage extends BaseComponent {
    constructor(config) {
      config.template = `
      <div class="vzb-errormessage-background"></div>
      <div class="vzb-errormessage-box">
        <div class="vzb-errormessage-hero">🙄</div>
        <div class="vzb-errormessage-title"></div>
        <div class="vzb-errormessage-body vzb-dialog-scrollable">
          <div class="vzb-errormessage-message"></div>
          <div class="vzb-errormessage-expand"></div>
          <pre class="vzb-errormessage-details vzb-hidden"></pre>
        </div>
      </div>
    `;

      super(config);
    }

    setup() {
      this.DOM = {
        background: this.element.select(".vzb-errormessage-background"),
        container: this.element.select(".vzb-errormessage-box"),
        close: this.element.select(".vzb-errormessage-close"),
        hero: this.element.select(".vzb-errormessage-hero"),
        title: this.element.select(".vzb-errormessage-title"),
        message: this.element.select(".vzb-errormessage-message"),
        expand: this.element.select(".vzb-errormessage-expand"),
        details: this.element.select(".vzb-errormessage-details")
      };
      
      this.element.classed("vzb-hidden", true);
      this.DOM.background.on("click", () => {
        this.toggle(true);
      });
      this.DOM.expand.on("click", () => {
        this.DOM.details.classed("vzb-hidden", !this.DOM.details.classed("vzb-hidden"));
      });
    }

    get MDL(){
      return {
        frame: this.model.encoding.frame
      };
    }

    //this is a hack because MobX autorun onError would eat the error rethrowing from there doesn't help
    rethrow(err){
      setTimeout(function(){
        throw(err);
      }, 1);
      setTimeout(function(){
        throw("ERROR REACHED USER");
      }, 1);
    }

    toggle(arg) {
      if (arg == null) arg = !hidden$1;
      hidden$1 = arg;
      this.element.classed("vzb-hidden", hidden$1);

      this.root.children.forEach(c => {
        c.element.classed("vzb-blur", c != this && !hidden$1);
      });
    }

    error(err){
      if(!hidden$1) return console.warn("errorMessage: skipping action because already in error");

      const localise = this.services.locale.status == "fulfilled"?
        this.services.locale.auto()
        : nop => nop;

      this.DOM.title.text(localise(err.name));
      this.DOM.message.text(localise(err.message));

      this.DOM.expand
        .style("display", err.details ? "block" : "none")
        .html(localise("crash/expand"));

      this.DOM.details
        .style("display", err.details ? "block" : "none")
        .text(JSON.stringify(err.details, null, 2));

      this.toggle(false);

      this.rethrow(err);
    }
  }


  _ErrorMessage.DEFAULT_UI = {
  };

  //export default BubbleChart;
  const ErrorMessage = mobx.decorate(_ErrorMessage, {
    "MDL": mobx.computed
  });

  /*!
   * VIZABI INDICATOR PICKER
   * Reusable indicator picker component
   */

  class IndicatorPicker extends BaseComponent {
    constructor(config) {
      config.template = `
      <span class="vzb-ip-holder">
        <span class="vzb-ip-select"></span>
        <span class="vzb-ip-info"></span>
      </span>
    `;

      super(config);
    }

    setup(options) {
      this.targetProp = options.targetProp;
      this.submodel = options.submodel;
      this.submodelFunc = options.submodelFunc;
      this.showHoverValues = options.showHoverValues || false;

      this.DOM = {
        select: this.element.select(".vzb-ip-select"),
        info: this.element.select(".vzb-ip-info")
      };

      this.DOM.select.on("click", () => {
        const rect = this.DOM.select.node().getBoundingClientRect();
        const rootEl = this.root.element;
        const rootRect = rootEl.node().getBoundingClientRect();
        const treemenuComp = this.root.findChild({type: "TreeMenu"});
        const treemenuColWidth = treemenuComp.profileConstants.col_width;
        const treemenuWrapper = treemenuComp.element.select(".vzb-treemenu-wrap");
        const treemenuPaddLeft = parseInt(treemenuWrapper.style("padding-left"), 10) || 0;
        const treemenuPaddRight = parseInt(treemenuWrapper.style("padding-right"), 10) || 0;
        const topPos = rect.bottom - rootRect.top;
        const leftPos = rect.left - rootRect.left - (treemenuPaddLeft + treemenuPaddRight + treemenuColWidth - rect.width) * 0.5;

        if (this._isEncoding()) {
          treemenuComp
            .alignX("left")
            .alignY("top")
            .top(topPos)
            .left(leftPos)
            .encoding(this.targetProp)
            //.updateView()
            .toggle();
        }
      });

      //TODO: continue with Info
    }

    draw() {
      this.MDL = {
        model: this._getModel()
      };
      if (this.showHoverValues) {
        this.MDL.highlighted = this.model.encoding.highlighted;
      }

      this.localise = this.services.locale.auto();
      this.addReaction(this._updateView);
    }

    _getModel() {
      if (this.submodel === "encoding") {
        return this.model.encoding[this.targetProp];
      }
      if (!this.submodel && !this.submodelFunc) return this.model;
      return this.submodelFunc ? this.submodelFunc() : getProp(this, this.submodel.split("."));
    }

    _updateView() {
      let selectText;

      if (this._isEncoding()) {
        if (this.MDL.model.data.isConstant) {
          const constant = this.MDL.model.data.constant;
          const scaleModelType = this.MDL.model.scale.config.modelType;
          selectText = this.localise("indicator/" + constant + (scaleModelType ? "/" + scaleModelType : ""));
        } else if (this.showHoverValues && this.MDL.highlighted.data.filter.markers.size === 1 && !this.MDL.model.scale.isPattern) {
          const highlightedMarkers = this.MDL.highlighted.data.filter.markers;
          const [key, payload] = highlightedMarkers.entries().next().value;
          const hoverKey = (this.model.dataMap.getByStr(key) || (payload !== true && JSON.parse(payload)) || {})[this.targetProp];

          if (["entity_domain", "entity_set"].includes(this.MDL.model.data.conceptProps.concept_type)){
            // entity domain or set and may gave an extra model to resolve names from  
            if (this.state.hoverKeyLabels && this.state.hoverKeyLabels[hoverKey] != null)
              selectText = this.state.hoverKeyLabels[hoverKey];
            else
              selectText = this.localise(hoverKey);          
          } else {        
            selectText = this.localise(hoverKey);
          }
            
        } else {
          selectText = getConceptShortName(this.MDL.model, this.localise);
        }
      }
      this.treemenu = this.root.findChild({type: "TreeMenu"});
      this.DOM.select
        .classed("vzb-disabled", this.treemenu.state.ownReadiness !== STATUS.READY)
        .text(selectText);
    }

    _isEncoding() {
      return !!this.MDL.model.marker;
    }

    _setModel(value) {
      this.MDL.model[this.checkbox] = value;
    }

  }

  /*!
   * VIZABI MIN MAX INPUT FIELDS
   */
  class MinMaxInputs extends BaseComponent {
    constructor(config) {
      config.template = `
      <div class="vzb-mmi-holder">

        <span class="vzb-mmi-zoomedmin-label"></span>
        <input type="text" class="vzb-mmi-zoomedmin" name="min">
        <span class="vzb-mmi-zoomedmax-label"></span>
        <input type="text" class="vzb-mmi-zoomedmax" name="max">

      </div>
    `;

      super(config);
    }

    setup() {
      this.DOM = {
        zoomed_labelMin: this.element.select(".vzb-mmi-zoomedmin-label"),
        zoomed_labelMax: this.element.select(".vzb-mmi-zoomedmax-label"),
        zoomed_fieldMin: this.element.select(".vzb-mmi-zoomedmin"),
        zoomed_fieldMax: this.element.select(".vzb-mmi-zoomedmax")
      };

      this.DOM.zoomed_fieldMin.on("change", this._setModel.bind(this));
      this.DOM.zoomed_fieldMax.on("change", this._setModel.bind(this));

      this.element.selectAll("input")
        .on("keypress", (event) => {
          if (event.which == 13) document.activeElement.blur();
        });

    }

    get MDL() {
      return {
        model: this._getModel()
      };
    }

    draw() {
      this.localise = this.services.locale.auto();

      const _this = this;
      this.formatter = function(n) {
        if (!n && n !== 0) return n;
        if (isDate(n)) return _this.localise(n);
        if (this.MDL.model.type === "time") return n;
        return d3.format(".2r")(n);
      };

      this.addReaction(this._updateView);

    }

    _updateView() {
      this.DOM.zoomed_labelMin.text(this.localise("hints/min") + ":");
      this.DOM.zoomed_labelMax.text(this.localise("hints/max") + ":");

      this.DOM.zoomed_fieldMin.property("value", this.formatter(this.MDL.model.zoomed[0]));
      this.DOM.zoomed_fieldMax.property("value", this.formatter(this.MDL.model.zoomed[1]));
    }

    _getModel() {
      if (this.state.submodel) {
        const submodel = this.state.submodel.split(".");
        if (submodel[0] === "encoding") {
          return getProp(this.model.encoding[submodel[1]], submodel.slice(2));
        }
      }
      if (!this.state.submodel && !this.state.submodelFunc) return this.model;
      return this.state.submodelFunc ? this.state.submodelFunc() : getProp(this, this.state.submodel.split("."));
    }

    _setModel() {
      const valueMin = this.DOM.zoomed_fieldMin.property("value");
      const valueMax = this.DOM.zoomed_fieldMax.property("value");
      let values = [valueMin, valueMax].map(m => m.replace("−", "-")); //replace the bourjois minus sign &#8722 to the proletarian &#45
      if (!this.MDL.model.type === "time") 
        values = values.map(m => parseFloat(m)); //replace the bourjois minus sign &#8722 to the proletarian &#45

      if(values.some(f => !f && f!==0)) {
        this._updateView();
      } else {
        this.MDL.model.config.zoomed = values;
      }
    }
  }

  MinMaxInputs.DEFAULT_UI = {
  };

  const decorated$a = mobx.decorate(MinMaxInputs, {
    "MDL": mobx.computed
  });

  /*!
   * VIZABI DIALOGS
   * Reusable dialogs component
   */

  //default existing dialogs
  const class_active$1 = "vzb-active";

  class Dialogs extends BaseComponent {
    constructor(config) {
      const { sidebar = [], popup = []} = deepExtend(deepExtend({}, config.ui.dialogs), config.default_ui.dialogs);
      const subcomponents = [];
      const templateArray  = [];

      const dialogList = unique([...sidebar, ...popup]);

      dialogList.forEach(dlg => {      
        subcomponents.push({
          type: decorated$b.get(dlg),
          placeholder: '.vzb-dialogs-dialog[data-dlg="' + dlg + '"]',
          model: config.model,
          name: dlg,
        });

        templateArray.push(
          `<div data-dlg="${dlg}" class="vzb-top-dialog vzb-dialogs-dialog vzb-dialog-shadow"></div>`
        );
      });

      config.subcomponents = subcomponents;
      config.template = templateArray.join("\n");
      super(config);
    } 

    setup() {
      this.DOM = {

      };

      const _this = this;
      this._curr_dialog_index = 20;
      
      this.element.selectAll(".vzb-top-dialog").data(this.children.map(c => ({ 
        name: c.name
      })))
        .on("custom-dragstart", function(event, d) {
          _this.bringForward(d.name);
        })
        .select(".vzb-top-dialog>.vzb-dialog-modal>.vzb-dialog-buttons>[data-click='closeDialog']")
        .on("click", (event, d) => {
          this.toggleDialogOpen(d.name, false);
        });
    }

    draw() {
      this._buttonList = this.root.findChild({type: "ButtonList"});
      if(!this._buttonList) console.warn("Dialogs was unable to find a subcomponent of type 'ButtonList' in root component. Could be that index.js of a tool is lacking a configuration.");
    }

    resize() {
      const _this = this;
      const profile = this.services.layout.profile;

      this.children.forEach(childComp => {
        const dialogEl = childComp.element;
        let cls = dialogEl.attr("class").replace(" vzb-popup", "").replace(" vzb-sidebar", "");

        if (profile === "LARGE" && _this.ui.dialogs.sidebar.indexOf(childComp.name) > -1) {
          cls += _this._buttonList.ui.sidebarCollapse ? " vzb-popup" : " vzb-sidebar";
          if (!_this._buttonList.ui.sidebarCollapse) dialogEl.style("z-index", null);
        } else if (_this.ui.dialogs.popup.indexOf(childComp.name) > -1) {
          cls += " vzb-popup";
        }

        dialogEl.attr("class", cls);
      });

    }

    toggleDialogOpen(name, forceState) {
      mobx.runInAction(() => {
        const dialog = this.findChild({ name });
        if (!dialog) return;
        const newState = forceState ? forceState : !dialog.getOpen();
        dialog.setOpen(newState);

        if(newState) {
          this.openDialog(name);
        } else {
          this.closeDialog(name);
        }
      });
    }

    //TODO: make opening/closing a dialog via update and model
    /*
     * Activate a dialog
     * @param {String} id dialog id
     */
    openDialog(name) {
      //close pinned dialogs for small profile
      const forceClose = this.services.layout.profile === "SMALL";
      
      //TODO
      this.closeAllDialogs(forceClose);

      const dialog = this.element.selectAll(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + name + "']");

      this._active_comp = this.findChild({ name });

      this._active_comp.beforeOpen();
      //add classes
      dialog.classed(class_active$1, true);

      this.bringForward(name);

      //call component function
      this._active_comp.open();
    }

    /*
     * Closes a dialog
     * @param {String} id dialog id
     */
    closeDialog(name) {
      const dialog = this.element.selectAll(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + name + "']");

      this._active_comp = this.findChild({ name });

      if (this._active_comp && !this._active_comp.isOpen) return;

      if (this._active_comp.getPin())
        this._active_comp.setPin(false);

      if (this._active_comp) {
        this._active_comp.beforeClose();
      }
      //remove classes
      dialog.classed(class_active$1, false);

      //call component close function
      if (this._active_comp) {
        this._active_comp.close();
      }
      this._active_comp = false;

    }

    /*
    * Close all dialogs
    */
    closeAllDialogs(forceclose) {
      const _this = this;
      //remove classes
      const dialogClass = forceclose ? ".vzb-popup.vzb-dialogs-dialog.vzb-active" : ".vzb-popup.vzb-dialogs-dialog.vzb-active:not(.pinned)";
      const all_dialogs = this.element.selectAll(dialogClass);
      all_dialogs.each(d => {
        _this.toggleDialogOpen(d.name);
      });
    }

    bringForward(name) {
      const dialog = this.element.select(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + name + "']");
      dialog.style("z-index", this._curr_dialog_index);
      this._curr_dialog_index += 10;
    }
  }

  const OPTIONS$4 = {
    checkbox: null,
    setCheckboxFunc: null,
    submodel: null,
    submodelFunc: null,
    prefix: "",
  };

  class SimpleCheckbox extends BaseComponent {
    constructor(config) {
      config.template = `
      <span class="vzb-sc-holder vzb-dialog-checkbox"><input type="checkbox"><label></label></span>    
    `;
      super(config);
    }

    setup(_options) {
      this.DOM = {
        check: this.element.select("input"),
        label: this.element.select("label")
      };
      
      this.options = deepExtend(deepExtend({}, OPTIONS$4), _options || {});

      const _this = this;

      const id = "-check-" + this.id;
      this.DOM.label.attr("for", id);
      this.DOM.check.attr("id", id)
        .on("change", function() {
          _this._setModel(d3.select(this).property("checked"));
        });

    }

    draw() {
      this.MDL = {
        model: this._getModel()
      };

      this.localise = this.services.locale.auto();
      this.addReaction(this._updateView);
    }

    _getModel() {
      const {
        submodel,
        submodelFunc
      } = this.options;
      
      if (!submodel && !submodelFunc) return this.model;
      return submodelFunc ? submodelFunc() : getProp(this, submodel.split("."));
    }

    _updateView() {
      const model = this.MDL.model;
      const {
        checkbox,
        prefix,
        labelText
      } = this.options;
      const modelExists = model && (model[checkbox] || model[checkbox] === false);

      this.DOM.label.classed("vzb-hidden", !modelExists);
      if (modelExists) {
        this.DOM.label.html(this.localise(labelText ? labelText : ("check/" + (prefix ? prefix + "/" : "") + checkbox)));
        this.DOM.check.property("checked", !!model[checkbox]);
      }
    }

    _setModel(value) {
      if (this.options.setCheckboxFunc) {
        this.options.setCheckboxFunc(value);
      } else {
        this.MDL.model[this.options.checkbox] = value;
      }
    }

  }

  const MENU_HORIZONTAL = 1;
  const MENU_VERTICAL = 2;

  //css custom classes
  const css = {
    wrapper: "vzb-treemenu-wrap",
    wrapper_header: "vzb-treemenu-wrap-header",
    wrapper_outer: "vzb-treemenu-wrap-outer",
    background: "vzb-treemenu-background",
    close: "vzb-treemenu-close",
    search: "vzb-treemenu-search",
    list: "vzb-treemenu-list",
    list_outer: "vzb-treemenu-list-outer",
    list_item: "vzb-treemenu-list-item",
    list_item_leaf: "vzb-treemenu-list-item-leaf",
    leaf: "vzb-treemenu-leaf",
    leaf_content: "vzb-treemenu-leaf-content",
    leaf_content_item: "vzb-treemenu-leaf-content-item",
    leaf_content_item_title: "vzb-treemenu-leaf-content-item-title",
    leaf_content_item_datasources: "vzb-treemenu-leaf-content-item-datasources",
    leaf_content_item_space: "vzb-treemenu-leaf-content-item-space",
    leaf_content_item_descr: "vzb-treemenu-leaf-content-item-descr",
    leaf_content_item_helptranslate: "vzb-treemenu-leaf-content-item-helptranslate",
    hasChild: "vzb-treemenu-list-item-children",
    list_item_label: "vzb-treemenu-list-item-label",
    list_top_level: "vzb-treemenu-list-top",
    search_wrap: "vzb-treemenu-search-wrap",
    isSpecial: "vzb-treemenu-list-item-special",
    hidden: "vzb-hidden",
    title: "vzb-treemenu-title",
    scaletypes: "vzb-treemenu-scaletypes",
    scaletypesDisabled: "vzb-treemenu-scaletypes-disabled",
    scaletypesActive: "vzb-treemenu-scaletypes-active",
    alignYt: "vzb-align-y-top",
    alignYb: "vzb-align-y-bottom",
    alignXl: "vzb-align-x-left",
    alignXr: "vzb-align-x-right",
    alignXc: "vzb-align-x-center",
    menuHorizontal: "vzb-treemenu-horizontal",
    menuVertical: "vzb-treemenu-vertical",
    absPosVert: "vzb-treemenu-abs-pos-vert",
    absPosHoriz: "vzb-treemenu-abs-pos-horiz",
    menuOpenLeftSide: "vzb-treemenu-open-left-side",
    noTransition: "notransition"
  };

  //options and globals
  const OPTIONS$3 = {
    MOUSE_LOCS: [], //contains last locations of mouse
    MOUSE_LOCS_TRACKED: 3, //max number of locations of mouse
    DELAY: 200, //amazons multilevel delay
    TOLERANCE: 150, //this parameter is used for controlling the angle of multilevel dropdown
    LAST_DELAY_LOC: null, //this is cached location of mouse, when was a delay
    TIMEOUT: null, //timeout id
    SEARCH_PROPERTY: "id", //property in input data we we'll search by
    SUBMENUS: "children", //property for submenus (used by search)
    SEARCH_MIN_STR: 1, //minimal length of query string to start searching
    RESIZE_TIMEOUT: null, //container resize timeout
    MOBILE_BREAKPOINT: 400, //mobile breakpoint
    CURRENT_PATH: [], //current active path
    MIN_COL_WIDTH: 60, //minimal column size
    MENU_DIRECTION: MENU_HORIZONTAL,
    MAX_MENU_WIDTH: 320,
    MENU_OPEN_LEFTSIDE: false
  };

  function spacesAreEqual$3(a, b){
    return a.concat().sort().join() === b.concat().sort().join();
  }
  class DeepLeaf{

    constructor(context, view){
      this.context = context;
      this.view = view;
      this.spaceChanged = false;
      this.encoding = this.context._targetModel;
      this.datum = view.datum();

      this.buildLeaf();
    }
    
    _getDatumForDS(){    
      return this.datum.byDataSources.find(f => f.dataSource == this.encoding.data.source) || this.datum.byDataSources[0];
    }
    _isSelectedConcept() {
      return this.datum.id == this.encoding.data.concept;
    }

    buildLeaf() {        
      this.view.selectAll("div").remove();

      const leafContent = this.view
        .append("div").attr("class", `${css.leaf} ${css.leaf_content} vzb-dialog-scrollable`)
        .style("width", this.width + "px");
      
      this.DOM = {
        title: leafContent.append("div")
          .attr("class", `${css.leaf_content_item} ${css.leaf_content_item_title}`),

        datasourceContainer: leafContent.append("div")
          .attr("class", `${css.leaf_content_item} ${css.leaf_content_item_datasources}`)
          .on("click", event => event.stopPropagation()),

        spaceContainer: leafContent.append("div")
          .classed(css.leaf_content_item + " " + css.leaf_content_item_space, true)
          .on("click", event => event.stopPropagation()),

        descr: leafContent.append("div")
          .attr("class", `${css.leaf_content_item} ${css.leaf_content_item_descr}`),

        helptranslate: leafContent.append("div")
          .attr("class", `${css.leaf_content_item} ${css.leaf_content_item_helptranslate}`)
      };
      
      this.updateNameSection();
      this.updateDatasoutceSection();
      this.updateSpaceSection();
      this.updateDescrSection();
    }

    updateNameSection(datumForDS = this._getDatumForDS()){
      this.DOM.title.text(replaceNumberSpacesToNonBreak(datumForDS.name) || "");
    }


    updateDescrSection(datumForDS = this._getDatumForDS()){   
      this.DOM.descr.text(replaceNumberSpacesToNonBreak(datumForDS.description || this.context.localise("hints/nodescr")));

      this.DOM.helptranslate
        .classed("vzb-invisible", !datumForDS.dataSource?.translateContributionLink)
        .html(`<a href="${datumForDS.dataSource?.translateContributionLink}" target="_blank">${this.context.localise("dialogs/helptranslate")}</a>`);
    }


    updateDatasoutceSection(){
      const _this = this;

      if(this.datum.id == "_default") return;

      const getDSColorLight = (v) => this.context.dsColorScaleLight(v.dataSource.id);
      const getDSColorDark = (v) => this.context.dsColorScaleDark(v.dataSource.id);
      const paintBackground = (v) => (v.dataSource == this.encoding.data.source) && this._isSelectedConcept() && multipleDataSourcesAvailable;        
      const multipleDataSourcesAvailable = () => this.datum.byDataSources > 1;

      if(this.context.ui.showDataSources){
        this.DOM.datasourceContainer.selectAll("span")
          .data(this.datum.byDataSources, v => v)
          .enter().append("span")
          //.text(v => v.dataSource.config.name)
          .text(v => v.dataSource.id)
          .on("mouseenter", function(event, v) {
            d3.select(this).style("background-color", getDSColorLight(v));
            _this.updateNameSection(v);
            _this.updateDescrSection(v);
          })
          .on("mouseout", function(event, v) {
            d3.select(this).style("background-color", paintBackground(v) ? getDSColorLight(v) : null);
            _this.updateNameSection();
            _this.updateDescrSection();
          })
          .on("click", function(event, v){
            if(_this.DOM.spaceContainer.select("select").node()) _this.resetPickers();
            _this.setDatasource(v);
          });
        
        this.DOM.datasourceContainer.selectAll("span")
          .style("pointer-events", this._isSelectedConcept() ? null : "none")
          .style("border-color", getDSColorDark)
          .style("background-color", v => paintBackground(v) ? getDSColorLight(v) : null);
      }
    }

    updateSpaceSection(datumForDS = this._getDatumForDS()){
      const _this = this;

      if(this.datum.id == "_default") return;

      const currentSpace = this.encoding.data.space;
      const markerSpace = this.encoding.marker.data.space;

      const multipleSpacesAvailable = () => datumForDS.spaces.length > 1;
      const shorterThanMarkerSpace = () => datumForDS.spaces[0].length < markerSpace.length;

      //only build the UI for selecting spaces if many conditions are met
      if(this._isSelectedConcept() && (multipleSpacesAvailable() || !spacesAreEqual$3(datumForDS.spaces[0], markerSpace) && !shorterThanMarkerSpace())) {

        const spaceSelect = this.DOM.spaceContainer
          .append("select")
          .attr("name", "vzb-select-treemenu-leaf-space")
          .attr("id", "vzb-select-treemenu-leaf-space")
          .on("change", function(){
            _this.spaceChanged = true;
            _this.updateComplimentSetters();
          });
    
        spaceSelect
          .selectAll("option")
          .data(datumForDS.spaces)
          .enter().append("option")
          .attr("value", option => option.join())
          .text(option => "by " + getSpaceName(this.encoding, option));
    
        spaceSelect
          .property("value", currentSpace.join());
        
        this.DOM.spaceContainer.append("div")
          .attr("class","vzb-treemenu-leaf-space-compliment");

        this.DOM.spaceContainer.append("div")
          .attr("class","vzb-hidden vzb-treemenu-leaf-space-reset")
          .text("Reset")
          .on("click", () => {
            this.resetPickers();
            this.setModel();
          });

        this.DOM.spaceContainer.append("div")
          .attr("class","vzb-hidden vzb-treemenu-leaf-space-apply")
          .text("Apply")
          .on("click", () => {
            this.setModel();
          });

        this.updateComplimentSetters();
      }
    }


    updateComplimentSetters() {
      const _this = this;
      const encoding = this.context._targetModel;
      const compliment = this.context.services.Vizabi.Vizabi.utils.relativeComplement(encoding.marker.data.space, this._getSelectedSpace());
      
      requestEntityNames(encoding.data.source, compliment).then(dims => {
        let dimSetters = this.DOM.spaceContainer.select("div.vzb-treemenu-leaf-space-compliment")
          .selectAll("div.vzb-treemenu-leaf-space-compliment-setter")
          .data(dims, d => d.dim);

        dimSetters.exit().remove();

        dimSetters = dimSetters
          .enter().append("div")
          .attr("class", "vzb-treemenu-leaf-space-compliment-setter")
          .each(function(d) {
            const view = d3.select(this);
            view
              .append("label")
              .attr("for", d.dim + "_extraDim")
              .text(getSpaceName(encoding, d.dim) + ":");
      
            const select = view
              .append("select")
              .attr("id", d.dim + "_extraDim")
              .on("change", () => {
                _this.spaceChanged = true;
                _this.updateResetApplyButtons();
              });

            select.selectAll("option")
              .data(d.data.raw)
              .enter().append("option")
              .attr("value", option => option[d.dim])
              .text(option => option.name);

            select.property("selectedIndex", -1);
          })
          .merge(dimSetters);


        dimSetters
          .each(function(d){
            const select = d3.select(this).select("select");
            const value = encoding.data.filter?.dimensions[d.dim]?.[d.dim];
            if (value)
              select.property("value", value);
            else
              select.property("selectedIndex", -1);
          });   
          
          
        this.updateResetApplyButtons();
      });
    }


    _getSelectedSpace() {
      const node = this.view.select("div." + css.leaf_content_item_space)
        .select("select").node();
      return d3.select(node.options[node.selectedIndex]).datum();
    }


    _getSelectedFilter() {
      const filter = {};
      let invalidFilter = false;
      this.view.select("div." + css.leaf_content_item_space)
        .select("div.vzb-treemenu-leaf-space-compliment")
        .selectAll("select")
        .each(function(d){ 
          filter[d.dim] = {};
          filter[d.dim][d.dim] = this.value;
          if(this.selectedIndex == -1) invalidFilter = true;
        });
      return invalidFilter ? null : filter;
    }


    updateResetApplyButtons(datumForDS = this._getDatumForDS()) {
      const currentSpace = this.context.targetModel().data.space;
      const defaultSpace = this.context.getNearestSpaceToMarkerSpace(datumForDS.spaces);

      const selectedSpace = this._getSelectedSpace();
      const selectedFilter = this._getSelectedFilter();

      const spaceContainer = this.view.select("div." + css.leaf_content_item_space);
      spaceContainer.select(".vzb-treemenu-leaf-space-reset")
        .classed("vzb-hidden", spacesAreEqual$3(currentSpace, defaultSpace));
      spaceContainer.select(".vzb-treemenu-leaf-space-apply")
        .classed("vzb-hidden", !this.spaceChanged)
        .classed("vzb-disabled", !selectedFilter && !spacesAreEqual$3(currentSpace, selectedSpace));
    }


    resetPickers(datumForDS = this._getDatumForDS()) {
      const defaultSpace = this.context.getNearestSpaceToMarkerSpace(datumForDS.spaces);
      
      this.view.select("div." + css.leaf_content_item_space)
        .select("select")
        .property("value", defaultSpace.join());

      this.updateComplimentSetters();
    }


    setDatasource(datumForDS = this._getDatumForDS()){
      const encoding = this.context._targetModel;
      mobx.runInAction(()=>{
        encoding.data.config.source = datumForDS.dataSource.id;
      });
    }
    
    setModel() {
      const encoding = this.context._targetModel;
      const selectedSpace = this._getSelectedSpace();
      const selectedFilter = this._getSelectedFilter() || {};

      mobx.runInAction(()=>{
        encoding.data.config.space = selectedSpace;
        encoding.data.filter.config.dimensions = selectedFilter;
      });
    }
  }

  const CONFIG = {
    triangleWidth: 10,
    triangleHeight: 10,
    height: 31,
    lineWidth: 10,
    domain: [1, 2, 3, 4, 5, 6],
    range: [1200, 900, 450, 200, 150, 100]
  };

  class SteppedSlider extends BaseComponent {

    constructor(config) {
      config.template = `
      <div class="vzb-stepped-slider">
        <svg>
          <g class="vzb-stepped-slider-triangle"></g>
          <g class="vzb-stepped-slider-axis"></g>
        </svg>
      </div>`;

      super(config);
    }

    setup() {
      //this.setDelay = throttle(this.setDelay, 50);
      this.config = deepExtend(deepExtend({}, CONFIG), this.config);
      this.config.height -= this.config.triangleHeight / 2;
    
      const {
        domain,
        range,
        height
      } = this.config;

      this.DOM = {
        svg: this.element.select("svg"),
        slide: this.element.select(".vzb-stepped-slider-triangle")
      };

      this.axisScale = d3.scaleLog()
        .domain(d3.extent(domain))
        .range([height, 0]);

      this.delayScale = d3.scaleLinear()
        .domain(domain)
        .range(range);

      this.initTriangle();
      this.initAxis();

    }

    draw() {
      this.addReaction(this.redraw);
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame
      };
    }

    initAxis() {
      const {
        lineWidth,
        triangleWidth,
        triangleHeight,
        height
      } = this.config;

      const axis = d3.axisLeft()
        .scale(this.axisScale)
        .tickFormat(() => "")
        .tickSizeInner(lineWidth)
        .tickSizeOuter(0);

      const tx = triangleWidth + lineWidth / 2;
      const ty = triangleHeight / 2;
      this.DOM.svg
        .on("mousedown", event => {
          const y = Math.max(0, Math.min(event.offsetY - ty, height));

          this.setDelay(Math.round(this.delayScale(this.axisScale.invert(y))), true, true);
        })
        .select(".vzb-stepped-slider-axis")
        .attr("transform", `translate(${tx}, ${ty})`)
        .call(axis);

      this.drag = d3.drag()
        .on("drag", event => {
          const { translateY } = transform(this.DOM.slide.node());
          const y = Math.max(0, Math.min(event.dy + translateY, height));

          this.setDelay(Math.round(this.delayScale(this.axisScale.invert(y))), true);
          //this.redraw(y);
        })
        .on("end", () => {
          this.setDelay(this.MDL.frame.speed);
        });

      this.DOM.svg.call(this.drag);
    }

    initTriangle() {
      this.DOM.slide
        .append("g")
        .append("path")
        .attr("d", this.getTrianglePath());
    }

    getTrianglePath() {
      const {
        triangleHeight,
        triangleWidth
      } = this.config;

      return `M ${triangleWidth},${triangleHeight / 2} 0,${triangleHeight} 0,0 z`;
    }

    redraw() {
      const y = this.axisScale(this.delayScale.invert(this.MDL.frame.speed));
      this.DOM.slide.attr("transform", `translate(0, ${y})`);
    }

    setDelay(value) {
      this.MDL.frame.setSpeed(value);
    }

  }

  const decorated$9 = mobx.decorate(SteppedSlider, {
    "MDL": mobx.computed
  });

  class Menu {
    constructor(context, parent, menu, options) {
      const _this = this;
      this.context = context;
      this.parent = parent;
      this.OPTIONS = options;
      this.width = this.OPTIONS.MIN_COL_WIDTH;
      this.direction = this.OPTIONS.MENU_DIRECTION;

      this.OPTIONS.createSubmenu(menu, menu.datum(), parent === null);
      this.entity = parent === null ? menu.selectAll("." + css.list_top_level) : menu.select("." + css.list_outer);

      this._setDirectionClass();
      this.menuItems = [];
      let menuItemsHolder;

      if (this.entity.empty()) return this;

      this.entity.each(function() {
        menuItemsHolder = d3.selectAll(this.childNodes).filter(function() {
          return d3.select(this).classed(css.list);
        });
      });
      if (menuItemsHolder.empty()) menuItemsHolder = this.entity;
      this.entity.selectAll("." + css.list_item)
        .filter(function() {
          return this.parentNode == menuItemsHolder.node();
        })
        .each(function() {
          _this.addSubmenu(d3.select(this));
        });
      if (!this.menuItems.length && this.isActive()) {
        this.deepleaf = new DeepLeaf(this.context, this.entity);
      }
      this.setWidth(this.OPTIONS.COL_WIDTH, false, true);
      return this;
    }

    setWidth(width, recursive, immediate) {
      if (this.width != width && this.entity.node()) {
        this.width = width;
        if ((this.entity.classed(css.list_top_level) || this.entity.classed("active")) && this.direction == MENU_HORIZONTAL) {
          if (!immediate) {
            this.entity.transition()
              .delay(0)
              .duration(100)
              .style("width", this.width + "px");
          } else {
            this.entity.style("width", this.width + "px");
          }
        }
        if (this.entity.classed(css.list_top_level)) {
          this.entity.selectAll("." + css.leaf).style("width", this.width - 1 + "px");
        }
        if (recursive) {
          for (let i = 0; i < this.menuItems.length; i++) {
            this.menuItems[i].setWidth(this.width, recursive, immediate);
          }
        }
        return this;
      }
    }

    /**
     * configure menu type (horizontal or vertical)
     * @param direction MENU_HORIZONTAL or MENU_VERTICAL
     * @param recursive change direction over menu sublevels
     * @returns {Menu}
     */
    setDirection(direction, recursive) {
      this.direction = direction;
      this.entity
        .style("width", "")
        .style("height", "");
      if (recursive) {
        for (let i = 0; i < this.menuItems.length; i++) {
          this.menuItems[i].setDirection(this.direction, recursive);
        }
      }
      this._setDirectionClass();
      return this;
    }

    _setDirectionClass() {
      if (this.direction == MENU_HORIZONTAL) {
        this.entity.classed(css.menuVertical, false);
        this.entity.classed(css.menuHorizontal, true);
      } else {
        this.entity.classed(css.menuHorizontal, false);
        this.entity.classed(css.menuVertical, true);
      }
    }

    addSubmenu(item) {
      this.menuItems.push(new MenuItem(this.context, this, item, this.OPTIONS));
    }

    open() {
      const _this = this;
      if (!this.isActive()) {
        _this.parent.parentMenu.openSubmenuNow = true;
        this.closeNeighbors(() => {
          if (_this.direction == MENU_HORIZONTAL) {
            if (!this.menuItems.length) _this.deepleaf = new DeepLeaf(_this.context, this.entity);
            _this._openHorizontal();
            _this.calculateMissingWidth(0);
          } else {
            _this._openVertical();
          }
        });
        _this.parent.parentMenu.openSubmenuNow = false;
      }
      return this;
    }

    /**
     * recursively calculate missed width for last menu level
     * @param width
     * @param cb
     */
    calculateMissingWidth(width, cb) {
      const _this = this;
      if (this.entity.classed(css.list_top_level)) {
        if (width > this.OPTIONS.MAX_MENU_WIDTH) {
          if (typeof cb === "function") cb(width - this.OPTIONS.MAX_MENU_WIDTH);
        }
      } else {
        this.parent.parentMenu.calculateMissingWidth(width + this.width, widthToReduce => {
          if (widthToReduce > 0) {
            _this.reduceWidth(widthToReduce, newWidth => {
              if (typeof cb === "function") cb(newWidth); // callback is not defined if it is emitted from this level
            });
          } else if (typeof cb === "function") cb(widthToReduce);
        });
      }
    }

    /**
     * restore width (if it was reduced before)
     * @param width
     * @param isClosedElement (parameter for check if curent element emit this action)
     * @param cb
     */
    restoreWidth(width, isClosedElement, cb) {
      const _this = this;
      if (isClosedElement) {
        this.parent.parentMenu.restoreWidth(width, false, cb);
      } else if (width <= 0) {
        if (typeof cb === "function") cb();
      } else if (!this.entity.classed(css.list_top_level)) {
        const currentElementWidth =  this.entity.node().offsetWidth;
        const newElementWidth = Math.min(width, _this.width);
        if (currentElementWidth < newElementWidth) {
          const duration = 250 * (currentElementWidth / newElementWidth);
          this.entity.transition()
            .delay(0)
            .duration(duration)
            .style("width", newElementWidth + "px")
            .on("end", () => {
            });
          _this.parent.parentMenu.restoreWidth(width - newElementWidth, false, cb);
        } else {
          this.parent.parentMenu.restoreWidth(width, false, cb);
        }
      } else {
        if (typeof cb === "function") cb();
      }
    }

    /**
     * made element narrower to free space for other element
     * @param width
     * @param cb
     */
    reduceWidth(width, cb) {
      const _this = this;
      const currWidth = this.entity.node().offsetWidth;

      if (currWidth <= this.OPTIONS.MIN_COL_WIDTH) {
        cb(width - _this.width + currWidth);
      } else {

        const newElementWidth = Math.max(this.OPTIONS.MIN_COL_WIDTH, _this.width - width);
        const duration = 250 / (_this.width / newElementWidth);
        this.entity.transition()
          .delay(0)
          .duration(duration)
          .style("width", newElementWidth + "px")
          .on("end", () => {
            cb(width - _this.width + newElementWidth);
          });
      }
    }

    _openHorizontal() {
      const _this = this;
      _this.entity.classed("active", true)
        .transition()
        .delay(0)
        .duration(250)
        .style("width", _this.width + "px")
        .on("end", () => {
          _this.marqueeToggle(true);
        });
    }

    _openVertical() {
      const _this = this;
      _this.entity.style("height", "0px");
      _this.entity.transition()
        .delay(0)
        .duration(250)
        .style("height", (36 * _this.menuItems.length) + "px")
        .on("end", () => {
          _this.entity.style("height", "auto");
          _this.marqueeToggle(true);
          _this.scrollToFitView();
        });
      _this.entity.classed("active", true);
    }

    closeAllChildren(cb) {
      let callbacks = 0;
      for (let i = 0; i < this.menuItems.length; i++) {
        if (this.menuItems[i].isActive()) {
          ++callbacks;
          this.menuItems[i].submenu.close(() => {
            if (--callbacks == 0) {
              if (typeof cb === "function") cb();
            }
          });
        }
      }
      if (callbacks == 0) {
        if (typeof cb === "function") cb();
      }
    }

    closeNeighbors(cb) {
      if (this.parent) {
        this.parent.closeNeighbors(cb);
      } else {
        cb();
      }
    }

    close(cb) {
      const _this = this;
      this.closeAllChildren(() => {
        if (_this.direction == MENU_HORIZONTAL) {
          _this.deepleaf = null;
          _this._closeHorizontal(cb);
        } else {
          _this._closeVertical(cb);
        }
      });
    }

    _closeHorizontal(cb) {
      const _this = this;
      const openSubmenuNow = _this.parent.parentMenu.openSubmenuNow;
      _this.entity.transition()
        .delay(0)
        .duration(20)
        .style("width", 0 + "px")
        .on("end", () => {
          _this.marqueeToggle(false);
          _this.entity.classed("active", false);
          if (!openSubmenuNow) {
            _this.restoreWidth(_this.OPTIONS.MAX_MENU_WIDTH, true, () => {
              if (typeof cb === "function") cb();
            });
          } else {
            if (typeof cb === "function") cb();
          }
        });
    }

    _closeVertical(cb) {
      const _this = this;
      _this.entity
        .transition()
        .delay(0)
        .duration(100)
        .style("height", 0 + "px")
        .on("end", () => {
          _this.marqueeToggle(false);
          _this.entity.classed("active", false);
          if (typeof cb === "function") cb();
        });
    }

    isActive() {
      return this.entity.classed("active");
    }

    hasActiveParentNeighbour() {
      return this.menuItems
        .filter(item => item.isActive())
        .some(item => !!d3.select(item.entity).node().classed(css.hasChild));
    }

    marqueeToggle(toggle) {
      for (let i = 0; i < this.menuItems.length; i++) {
        this.menuItems[i].marqueeToggle(toggle);
      }
    }

    marqueeToggleAll(toggle) {
      for (let i = 0; i < this.menuItems.length; i++) {
        this.menuItems[i].marqueeToggleAll(toggle);
      }
    }

    findItemById(id) {
      for (let i = 0; i < this.menuItems.length; i++) {
        if (this.menuItems[i].entity.datum().id == id) {
          return this.menuItems[i];
        }
        if (this.menuItems[i].submenu) {
          const item = this.menuItems[i].submenu.findItemById(id);
          if (item) return item;
        }
      }
      return null;
    }

    getTopMenu() {
      return this.parent ?
        this.parent.parentMenu.getTopMenu() :
        this;
    }

    scrollToFitView() {
      const treeMenuNode = this.getTopMenu().entity.node().parentNode;
      const parentItemNode = this.entity.node().parentNode;
      const menuRect = treeMenuNode.getBoundingClientRect();
      const itemRect = parentItemNode.getBoundingClientRect();
      const viewportItemTop = itemRect.top - menuRect.top;
      if (viewportItemTop + itemRect.height > menuRect.height) {
        const newItemTop = (itemRect.height > menuRect.height) ?
          (menuRect.height - 10) : (itemRect.height + 10);

        const newScrollTop = treeMenuNode.scrollTop + newItemTop - menuRect.height + viewportItemTop;

        const scrollTopTween = function(scrollTop) {
          return function() {
            const i = d3.interpolateNumber(this.scrollTop, scrollTop);
            return function(t) {
              treeMenuNode.scrollTop = i(t);
            };
          };
        };

        d3.select(treeMenuNode).transition().duration(100)
          .tween("scrolltoptween", scrollTopTween(newScrollTop));

      }

    }
  }
  class MenuItem {
    constructor(context, parent, item, options) {
      const _this = this;
      this.context = context;
      this.parentMenu = parent;
      this.entity = item;
      this.entity.select("." + css.list_item_label).call(select => {
        if (isTouchDevice()) {
          select.onTap((event) => {
            event.stopPropagation();
            if (_this.parentMenu.direction == MENU_VERTICAL) {
              const view = _this.entity.select("." + css.list_item_label);
              //only for leaf nodes
              if (!view.attr("children")) return;
            }
            if (!_this.submenu) {
              _this.submenu = new Menu(_this.context, _this, _this.entity, options);
            }
            _this.toggleSubmenu();
          });
        } else {
          select.on("mouseenter", function() {
            if (_this.parentMenu.direction == MENU_HORIZONTAL && !d3.select(this).attr("children")) {
              if (!_this.submenu) {
                _this.submenu = new Menu(_this.context, _this, _this.entity, options);
              }
              _this.openSubmenu();
            } else if (!_this.parentMenu.hasActiveParentNeighbour()) {
              _this.closeNeighbors();
            }
            _this.marqueeToggle(true);
          }).on("click.item", function(event) {
            event.stopPropagation();
            if (!_this.submenu) {
              _this.submenu = new Menu(_this.context, _this, _this.entity, options);
            }
            if (_this.parentMenu.direction == MENU_HORIZONTAL) {
              _this.openSubmenu();
            } else {
              const view = d3.select(this);
              //only for leaf nodes
              if (!view.attr("children")) return;
              _this.toggleSubmenu();
            }
          });
        }

        if (options.selectedPath[0] === select.datum().id) {
          options.selectedPath.shift();
          _this.submenu = new Menu(_this.context, _this, _this.entity, options);
        }
      });
      return this;
    }

    setWidth(width, recursive, immediate) {
      if (this.submenu && recursive) {
        this.submenu.setWidth(width, recursive, immediate);
      }
      return this;
    }

    setDirection(direction, recursive) {
      if (this.submenu && recursive) {
        this.submenu.setDirection(direction, recursive);
      }
      return this;
    }

    toggleSubmenu() {
      if (this.submenu) {
        if (this.submenu.isActive()) {
          this.submenu.close();
        } else {
          this.submenu.open();
        }
      }
    }

    openSubmenu() {
      if (this.submenu) {
        this.submenu.open();
      } else {
        this.closeNeighbors();
      }
    }

    closeNeighbors(cb) {
      this.parentMenu.closeAllChildren(cb);
    }

    isActive() {
      return this.submenu && this.submenu.isActive();
    }

    marqueeToggleAll(toggle) {
      const labels = this.entity.selectAll("." + css.list_item_label);
      labels.each(function() {
        const label = d3.select(this).select("span");
        const parent = d3.select(this.parentNode);
        parent.classed("marquee", false);
        label.style("width", "");
        if (toggle) {
          if (label.node().scrollWidth > label.node().offsetWidth) {
            label.attr("data-content", label.text());
            const space = 30;
            const offset = space + label.node().scrollWidth;
            label.style("width", offset + "px");
            parent.classed("marquee", true);
          }
        }
      });
    }

    marqueeToggle(toggle) {
      const label = this.entity.select("." + css.list_item_label).select("span");
      this.entity.classed("marquee", false);
      label.style("width", "");
      if (toggle) {
        if (label.node().scrollWidth > label.node().offsetWidth) {
          label.attr("data-content", label.text());
          const space = 30;
          const offset = space + label.node().scrollWidth;
          label.style("width", offset + "px");
          this.entity.classed("marquee", true);
        }
      }
    }
  }

  const PROFILE_CONSTANTS$1 = {
    SMALL: {
      col_width: 200
    },
    MEDIUM: {
      col_width: 200
    },
    LARGE: {
      col_width: 200
    }
  };

  const PROFILE_CONSTANTS_FOR_PROJECTOR$1 = {
    MEDIUM: {
      col_width: 200
    },
    LARGE: {
      col_width: 200
    }
  };

  function getTagNameForDs(ds){
    return "dataset " + ds.id;
  }

  function getItemName(item){
    if (item.type == "indicator"){
      return item.byDataSources.map(m => m.name_catalog)
        .concat(item.byDataSources.map(m => m.name))
        .concat(item.id)
        .filter(f => f)[0];
    } else {
      return item.name_catalog || item.name || item.id;
    }
  }


  function resolveDefaultScales(concept) {
    if (concept.scales) return JSON.parse(concept.scales);
    switch (concept.concept_type) {
    case "measure": return ["linear", "log"];
    case "string": return ["ordinal"];
    case "entity_domain": return ["ordinal"];
    case "entity_set": return ["ordinal"];
    case "boolean": return ["ordinal"];
    case "time": return ["time"];
    default: return ["linear", "log"];
    }
  }

  function spacesAreEqual$2(a, b){
    return a.concat().sort().join() === b.concat().sort().join();
  }

  /*!
   * VIZABI TREEMENU
   * Treemenu component
   */

  class TreeMenu extends BaseComponent {

    constructor(config) {
      //contructor is the same as any component
      super(config);
    }

    //setters-getters
    indicatorsTree(input) {
      if (!arguments.length) return this._indicatorsTree;
      this._indicatorsTree = input;
      return this;
    }
    callback(input) {
      if (!arguments.length) return this._callback;
      this._callback = input;
      return this;
    }
    encoding(input) {
      if (!arguments.length) return this._encoding;
      this._encoding = input;
      this.targetModel(this.model.encoding[this._encoding]);
      return this;
    }
    showWhenReady(input) {
      if (!arguments.length) return this._showWhenReady;
      this._showWhenReady = input;
      return this;
    }
    scaletypeSelectorDisabled(input) {
      if (!arguments.length) return this._scaletypeSelectorDisabled;
      this._scaletypeSelectorDisabled = input;
      return this;
    }
    title(input) {
      if (!arguments.length) return this._title;
      this._title = input;
      return this;
    }

    alignX(input) {
      if (!arguments.length) return this._alignX;
      this._alignX = input;
      return this;
    }
    alignY(input) {
      if (!arguments.length) return this._alignY;
      this._alignY = input;
      return this;
    }
    top(input) {
      if (!arguments.length) return this._top;
      this._top = input;
      return this;
    }
    left(input) {
      if (!arguments.length) return this._left;
      this._left = input;
      return this;
    }

    targetModel(input) {
      if (!arguments.length) return this._targetModel;

      this.removeReaction(this._targetModelReaction);
      this._targetModel = input;
      this._targetProp = null;
      this._targetProp = ["data", "concept"];
      this.addReaction(this._targetModelReaction);

      return this;
    }

    targetProp(input) {
      if (!arguments.length) return this._targetProp;
      this._targetProp = input;
      return this;
    }

    _targetModelReaction() {
      getProp(this._targetModel, ["scale", "type"]);
      getProp(this._targetModel, this._targetProp);
      this.updateView();
    }

    _buildTagFolderTree({ tagsArray, dataModels }) {
      if (tagsArray === true || !tagsArray) tagsArray = [];

      const ROOT = "_root";
      const ADVANCED = "advanced";
      const OTHER_DATASETS = "other_datasets";

      const FOLDER_STRATEGY_SPREAD = "spread"; //spread indicatos over the root of treemeny
      const FOLDER_STRATEGY_ROOT = "root"; //put indicators in dataset's own folder under root of treemeny
      const FOLDER_STRATEGY_FOLDER = "folder"; //put indicators in dataset's own folder inside a specified folder. use notation like "folder:other_datasets"

      //const dataModels = _this.model.marker._root.dataManager.getDataModels();
      const FOLDER_STRATEGY_DEFAULT = dataModels.length == 1 ? FOLDER_STRATEGY_SPREAD : FOLDER_STRATEGY_ROOT;

      //init the dictionary of tags and add default folders
      const tags = {};
      tags[ROOT] = { id: ROOT, children: [] };
      tags[ADVANCED] = { id: ADVANCED, name: this.localise("treemenu/advanced"), type: "folder", children: [] };
      tags[ROOT].children.push(tags[ADVANCED]);
      tags[OTHER_DATASETS] = { id: OTHER_DATASETS, name: this.localise("treemenu/other_datasets"), type: "folder", children: [] };
      tags[ROOT].children.push(tags[OTHER_DATASETS]);

      //populate the dictionary of tags
      tagsArray.forEach(tag => { tags[tag.tag] = { id: tag.tag, name: tag.name, type: "folder", children: [] }; });

      //put the dataset folders where they should be: either in root or in specific folders or ==root in case of spreading
      const folderStrategies = {};
      dataModels.forEach((ds) => {
        //special ds tag id is needed to prevent a situation when DS id happens to be equal to ID of one of the tags
        const dsTag = getTagNameForDs(ds);

        //figure out the folder strategy
        let strategy = getProp(this.ui, ["folderStrategyByDataset", ds.id]);
        let folder = null;
        if (!strategy) strategy = FOLDER_STRATEGY_DEFAULT;

        if (strategy.includes(":")) {
          folder = strategy.split(":")[1];
          strategy = strategy.split(":")[0];
        }

        //add the dataset's folder to the tree
        tags[dsTag] = { id: ds.id, name: this._getDatasetName(ds), type: "dataset", children: [] };

        if (strategy == FOLDER_STRATEGY_FOLDER && tags[folder]) {
          tags[folder].children.push(tags[dsTag]);
        } else if (strategy == FOLDER_STRATEGY_SPREAD) {
          tags[dsTag] = tags[ROOT];
        } else {
          tags[ROOT].children.push(tags[dsTag]);
        }

        folderStrategies[ds.id] = strategy;
      });

      //populate the tag tree
      tagsArray.forEach(tag => {

        //if tag's parent is defined
        if (tag.parent && tags[tag.parent]) {

          //add tag to a branch
          tags[tag.parent].children.push(tags[tag.tag]);

        } else {

          //if parent is missing add a tag either to dataset's own folder or to the root if spreading them
          if (folderStrategies[tag.datasource.id] == FOLDER_STRATEGY_SPREAD) {
            tags[ROOT].children.push(tags[tag.tag]);
          } else {
            if (tags[getTagNameForDs(tag.datasource)])
              tags[getTagNameForDs(tag.datasource)].children.push(tags[tag.tag]);
            else
              warn(`Tags request to the datasource ${tag.datasource.id} probably didn't succeed`);
          }
        }
      });

      return {tags, tagsRoot: tags[ROOT]};
    }

    _addIndicatorToTheTree(id, item, folder) {
      const existing = folder.children.find(f => f.id == id);
      if (existing) {
        //add to an existing item group
        existing.byDataSources.push(item);
      } else {
        //create a new item group
        folder.children.push({ id: id, concept_type: item.concept_type, type: "indicator", scales: item.scales, byDataSources: [item] });
      }
      return folder;
    }

    _buildIndicatorsTree({ tagsArray, dataModels }) {

      let consoleGroupOpen = false;
      const {tags, tagsRoot} = this._buildTagFolderTree({ tagsArray, dataModels });

      //add constant pseudoconcept
      this._addIndicatorToTheTree("_default", { spaces: [[]] }, tagsRoot);

      const nest = this._nestAvailabilityByConcepts(this._getAvailability());
      const filtervl = this._conceptsCompatibleWithMarkerSpace(nest, this.model.data.space);
      const concepts = this._convertConceptMapToArray(filtervl);

      concepts
        //add marker space concepts to be able to select "color by countries" or "x by time"
        .concat(this.model.data.space.map(d => {
          return { 
            spaces: [[d]],
            source: this.model.data.source,
            concept: this.model.data.source.getConcept(d)
          }; 
        }))
        .filter(f =>  (!f.concept.tags || f.concept.tags !== "_none") && f.concept.concept && f.concept.concept.slice(0,4) !== "is--" )
        .forEach(({concept, spaces, source}) => {

          const id = concept.concept;
          const props = {
            concept_type: concept.concept_type,
            dataSource: source,
            spaces,
            name: concept.name || concept.concept,
            name_catalog: concept.name_catalog,
            description: concept.description,
            scales: concept.scales ? JSON.parse(concept.scales) : null
          };

          if (concept.concept_type == "time" || concept.concept == "_default"){
            //special concepts
            this._addIndicatorToTheTree(id, props, tagsRoot);

          } else if (concept.concept_type == "entity_domain" || concept.concept_type == "entity_set") {
            //entity sets and domains
            const keyConcept = source.getConcept(spaces[0][0]);
            const folderName = keyConcept.concept + "_properties";
            if (!tags[folderName]) {
              tags[folderName] = { id: folderName, name: (keyConcept.name || keyConcept.concept) + " properties", type: "folder", children: [] };
              tagsRoot.children.push(tags[folderName]);
            }
            this._addIndicatorToTheTree(id, props, tags[folderName]);

          } else {
            //regulat indicators
            const conceptTags = concept.tags || getTagNameForDs(source) || "_root";
            conceptTags.split(",").forEach(tag => {
              tag = tag.trim();
              if (tags[tag]) {
                this._addIndicatorToTheTree(id, props, tags[tag]);
              } else {
                //if entry's tag is not found in the tag dictionary
                if (!consoleGroupOpen) {
                  console.groupCollapsed("Some tags were not found, so indicators went under menu root");
                  consoleGroupOpen = true;
                }
                warn("tag '" + tag + "' for indicator '" + props.id + "'");
                this._addIndicatorToTheTree(id, props, tagsRoot);
              }
            });

          }
        });


      if (consoleGroupOpen) console.groupEnd();
      this._sortChildren(tagsRoot);
      this.indicatorsTree(tagsRoot);

      return Promise.resolve();
    }

    _sortChildren(tree, isSubfolder) {
      const _this = this;
      if (!tree.children) return;
      tree.children.sort(
        firstBy()((a, b) => { a = a.type === "dataset" ? 1 : 0;  b = b.type === "dataset" ? 1 : 0; return b - a; })
          .thenBy((a, b) => { a = a.children ? 1 : 0;  b = b.children ? 1 : 0; return a - b; })
          .thenBy((a, b) => {
          //in the root level put "time" on top and send "anvanced" to the bottom
            if (!isSubfolder) {
              if (a.id == "time") return -1;
              if (b.id == "time") return 1;
              if (a.id == "other_datasets") return 1;
              if (b.id == "other_datasets") return -1;
              if (a.id == "advanced") return 1;
              if (b.id == "advanced") return -1;
              if (a.id == "_default") return 1;
              if (b.id == "_default") return -1;
            }
            //sort items alphabetically. folders go down because of the emoji folder in the beginning of the name
            return getItemName(a) > getItemName(b) ? 1 : -1;
          })
      );

      //recursively sort items in subfolders too
      tree.children.forEach(d => {
        _this._sortChildren(d, true);
      });
    }

    //happens on resizing of the container
    _resize() {
      this.services.layout.size;
      
      const _this = this;
      const { wrapper, wrapperOuter } = this.DOM;

      let top = this._top;
      let left = this._left;

      if (!wrapper) return warn("treemenu resize() abort because container is undefined");

      wrapper.classed(css.noTransition, true);
      wrapper.node().scrollTop = 0;

      this.OPTIONS.IS_MOBILE = this.services.layout.profile === "SMALL";

      if (this.menuEntity) {
        this.menuEntity.setWidth(this.profileConstants.col_width, true, true);

        if (this.OPTIONS.IS_MOBILE) {
          if (this.menuEntity.direction != MENU_VERTICAL) {
            this.menuEntity.setDirection(MENU_VERTICAL, true);
            this.OPTIONS.MENU_DIRECTION = MENU_VERTICAL;
          }
        } else {
          if (this.menuEntity.direction != MENU_HORIZONTAL) {
            this.menuEntity.setDirection(MENU_HORIZONTAL, true);
            this.OPTIONS.MENU_DIRECTION = MENU_HORIZONTAL;
          }
        }
      }

      this.width = _this.element.node().offsetWidth;
      this.height = _this.element.node().offsetHeight;
      const rect = wrapperOuter.node().getBoundingClientRect();
      const containerWidth = rect.width;
      let containerHeight = rect.height;
      if (containerWidth) {
        if (this.OPTIONS.IS_MOBILE) {
          this.clearPos();
        } else {
          if (top || left) {
            if (wrapperOuter.node().offsetTop < 10) {
              wrapperOuter.style("top", "10px");
            }
            if (this.height - wrapperOuter.node().offsetTop - containerHeight < 0) {
              if (containerHeight > this.height) {
                containerHeight = this.height - 20;
              }
              wrapperOuter.style("top", (this.height - containerHeight - 10) + "px");
              wrapperOuter.style("bottom", "auto");
            }
            if (top) top = wrapperOuter.node().offsetTop;
          }

          let maxHeight;
          if (wrapperOuter.classed(css.alignYb)) {
            maxHeight = wrapperOuter.node().offsetTop + wrapperOuter.node().offsetHeight;
          } else {
            maxHeight = this.height - wrapperOuter.node().offsetTop;
          }
          wrapper.style("max-height", (maxHeight - wrapper.node().offsetTop - 10) + "px");

          wrapperOuter.classed(css.alignXc, this._alignX === "center");
          wrapperOuter.style("margin-left", this._alignX === "center" ? "-" + containerWidth / 2 + "px" : null);
          if (this._alignX === "center") {
            this.OPTIONS.MAX_MENU_WIDTH = this.width / 2 - containerWidth * 0.5 - 10;
          } else {
            this.OPTIONS.MAX_MENU_WIDTH = this.width - wrapperOuter.node().offsetLeft - containerWidth - 10; // 10 - padding around wrapper
          }

          const minMenuWidth = this.profileConstants.col_width + this.OPTIONS.MIN_COL_WIDTH * 2;
          let leftPos = wrapperOuter.node().offsetLeft;
          this.OPTIONS.MENU_OPEN_LEFTSIDE = this.OPTIONS.MAX_MENU_WIDTH < minMenuWidth && leftPos > (this.OPTIONS.MAX_MENU_WIDTH + 10);
          if (this.OPTIONS.MENU_OPEN_LEFTSIDE) {
            if (leftPos <  (minMenuWidth + 10)) leftPos = (minMenuWidth + 10);
            this.OPTIONS.MAX_MENU_WIDTH = leftPos - 10; // 10 - padding around wrapper
          } else {
            if (this.OPTIONS.MAX_MENU_WIDTH < minMenuWidth) {
              leftPos -= (minMenuWidth - this.OPTIONS.MAX_MENU_WIDTH);
              this.OPTIONS.MAX_MENU_WIDTH = minMenuWidth;
            }
          }

          if (left) {
            left = leftPos;
          } else {
            if (leftPos != wrapperOuter.node().offsetLeft) {
              wrapperOuter.style("left", "auto");
              wrapperOuter.style("right", (this.width - leftPos - rect.width) + "px");
            }
          }

          this._top = top;
          this._left = left;

          if (left || top) this.setPos();

          wrapperOuter.classed("vzb-treemenu-open-left-side", !this.OPTIONS.IS_MOBILE && this.OPTIONS.MENU_OPEN_LEFTSIDE);
        }
      }

      wrapper.node().offsetHeight;
      wrapper.classed(css.noTransition, false);

      this._setHorizontalMenuHeight();

      return this;
    }

    toggle() {
      this.setHiddenOrVisible(!this.element.classed(css.hidden));
    }

    setHiddenOrVisible(hidden) {
      const _this = this;

      this.element.classed(css.hidden, hidden);
      this.DOM.wrapper.classed(css.noTransition, hidden);

      if (hidden) {
        this.clearPos();
        this.menuEntity.marqueeToggle(false);
      } else {
        this.setPos();
        !isTouchDevice() && this._focusSearch();
        this._resize();
        this._scrollToSelected();
      }

      this.root.children.forEach(c => {
        if (c.name == "gapminder-dialogs") {
          d3.select(c.placeholder.parentNode).classed("vzb-blur", !hidden);
        } else
        if (c.element.classed) {
          c.element.classed("vzb-blur", c != _this && !hidden);
        } else {
          d3.select(c.element).classed("vzb-blur", c != _this && !hidden);
        }
      });

      this.width = _this.element.node().offsetWidth;

      return this;
    }

    _scrollToSelected() {
      if (!this.selectedNode) return;
      const _this = this;

      if (this.menuEntity.direction == MENU_VERTICAL) {
        scrollToItem(this.DOM.wrapper.node(), this.selectedNode);
        _this.menuEntity.marqueeToggleAll(true);
      } else {
        const selectedItem = this.menuEntity.findItemById(d3.select(this.selectedNode).datum().id);
        selectedItem.submenu.calculateMissingWidth(0, () => {
          _this.menuEntity.marqueeToggleAll(true);
        });

        let parent = this.selectedNode;
        let listNode;
        while (!(hasClass(parent, css.list_top_level))) {
          if (parent.tagName == "LI") {
            listNode = hasClass(parent.parentNode, css.list_top_level) ? parent.parentNode.parentNode : parent.parentNode;
            scrollToItem(listNode, parent);
          }
          parent = parent.parentNode;
        }
      }

      function scrollToItem(listNode, itemNode){
        listNode.scrollTop = 0;
        const rect = listNode.getBoundingClientRect();
        const itemRect = itemNode.getBoundingClientRect();
        const scrollTop = itemRect.bottom - rect.top - listNode.offsetHeight + 10;
        listNode.scrollTop = scrollTop;
      }
    }

    setPos() {
      const { wrapperOuter } = this.DOM;

      const top = this._top;
      const left = this._left;
      const rect = wrapperOuter.node().getBoundingClientRect();

      if (top) {
        wrapperOuter.style("top", top + "px");
        wrapperOuter.style("bottom", "auto");
        wrapperOuter.classed(css.absPosVert, top);
      }
      if (left) {
        let right = this.element.node().offsetWidth - left - rect.width;
        right = right < 10 ? 10 : right;
        wrapperOuter.style("right", right + "px");
        wrapperOuter.style("left", "auto");
        wrapperOuter.classed(css.absPosHoriz, right);
      }

    }

    clearPos() {
      const { wrapper, wrapperOuter } = this.DOM;

      this._top = "";
      this._left = "";
      wrapperOuter.attr("style", "");
      wrapperOuter.classed(css.absPosVert, "");
      wrapperOuter.classed(css.absPosHoriz, "");
      wrapperOuter.classed(css.menuOpenLeftSide, "");
      wrapper.style("max-height", "");
    }

    _setHorizontalMenuHeight() {
      const { wrapper } = this.DOM;

      let wrapperHeight = null;
      if (this.menuEntity && this.OPTIONS.MENU_DIRECTION == MENU_HORIZONTAL && this.menuEntity.menuItems.length) {
        const oneItemHeight = parseInt(this.menuEntity.menuItems[0].entity.style("height"), 10) || 0;
        const menuMaxHeight = oneItemHeight * this._maxChildCount;
        const rootMenuHeight = Math.max(this.menuEntity.menuItems.length, 3) * oneItemHeight + this.menuEntity.entity.node().offsetTop + parseInt(wrapper.style("padding-bottom"), 10);
        wrapperHeight = "" + Math.max(menuMaxHeight, rootMenuHeight) + "px";
      }
      wrapper.classed(css.noTransition, true);
      wrapper.node().offsetHeight;
      wrapper.style("height", wrapperHeight);
      wrapper.node().offsetHeight;
      wrapper.classed(css.noTransition, false);
    }

    //search listener
    _enableSearch() {
      const _this = this;

      const input = this.DOM.wrapperHeader.select("." + css.search);

      //it forms the array of possible queries
      const getMatches = function(value) {
        const matches = {
          _id: "root",
          children: []
        };

        //translation integration
        const translationMatch = function(value, data, i) {

          //search name in all datasources
          const item = data[i];
          let translate = item.type == "folder" && item.name || item.type == "indicator" && item.byDataSources.map(m => m.name).join();
          if (!translate && _this.localise) {
            const t1 = _this.localise("indicator" + "/" + data[i][_this.OPTIONS.SEARCH_PROPERTY] + "/" + _this._targetModel._type);
            translate =  t1 || _this.localise("indicator/" + data[i][_this.OPTIONS.SEARCH_PROPERTY]);
          }
          return translate && translate.toLowerCase().indexOf(value.toLowerCase()) >= 0;
        };

        const matching = function(data) {
          const SUBMENUS = _this.OPTIONS.SUBMENUS;
          for (let i = 0; i < data.length; i++) {
            let match = false;
            match =  translationMatch(value, data, i);
            if (match) {
              matches.children.push(data[i]);
            }
            if (!match && data[i][SUBMENUS]) {
              matching(data[i][SUBMENUS]);
            }
          }
        };
        matching(_this.dataFiltered.children);

        matches.children = unique(matches.children, child => child.id);
        return matches;
      };

      let searchValueNonEmpty = false;

      const searchIt = debounce(() => {
        const value = input.node().value;

        //Protection from unwanted IE11 input events.
        //IE11 triggers an 'input' event when 'placeholder' attr is set to input element and
        //on 'focusin' and on 'focusout', if nothing has been entered into the input.
        if (!searchValueNonEmpty && value == "") return;
        searchValueNonEmpty = value != "";

        if (value.length >= _this.OPTIONS.SEARCH_MIN_STR) {
          _this.redraw(getMatches(value));
        } else {
          _this.redraw();
        }
      }, 250);

      input.on("input", searchIt);
    }

    _selectIndicator(concept) {
      if(concept.id == this._targetModel.data.concept) return;
      this._setModelWhich(concept);
      this.toggle();
    }


    _getFilteredTree() {
      const _this = this;

      const conceptFilter = function conceptFilter(concept) {
        return _this._targetModel.data.allow.concept.filter(concept);
      };

      const scaleTypeFilter = function scaleTypeFilter(concept) {
        const allowedTypes = _this._targetModel.scale.allowedTypes;

        //keep indicator if nothing is specified in tool properties or if any scale is allowed explicitly
        if (!allowedTypes || !allowedTypes.length || allowedTypes[0] == "*") return true;
        
        //match specific scale types if defined
        if(concept.scales) return !!d3.intersection(allowedTypes, concept.scales).size;

        //otherwise go by concept types
        const ctype = concept.concept_type;

        return d3.intersection(allowedTypes, ["ordinal", "point"]).size && concept.id === "_default"
          //for entities, strings need an ordinal or rank scale to be allowed
          || d3.intersection(allowedTypes, ["ordinal", "rank"]).size && ["entity_domain", "entity_set", "string"].includes(ctype) 
          // for measures need linear or log or something
          || d3.intersection(allowedTypes, ["linear", "log", "genericLog", "pow"]).size && ["measure"].includes(ctype)
          // special case for time
          || (ctype === "time" && allowedTypes.includes("time"));
      };

      const satisfiesAllowedSpaces = (item) => {
        //optionally check if at least one space in at least one space of at least one DS of a menu item satisfies the "allow.space" filter
        let spacesFromAllDS = [];
        item.byDataSources.forEach(item => spacesFromAllDS = spacesFromAllDS.concat(item.spaces));
        return spacesFromAllDS.some(space => this._targetModel.data.allow.space.filter(space));          
      };
      return pruneTree(this._indicatorsTree, f => conceptFilter(f) && scaleTypeFilter(f)  && f.type == "indicator" && satisfiesAllowedSpaces(f));
    }

    //function is redrawing data and built structure
    redraw(data) {
      const _this = this;

      const searchApplied = !!data;

      if (!searchApplied) this.dataFiltered = data = this._getFilteredTree();

      const { wrapper, wrapperHeader } = this.DOM;
      const targetModelName = _this._targetModel.name || _this._targetModel.config.type;
      wrapper.classed("vzb-hidden", !searchApplied).select("ul").remove();

      let title = "";
      if (this._title || this._title === "") {
        title = this._title;
      } else {
        title = this.localise("buttons/" + targetModelName);
      }
      wrapperHeader.select("." + css.title).select("span")
        .text(title);

      wrapperHeader.select("." + css.search)
        .attr("placeholder", this.localise("placeholder/search") + "...");

      this._maxChildCount = 0;
      let selected = getProp(_this._targetModel, _this._targetProp);
      const selectedPath = [];
      eachTree(data, (f, parent) => {
        if (f.children && f.children.length > _this._maxChildCount) _this._maxChildCount = f.children.length;
        if (f.id === selected && parent) {
          selectedPath.unshift(f.id);
          selected = parent.id;
        }
      });
      this.OPTIONS.selectedPath = selectedPath;

      if (this.OPTIONS.IS_MOBILE) {
        this.OPTIONS.MENU_DIRECTION = MENU_VERTICAL;
      } else {
        this.OPTIONS.MENU_DIRECTION = MENU_HORIZONTAL;
      }
      this.OPTIONS.createSubmenu = this._createSubmenu.bind(this);
      this.OPTIONS.COL_WIDTH = this.profileConstants.col_width;

      this.selectedNode = null;
      wrapper.datum(data);
      this.menuEntity = new Menu(this, null, wrapper, this.OPTIONS);
      wrapper.classed("vzb-hidden", false);

      this._setHorizontalMenuHeight();

      if (!searchApplied) {
        const concept = this._targetModel.data.conceptProps || {};

        const scaleTypesData = resolveDefaultScales(concept).filter(f => {
          if (_this._targetModel.scale.allowedTypes) return _this._targetModel.scale.allowedTypes.includes(f);
          if (!_this._targetModel.data.allow || !_this._targetModel.data.allow.scales) return true;
          if (_this._targetModel.data.allow.scales[0] == "*") return true;
          return _this._targetModel.data.allow.scales.indexOf(f) > -1;
        });
        if (scaleTypesData.length == 0) {
          this.element.select("." + css.scaletypes).classed(css.hidden, true);
        } else {

          let scaleTypes = this.element.select("." + css.scaletypes).classed(css.hidden, false).selectAll("span")
            .data(scaleTypesData, d => d);

          scaleTypes.exit().remove();

          scaleTypes = scaleTypes.enter().append("span")
            .on("click", (event, d) => {
              event.stopPropagation();
              _this._setModelScaleType(d);
            })
            .merge(scaleTypes);

          const mdlScaleType = _this._targetModel.scale.type;

          scaleTypes
            .classed(css.scaletypesDisabled, scaleTypesData.length < 2 || _this._scaletypeSelectorDisabled)
            .classed(css.scaletypesActive, d => (d == mdlScaleType || d === "log" && mdlScaleType === "genericLog") && scaleTypesData.length > 1)
            .text(d => _this.localise("scaletype/" + d));
        }

      }

      return this;
    }

    _createSubmenu(select, data, toplevel) {
      if (!data.children) return;
      const _this = this;
      const targetModelName = _this._targetModel.name || _this._targetModel.config.type;
      const _select = toplevel ? select : select.append("div")
        .classed(css.list_outer, true);

      const li = _select.append("ul")
        .classed(css.list, !toplevel)
        .classed(css.list_top_level, toplevel)
        .classed("vzb-dialog-scrollable", true)
        .selectAll("li")
        .data(data.children, d => d["id"])
        .enter()
        .append("li");

      li.append("span")
        .classed(css.list_item_label, true)
        // .attr("info", function(d) {
        //   return d.id;
        // })
        .attr("children", d => d.children ? "true" : null)
        .attr("type", d => d.type ? d.type : null)
        .style("color", d => {
          if (this.ui.showDataSources && d.type == "indicator" && d.id !== "_default" && d.byDataSources.length == 1) {
            return this.dsColorScaleDark(d.byDataSources[0].dataSource.id);
          } else {
            return null;
          }
        })
        .on("click", function(event, d) {
          const view = d3.select(this);
          //only for leaf nodes
          if (view.attr("children")) return;
          event.stopPropagation();
          _this._selectIndicator(d);
        })
        .append("span")
        .text(d => {
          //Let the indicator "_default" in tree menu be translated differnetly for every hook type
          const translated = d.id === "_default" ? _this.localise("indicator/_default/" + targetModelName) : getItemName(d);
          if (!translated && translated !== "") warn("translation missing: NAME of " + d.id);
          return translated || "";
        });

      li.classed(css.list_item, true)
        .classed(css.hasChild, d => d["children"])
        .classed(css.isSpecial, d => d["special"])
        .each(function(d) {
          const view = d3.select(this);

          //deepLeaf
          if (!d.children) {
            if (d.id === "_default") {
              d.byDataSources[0].name = _this.localise("indicator/_default/" + targetModelName);
              d.byDataSources[0].description = _this.localise("description/_default/" + targetModelName);
            }
            const deepLeaf = view.append("div")
              .attr("class", css.menuHorizontal + " " + css.list_outer + " " + css.list_item_leaf);
            deepLeaf.on("click", (event, d) => {
              _this._selectIndicator(d);
            });
          }

          if (d.id == getProp(_this._targetModel, _this._targetProp)) {
            let parent;
            if (_this.selectedNode && toplevel) {
              parent = _this.selectedNode.parentNode;
              d3.select(_this.selectedNode)
                .select("." + css.list_item_leaf).classed("active", false);
              while (!(hasClass(parent, css.list_top_level))) {
                if (parent.tagName == "UL") {
                  d3.select(parent.parentNode)
                    .classed("active", false);
                }
                parent = parent.parentNode;
              }
            }
            if (!_this.selectedNode || toplevel) {
              parent = this.parentNode;
              d3.select(this).classed("item-active", true)
                .select("." + css.list_item_leaf).classed("active", true);
              while (!(hasClass(parent, css.list_top_level))) {
                if (parent.tagName == "UL") {
                  d3.select(parent.parentNode)
                    .classed("active", true);
                }
                if (parent.tagName == "LI") {
                  d3.select(parent).classed("item-active", true);
                }
                parent = parent.parentNode;
              }
              _this.selectedNode = this;
            }
          }
        });
    }

    updateView() {
      if (!this._targetModel) return;
      if (!this._indicatorsTree) return console.error("Tree menu: indicator tree has not been constructed (yet?)");

      const { wrapperHeader, wrapperOuter } = this.DOM;

      wrapperOuter.classed(css.absPosVert, this._top);
      wrapperOuter.classed(css.alignYt, this._alignY === "top");
      wrapperOuter.classed(css.alignYb, this._alignY === "bottom");
      wrapperOuter.classed(css.absPosHoriz, this._left);
      wrapperOuter.classed(css.alignXl, this._alignX === "left");
      wrapperOuter.classed(css.alignXr, this._alignX === "right");

      this.redraw();

      if (this._showWhenReady) this.setHiddenOrVisible(false).showWhenReady(false);

      wrapperHeader.select("." + css.search).node().value = "";

      return this;
    }

    _focusSearch(focus = true) {
      const searchInput = this.DOM.wrapperHeader.select("." + css.search).node();

      if (focus) {
        searchInput.focus();
      } else {
        searchInput.blur();
      }
    }

    _setModelScaleType(type){
      this._targetModel.scale.config.type = type;
    }

    _setModelWhich(concept) {    
      if(concept.id == "_default"){
        this._targetModel.setWhich({
          key: null,
          value: {concept: "_default", dataSource: null}
        });
      } else {
        const {space, dataSource} = this.getBestFittingDataSourceAndSpace(concept.byDataSources);
        this._targetModel.setWhich({
          key: space,
          value: {concept: concept.id, dataSource: dataSource.id}
        });
      }
    }

    getBestFittingDataSourceAndSpace(byDataSources) {
      const bestSpacePerDataSource = byDataSources.map(m => this.getNearestSpaceToMarkerSpace(m.spaces));
      const bestSpace = this.getNearestSpaceToMarkerSpace(bestSpacePerDataSource);

      const dsCandidates = byDataSources.filter(f => f.spaces.find(s => spacesAreEqual$2(s, bestSpace))).map(m => m.dataSource);
       
      if (dsCandidates.includes(this.model.data.source))
        return {space: bestSpace, dataSource: this.model.data.source};
      else if (dsCandidates.includes(this._targetModel.data.source)) 
        return {space: bestSpace, dataSource: this._targetModel.data.source};
      else
        return {space: bestSpace, dataSource: dsCandidates[0]};
    }

    getNearestSpaceToMarkerSpace(spaces){
      //concept has an available space same as already set in marker: perfect match!
      if (spaces.find(f => spacesAreEqual$2(f, this.model.data.space))) 
        return this.model.data.space;

      //otherwise return space that is closest by length to marker space length
      //so we prioritise [country, gender, time] over [country, gender, age, time]
      const markerSpaceLen = this.model.data.space.length;
      const spacesPrio = spaces.concat()
        .sort((a, b) => Math.abs(a.length - markerSpaceLen) - Math.abs(b.length - markerSpaceLen));
      return spacesPrio[0];
    }

    setup() {
      this.state = {
        ownReadiness: STATUS.INIT
      };

      // object for manipulation with menu representation level
      this.menuEntity = null;

      this._alignX = "center";
      this._alignY = "center";

      //options
      this.OPTIONS = deepClone(OPTIONS$3);

      //general markup
      this.DOM = {
      };

      this.element.classed(css.hidden, true)
        .append("div")
        .attr("class", css.background)
        .on("click", (event) => {
          event.stopPropagation();
          this.toggle();
        });

      const wrapperOuter = this.DOM.wrapperOuter = this.element
        .append("div")
        .classed(css.wrapper_outer, true)
        .classed(css.noTransition, true);

      const wrapperHeader = this.DOM.wrapperHeader = wrapperOuter
        .append("div")
        .classed(css.wrapper_header, true);

      wrapperHeader.append("div")
        .attr("class", css.close)
        .html(ICON_CLOSE)
        .on("click", (event) => {
          event.stopPropagation();
          this.toggle();
        })
        .select("svg")
        .attr("width", "0px")
        .attr("height", "0px")
        .attr("class", css.close + "-icon");

      wrapperHeader.append("div")
        .classed(css.scaletypes, true)
        .append("span");

      wrapperHeader.append("div")
        .classed(css.title, true)
        .append("span");

      wrapperHeader.append("div")
        .classed(css.search_wrap, true)
        .append("input")
        .classed(css.search, true)
        .attr("type", "search")
        .attr("id", css.search);

      const wrapper = this.DOM.wrapper = wrapperOuter
        .append("div")
        .classed(css.wrapper, true)
        .classed(css.noTransition, true)
        .classed("vzb-dialog-scrollable", true);

      wrapper
        .on("click", (event) => {
          event.stopPropagation();
        });

      wrapper.on("mouseleave", () => {
        //if(_this.menuEntity.direction != MENU_VERTICAL) _this.menuEntity.closeAllChildren();
      });

      const datasources = this._getDataModels(this.root.model.config.dataSources);
      this.dsColorScaleLight = d3.scaleOrdinal().range(d3.schemePastel2).domain(datasources.map(m=>m.id));
      this.dsColorScaleDark = d3.scaleOrdinal().range(d3.schemeSet2).domain(datasources.map(m=>m.id));
    }

    draw() {
      this.localise = this.services.locale.auto();
      this.addReaction(this._prepareTags, true);

      this._updateLayoutProfile();
      this.addReaction(this._resize);
    }

    _prepareTags() {
      mobx.runInAction(() => {
        this.state.ownReadiness = STATUS.PENDING;
      });
      const datasources = this._getDataModels(this.root.model.config.dataSources);
      if (this.services.Vizabi.Vizabi.utils.combineStates(datasources.map(ds => ds.state)) == "fulfilled") {
        const localeId = this.services.locale.id;
        mobx.runInAction(() => {
          this.getTags(localeId)
            .then(tags => {
              return this._buildIndicatorsTree({
                tagsArray: tags,
                dataModels: this._getDataModels(this.root.model.config.dataSources)
              });})
            .then(this.updateView.bind(this))
            .then(() => {
              this._enableSearch();
              this.state.ownReadiness = STATUS.READY;
            });
        });
      }
    }

    _updateLayoutProfile(){
      this.services.layout.size;

      this.profileConstants = this.services.layout.getProfileConstants(PROFILE_CONSTANTS$1, PROFILE_CONSTANTS_FOR_PROJECTOR$1);
      this.height = this.element.node().clientHeight || 0;
      this.width = this.element.node().clientWidth || 0;
      if (!this.height || !this.width) return "TreeMenu _updateProfile() abort: container is too little or has display:none";
    }

    _getDatasetName(ds) {
      if (ds.reader.getDatasetInfo) {
        const meta = ds.reader.getDatasetInfo();
        return meta.name + (meta.version ? " " + meta.version : "");
      }
      return ds.id ?? "Unnamed datasource";
    }

    _getDataModels(dsConfig) {
      return Object.keys(dsConfig).map(dsName => this.services.Vizabi.Vizabi.stores.dataSources.get(dsName));
    }

    _nestAvailabilityByConcepts(availability){
      return availability.reduce((map, kv) => {
        const key = kv.value;
        const space = kv.key;
        if (!map.has(key)) map.set(key, {source: kv.source, spaces: new Set()});
        map.get(key).spaces.add(space);
        return map;
      }, new Map());
    }

    //returns concepts and their spaces (availbility keys), 
    //such that only strict superspaces, strict subspaces and matching spaces remain
    _conceptsCompatibleWithMarkerSpace(availabilityMapByConcepts, markerSpace){
      const filteredValueLookup = new Map();
      const markerSpaceSet = new Set(markerSpace);
      const intersect = (a,b) => a.filter(e => b.has(e));
      for (const [concept, {source, spaces}] of availabilityMapByConcepts) {  
        const filteredSpaces = [...spaces].filter(space => {
          const intersection = intersect(space, markerSpaceSet);
          return intersection.length == markerSpaceSet.size || intersection.length == space.length;
        });
        if (filteredSpaces.length) filteredValueLookup.set(concept, {source, spaces: filteredSpaces});
      }
      return filteredValueLookup;
    }

    _convertConceptMapToArray(conceptmap){
      return [...conceptmap].map(([concept, {source, spaces}]) => ({concept, source, spaces: [...spaces]}));
    }

    __observeDataSources() {
      return this._getDataModels(this.root.model.config.dataSources).map(ds => [ds.state, ds.config]);
    }

    _getAvailability(){
      const items = [];
      this._getDataModels(this.root.model.config.dataSources).forEach(ds => {
        ds.availability.data.forEach(kv => {
          items.push({ key: kv.key, value: ds.getConcept(kv.value), source: ds });
        });
      });
      return items;
    }

    /**
     * Return tag entities with name and parents from all data sources
     * @return {array} Array of tag objects
     */
    getTags(locale) {
      const TAG_KEY = "tag";
      const query = {
        select: {
          key: [TAG_KEY],
          value: []
        },
        language: locale,
        from: "entities"
      };

      const dataSources = this._getDataModels(this.root.model.config.dataSources).reduce((res, ds) => {
        res.set(ds, deepClone(query));
        return res;
      }, new Map());

      this._getAvailability()
        .filter(f => f.key.join() == TAG_KEY)
        .forEach(av => {
          dataSources.get(av.source).select.value.push(av.value.concept);
        });

      const dataSourcesWithTags = [...dataSources].filter(([, query]) => query.select.value.length);

      return dataSourcesWithTags.length ? Promise.all(dataSourcesWithTags
        .map(([ds, query]) => ds.query(query).then(result => {
          return [...result.forQueryKey().values()].map(r => {
            r.datasource = ds;
            return r;
          });
        })))
        .then(results => this.mergeResults(results, ["tag"])) // using merge because key-duplicates terribly slow down treemenu
        : Promise.resolve([]);    
    }

    /**
     * Merges query results. The first result is base, subsequent results are only added if key is not yet in end result.
     * @param  {array of arrays} results Array where each element is a result, each result is an array where each element is a row
     * @param  {array} key     primary key to each result
     * @return {array}         merged results
     */
    mergeResults(results, key) {
      const keys = new Map();
      results.forEach(result => {
        result.forEach(row => {
          const keyString = this.createKeyString(key, row);
          if (!keys.has(keyString))
            keys.set(keyString, row);
        });
      });
      return Array.from(keys.values());
    }

    createKeyString(key, row) {
      return key.map(concept => row[concept]).join(",");
    }

  }

  function firstLastOrMiddle(index, total){
    return {first: index === 0, last: index + 1 === total};
  }

  class _Repeater extends BaseComponent {

    get MDL(){
      return {
        repeat: this.model.encoding.repeat
      };
    }


    loading(){
      this.addReaction(this.addRemoveSubcomponents, true);
    }


    addRemoveSubcomponents(){
      const {repeatedComponentCssClass} = this.options;
      const {rowcolumn, ncolumns, nrows} = this.MDL.repeat;
      const repeat = this.MDL.repeat;

      //The fr unit sets size of track as a fraction of the free space of grid container
      //We need as many 1fr as rows and columns to have cells equally sized (grid-template-columns: 1fr 1fr 1fr;)
      this.element
        .style("grid-template-rows", "1fr ".repeat(nrows))
        .style("grid-template-columns", "1fr ".repeat(ncolumns));

      let sections = this.element.selectAll(".vzb-repeat-inner")
        .data(rowcolumn, d => repeat.getName(d));

      sections.exit()
        .each(d => this.removeSubcomponent(d))
        .remove();      

      sections.enter().append("div")
        .attr("class", "vzb-repeat-inner")
        //add an intermediary div with null datum to prevent unwanted data inheritance to subcomponent
        //https://stackoverflow.com/questions/17846806/preventing-unwanted-data-inheritance-with-selection-select
        .each(function(d){
          d3.select(this).append("div")
            .datum(null)
            .attr("class", () => `${repeatedComponentCssClass} vzb-${repeat.getName(d)}`);
        })
        .each((d,i) => this.addSubcomponent(d,i))
        .merge(sections)      
        .style("grid-row-start", (_, i) => repeat.getRowIndex(i) + 1)
        .style("grid-column-start", (_, i) => repeat.getColumnIndex(i) + 1)
        .each((d,i) => {
          this.findChild({name: repeat.getName(d)}).state.positionInRepeat = this.getPosition(i);
        });

      this.services.layout._resizeHandler();
    }

    getPosition(i){
      const repeat = this.MDL.repeat;
      const {ncolumns, nrows} = repeat;

      return {
        row: firstLastOrMiddle(repeat.getRowIndex(i), nrows),
        column: firstLastOrMiddle(repeat.getColumnIndex(i), ncolumns)
      };
    }

    addSubcomponent(d, index){
      const {repeatedComponent} = this.options;
      const name = this.MDL.repeat.getName(d);

      const subcomponent = new repeatedComponent({
        id: this.id + "-" + index,
        placeholder: ".vzb-" + name,
        model: this.model,
        name,
        parent: this,
        root: this.root,
        state: {alias: d},
        services: this.services,
        options: this.options.repeatedComponentOptions,
        ui: this.ui,
        default_ui: this.DEFAULT_UI
      });
      this.children.push(subcomponent);
    }


    removeSubcomponent(d){
      const subcomponent = this.findChild({name: this.MDL.repeat.getName(d)});
      if(subcomponent) {
        subcomponent.deconstruct();
      }
    }
  }

  _Repeater.DEFAULT_UI = {
  };

  const Repeater = mobx.decorate(_Repeater, {
    "MDL": mobx.computed
  });

  function spacesAreEqual$1(a, b){
    return a.concat().sort().join() === b.concat().sort().join();
  }

  function getMatchingSpace$1(spaces, targetSpace){
    return spaces.find(s => spacesAreEqual$1(s, targetSpace));
  }

  function getSubspaces$1(spaces, targetSpace){
    return spaces.filter(s => s.every(dim => targetSpace.includes(dim)))
      //sort longest first
      .sort((a,b) => b.length - a.length);
  }

  function getSuperspaces$1(spaces, targetSpace){
    return spaces.filter(s => targetSpace.every(dim => s.includes(dim)))
      //sort shortest first
      .sort((a,b) => a.length - b.length);
  }

  function getPartiallyOverlappingSpaces$1(spaces, targetSpace){
    return spaces.filter(s => targetSpace.some(dim => s.includes(dim)))
      //sort shortest first
      .sort((a,b) => a.length - b.length);
  }

  function removeDulicates$1(array){
    const result = [];
    array.forEach(space => {
      if(!result.some(s => spacesAreEqual$1(s, space)))
        result.push(space);
    });
    return result;
  }

  let hidden = true;
  class _SpaceConfig extends BaseComponent {
    constructor(config) {
      config.template = `
      <div class="vzb-spaceconfig-background"></div>
      <div class="vzb-spaceconfig-box">
        <div class="vzb-spaceconfig-title"></div>
        <div class="vzb-spaceconfig-body vzb-dialog-scrollable">
          <div class="vzb-spaceconfig-marker">
            <label for="vzb-spaceconfig-select"></label>
            <select id="vzb-spaceconfig-select"></select>
          </div>
          <div class="vzb-spaceconfig-encodings"></div>
        </div>
        <div class="vzb-spaceconfig-buttons">
        <div class="vzb-spaceconfig-button-apply"></div>
        <div class="vzb-spaceconfig-button-cancel"></div>
        </div>
      </div>
    `;

      super(config);
    }

    setup() {
      this.DOM = {
        background: this.element.select(".vzb-spaceconfig-background"),
        container: this.element.select(".vzb-spaceconfig-box"),
        close: this.element.select(".vzb-spaceconfig-close"),
        title: this.element.select(".vzb-spaceconfig-title"),
        body: this.element.select(".vzb-spaceconfig-body"),
        marker: this.element.select(".vzb-spaceconfig-marker"),
        encodings: this.element.select(".vzb-spaceconfig-encodings"),
        buttoncancel: this.element.select(".vzb-spaceconfig-button-cancel"),
        buttonapply: this.element.select(".vzb-spaceconfig-button-apply"),
        button: d3.select(this.options.button)
      };
      
      this.element.classed("vzb-hidden", true);

      this.setupDialog();
      this.setupTiggerButton();
    }

    setupDialog() {
      this.DOM.background
        .on("click", () => {
          this.toggle(true);
        });

      this.DOM.container.append("div")
        .html(ICON_CLOSE)
        .on("click", () => {
          this.toggle();
        })
        .select("svg")
        .attr("width", "0px")
        .attr("height", "0px")
        .attr("class", "vzb-spaceconfig-close");

    }

    setupTiggerButton() {
      if(!this.DOM.button.size()) return warn("quit setupTiggerButton of SpaceConfig because no button provided");
      
      setIcon(this.DOM.button, ICON_ELLIPSIS_V)
        .attr("title", "Configure marker space")
        .on("click", () => {
          this.toggle();
        });
    }

    get MDL(){
      return {
        frame: this.model.encoding.frame
      };
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.updateUIstrings);
      this.addReaction(this.drawContent);

    }

    drawContent(){
      if (this.element.classed("vzb-hidden")) return;

      this.addReaction(this.updateMarker);
      this.addReaction(this.updateEncodigns);
      this.addReaction(this.updateApplyCancelButtons);
    }

    updateUIstrings(){
      this.DOM.title.html(this.localise("Space config"));
      this.DOM.marker.select("label").text(this.localise("Marker space"));
      this.DOM.buttoncancel.text("Cancel");
      this.DOM.buttonapply.text("Apply");
      //this.DOM.body.html(this.localise("datawarning/body/" + this.root.name));
    }

    toggle(arg) {
      if (arg == null) arg = !hidden;
      hidden = arg;
      this.element.classed("vzb-hidden", hidden);

      this.root.children.forEach(c => {
        c.element.classed("vzb-blur", c != this && !hidden);
      });

      this.drawContent();
    }

    _getDataModels(dsConfig) {
      return Object.keys(dsConfig).map(dsName => this.services.Vizabi.Vizabi.stores.dataSources.get(dsName));
    }

    _getAvailability(){
      const items = [];
      this._getDataModels(this.root.model.config.dataSources).forEach(ds => {
        ds.availability.data.forEach(kv => {
          items.push({ key: kv.key, value: ds.getConcept(kv.value), source: ds });
        });
      });
      return items;
    }

    _getSpaceAvailability(){
      const items = [];
      this._getDataModels(this.root.model.config.dataSources).forEach(ds => {
        ds.availability.keyLookup.forEach(val => {
          items.push(val);
        });
      });
      return items;
    }

    _nestAvailabilityByConcepts(availability){
      return availability.reduce((map, kv) => {
        const key = kv.value;
        const space = kv.key;
        if (!map.has(key)) map.set(key, {source: kv.source, spaces: new Set()});
        map.get(key).spaces.add(space);
        return map;
      }, new Map());
    }

    //returns concepts and their spaces (availbility keys), 
    //such that only strict superspaces, strict subspaces and matching spaces remain
    _conceptsCompatibleWithMarkerSpace(availabilityMapByConcepts, markerSpace){
      const filteredValueLookup = new Map();
      const markerSpaceSet = new Set(markerSpace);
      const intersect = (a,b) => a.filter(e => b.has(e));
      for (const [concept, {source, spaces}] of availabilityMapByConcepts) {  
        const filteredSpaces = [...spaces].filter(space => {
          const intersection = intersect(space, markerSpaceSet);
          return intersection.length == markerSpaceSet.size || intersection.length == space.length;
        });
        if (filteredSpaces.length) filteredValueLookup.set(concept, {source, spaces: filteredSpaces});
      }
      return filteredValueLookup;
    }

    _convertConceptMapToArray(conceptmap){
      return [...conceptmap].map(([concept, {source, spaces}]) => ({concept, source, spaces: [...spaces]}));
    }


    updateMarker(){
      const _this = this;

      const frameConcept = this.MDL.frame.data.concept;
      const spaceAvailability = removeDulicates$1(this._getSpaceAvailability().filter(f => f.includes(frameConcept)));
      const selector = this.DOM.marker.select("select");
      const options = selector.selectAll("option").data(spaceAvailability, d => d.sort().join());
      options.exit().remove();
      options.enter().append("option")
        .text(d => d.join())
        .merge(options)
        .property("selected", d => spacesAreEqual$1(d, this.model.data.space));

      selector
        .on("change", function() {
          const space = d3.select(this.options[this.selectedIndex]).datum();
          _this.proposedSpace = space;
          _this.updateEncodigns();
          _this.updateApplyCancelButtons();
          //_this.model.config.data.space = space;
        });

    }

    getEncodings(){
      const encs = this.model.encoding;
      return Object.keys(encs).filter(enc => {
        if (!this.model.requiredEncodings || this.model.requiredEncodings.includes(enc)) return true;
        if (enc == "color") return true;
        if (enc == "label") return true;
      });
    }

    updateEncodigns(){
      const _this = this;
      const encs = this.model.encoding;

      const nest = this._nestAvailabilityByConcepts(this._getAvailability());
      //const filtervl = this._conceptsCompatibleWithMarkerSpace(nest, this.model.data.space);
      this.concepts = this._convertConceptMapToArray(nest);
      this.encNewConfig = {};

      this.DOM.encodings
        .html("")
        .selectAll("div")
        .data(this.getEncodings(), d=>d)
        .enter().append("div")
        .each(function(enc){
          const view = d3.select(this);

          const encoding = encs[enc];
          const status = _this.getSpaceCompatibilityStatus(encoding);
          const concept = _this.concepts.find(f => f.concept.concept == encoding.data.concept);
          const isSpaceSet = encoding.data.config.space;
          const newConfig = _this.encNewConfig[enc] = {};

          view.append("div")
            .attr("class", "vzb-spaceconfig-enc-status")
            .attr("title", status.status)
            .text(_this.statusIcons(status));

          view.append("div")
            .attr("class", "vzb-spaceconfig-enc-name")
            .text(enc);

          if(status.status == "constant"){
            view.append("div")
              .attr("class", "vzb-spaceconfig-enc-concept")
              .text("constant: " + encoding.data.constant);
          }else {

            view.append("div")
              .attr("class", "vzb-spaceconfig-enc-concept")
              .text(concept.concept.name);

            view.append("div")
              .attr("for", "vzb-spaceconfig-enc-space-current")
              .text("current space: " + encoding.data.space.join() + (isSpaceSet? " (set)" : " (inherited)") );

            if(status.status == "alreadyInSpace" || status.status == "entityPropertyDataConfig") {
              view.append("div")
                .attr("for", "vzb-spaceconfig-enc-space-new")
                .text("new space: will reset to marker space if set");

              if(isSpaceSet) newConfig["space"] = null;
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }

            if(status.status == "matchingSpaceAvailable") {
              view.append("div")
                .attr("for", "vzb-spaceconfig-enc-space-new")
                .text("new space: " + status.spaces[0].join() + (isSpaceSet? " (set)" : " (inherited)"));

              if(isSpaceSet) newConfig["space"] = null;
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }     
            
            if(status.status == "subspaceAvailable") {
              view.append("div")
                .attr("for", "vzb-spaceconfig-enc-space-new")
                .text("new space: " + status.spaces[0].join() + " (set)");

              newConfig["space"] = status.spaces[0];
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }  

            if(status.status == "superspaceAvailable") {
              view.append("div")
                .attr("for", "vzb-spaceconfig-enc-space-new")
                .text("new space: " + status.spaces[0].join() + " (set)");
              view.append("div")
                .attr("for", "vzb-spaceconfig-enc-space-new")
                .text("suggest constants for compliment dimensions!");

              newConfig["space"] = status.spaces[0];
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }  


            if(status.status == "patialOverlap" || status.status == "noOverlap") {
              view.append("div")
                .attr("for", "vzb-spaceconfig-enc-space-new")
                .text("new space: not avaiable");

              view.append("label")
                .attr("for", "vzb-spaceconfig-enc-space-select")
                .text("select concept:");

              const filtervl = _this._conceptsCompatibleWithMarkerSpace(nest, _this.proposedSpace);
              const concepts = _this._convertConceptMapToArray(filtervl);
    
              const select = view.append("select")
                .attr("class", "vzb-spaceconfig-enc-concept-new")
                .attr("id", "vzb-spaceconfig-enc-space-select")
                .on("change", function(){
                  newConfig["concept"] = d3.select(this).property("value");
                  newConfig["space"] = null;
                  newConfig["filter"] = {};
                })
                .selectAll("option")
                .data(concepts)
                .enter().append("option")
                .attr("value", option => option.concept.concept)
                .text(option => option.concept.name);

              select.property("selectedIndex", -1);
              
    
            }  

          }
        });
    }

    statusIcons(compatibility){
      return {
        true: "⚫",
        constant: "✳️",
        alreadyInSpace: "♻️", //reset filter on enc
        entityPropertyDataConfig: "🏷", //reset filter on enc
        matchingSpaceAvailable: "➡️",
        subspaceAvailable: "↘️",
        superspaceAvailable: "↗️", //request connstants 
        patialOverlap: "🚧", //request another concept
        noOverlap: "🚧", //request another concept
        false: "❌"
      }[""+compatibility.status];
    }

    getSpaceCompatibilityStatus(encoding){
      const spaces = this.concepts.find(f => f.concept.concept == encoding.data.concept)?.spaces;
      const proposedSpace = this.proposedSpace;

      if (!proposedSpace) return {status: true, spaces: []};
      if (encoding.data.isConstant) return {status: "constant"};

      if (encoding.data.config.modelType == "entityPropertyDataConfig")
        return {status: "entityPropertyDataConfig", spaces: [proposedSpace]};

      if (spacesAreEqual$1(encoding.data.space, proposedSpace)) 
        return {status: "alreadyInSpace", spaces: [proposedSpace]};

      if (getMatchingSpace$1(spaces, proposedSpace)) 
        return {status: "matchingSpaceAvailable", spaces: [proposedSpace]};

      const subspaces = getSubspaces$1(spaces, proposedSpace);
      if (subspaces.length > 0) 
        return {status: "subspaceAvailable", spaces: subspaces};

      const superspaces = getSuperspaces$1(spaces, proposedSpace);
      if (superspaces.length > 0) 
        return {status: "superspaceAvailable", spaces: superspaces};

      const partialOverlap = getPartiallyOverlappingSpaces$1(spaces, proposedSpace);
      if (partialOverlap.length > 0) 
        return {status: "patialOverlap", spaces: []};
      if (partialOverlap.length == 0) 
        return {status: "noOverlap", spaces: []};

      return {status: false, spaces: []};
    }



    updateApplyCancelButtons(){
      const hide = !this.proposedSpace || spacesAreEqual$1(this.proposedSpace, this.model.data.space);
      this.DOM.buttoncancel.classed("vzb-hidden", hide)
        .on("click", () => {this.cancelChanges();});
      this.DOM.buttonapply.classed("vzb-hidden", hide)
        .on("click", () => {this.applyChanges();});
    }
    cancelChanges(){
      this.proposedSpace = null;
      this.toggle();
    }

    applyChanges(){
      if (!this.proposedSpace) return;
      mobx.runInAction(()=>{
        this.model.config.data.space = this.proposedSpace;
        Object.keys(this.encNewConfig).forEach(enc => {
          const newConfig = this.encNewConfig[enc];

          if (newConfig.concept)
            this.model.encoding[enc].config.data.concept = newConfig.concept;

          if (newConfig.space)
            this.model.encoding[enc].config.data.space = newConfig.space;
          else if (newConfig.hasOwnProperty("space"))
            delete this.model.encoding[enc].config.data.space;

          if (newConfig.filter)
            this.model.encoding[enc].config.data.filter = newConfig.filter;
          else if (newConfig.hasOwnProperty("filter"))
            delete this.model.encoding[enc].config.data.filter;
            
        });
      });
      this.toggle();
    }

  }

  _SpaceConfig.DEFAULT_UI = {
  };

  //export default BubbleChart;
  const SpaceConfig = mobx.decorate(_SpaceConfig, {
    "MDL": mobx.computed
  });

  /*!
   * VIZABI ZOOMBUTTONLIST
   * Reusable zoombuttonlist component
   */

  //default existing buttons
  const class_active = "vzb-active";
  // var class_active_locked = "vzb-active-locked";
  // var class_hide_btn = "vzb-dialog-side-btn";
  // var class_unavailable = "vzb-unavailable";
  // var class_vzb_fullscreen = "vzb-force-fullscreen";
  // var class_container_fullscreen = "vzb-container-fullscreen";

  class ZoomButtonList extends BaseComponent {
    constructor(config) {

      super(config);
    } 

    setup() {

      this._available_buttons = {
        "arrow": {
          title: "buttons/cursorarrow",
          icon: "cursorArrow",
          func: this.toggleCursorMode.bind(this),
          required: true,
          statebind: "root.ui.chart.cursorMode",
          statebindfunc: this.setCursorMode.bind(this)
        },
        "plus": {
          title: "buttons/cursorplus",
          icon: "cursorPlus",
          func: this.toggleCursorMode.bind(this),
          required: true,
          statebind: "root.ui.chart.cursorMode",
          statebindfunc: this.setCursorMode.bind(this)
        },
        "minus": {
          title: "buttons/cursorminus",
          icon: "cursorMinus",
          func: this.toggleCursorMode.bind(this),
          required: true,
          statebind: "root.ui.chart.cursorMode",
          statebindfunc: this.setCursorMode.bind(this)
        },
        "hand": {
          title: "buttons/cursorhand",
          icon: "cursorHand",
          func: this.toggleCursorMode.bind(this),
          required: true,
          statebind: "root.ui.chart.cursorMode",
          statebindfunc: this.setCursorMode.bind(this)
        },
        "hundredpercent": {
          title: "buttons/hundredpercent",
          icon: "hundredPercent",
          func: this.toggleHundredPercent.bind(this),
          required: true
          // ,
          // statebind: "ui.chart.trails",
          // statebindfunc: this.setBubbleTrails.bind(this)
        }
      };  
    }

    draw() {

      this.localise = this.services.locale.auto();

      Object.keys(this._available_buttons).forEach(buttonId => {
        const button = this._available_buttons[buttonId];
        if (button && button.statebind) {
          this.addReaction(() => {
            button.statebindfunc(buttonId, getProp(this, button.statebind.split(".")));
          });
        }
      });

      this._addButtons(Object.keys(this._available_buttons), []);

    }

    /*
     * adds buttons configuration to the components and template_data
     * @param {Array} button_list list of buttons to be added
     */
    _addButtons(button_list, button_expand) {
      const _this = this;
      this._components_config = [];
      const details_btns = [];
      if (!button_list.length) return;
      //add a component for each button
      for (let i = 0; i < button_list.length; i++) {

        const btn = button_list[i];
        const btn_config = this._available_buttons[btn];

        //add template data
        const d = (btn_config) ? btn : "_default";
        const details_btn = clone(this._available_buttons[d]);
        if (d == "_default") {
          details_btn.title = "buttons/" + btn;
        }
        details_btn.id = btn;
        details_btn.icon = iconset["ICON_" + details_btn.icon.toUpperCase()];
        details_btns.push(details_btn);
      }

      const t = this.localise;

      this.element.selectAll("button").data(details_btns)
        .enter().append("button")
        .attr("class", d => {
          let cls = "vzb-buttonlist-btn";
          if (button_expand.length > 0) {
            if (button_expand.indexOf(d.id) > -1) {
              cls += " vzb-dialog-side-btn";
            }
          }

          return cls;
        })
        .attr("data-btn", d => d.id)
        .html(btn => "<span class='vzb-buttonlist-btn-icon fa'>" +
            btn.icon + "</span><span class='vzb-buttonlist-btn-title'>" +
            t(btn.title) + "</span>");

      const buttons = this.element.selectAll(".vzb-buttonlist-btn");

      //clicking the button
      buttons.on("click", function(event, d) {

        event.preventDefault();
        event.stopPropagation();

        _this.proceedClick(d.id);
      });
      
    }

    proceedClick(id) {
      const _this = this;
      const btn = _this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
      const classes = btn.attr("class");
      const btn_config = _this._available_buttons[id];

      if (btn_config && btn_config.func) {
        btn_config.func(id);
      } else {
        const btn_active = classes.indexOf(class_active) === -1;

        btn.classed(class_active, btn_active);
        const evt = {};
        evt["id"] = id;
        evt["active"] = btn_active;
        _this.trigger("click", evt);
      }
    }

    setButtonActive(id, boolActive) {
      const btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

      btn.classed(class_active, boolActive);
    }

    toggleCursorMode(id) {
      const value = id;
      this.root.ui.chart.cursorMode = value;
    }

    setCursorMode(id, value) {
      //const value = this.model.ui.cursorMode ? this.model.ui.cursorMode : "arrow";
      this.element.selectAll(".vzb-buttonlist-btn")
        .classed(class_active, d => d.id == value);
    }

    toggleHundredPercent() {
      this.root.element.dispatch("custom-resetZoom");
    }

  }

  const HTML_ICON_PLAY = 
    `<svg class="vzb-icon vzb-icon-play" viewBox="3 3 42 42"
  xmlns="http://www.w3.org/2000/svg">
  <path xmlns="http://www.w3.org/2000/svg" d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-4 29V15l12 9-12 9z"/>
  </svg>`;
  const HTML_ICON_PAUSE =
    `<svg class="vzb-icon vzb-icon-pause" viewBox="3 3 42 42"
  xmlns="http://www.w3.org/2000/svg">
  <path xmlns="http://www.w3.org/2000/svg" d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-2 28h-4V16h4v16zm8 0h-4V16h4v16z"/>
  </svg>`;
  const HTML_ICON_LOADING =
    `<div class='vzb-loader'></div>`;

  class PlayButton extends BaseComponent {

    constructor(config) {
      config.template = 
        `<button class="vzb-ts-btn">
        <div class='vzb-loader'></div>
      </button>`;
      super(config);
    }

    setup() {
      this.buttonEl = this.element.select(".vzb-ts-btn")
        .on("click", () => {this.model.encoding.frame.togglePlaying();});
    }

    draw() {
      this.buttonEl.html(this.model.encoding.frame.playing ? HTML_ICON_PAUSE : HTML_ICON_PLAY);
    }

    loading() {
      this.buttonEl.html(HTML_ICON_LOADING);
    }
  }

  const PROFILE_CONSTANTS = {
    SMALL: {
      margin: {
        top: 7,
        right: 25,
        bottom: 10,
        left: 60
      },
      radius: 8,
      label_spacing: 5
    },
    MEDIUM: {
      margin: {
        top: 0,
        right: 25,
        bottom: 10,
        left: 55
      },
      radius: 9,
      label_spacing: 5
    },
    LARGE: {
      margin: {
        top: -5,
        right: 25,
        bottom: 10,
        left: 80
      },
      radius: 11,
      label_spacing: 8
    }
  };


  const PROFILE_CONSTANTS_FOR_PROJECTOR = {
    MEDIUM: {
      margin: {
        top: 9,
        right: 25,
        bottom: 10,
        left: 55
      }
    },
    LARGE: {
      margin: {
        top: -5,
        right: 25,
        bottom: 10,
        left: 80
      }
    }
  };

  //constants
  const class_playing = "vzb-playing";
  const class_loading = "vzb-ts-loading";
  const class_hide_play = "vzb-ts-hide-play-button";
  const class_dragging = "vzb-ts-dragging";
  const class_axis_aligned = "vzb-ts-axis-aligned";
  const class_show_value = "vzb-ts-show-value";
  const class_show_value_when_drag_play = "vzb-ts-show-value-when-drag-play";

  class TimeSlider extends BaseComponent {

    constructor(config){
      config.subcomponents = [{
        type: PlayButton,
        placeholder: ".vzb-ts-btns",
        //model: this.model
      }];

      config.template = `
      <div class="vzb-ts-slider">
        <svg class="vzb-ts-slider-svg">
          <g>
            <g class="vzb-ts-slider-axis"></g>
            <g class="vzb-ts-slider-progress"></g>
            <g class="vzb-ts-slider-select"></g>
            <line class="vzb-ts-slider-forecastboundary"></line>
            <circle class="vzb-ts-slider-handle"></circle>
            <text class="vzb-ts-slider-value"></text>
            <line class="vzb-ts-slider-slide"></line>
          </g>
        </svg>      
      </div>
      <div class="vzb-ts-btns"></div>
    `;
      super(config);
    }

    setup() {
      this.DOM = {
        //slider: this.element.select(".vzb-ts-slider")
        slider_outer: this.element.select(".vzb-ts-slider-svg"),
        axis: this.element.select(".vzb-ts-slider-axis"),
        select: this.element.select(".vzb-ts-slider-select"),
        progressBar: this.element.select(".vzb-ts-slider-progress"),
        slide: this.element.select(".vzb-ts-slider-slide"),
        forecastBoundary: this.element.select(".vzb-ts-slider-forecastboundary"),
        handle: this.element.select(".vzb-ts-slider-handle"),
        valueText: this.element.select(".vzb-ts-slider-value")
      };

      this.DOM.slider = this.DOM.slider_outer.select("g");

      //Axis
      this.xAxis = axisSmart$1("bottom");

      const { valueText, slider, slide, slider_outer } = this.DOM;
      //Value
      valueText.classed("stroke", true);
      if (!slider.style("paint-order").length) {
        slider.insert("text", ".vzb-ts-slider-value")
          .attr("class", "vzb-ts-slider-value stroke");

        valueText.classed("stroke", false);
      }
      this.DOM.valueText = this.element.selectAll(".vzb-ts-slider-value")
        .attr("text-anchor", "middle")
        .attr("dy", "-0.7em");

      //Slide
      slide.call(d3.drag()
        //.on("start.interrupt", function() { _this.slide.interrupt(); })
        .on("start drag", event => this._brushed(event))
        .on("end", event => this._brushedEnd(event))
      );

      slider_outer.on("mousewheel", (event) => {
        //do nothing and dont pass the event on if we are currently dragging the slider
        if (this.ui.dragging) {
          event.stopPropagation();
          event.preventDefault();
          event.returnValue = false;
          return false;
        }
      });

      this.DOM.forecastBoundary.on("click", () => {
        this.MDL.frame.setValueAndStop(this.root.ui.chart.endBeforeForecast);
      });
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame
      };
    }

    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);
      
      this.element.classed(class_loading, false);

      if (this._updateLayoutProfile()) return; //return if exists with error

      this.addReaction(this._configEndBeforeForecast);
      this.addReaction(this._adjustFrameScaleDomainConfig);
      this.addReaction(this._updateSize);
      this.addReaction(this._redrawForecast);
      this.addReaction(this._optionClasses);
      this.addReaction(this._processForecast);
      this.addReaction(this._setHandle);

    }

    // _changeLimits() {
    //   const minValue = this.model.time.start;
    //   const maxValue = this.model.time.end;
    //   //scale
    //   this.xScale.domain([minValue, maxValue]);
    //   //axis
    //   this.xAxis.tickValues([minValue, maxValue])
    //     .tickFormat(this.model.time.getFormatter());
    // }

    _updateLayoutProfile() {
      this.services.layout.size;

      this.profileConstants = this.services.layout.getProfileConstants(PROFILE_CONSTANTS, PROFILE_CONSTANTS_FOR_PROJECTOR);
      this.height = this.element.node().clientHeight || 0;
      this.width = this.element.node().clientWidth || 0;
      if (!this.height || !this.width) return warn("Timeslider _updateProfile() abort: container is too little or has display:none");
    }

    get xScale() {
      return this.MDL.frame.scale.d3Scale;
    }

    _configEndBeforeForecast() {
      const frame = this.MDL.frame;
      const { offset, floor } = this.services.Vizabi.Vizabi.utils.interval(frame.interval);
      if (!this.root.ui.chart.endBeforeForecast) {
        const stepBack = floor(offset(new Date(), -1));
        this.root.ui.chart.endBeforeForecast = frame.formatValue(stepBack);
      }
      this.firstForecastFrame = offset(frame.parseValue(this.root.ui.chart.endBeforeForecast), +1);
    }

    _adjustFrameScaleDomainConfig() {
      const frame = this.MDL.frame;
      if (this.root.ui.chart.showForecast) {
        delete frame.scale.config.domain;
      } else {
        const lastNonForecast = frame.parseValue(this.root.ui.chart.endBeforeForecast);
        if (lastNonForecast && frame.data.domain[1] > lastNonForecast)
          frame.scale.config.domain = [ frame.data.domain[0], lastNonForecast ]
            .map(v => frame.formatValue(v));
        else 
          delete frame.scale.config.domain;
      }
    }

    _processForecast() {
      const frame = this.MDL.frame;
      const lastNonForecast = frame.parseValue(this.root.ui.chart.endBeforeForecast);
      const forecastPauseSetting = this.root.ui.chart.pauseBeforeForecast;
      const equals = this.services.Vizabi.Vizabi.utils.equals;

      // stop when 
      // - first forecast value is reached, then set to previous year. This way animation finishes.
      // - previous frame was reached while playing (= allowed)
      if (frame.playing
          && forecastPauseSetting 
          && equals(frame.value, this.firstForecastFrame) 
          && this.allowForecastPause
      ) {
        frame.setValueAndStop(lastNonForecast);
      }

      // set up pause if we're playing and we're on the last frame before pause (i.e. the frame we actually want to pause on)
      this.allowForecastPause = frame.playing && equals(frame.value, lastNonForecast);
    }

    _redrawForecast() {
      this.services.layout.size;

      const endBeforeForecast = this.MDL.frame.parseValue(this.root.ui.chart.endBeforeForecast);
      const forecastIsOn = this.root.ui.chart.showForecast && (this.MDL.frame.scale.domain[1] > endBeforeForecast);
      this.DOM.forecastBoundary
        .classed("vzb-hidden", !forecastIsOn);

      if (forecastIsOn) {
        const radius = this.profileConstants.radius;

        this.DOM.forecastBoundary
          .attr("transform", "translate(0," + this.height / 2 + ")")
          .attr("x1", this.xScale(endBeforeForecast) - radius / 2)
          .attr("x2", this.xScale(endBeforeForecast) + radius / 2)
          .attr("y1", radius)
          .attr("y2", radius);
      }

    }

    /**
     * Executes everytime the container or vizabi is resized
     * Ideally,it contains only operations related to size
     */
    _updateSize() {
      this.services.layout.size;

      const {
        margin,
        radius,
        label_spacing
      } = this.profileConstants;

      const {
        slider,
        slide,
        axis,
        handle,
        select,
        progressBar
      } = this.DOM;

      // const slider_w = parseInt(this.slider_outer.style("width"), 10) || 0;
      // const slider_h = parseInt(this.slider_outer.style("height"), 10) || 0;

      // if (!slider_h || !slider_w) return utils.warn("time slider resize() aborted because element is too small or has display:none");
      const marginRight = this.services.layout.hGrid.length ? 
        this.width - this.services.layout.hGrid[0]
        : margin.right;
      this.sliderWidth = this.width - margin.left - marginRight;
      this.sliderHeight = this.height - margin.bottom - margin.top;

      //translate according to margins
      slider.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      this.MDL.frame.scale.config.range = [0, this.sliderWidth];

      slide
        .attr("transform", "translate(0," + this.sliderHeight / 2 + ")")
        .attr("x1", this.xScale.range()[0])
        .attr("x2", this.xScale.range()[1])
        .style("stroke-width", radius * 2 + "px");

      //adjust axis with scale
      this.xAxis.scale(this.xScale)
        .tickSizeInner(0)
        .tickSizeOuter(0)
        .tickPadding(label_spacing)
        .tickSizeMinor(0, 0);

      axis.attr("transform", "translate(0," + this.sliderHeight / 2 + ")")
        .call(this.xAxis);

      select.attr("transform", "translate(0," + this.sliderHeight / 2 + ")");
      progressBar.attr("transform", "translate(0," + this.sliderHeight / 2 + ")");

      //size of handle
      handle.attr("transform", "translate(0," + this.sliderHeight / 2 + ")")
        .attr("r", radius);

      //this.sliderWidth = slider.node().getBoundingClientRect().width;

      // this.resizeSelectedLimiters();
      // this._resizeProgressBar();
      // this._setHandle();

    }

    /**
     * Returns width of slider text value.
     * Parameters in this function needed for memoize function, so they are not redundant.
     */
    _getValueWidth() {
      return this.valueText.node().getBoundingClientRect().width;
    }

    _brushed(event) {
      const { frame } = this.MDL;
      const { handle, valueText } = this.DOM;

      if (frame.playing) {
        frame.stopPlaying();
      }

      this.ui.dragging = true;
      this.element.classed(class_dragging, this.ui.dragging);

      let value;// = _this.brush.extent()[0];
      //var value = d3.brushSelection(_this.slide.node());

      //if(!value) return;

      //set brushed properties

      if (event.sourceEvent) {
        // Prevent window scrolling on cursor drag in Chrome/Chromium.
        event.sourceEvent.preventDefault();

        //_this.model.time.dragStart();
        let posX = event.x;
        const maxPosX = this.sliderWidth;

        const endBeforeForecast = frame.parseValue(this.root.ui.chart.endBeforeForecast);
        const forecastBoundaryIsOn = this.root.ui.chart.showForecast && (frame.data.domain.at(-1) > endBeforeForecast);
        const forecastBoundaryPos = this.xScale(endBeforeForecast);
        const snappyMargin = 0.5 * handle.attr("r");

        if (posX > maxPosX) {
          posX = maxPosX;
        } else if (posX < 0) {
          posX = 0;
        } else if ((Math.abs(posX - forecastBoundaryPos) < snappyMargin) && event.sourceEvent.shiftKey && forecastBoundaryIsOn) {
          posX = forecastBoundaryPos;
        }

        value = this.xScale.invert(posX);
        //set handle position
        handle.attr("cx", posX);
        valueText.attr("transform", "translate(" + posX + "," + (this.sliderHeight / 2) + ")");
        valueText.text(this.localise(value));
      }

      //set time according to dragged position
      if (value - this.MDL.frame.value !== 0) {
        this._setTime(value);
      }
    }

    /**
     * Gets brushedEnd function to be executed when dragging ends
     * @returns {Function} brushedEnd function
     */
    _brushedEnd() {
      this.MDL.frame.snap();
      this.ui.dragging = false;
      this.element.classed(class_dragging, this.ui.dragging);
    }

    _setHandle() {
      this.services.layout.size;
      this.services.layout.hGrid;

      const { value, speed, playing } = this.MDL.frame;

      if (this.ui.dragging || this._isDomainNotVeryGood()) return;
      const { handle, valueText } = this.DOM; 
    
      //this.slide.call(this.brush.extent([value, value]));
      const newPos = this.xScale(value);
      //this.brush.move(this.slide, [newPos, newPos])

      //    this.valueText.text(this.model.time.formatDate(value));

      //    var old_pos = this.handle.attr("cx");
      //var newPos = this.xScale(value);
      //if (_this.prevPosition == null) _this.prevPosition = newPos;
      //const delayAnimations = newPos > _this.prevPosition ? this.model.time.delayAnimations : 0;
      const delayAnimations = speed;
      if (playing) {
        handle//.attr("cx", _this.prevPosition)
          .transition()
          .duration(delayAnimations)
          .ease(d3.easeLinear)
          .attr("cx", newPos);

        valueText//.attr("transform", "translate(" + _this.prevPosition + "," + (this.height / 2) + ")")
          .transition("text")
          .delay(delayAnimations)
          .text(this.localise(value));
        valueText
          .transition()
          .duration(delayAnimations)
          .ease(d3.easeLinear)
          .attr("transform", "translate(" + newPos + "," + (this.sliderHeight / 2) + ")");
      } else {
        handle
          //cancel active transition
          .interrupt()
          .attr("cx", newPos);

        valueText
          //cancel active transition
          .interrupt()
          .interrupt("text")
          .transition("text");
        valueText
          .attr("transform", "translate(" + newPos + "," + (this.sliderHeight / 2) + ")")
          .text(this.localise(value));
      }
      //_this.prevPosition = newPos;

    }

    /**
     * Sets the current time model to time
     * @param {number} time The time
     */
    _setTime(time) {
      //update state
      const _this = this;
      const frameRate = 50;

      //avoid updating more than once in "frameRate"
      var now = new Date();
      if (this._updTime != null && now - this._updTime < frameRate) return;
      this._updTime = now;
      //const persistent = !this.model.time.dragging && !this.model.time.playing;
      //_this.model.time.getModelObject("value").set(time, false, persistent); // non persistent
      _this.MDL.frame.setValue(time);

    }

    /**
     * Applies some classes to the element according to options
     */
    _optionClasses() {
      //show/hide classes
      const { frame } = this.MDL;

      const show_ticks = this.ui.show_ticks;
      const show_value = this.ui.show_value;
      const show_value_when_drag_play = this.ui.show_value_when_drag_play;
      const axis_aligned = this.ui.axis_aligned;
      const show_play = (this.ui.show_button) && (frame.playable);

      this.xAxis.labelerOptions({
        scaleType: "time",
        removeAllLabels: !show_ticks,
        limitMaxTickNumber: 3,
        showOuter: false,
        toolMargin: {
          left: 10,
          right: 10,
          top: 0,
          bottom: 30
        },
        fitIntoScale: "optimistic"
      });
      this.DOM.axis
        .call(this.xAxis);

      this.element.classed("vzb-ts-disabled", this._isDomainNotVeryGood());
      this.element.classed(class_hide_play, !show_play);
      this.element.classed(class_playing, frame.playing);
      this.element.classed(class_show_value, show_value);
      this.element.classed(class_show_value_when_drag_play, show_value_when_drag_play);
      this.element.classed(class_axis_aligned, axis_aligned);
    }

    _isDomainNotVeryGood(){
      const domain = this.xScale.domain();
      //domain not available
      if(!domain || domain.length !== 2) return true;
      //domain inverted or shrunk to one point
      if(domain[1] - domain[0] <= 0) return true;
      //domain sucks in some other way
      if(domain.some(s => s == null || isNaN(s))) return true;
      return false;
    }
  }

  TimeSlider.DEFAULT_UI = {
    show_ticks: false,
    show_value: false,
    show_value_when_drag_play: true,
    axis_aligned: false,
    show_button: true,
    dragging: false
  };

  const decorated$8 = mobx.decorate(TimeSlider, {
    "xScale": mobx.computed,
    "MDL": mobx.computed
  });

  /*!
   * VIZABI BUBBLE SIZE slider
   * Reusable bubble size slider
   */

  const OPTIONS$2 = {
    PADDING: { TOP: 132, BOTTOM: 50, LEFT: 20, RIGHT: 20 },
    BAR_WIDTH: 3,
    TEXT_PARAMS: { TOP: 11, LEFT: 10, MAX_WIDTH: 42, MAX_HEIGHT: 16 },
    THUMB_STROKE_WIDTH: 2,
    THUMB_HEIGHT: 15,
    labelsValue: "domain",

    PROFILE_CONSTANTS: {
      SMALL: {
      },
      MEDIUM: {
      },
      LARGE: {
      }
    }
  };

  class BubbleSize extends decorated$f {
    setup(_options) {
      const options = deepExtend(deepExtend({}, OPTIONS$2), _options || {});

      super.setup(options);

      this.rescaler.clamp(false);

      this.showArcs = this.options.showArcs;

      if (this.showArcs) {
        this.DOM.sliderArcs = this.DOM.slider.selectAll(".vzb-bs-slider-thumb-arc").data([0, 0]).enter()
          .append("path")
          .attr("class", (d, i) => `vzb-bs-slider-thumb-arc vzb-bs-slider-thumb-arc-${i ? "max": "min"}`)
          .lower();
      }

      this.DOM.sliderLabelsWrapper = this.DOM.slider.append("g");
      this.DOM.sliderLabels = this.DOM.sliderLabelsWrapper.selectAll("text").data([0, 0]).enter()
        .append("text")
        .attr("class", "vzb-bs-slider-thumb-label")
        .attr("dy", (d, i) => i ? "-0.5em" : "1.9em");
    }

    draw() { 
      super.draw();
    
      this.addReaction(this._setLabelsText);
    }

    _getPadding() {
      const padding = super._getPadding();
      padding.top = this.options.PADDING.TOP;
      padding.left = this.options.PADDING.LEFT;
      padding.right = this.options.PADDING.RIGHT;
      padding.bottom = this.options.PADDING.BOTTOM;
      return padding;
    }

    _updateThumbs(extent) {
      this._updateArcs(extent);
      this._updateLabels(extent);
    }

    _updateArcs(s) {
      if (!this.showArcs) return;
      const _this = this;
      const valueArc = d3.arc()
        .outerRadius(d => _this.rescaler(d))
        .innerRadius(0)
        .startAngle(-0.5*Math.PI)
        .endAngle(1.5*Math.PI);
      this.DOM.sliderArcs.data(s)
        .attr("d", valueArc)
        .attr("transform", "translate(0,0)");
    }

    _updateLabels(s) {
      if (s) { this.DOM.sliderLabels.data(s); }
      const isRTL = this.services.locale.isRTL();
      this.DOM.sliderLabels
        .attr("transform", (d) => {
          const dX = this.rescaler(d);
          const dY = 0;
          return "translate(" + ((isRTL ? -1 : 1) * dX) + "," + (dY) + ")";
        })
        .attr("text-anchor", (d) => !isRTL && (d < this.__labelSideSwitchEdge) || isRTL && (d >= this.__labelSideSwitchEdge) ? "start" : "end")
        .attr("dx", (d, i) => ((isRTL ? -1 : 1) * ((d < this.__labelSideSwitchEdge) ? i ? 0.3 : 0.1 : i ? -0.3 : -0.4 )) + "em");
    }

    _setLabelsText() {
      let texts = [];

      if (this.MDL.model.data.isConstant) {
        texts = ["", ""];
      } else {
        texts = this.MDL.model[this.options.labelsValue].map(this.localise);
      }

      this.DOM.sliderLabels.text((d, i) => texts[i]);
    }

    _getMinMaxBubbleRadius() {
      if(this.root.ui.minMaxRadius) return this.root.ui.minMaxRadius;
      const range = this.model.encoding.size.scale.range;
      const min = areaToRadius(d3.min(range));
      const max = areaToRadius(d3.max(range));
      return { min, max };
    }

    _updateSize() {

      super._updateSize();

      this.__labelSideSwitchEdge = this.rescaler.invert(this._getComponentWidth()) * 0.75;

      this.DOM.sliderLabelsWrapper
        .attr("transform", this.services.locale.isRTL() ? "scale(-1,1)" : null);
    }

    _setBrushExtent() {
      return this.brush.extent([[this.rescaler.range()[0], 0], [this._getComponentWidth(), this._getComponentHeight()]]);
    }

    _updateRescaler() {
      const minMaxBubbleRadius = this._getMinMaxBubbleRadius();
      this.rescaler.range([minMaxBubbleRadius.min, minMaxBubbleRadius.max]);
    }

  }

  /*!
   * VIZABI BUBBLE SIZE slider
   * Reusable bubble size slider
   */

  const OPTIONS$1 = {
    THUMB_HEIGHT: 17,
    THUMB_STROKE_WIDTH: 3,
    domain: null,
    suppressInput: null,
    snapValue: null
  };

  class SingleHandleSlider extends decorated$f {


    setup(_options) {
      this.type = this.type || "singlehandleslider";
      
      const options = extend(extend({}, OPTIONS$1), _options || {});

      super.setup(options);

      if (this.options.domain) this._setDomain(this.options.domain);

      this.DOM.slider.selectAll(".w").classed("vzb-hidden", true);
      this.DOM.slider.select(".selection").classed("vzb-hidden", true);

      this.DOM.slider.select(".overlay")
        .lower()
        .style("stroke-opacity", "0")
        .style("stroke-width", (this.options.THUMB_HEIGHT * 0.5) + "px")
        .attr("rx", this.options.BAR_WIDTH * 0.5)
        .attr("ry", this.options.BAR_WIDTH * 0.5);

      this.DOM.slider.selectAll(".vzb-slider-thumb-badge")
        .style("stroke-width", this.options.THUMB_STROKE_WIDTH + "px");
    }

    _setDomain(domain){
      this.options.EXTENT_MIN = this.options.domain[0];
      this.options.EXTENT_MAX = this.options.domain[this.options.domain.length - 1];
      this.rescaler.domain(domain);
    }

    _createThumbs(thumbsEl) {
      const halfThumbHeight = this.options.THUMB_HEIGHT * 0.5;

      const thumbArc = d3.arc()
        .outerRadius(halfThumbHeight)
        .startAngle(0)
        .endAngle(2 * Math.PI);

      thumbsEl
        .attr("transform", "translate(" + (halfThumbHeight + this.options.THUMB_STROKE_WIDTH * 0.5) + "," + (halfThumbHeight + this.options.THUMB_STROKE_WIDTH * 0.5) + ")")
        .append("path")
        .attr("d", thumbArc);
    }

    _getBrushEventListeners() {
      const _superListeners = super._getBrushEventListeners();

      return {
        start: _superListeners.start,
        brush: (event, d) => {
          if (this.nonBrushChange || !event.sourceEvent) return;

          if (!this.options.suppressInput) {
            _superListeners.brush.call(this, event, d);
          } else {
            this._savedSelection = event.selection;
            this._snap(event.selection);
          }
        },
        end:(event) => {
          if (this.nonBrushChange || !event.sourceEvent) return;

          if (this.options.snapValue) {
            this._snap(event.selection || this._savedSelection);
          } else {
            this.DOM.slider.call(this.brush.move, [this.rescaler.range()[0], this._savedSelection[1]]);
          }
          this._setFromExtent(true, true); // force a persistent change
          this._savedSelection = void 0;
        }
      };
    }

    _snap(selection) {
      let value = this.rescaler.invert(this._extentToValue(selection));
      const domain = this.rescaler.domain();
      const ascendingDomain = domain[domain.length - 1] > domain[0];
      const next = d3.bisector(d3[ascendingDomain ? "ascending" : "descending"]).left(domain, value) || 1;
      value = (ascendingDomain ? 1 : -1) * ((value - domain[next - 1]) - (domain[next] - value)) > 0 ? domain[next] : domain[next - 1];
      this._moveBrush(this._valueToExtent(value));
    }

    _getHandleSize() {
      return this.options.THUMB_HEIGHT + this.options.THUMB_STROKE_WIDTH;
    }

    _getPadding() {
      const barWidth = this.options.BAR_WIDTH;
      const thumbHeight = this.options.THUMB_HEIGHT;
      const padding = super._getPadding();

      padding.top = (thumbHeight + this.options.THUMB_STROKE_WIDTH) * 0.5;
      padding.bottom = (thumbHeight + this.options.THUMB_STROKE_WIDTH) * 0.5 - barWidth;
      
      return padding;
    }

    _updateSize() {
      super._updateSize();

      const componentWidth = this._getComponentWidth();
      this.rescaler.range(d3.range(0, componentWidth || 1, (componentWidth / (this.rescaler.domain().length - 1)) || 1).concat([componentWidth]));
    }

    _valueToExtent(value) {
      return [this.rescaler.domain()[0], value];
    }

    _extentToValue(extent) {
      return extent[1];
    }

    _setModel(value, force, persistent) {
      if (this.options.suppressInput) {
        const _value = this._extentToValue(value).toFixed(this.options.ROUND_DIGITS);
        if (_value == this.MDL.model[this.value]) return;
      }
      super._setModel(value, force, persistent);
    }

  }

  /*!
   * VIZABI OPTIONSBUTTONLIST
   * Reusable optionsbuttonlist component
   */

  class OptionsButtonList extends ButtonList {
    setup() {
      super.setup();
      Object.keys(this._available_buttons).forEach(buttonId => {
        const button = this._available_buttons[buttonId];
        button.required = !button.required;
      });

    }

    draw() {
      super.draw();

      const buttonList = this.root.findChild({ name: "buttons" });
      buttonList.element.on("custom-togglebuttons", (event) => {
        const { hiddenButtons } = event.detail;
        this.element.selectAll(".vzb-buttonlist-btn")
          .style("display", d => hiddenButtons.indexOf(d.id) == -1 ? "none" : "");
      });
    }

    _toggleButtons() {

    }
  }

  /*
   * About dialog
   */
  function formatVersion(version){
    return version || "N/A";
  }

  function formatBuild(timestamp){
    if (!timestamp) return "N/A";
    return d3.utcFormat("%Y-%m-%d at %H:%M")(new Date(parseInt(timestamp)));
  }

  function url(text = "", link = ""){
    if (!link) return text;
    return `<a class='vzb-underline' href='${link}' target='_blank'>⧉ ${text}</a>`;
  }

  class About extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title"> 
          <span data-localise="buttons/about"></span>
        </div>

        <div class="vzb-dialog-content">
          <div class="vzb-about-header"></div>
          <div class="vzb-about-body"></div>
          <div class="vzb-about-footer"></div>
        </div>
    
        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>
      </div>
    `;

      super(config);
    }

    setup() {
      this.DOM = {
        header: this.element.select(".vzb-about-header"),
        body: this.element.select(".vzb-about-body"),
        footer: this.element.select(".vzb-about-footer")
      };
    }

    draw(){
      this.addReaction(this.drawHeader);
      this.addReaction(this.drawBody);
      this.addReaction(this.drawFooter);
    }


    drawHeader(){
      const author = this.root.constructor.versionInfo?.sharedComponents?.package?.author || {};

      this.DOM.header.html("");
      this.DOM.header.append("p").html(url("Report a problem", "https://github.com/Gapminder/tools-page/issues"));
      this.DOM.header.append("p").html("This chart is made with Vizabi, <br/> a project by " + url(author.name, author.url));
    }


    drawBody(){
      const vizabiModulesData = [
        this.root.constructor.versionInfo || {},
        this.root.constructor.versionInfo?.sharedComponents || {},
        this.services.Vizabi.Vizabi.versionInfo || {}
      ];

      const readerData = this.services.Vizabi.Vizabi.stores.dataSources.getAll().map(dataSource => {
        const datasetInfo = dataSource.reader.getDatasetInfo ? dataSource.reader.getDatasetInfo() : {};
        return {
          name: dataSource.config.name || datasetInfo.name,
          url: dataSource.config.path,
          type: dataSource.config.modelType
        };
      }); 

      this.DOM.body.html("");
      this.DOM.body.append("div").append("p").append("h1").html("Components:");
      this.DOM.body.append("div").selectAll("p")
        .data(vizabiModulesData)
        .enter().append("p")
        .html(d => url(d.package?.description || d.package?.name, d.package?.homepage) + `<br/> - Version: ${formatVersion(d.version)} <br/> - Build ${formatBuild(d.build)}`);
      
      this.DOM.body.append("div").append("p").append("h1").html("Data sources:");
      this.DOM.body.append("div").selectAll("p")
        .data(readerData)
        .enter().append("p")
        .html(d =>  url(d.type + " " + d.name, d.url));
    }


    drawFooter(){
      const contributors = this.root.constructor.versionInfo?.sharedComponents?.package?.contributors || [];
      
      this.DOM.footer.html("");
      this.DOM.footer.append("p").append("h1").html(`Contributors:`);
      this.DOM.footer.append("p").selectAll("span")
        .data(contributors)
        .enter().append("span")
        .html(d => url(d.name, d.url));
    }
  }

  decorated$b.add("about", About);

  /*
   * Axes dialog
   */

  class Axes extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="axes" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="axes" data-click="dragDialog"></span>
        <div class="vzb-dialog-title">
          <span data-localise="buttons/axes"></span>
        </div>
        <div class="vzb-dialog-content">
          <p class="vzb-dialog-sublabel">
            <span data-localise="buttons/x"></span>
            <span class="vzb-xaxis-selector"></span>
          </p>
          <div class="vzb-xaxis-minmax vzb-dialog-paragraph"></div>
          <p class="vzb-dialog-sublabel">
            <span data-localise="buttons/y"></span>
            <span class="vzb-yaxis-selector"></span>
          </p>
          <div class="vzb-yaxis-minmax vzb-dialog-paragraph"></div>
        </div>
        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>
      </div>    
    `;

      config.subcomponents = [{
        type: IndicatorPicker,
        placeholder: ".vzb-xaxis-selector",
        options: {
          submodel: "encoding",
          targetProp: "x"
        }
      },{
        type: decorated$a,
        placeholder: ".vzb-xaxis-minmax",
        state: {
          submodel: "encoding.x.scale"
        }
      },{
        type: IndicatorPicker,
        placeholder: ".vzb-yaxis-selector",
        options: {
          submodel: "encoding",
          targetProp: "y"
        }
      },{
        type: decorated$a,
        placeholder: ".vzb-yaxis-minmax",
        state: {
          submodel: "encoding.y.scale"
        }
      }];

      super(config);
    }

  }

  decorated$b.add("axes", Axes);

  /*!
   * VIZABI BUBBLE SIZE slider
   * Reusable bubble size slider
   */

  const OPTIONS = {
    propertyName: "LabelTextSize",

    PROFILE_CONSTANTS: {
      SMALL: {
        minLabelTextSize: 7,
        maxLabelTextSize: 21,
        defaultLabelTextSize: 12
      },
      MEDIUM: {
        minLabelTextSize: 7,
        maxLabelTextSize: 30,
        defaultLabelTextSize: 15
      },
      LARGE: {
        minLabelTextSize: 6,
        maxLabelTextSize: 48,
        defaultLabelTextSize: 20
      }
    }
  };

  class SizeSlider extends decorated$f {
    setup(_options) {
      const options = deepExtend(deepExtend({}, OPTIONS), _options || {});

      super.setup(options);

      const barWidth = this.options.BAR_WIDTH;

      this.DOM.sliderLabelsWrapper = this.DOM.slider.append("g");
      this.DOM.sliderLabelsWrapper.selectAll("text").data([0, 0]).enter()
        .append("text")
        .attr("class", (d, i) => "vzb-szs-slider-thumb-label " + (i ? "e" : "w"))
        .attr("dy", (-barWidth * 1.25) + "px");

      this.DOM.sliderLabels = this.DOM.slider.selectAll("text.vzb-szs-slider-thumb-label");

      this.propertyScale = d3.scaleLinear()
        .domain([this.options.EXTENT_MIN, this.options.EXTENT_MAX])
        .clamp(true);

    }

    draw() { 
      super.draw();

      if (this.MDL.model.data.isConstant) {
        this.DOM.slider.selectAll(".w").classed("vzb-hidden", true);
        this.DOM.slider.select(".selection").classed("vzb-hidden", true);
        this.DOM.slider.select(".overlay").classed("vzb-pointerevents-none", true);
      } else {
        this.DOM.slider.selectAll(".w").classed("vzb-hidden", false);
        this.DOM.slider.select(".selection").classed("vzb-hidden", false);
        this.DOM.slider.select(".overlay").classed("vzb-pointerevents-none", false);
      }

      this.addReaction(this._setLabelsText);
    }

    _updateThumbs(extent) {
      this._updateLabels(extent);
    }

    _updateLabels(s) {
      if (s) { this.DOM.sliderLabels.data(s); }
      this.DOM.sliderLabels
        .attr("transform", (d, i) => {
          const dX = this.rescaler(i);
          const dY = 0;
          return "translate(" + ((this.services.locale.isRTL() ? -1 : 1) * dX) + "," + (dY) + ")";
        })
        .attr("font-size", (d) => this.propertyScale(d));
      if (this.MDL.model.data.isConstant)
        this.DOM.sliderLabels.text(d => ~~(this.propertyScale(d)) + (this.localise(this.options.constantUnit) || ""));
    }

    _setLabelsText() {
      const domain = this.MDL.model.domain;
      const texts = [domain[0], domain[domain.length - 1]].map(this.localise);

      if (this.MDL.model.data.isConstant) return;

      this.DOM.sliderLabels.text((d, i) => texts[i]);
    }

    _getMinMaxDefaultPropertyValues() {
      const propertyName = this.options.propertyName;

      return {
        min: this.profileConstants["min" + propertyName],
        max: this.profileConstants["max" + propertyName],
        default: this.profileConstants["default" + propertyName],
      };
    }

    _updateSize() {
      const propertyValues = this._getMinMaxDefaultPropertyValues();

      this.padding.top = propertyValues.max + this.options.BAR_WIDTH * 1.25;
      this.propertyScale.range([propertyValues.min, propertyValues.max]);

      super._updateSize();

      const isRTL = this.services.locale.isRTL();
      this.DOM.sliderLabelsWrapper
        .attr("transform", isRTL ? "scale(-1,1)" : null);
      this.DOM.sliderLabels
        .attr("text-anchor", (d, i) => (isRTL ? i : !i) ? "start" : "end");
    }

    _valueToExtent(value) {
      if (this.MDL.model.data.isConstant && value[1] === null) {
        return super._valueToExtent([value[0], this.propertyScale.invert(this._getMinMaxDefaultPropertyValues().default)]);
      }
      return super._valueToExtent(value);
    }

  }

  /*!
   * VIZABI COLOR DIALOG
   */

  class Colors extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="colors" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="colors" data-click="dragDialog"></span>
        
        <div class="vzb-dialog-title">
          <span data-localise="buttons/colors"></span>
          <span class="vzb-caxis-selector"></span>
        </div>
      
        <div class="vzb-dialog-content vzb-dialog-scrollable">
          <div class="vzb-clegend-container">
            <svg>
              <g class="vzb-timedisplay"></g>
            </svg>
          </div>
        </div>

        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>

      </div>
    `;
      
      config.subcomponents = [{
        type: IndicatorPicker,
        placeholder: ".vzb-caxis-selector",
        options: {
          submodel: "encoding",
          targetProp: "color",
          showHoverValues: true
        },
        //model: config.root.model.stores.markers.get("legend")
        state: {
          get hoverKeyLabels() {
            const legendMarker = config.root.model.markers?.[config.root.options?.markerNames?.legend || "legend"];
            if (!legendMarker) return null;
            if (legendMarker.state === STATUS.READY) {
              //TODO: fix on multi dimensions config
              const labelKey = legendMarker.data.space[0];
              return legendMarker.dataArray.reduce((labels, data) => {
                labels[data[labelKey]] = data.name;
                return labels;
              }, {});
            }
            
            return null;
          }
        }
      }, {
        type: decorated$e,
        placeholder: ".vzb-clegend-container",
        options: {
          colorModelName: "color",
          legendModelName: config.root.options?.markerNames?.legend || "legend"
        }
      }];
      
      super(config);
    }

  }

  decorated$b.add("colors", Colors);

  /*!
   * VIZABI SHOW PANEL CONTROL
   * Reusable show panel dialog
   */

  class Show extends BaseComponent {
    constructor(config) {
      config.template = `
      <div class="vzb-show-list vzb-accordion">
        <!-- list will be placed here -->
      </div>
    `;

      super(config);
    }

    setup() {
      this.DOM = {};
      this.DOM.list = this.element.select(".vzb-show-list");
      this.DOM.input_search = this.parent.element.select(".vzb-find-search");
      this.DOM.deselect_all = this.parent.element.select(".vzb-show-deselect");
      this.DOM.apply = this.parent.element.select(".vzb-show-apply");
    
      this.DOM.deselect_all.on("click", () => {
        this._resetShow();
      });

      this.DOM.apply.on("click", () => {
        this._applyShowChanges();
      });

      this.tabsConfig = this.ui.showTabs || {};
    }

    draw() {
      this.MDL = {
        selected: this.model.encoding.selected,
        frame: this.model.encoding.frame
      };

      this.localise = this.services.locale.auto();

      this.previewShow = {};
      const dimensionFilter = this.model.data.filter.dimensions;
      if (!this.resetFilter) this.resetFilter = deepClone(dimensionFilter);
      forEach(this.model.data.space, dim => {
        if (dimensionFilter[dim]) {
          this.previewShow[dim] = deepExtend({}, dimensionFilter[dim]);
          forEach(dimensionFilter[dim].$and || [dimensionFilter[dim]], filter$and => {
            forEach(filter$and, (filter, key) => {
              this.previewShow[dim][key] = (filter.$in || []).slice(0);
            });
          });
        }
      });

      this.checkedDifference = {};

      this.addReaction(this._updateView);
    }

    _updateView() {
      const _this = this;
      if (this.parent._getPanelMode() !== "show") return;

      
      function addCategory(catalog, dim) {
        if (catalog.entities) {
          const filterSpec = _this.model.encoding.show?.data.filter.dimensions[dim];
          categories.push({
            dim,
            key: catalog.concept.concept,
            entities: catalog.entities.filter(filterSpec),
            name: catalog.concept.name
          });
        }
        if (catalog.properties) {
          Object.keys(catalog.properties).forEach(property => {
            addCategory(catalog.properties[property], dim);
          });
        }
      }
      
      const categories = [];
      this.model.data.spaceCatalog.then(spaceCatalog => {
        Object.keys(spaceCatalog).forEach(dim => {
          addCategory(spaceCatalog[dim], dim);
        });
        this.buildList(categories);
      });
    }

    buildList(categories) {
      const _this = this;
      this.DOM.list.html("");

      forEach(categories, ({ dim, key, name, entities }) => {
        const isSet = dim !== key;
          
        entities = [...entities.values()]
          .map(d => Object.assign(d, {
            isShown: this._isMarkerInDimFilter(d, dim, key)
          }))
          //sort data alphabetically
          .sort((a, b) => (a.name < b.name) ? -1 : 1);
        
        const section = this.DOM.list.append("div")
          .attr("class", "vzb-accordion-section")
          .classed("vzb-accordion-active", this.tabsConfig[key] === "open")
          .datum({ key, isSet });

        section.append("div")
          .attr("class", "vzb-accordion-section-title")
          .on("click", function() {
            const parentEl = d3.select(this.parentNode);
            parentEl.classed("vzb-fullexpand", false)
              .classed("vzb-accordion-active", !parentEl.classed("vzb-accordion-active"));
          })
          .call(elem => elem.append("span")
            .attr("class", "vzb-show-category")
            .classed("vzb-show-category-set", d => d.isSet)
            .text(name)
            .attr("title", function() {
              return this.offsetWidth < this.scrollWidth ? name : null;
            })
          )
          .call(elem => elem.append("span")
            .attr("class", "vzb-show-clear-cross")
            .text("✖")
            .on("click", (event) => {
              event.stopPropagation();
              section.selectAll(".vzb-checked input")
                .property("checked", false)
                .dispatch("change");
            })
          )
          .call(elem => elem.append("span")
            .attr("class", "vzb-show-more vzb-dialog-button")
            .text(_this.localise("buttons/moreellipsis"))
            .on("click", (event) => {
              event.stopPropagation();
              section.classed("vzb-fullexpand", true);
            })
          );

        const list = section.append("div")
          .attr("class", "vzb-show-category-list");

        const items = list.selectAll(".vzb-show-item")
          .data(entities)
          .enter()
          .append("div")
          .attr("class", "vzb-show-item vzb-dialog-checkbox")
          .classed("vzb-checked", d => d.isShown);

        items.append("input")
          .attr("type", "checkbox")
          .attr("class", "vzb-show-item")
          .attr("id", d => "-show-" + key + "-" + d[key] + "-" + _this.id)
          .property("checked",  d => d.isShown)
          .on("change", (event, d) => {
            if (d.isShown !== event.currentTarget.checked) {
              this.checkedDifference[key + d[key]] = true;
            } else {
              delete this.checkedDifference[key + d[key]];
            }
            this.DOM.apply.classed("vzb-disabled", !Object.keys(this.checkedDifference).length);

            if (!this.previewShow[dim]) {
              this.previewShow[dim] = {};
            }
            if (!this.previewShow[dim][key]) {
              this.previewShow[dim][key] = [];
            }
            const index = this.previewShow[dim][key].indexOf(d[key]);
            index === -1 ? this.previewShow[dim][key].push(d[key]) : this.previewShow[dim][key].splice(index, 1);
          });

        items.append("label")
          .attr("for", d => "-show-" + key + "-" + d[key] + "-" + _this.id)
          .text(d => d.name)
          .attr("title", function(d) {
            return this.offsetWidth < this.scrollWidth ? d.name : null;
          });

        const lastCheckedNode = list.selectAll(".vzb-checked")
          .classed("vzb-separator", false)
          .lower()
          .nodes()[0];

        if (lastCheckedNode && lastCheckedNode.nextSibling) {
          //const lastCheckedEl = d3.select(lastCheckedNode).classed("vzb-separator", !!lastCheckedNode.nextSibling);
          const offsetTop = lastCheckedNode.parentNode.offsetTop + lastCheckedNode.offsetTop;
          d3.select(lastCheckedNode.parentNode.parentNode).style("max-height", (offsetTop + lastCheckedNode.offsetHeight + 25) + "px")
            .select(".vzb-show-more").style("transform", `translate(0, ${offsetTop}px)`);
        } else {
          section.select(".vzb-show-more").classed("vzb-hidden", true);
        }

        section.classed("vzb-filtered", !!lastCheckedNode);
        section.classed("vzb-fullexpand", !!lastCheckedNode && this.tabsConfig[key] === "open fully");
      });

      //_this.DOM.content.node().scrollTop = 0;

    }

    _showHideSearch() {
      if (this.parent._getPanelMode() !== "show") return;

      let search = this.DOM.input_search.node().value || "";
      search = search.toLowerCase();
      this.DOM.list.selectAll(".vzb-show-item")
        .classed("vzb-hidden", d => {
          const lower = (d.name || "").toString().toLowerCase();
          return (lower.indexOf(search) === -1);
        });

      if (search !== "") {
        this.DOM.list.selectAll(".vzb-accordion-section")
          .classed("vzb-accordion-active", true);
      }
    }

    _showHideButtons() {
      if (this.parent._getPanelMode() !== "show") return;

      this.DOM.deselect_all.classed("vzb-hidden", this._hideResetButton());
      //
      this.DOM.apply.classed("vzb-hidden", false)
        .classed("vzb-disabled", true);
    }

    _hideResetButton() {
      let showEquals = true;
      const space = this.model.data.space;
      forEach(space, key => {
        showEquals = comparePlainObjects(this.resetFilter[key] || {}, this.model.data.filter.dimensions[key] || {});
        return showEquals;
      });

      return showEquals;
    }

    _applyShowChanges() {
      mobx.runInAction(() => {
        this.MDL.selected.data.filter.delete([...this.MDL.selected.data.filter.markers]);

        const setObj = {};
        forEach(this.previewShow, (showObj, entities) => {
          const $and = {};
          const $andKeys = [];
          forEach(showObj, (entitiesArray, category) => {
            $andKeys.push(category);
            if (entitiesArray.length) {
              $and[category] = { $in: entitiesArray.slice(0) };
            }
          });

          forEach(this.model.data.filter.dimensions[entities], (filter, key) => {
            if (!$andKeys.includes(key)) {
              $and[key] = deepClone(filter);
            }
          });

          setObj[entities] = $and;
        });
        this.model.data.filter.config.dimensions = setObj;
      });
    }

    _resetShow() {
      mobx.runInAction(() => {
        this.model.data.filter.config.dimensions = this.resetFilter;
      });
    }

    _closeClick() {
      this._applyShowChanges();
    }

    _isMarkerInDimFilter(d, dim, key) {
      const dimensionFilter = this.model.data.filter.dimensions[dim] || {};

      return getProp(dimensionFilter, [key, "$in"], []).includes(d[key]);
    }

  }

  /*!
   * VIZABI FIND CONTROL
   * Reusable find dialog
   */

  class Find extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="find" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="find" data-click="dragDialog"></span>
        <div class="vzb-dialog-title">
          <label class="vzb-dialog-title-switch">
            <input type="checkbox">
            <span class="vzb-switch-slider round"></span>
            <span class="vzb-switch-off">
              <span data-localise="dialogs/find"></span>
            </span>
            <span class="vzb-switch-on">
              <span data-localise="buttons/show"></span>
            </span>
          </label>

          <span class="vzb-dialog-content vzb-find-filter">
            <form novalidate>
              <input class="vzb-find-search" type="search" required/>
              <button class="vzb-cancel-button" type="reset"></button>
            </form>
          </span>

          <span class="vzb-spaceconfig-button"></span>
        </div>

        <div class="vzb-dialog-content vzb-dialog-content-fixed vzb-dialog-scrollable">
          <div class="vzb-dialog-content vzb-dialog-scrollable vzb-dialog-panel vzb-dialog-panel-find vzb-active">
            <div class="vzb-find-list">
              <!-- list will be placed here -->
            </div>
          </div>

          <div class="vzb-dialog-content vzb-dialog-scrollable vzb-dialog-panel vzb-dialog-panel-show">
          </div>
        </div>

        <div class="vzb-dialog-buttons">
          <div class="vzb-dialog-bubbleopacity vzb-dialog-control" data-panel="find"></div>
          <div class="vzb-dialog-button vzb-find-deselect" data-panel="find">
            <span data-localise="buttons/deselect"></span>
          </div>
          <div class="vzb-dialog-button vzb-show-deselect" data-panel="show">
            <span data-localise="buttons/reset"></span>
          </div>
          <div class="vzb-dialog-button vzb-show-apply" data-panel="show">
            <span data-localise="buttons/apply"></span>
          </div>

          <div data-dialogtype="find" data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>  

      </div>      
    `;

      config.subcomponents = [{
        type: Show,
        placeholder: ".vzb-dialog-panel-show"
      }, {
        type: SingleHandleSlider,
        placeholder: ".vzb-dialog-bubbleopacity",
        options: {
          value: "opacitySelectDim",
          submodel: "root.ui.chart"
        }
      }];

      super(config);
    }

    setup(options) {
      super.setup(options);

      this.DOM.findList = this.element.select(".vzb-find-list");
      this.DOM.titleSwitch = this.element.select(".vzb-dialog-title-switch");
      this.DOM.titleSwitchSlider = this.DOM.titleSwitch.select(".vzb-switch-slider");
      this.DOM.titleSwitchInput = this.DOM.titleSwitch.select("input");
      this.DOM.panels = this.DOM.content.selectAll(".vzb-dialog-content");
      this.DOM.panelFind = this.DOM.content.select(".vzb-dialog-panel-find");
      this.DOM.input_search = this.element.select(".vzb-find-search");
      this.DOM.deselect_all = this.element.select(".vzb-find-deselect");
      this.DOM.markerSpaceButton = this.element.select(".vzb-spaceconfig-button");
      this.DOM.opacity_nonselected = this.element.select(".vzb-dialog-bubbleopacity");

      this.DOM.titleSwitchInput.on("change", () => {
        this.ui.panelMode = this.DOM.titleSwitchInput.property("checked") ? "show" : "find";
      }).property("checked", this._getPanelMode() !== "find");

      this.DOM.input_search.on("keyup", event => {
        if (event.keyCode == 13 && this.DOM.input_search.node().value == "select all") {
          this.DOM.input_search.node().value = "";

          //TODO: select all markers

          // //clear highlight so it doesn't get in the way when selecting an entity        
          // if (!utils.isTouchDevice()) _this.model.state.marker.clearHighlighted();
          // _this.model.state.marker.selectAll();
          // utils.defer(() => _this.panelComps[_this.getPanelMode()].showHideSearch());
        }
      });

      this.DOM.input_search.on("input", () => {
        this.panelComps[this._getPanelMode()]._showHideSearch();
      });

      d3.select(this.DOM.input_search.node().parentNode)
        .on("reset", () => {
          defer(() => this.panelComps[this._getPanelMode()]._showHideSearch());
        })
        .on("submit", event => {
          event.preventDefault();
          return false;
        });

      this.DOM.deselect_all.on("click", () => {
        this.MDL.selected.data.filter.clear();
      });

      const closeButton = this.DOM.buttons.select(".vzb-dialog-button[data-click='closeDialog']");
      closeButton.on("click.panel", () => this.panelComps[this._getPanelMode()]._closeClick());

      this.panelComps = { find: this, show: this.findChild({ type: "Show" }) };
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted
      };
    }

    draw() {
      super.draw();

      this.TIMEDIM = this.MDL.frame.data.concept;
      this.KEY = Symbol.for("key");
      this.KEYS = this.model.data.space.filter(dim => dim !== this.TIMEDIM);

      this.DOM.input_search.attr("placeholder", this.localise("placeholder/search") + "...");

      this.addReaction(this._enablePanelModeSwitch);
      this.addReaction(this._enableMarkerSpaceOptions);
      this.addReaction(this._changePanelMode);
      this.addReaction(this._createFindList);
      this.addReaction(this._updateBrokenData);
      this.addReaction(this._selectDataPoints);
    }

    _changePanelMode() {
      const panelMode = this._getPanelMode();
      this.DOM.panels.classed("vzb-active", false);
      this.DOM.content.select(".vzb-dialog-panel-" + panelMode).classed("vzb-active", true);
      this.panelComps[panelMode]._showHideSearch();
      this._buttonAdjust();
      this.panelComps[panelMode]._showHideButtons();
    }

    _getPanelMode() {
      return this.ui.panelMode;
    }

    _enablePanelModeSwitch() {
      this.DOM.titleSwitchSlider.classed("vzb-hidden", !this.ui.enableSelectShowSwitch);
      this.DOM.titleSwitch.style("pointer-events", this.ui.enableSelectShowSwitch ? "auto" : "none");
    }

    _enableMarkerSpaceOptions() {
      this.DOM.markerSpaceButton.classed("vzb-hidden", !this.ui.enableMarkerSpaceOptions);
    }

    _buttonAdjust() {
      this.DOM.buttons.selectAll(".vzb-dialog-buttons > :not([data-dialogtype])").classed("vzb-hidden", true);
      this.DOM.buttons.selectAll(`[data-panel=${this._getPanelMode()}]`).classed("vzb-hidden", false);
    }

    _processFramesData() {
      const KEY = this.KEY;
      const data = new Map();
      this.model.getTransformedDataMap("filterRequired").each(frame => frame.forEach((valuesObj, key) => {
        if (!data.has(key)) data.set(key, { 
          [KEY]: key, 
          name: this._getCompoundLabelText(valuesObj)
        });
      }));
      return data;
    }

    _createFindList() {
      const findList = this.DOM.findList;
      const KEY = this.KEY;

      const data = [...this._processFramesData().values()];

      //sort data alphabetically
      data.sort((a, b) => (a.name < b.name) ? -1 : 1);

      this.DOM.findListItems = findList.text("").selectAll("div")
        .data(data, function(d) { return d[KEY]; })
        .join("div")
        .attr("class", "vzb-find-item vzb-dialog-checkbox")
        .call(this._createListItem.bind(this));
    }

    _createListItem(listItem) {
      listItem.append("input")
        .attr("type", "checkbox")
        .attr("class", "vzb-find-item")
        .attr("id", (d, i) => "-find-" + i + "-" + this.id)
        .on("change", (event, d) => {
          //clear highlight so it doesn't get in the way when selecting an entity
          if (!isTouchDevice()) this.MDL.highlighted.data.filter.delete(d);
          this.MDL.selected.data.filter.toggle(d);
          this.DOM.panelFind.node().scrollTop = 0;
          //return to highlighted state
          if (!isTouchDevice() && !d.brokenData) this.MDL.highlighted.data.filter.set(d);
        });

      listItem.append("label")
        .attr("for", (d, i) => "-find-" + i + "-" + this.id)
        .text(d => d.name)
        .on("mouseover", (event, d) => {
          if (!isTouchDevice() && !d.brokenData) this.MDL.highlighted.data.filter.set(d);
        })
        .on("mouseout", (event, d) => {
          if (!isTouchDevice()) this.MDL.highlighted.data.filter.delete(d);
        });
    }

    _getCompoundLabelText(d) {
      if (typeof d.label == "object") {
        return Object.entries(d.label)
          .filter(entry => entry[0] != this.MDL.frame.data.concept)
          .map(entry => isNumber(entry[1]) ? (entry[0] + ": " + entry[1]) : entry[1])
          .join(", ");
      }
      if (d.label != null) return "" + d.label;
      return d[Symbol.for("key")];
    }

    _updateBrokenData() {
      const currentDataMap = this.model.dataMap;
      const findListItems = this.DOM.findListItems;
      const KEY = this.KEY;

      findListItems.data().forEach(d => {
        d.brokenData = !currentDataMap.hasByStr(d[KEY]);
      });

      this._updateLabelTitle();
    }

    _updateLabelTitle() {
      const noDataSubstr = this.localise(this.MDL.frame.value) + ": " + this.localise("hints/nodata");
      this.DOM.findListItems.select("label")
        .classed("vzb-find-item-brokendata", d => d.brokenData)
        .attr("title", d => d.nameIfEllipsis + (d.brokenData ? (d.nameIfEllipsis ? " | " : "") + noDataSubstr : ""));
    }

    _updateView() {

    }

    _selectDataPoints() {
      //    const selected = this.model.state.marker.getSelected(KEY);
      const selected = this.MDL.selected.data.filter;
      this.DOM.findListItems.order().select("input")
      //      .property("checked", d => (selected.indexOf(d[KEY]) !== -1));
        .property("checked", function(d) {
          const isSelected = selected.has(d);
          d3.select(this.parentNode).classed("vzb-checked", isSelected);
          return isSelected;
        });
      
      const checkedItems = this.DOM.findList.selectAll(".vzb-checked");
      checkedItems
        .lower()
        .classed("vzb-separator", (d, i) => !i);    
    }

    _showHideSearch() {
      if (this._getPanelMode() !== "find") return;

      let search = this.DOM.input_search.node().value || "";
      search = search.toLowerCase();

      this.DOM.findList.selectAll(".vzb-find-item")
        .classed("vzb-hidden", d => {
          const lower = (d.name || "").toString().toLowerCase();
          return (lower.indexOf(search) === -1);
        });
    }

    _showHideButtons() {
      if (this._getPanelMode() !== "find") return;

      const someSelected = this.MDL.selected.data.filter.any();
      this.DOM.deselect_all.classed("vzb-hidden", !someSelected);
      this.DOM.opacity_nonselected.classed("vzb-hidden", !someSelected);
      if (someSelected) {
        mobx.runInAction(() => {
          const opacityNonSelectedSlider = this.findChild({ type: "SingleHandleSlider" });
          opacityNonSelectedSlider._updateSize();
          opacityNonSelectedSlider._updateView();
        });
      }
    }

    _closeClick() {}
  }

  Find.DEFAULT_UI = {
    enableSelectShowSwitch: false,
    enableMarkerSpaceOptions: false,
    panelMode: "find",
    enablePicker: false
  };

  const decorated$7 = mobx.decorate(Find, {
    "MDL": mobx.computed
  });

  decorated$b.add("find", decorated$7);

  /*
   * Label dialog
   */

  class Label extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="label" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="label" data-click="dragDialog"></span>
        <div class="vzb-dialog-title"> 
          <span data-localise="buttons/label"></span>
        </div>

        <div class="vzb-dialog-content">
          <div class="vzb-enablelabelbox-switch"></div>
          <span class="vzb-saxis-selector"></span>
          <div class="vzb-dialog-sizeslider"></div>
          <div class="vzb-removelabelbox-switch"></div>
        </div>

        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>

      </div>
    `;

      config.subcomponents = [{
        type: SizeSlider,
        placeholder: ".vzb-dialog-sizeslider",
        options: {
          constantUnit: "unit/pixels",
          submodelFunc: () => this.model.encoding.size_label.scale,
        }
      }, {
        type: IndicatorPicker,
        placeholder: ".vzb-saxis-selector",
        options: {
          submodel: "encoding",
          targetProp: "size_label",
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-removelabelbox-switch",
        options: {
          checkbox: "removeLabelBox",
          submodel: "root.ui.chart.labels"
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-enablelabelbox-switch",
        options: {
          checkbox: "enabled",
          submodel: "root.ui.chart.labels"
        }
      }];

      super(config);
    }
  }

  decorated$b.add("label", Label);

  class MarkerControlsSection extends BaseComponent {
    constructor(config) {
      config.template = `
      <div class = "vzb-header">
        <span class = "vzb-back">⬅</span>
        <span class = "vzb-title"></span>
        <span class = "vzb-threedots"></span>
        <span class = "vzb-enterhint"></span>
      </div>
      <div class = "vzb-content"></div>

    `;
      super(config);
      this.magicCommand = this.constructor.name.replace("_","").replace("Section","").toLowerCase();
    }

    setup() {
      this.DOM = {
        header: this.element.select(".vzb-header"),
        back: this.element.select(".vzb-back"),
        title: this.element.select(".vzb-title"),
        threedots: this.element.select(".vzb-threedots"),
        enterhint: this.element.select(".vzb-enterhint"),
        content: this.element.select(".vzb-content"),
      };

      this.DOM.back.on("click", () => this.cancelChanges());
    }

    example() {
      return "";
    }

    cancelChanges() {
      this.parent.toggleFullscreenish();
    }

    showHideHeader(showHide){
      this.DOM.header.classed("vzb-hidden", !showHide);
    }

    hide(arg) {
      this.element.classed("vzb-hidden", arg);
    }

    updateSearch() {
      console.warn("updateSearch(text) function is not implemented in " + this.constructor.name);
      this.showHideHeader();
    }

    concludeSearch() {
      console.warn("concludeSearch(text) function is not implemented in " + this.constructor.name);
    }


  }

  const KEY$3 = Symbol.for("key");

  class SectionFind extends MarkerControlsSection {
    constructor(config) {
      super(config);
    }

    setup(options) {
      super.setup(options);
      this.DOM.title.text("Find");
      this.DOM.list = this.DOM.content.append("div").attr("class", "vzb-list");
      this.listReady = false;
      this.entitiesWithMissingData = [];
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.createList);
      this.addReaction(this.updatemissingDataForFrame);
      this.addReaction(this.updateSelection);
      this.addReaction(this.getEntitiesDeliberatelyAddedInFilterButMissingData);
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted
      };
    }

    getEntitiesDeliberatelyAddedInFilterButMissingData() {
      const entitiesWithMissingData = [];
      this.model.data.spaceCatalog.then(spaceCatalog => {
        for (const dim in spaceCatalog) {
          const filterSpec = this.model.encoding?.show?.data?.filter?.dimensions?.[dim] || {};
          if (spaceCatalog[dim].entities) {
            const dimOrIn = this.model.data.filter.dimensions?.[dim]?.$or?.find( f => f[dim])?.[dim]?.$in || [];
            [...spaceCatalog[dim].entities.filter(filterSpec).values()].forEach(entity => {
              if (dimOrIn.includes(entity[KEY$3]) && ![...this.parent.markersData.values()].some(s => s[dim] === entity[dim])) {
                const push = {
                  [KEY$3]: entity[KEY$3],
                  [dim]: entity[dim], 
                  name: entity.name, 
                  missingData: true
                };
                entitiesWithMissingData.push(push);
              }
              
            });
          }
        }

        this.entitiesWithMissingData = entitiesWithMissingData;
      });
    }

    createList() {
      this.listReady = false;
      let data = [...this.parent.markersData.values()]
        .concat(this.entitiesWithMissingData)
        .toSorted((a, b) => (a.name < b.name) ? -1 : 1);

      const primaryDimension = this.parent.ui.primaryDim ? this.parent.ui.primaryDim : this.model.data.space[0];
      data = d3.groups(data, d =>d[primaryDimension])
        .map(([key, children]) => ({
          [KEY$3]: key, 
          children, 
          name: children[0].label?.[primaryDimension] || children[0].name, 
          missingData: children.every(child => child.missingData)
        }));
    
      const list = this.DOM.list.text("");

      this.DOM.listItems = list.selectAll("div")
        .data(data, d => d[KEY$3] )
        .join("div")
        .attr("class", "vzb-item vzb-dialog-checkbox")
        .call(this._createListItem.bind(this, data.length));

      this.listReady = true;
    }

    _createListItem(dataLength, listItem) {

      listItem.append("input")
        .attr("type", "checkbox")
        .attr("id", (d, i) => d[KEY$3] + "-find-" + i + "-" + this.id)
        .on("change", (event, d) => {
          if(this.parent.ui.disableFindInteractions) return;
          this.setModel.select(d);
          this.parent.DOM.content.node().scrollTop = 0;
          this.parent._clearSearch();
          this.parent.updateSearch();
        });

      listItem.append("label")
        .classed("vzb-disabled", this.parent.ui.disableFindInteractions)
        .attr("for", (d, i) => d[KEY$3] + "-find-" + i + "-" + this.id)
        .on("mouseover", (event, d) => {
          if (isTouchDevice()) return;
          if(this.parent.ui.disableFindInteractions) return;
          this.setModel.highlight(d);
        })
        .on("mouseout", (event, d) => {
          if (isTouchDevice()) return;
          if(this.parent.ui.disableFindInteractions) return;
          this.setModel.unhighlight(d);
        });

      listItem.append("span")
        .attr("class", "vzb-closecross")
        .text("✖️")
        .classed("vzb-hidden", dataLength === 1)
        .on("click", (event, d) => {
          this.setModel.unhighlight(d);
          this.setModel.deselect(d);
          const principalDimension = this.model.data.space[0];
          this.parent.findChild({type: "SectionRemove"}).setModel(Object.assign({}, d, {prop: principalDimension, dim: principalDimension}));
          this.parent._clearSearch();
          this.parent.updateSearch();
        });
    }

    setModel = {
      select: (d) => {
        if (d.missingData) return;
        mobx.runInAction(() => d.children.forEach(child => this.MDL.selected.data.filter.toggle(child)));
      },
      deselect: (d) => {
        mobx.runInAction(() => d.children.forEach(child => this.MDL.selected.data.filter.delete(child)));
      },
      highlight: (d) => {
        if (d.missingDataForFrame || d.missingData) return;
        mobx.runInAction(() => d.children.forEach(child => this.MDL.highlighted.data.filter.set(child)));
      },
      unhighlight: (d) => {
        mobx.runInAction(() => d.children.forEach(child => this.MDL.highlighted.data.filter.delete(child)));
      },
    }

    updatemissingDataForFrame() {
      if(!this.listReady) return;
      this.entitiesWithMissingData;
      const currentDataMap = this.model.dataMap;
      const listItems = this.DOM.listItems;

      listItems.data().forEach(d => {
        d.missingDataForFrame = !d.missingData && d.children.every(child => !currentDataMap.hasByStr(child[KEY$3]));
      });

      const frame = this.localise(this.MDL.frame.value);
      const noDataSubstr = frame + ": " + this.localise("hints/nodata");
      this.DOM.listItems.select("label")
        .classed("vzb-find-item-missingDataForFrame", d => d.missingDataForFrame)
        .classed("vzb-find-item-missingData", d => d.missingData)
        .html(d => d.missingDataForFrame ? `<span>${d.name}</span> <span class=vzb-frame>${frame}</span>` : d.name)
        .attr("title", d => "key: " + d[KEY$3] + (d.missingDataForFrame ? ", " + noDataSubstr : ""));
    }

    example() {
      const data = [...this.parent.markersData.values()];
      const randomItem = data[Math.floor(Math.random() * data.length)];
      return randomItem.name;
    }

    updateSelection() {
      if(!this.listReady) return;
      const selected = this.MDL.selected.data.filter;
      this.DOM.listItems.order().select("input")
        .property("checked", function(d) {
          const isSelected = selected.has(d);
          d3.select(this.parentNode).classed("vzb-checked", isSelected);
          return isSelected;
        });
      
      const checkedItems = this.DOM.list.selectAll(".vzb-checked");
      checkedItems
        .lower()
        .classed("vzb-separator", (d, i) => !i);    
    }

    updateSearch(text = "") {
      if(!this.listReady) return;
      let hiddenItems = 0;

      const items = this.DOM.list.selectAll(".vzb-item")
        .classed("vzb-hidden", d => {
          const hide = text && !(d.name || "").toString().toLowerCase().includes(text);
          hiddenItems += +hide;
          return hide;
        });
      this.showHideHeader(items.size() - hiddenItems);
    }

    getListItemCount() {
      return this.DOM.list.selectAll(".vzb-item:not(.vzb-hidden)").size();
    }

    concludeSearch(text = "") {
      mobx.runInAction(() => {
        const data = [...this.parent.markersData.values()];
        const filtered = data.filter(f => (f.name || "").toString().toLowerCase().includes(text));
        if (filtered.length === 1) {
          this.MDL.selected.data.filter.toggle(filtered[0]);
          this.updateSearch();
        }
      });
    }

  }

  const decorated$6 = mobx.decorate(SectionFind, {
    "MDL": mobx.computed,
    "entitiesWithMissingData": mobx.observable,
    "listReady": mobx.observable
  });

  const KEY$2 = Symbol.for("key");
  //¬

  class SectionAdd extends MarkerControlsSection {
    constructor(config) {
      super(config);
    }

    setup(options) {
      super.setup(options);
      this.DOM.title.text("Add");
      this.DOM.matches = this.DOM.content.append("ul").attr("class", "vzb-addgeo-matches");

      this.catalog = [];
      this.allCatalog = [];
      this.entitySetsColorScale = d3.scaleOrdinal(d3.schemePastel2);
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.buildList);
    }

    updateSearch(text = "") {
      this.search(text);
    }

    concludeSearch(text = "") {
      this.search(text);
    }

    _getKey(element, key, dim) {
      return dim + "¬" + key + "¬" + element;
    }

    buildList() {
      this.model.encoding.label.data.spaceCatalog.then(spaceCatalog => {
        const catalog = [];
        const allCatalog = [];
        for (const dim in spaceCatalog) {
          if(this.parent.ui.primaryDim && dim !== this.parent.ui.primaryDim) continue;

          const filterSpec = this.model.encoding?.show?.data?.filter?.dimensions?.[dim] || {};
          const dimOr = this.model.data.filter.dimensions?.[dim]?.$or?.[0];
          const dimOrInEntityKeys = [];

          for (const key in dimOr) {
            if (key == dim) continue;
            if (dimOr[key].$in) {
              dimOr[key].$in.forEach(value => {
                dimOrInEntityKeys.push(this._getKey(value, key, dim));
              });
            }
          }

          if (spaceCatalog[dim].entities) {
            const dimOrIn = this.model.data.filter.dimensions?.[dim]?.$or?.find( f => f[dim])?.[dim]?.$in || [];
            const entities = [...spaceCatalog[dim].entities.filter(filterSpec).values()]
              .map(_d => {
                const d = deepClone(_d);
                d.isness= Object.keys(d).filter(f => f.includes("is--") && d[f]).map(m => {              
                  const concept = m.replace("is--","");
                  return {
                    id: m,
                    name: this.model.data.source.getConcept(concept)?.name,
                    concept,
                    isProp: spaceCatalog[dim].properties.hasOwnProperty(concept)
                  };
                });
                d[KEY$2] = _d[KEY$2];
                d.dim = dim;
                d.prop = dim;
                return d;
              });

            catalog.push(...entities.filter(f => {
              return !this.parent.dimMarkersData.has(f[Symbol.for("key")]) &&
                !dimOrIn.includes(f[Symbol.for("key")]);
            }));

            if(!this.parent.ui.disableAddRemoveGroups) allCatalog.push(...entities
              .reduce((result, entity) => {
                const props = entity.isness.filter(d => d.isProp);
                if (props.length) {
                  props.forEach(prop => {
                    if (!dimOrInEntityKeys.includes(this._getKey(entity[KEY$2], prop.concept, dim))) {
                      result.push({
                        __allElements: true,
                        [KEY$2]: entity[KEY$2],
                        name: entity.name,
                        prop: prop.concept,
                        propName: prop.name,
                        dim
                      });
                    }
                  });
                }
                return result;
              }, []));
          }
        }
        this.catalog = catalog;
        this.allCatalog = allCatalog;
        this.search();
      });
    }

    example() {
      const data = this.catalog;
      const randomItem = data[Math.floor(Math.random() * data.length)];
      return randomItem.name;
    }

    search(string = "") {
      if(string && string.length < 2) {
        this.DOM.matches.selectAll("li").remove();
        this.DOM.matches.classed("vzb-hidden", true);
        this.showHideHeader();
        return;
      }

      const matches = this.catalog.filter(f => f.name.toLowerCase().trim().includes(string.toLowerCase().trim()) || f[Symbol.for("key")].includes(string.toLowerCase().trim()))
        .sort((x, y) => d3.ascending(x.isness.map(k => k.id).join(), y.isness.map(k => k.id).join()))
        .concat(
          this.allCatalog.filter(f => f.name.toLowerCase().trim().includes(string.toLowerCase().trim()) || f[Symbol.for("key")].includes(string.toLowerCase().trim()))
            .sort((x, y) => d3.ascending(x.propName, y.propName))
        );
      
      this.DOM.matches.classed("vzb-hidden", !matches.length);
      this.DOM.matches.selectAll("li").remove();
      this.DOM.matches.selectAll("li")
        .data(matches)
        .enter().append("li")
        .html((d) => {
          if (d.__allElements) {
            return "ALL "
              + this.localise("marker-plural/" + this.model.id.replace("-splash", ""))
              + " where</br>"
              + d.propName + " = " + d.name;
          } else {
            return d.name + d.isness.map(m => `<span class="vzb-dialog-isness" style="background-color:${this.entitySetsColorScale(m.id)}">${m.name}</span>`).join("");
          }
        })
        .on("click", (event, d) => {
          const dimNin = this.model.data.filter.dimensions?.[d.dim]?.[d.prop]?.$nin || [];

          if (dimNin.includes(d[KEY$2])) {
            this.model.data.filter.deleteFromDimensionsFirstINstatement(d, [d.dim, d.prop, "$nin"]);
          } else {
            this.model.data.filter.addToDimensionsFirstINstatement(d, [d.dim, "$or", 0, d.prop, "$in"]);
          }

          this.concludeSearch();
        })
        .classed("vzb-dialog-all-entites", d => d.__allElements);

      this.showHideHeader(matches.length);
    }
  }

  const decorated$5 = mobx.decorate(SectionAdd, {
  });

  const KEY$1 = Symbol.for("key");

  class SectionRemove extends MarkerControlsSection {
    constructor(config) {
      super(config);
    }

    setup(options) {
      super.setup(options);
      this.DOM.title.text("Remove");
      this.DOM.matches = this.DOM.content.append("ul").attr("class", "vzb-remove-matches");

      this.catalog = [];
      this.allCatalog = [];
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.createList);

    }

    updateSearch(text = "") {
      this.search(text);
    }

    concludeSearch(text = "") {
      this.search(text);
    }

    _getKey(element, key, dim) {
      return dim + "¬" + key + "¬" + element;
    }

    createList() {
      this.model.encoding.label.data.spaceCatalog.then(spaceCatalog => {
        const dataKeys = [...this.parent.dimMarkersData.keys()];
        const markersFromIn = [];

        for (const dim in spaceCatalog) {
          const dimOrIn = this.model.data.filter.dimensions?.[dim]?.$or?.find( f => f[dim])?.[dim]?.$in || [];
          markersFromIn.push(...dimOrIn
            .filter(d => !dataKeys.includes(d))
            .map(d => {
              if (spaceCatalog[dim].entities && spaceCatalog[dim].entities.has(d)) {
                const entity = spaceCatalog[dim].entities.get(d);
                return ({
                  [KEY$1]: entity[KEY$1],
                  [dim]: entity[dim],
                  name: entity.name,
                  prop: dim,
                  dim
                });
              }
              return ({
                [KEY$1]: d,
                [dim]: dim,
                name: d,
                prop: dim,
                dim
              });
            })
          );
        }

        this.catalog = [...this.parent.dimMarkersData.values(), ...markersFromIn];

        const allCatalog = [];
        for (const dim in spaceCatalog) {
          const dimFilter = this.model.data.filter.dimensions?.[dim] || {};
          const dimNinEntities = [];
          for (const key in dimFilter) {
            if (key == dim) continue;
            if (dimFilter[key].$nin) {
              dimFilter[key].$nin.forEach(element => {
                dimNinEntities.push(this._getKey(element, key, dim));
              });
            }
          }
          const dimProps = spaceCatalog[dim].properties;
          if (dimProps) {
            for (const prop in dimProps) {
              if (dimProps[prop]?.concept?.concept_type == "entity_set") {
                dimProps[prop].entities.forEach((entityObj, key) => {
                  if (!dimNinEntities.includes(this._getKey(key, prop, dim))) {
                    allCatalog.push({
                      __allElements: true,
                      [KEY$1]: key,
                      [dim]: prop,
                      name: entityObj.name,
                      prop,
                      propName: dimProps[prop].concept.name,
                      dim
                    });
                  }
                });
              }
            }
          }
        }

        if(!this.parent.ui.disableAddRemoveGroups) this.allCatalog = allCatalog;
        this.search();
      });

    }

    search(string = ""){
      if(string && string.length < 2) {
        this.DOM.matches.selectAll("li").remove();
        this.DOM.matches.classed("vzb-hidden", true);
        this.showHideHeader();
        return;
      }

      const matches = this.catalog.filter(f => f.name.toLowerCase().trim().includes(string.toLowerCase().trim()) || f[Symbol.for("key")].includes(string.toLowerCase().trim()))
        .sort((x, y) => d3.ascending(x.name, y.name))
        .concat(
          this.allCatalog.filter(f => f.name.toLowerCase().trim().includes(string.toLowerCase().trim()) || f[Symbol.for("key")].includes(string.toLowerCase().trim()))
            .sort((x, y) => d3.ascending(x.propName, y.propName))
        );

      this.DOM.matches.classed("vzb-hidden", !matches.length);
      this.DOM.matches.selectAll("li").remove();
      this.DOM.matches.selectAll("li")
        .data(matches)
        .enter().append("li")
        .html((d) => {
          if (d.__allElements) {
            return "ALL "
              + this.localise("marker-plural/" + this.model.id.replace("-splash", ""))
              + " where</br>"
              + d.propName + " = " + d.name;
          } else {
            return d.name;
          }
        })
        .on("click", (event, d) => {
          this.setModel(d);
          this.concludeSearch();
        })
        .classed("vzb-dialog-all-entites", d => d.__allElements);

      this.showHideHeader(matches.length);
    }

    setModel(d){
      const dimOrIn = this.model.data.filter.dimensions?.[d.dim]?.$or?.find( f => f[d.prop])?.[d.prop]?.$in || [];

      if (dimOrIn.includes(d[KEY$1])) {
        this.model.data.filter.deleteFromDimensionsFirstINstatement(d, [d.dim, "$or", 0, d.prop, "$in"]);
      } else {
        this.model.data.filter.addToDimensionsFirstINstatement(d, [d.dim, d.prop, "$nin"]);
      }
    }

  }

  const decorated$4 = mobx.decorate(SectionRemove, {
  });

  const ellipsis = (string, n)  => string.length > n ? string.substr(0, n) + "…" : string;

  class SectionSwitch extends MarkerControlsSection {
    constructor(config) {
      super(config);
    }

    setup(options) {
      super.setup(options);
      this.DOM.title.text("Switch to");
      this.DOM.list = this.DOM.content.append("div").attr("class", "vzb-list");
      this.DOM.hint = this.DOM.content.append("div").attr("class", "vzb-hint");
      this.items = [];
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.getListData);
      this.addReaction(this.createList);
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted
      };
    }

    getListData() {

      const getAvailabilitySize = (concept, dim, concept_type) => {
        const frameDim = this.MDL.frame.data.concept;
        const createKeyStr = (space) => space.toSorted().join("¬");
        const space = concept_type === "boolean" ? [dim, frameDim] : [concept, frameDim];
        return this.model.data.source.availability.keyValueLookup.get(createKeyStr(space))?.size;
      };

      const items = [];
      this.model.data.spaceCatalog.then(spaceCatalog => {
        for (const dim in spaceCatalog) {

          if (spaceCatalog[dim].entities && spaceCatalog[dim].properties) {

            const entityProps = spaceCatalog[dim].properties;
            const newitems = Object.keys(entityProps)
              .filter(f => f.includes("is--") || entityProps[f].concept.concept_type === "boolean")
              .map(m => m.replace("is--", ""))
              .map(concept => ({
                dim, 
                concept, 
                concept_type: this.model.data.source.getConcept(concept).concept_type, 
                name: this.model.data.source.getConcept(concept).name || concept, 
                availabilitySize: getAvailabilitySize(concept, dim, this.model.data.source.getConcept(concept).concept_type)
              }))
              .concat({
                dim,
                concept: dim,
                concept_type: "entity_domain",
                name: this.model.data.source.getConcept(dim).name, 
                availabilitySize: getAvailabilitySize(dim)
              })
              .filter(f => f.availabilitySize)
              .toSorted((a, b) => b.availabilitySize - a.availabilitySize);

            items.push(newitems);
          }

        }

        this.items = items.flat();
        
      });
    }

    isCurrentSetting({dim, concept}) {
      const filterDim = this.model.data.filter.dimensions[dim];
      if (!filterDim && dim === concept) return true;
      if (!filterDim) return false;
      return filterDim[concept] || filterDim["is--" + concept] 
        || filterDim["$or"] && (filterDim["$or"].some(s => s[concept] || s["is--" + concept]))
        || false;
    }

    createList() {
      const list = this.DOM.list;
      this.model.data.filter;

      this.DOM.listItems = list.selectAll("div")
        .data(this.items, d => d.concept)
        .join(
          enter => enter.append("div")
            .attr("class", "vzb-item")
            .call(view => {
              view.append("input")
                .attr("type", "radio")
                .attr("id", d => this.id + "--" + d.concept)
                .attr("name", this.id + "--radiogroup")
                .on("change", (event, d) => this.setFilter(d));

              view.append("label")
                .attr("for", d => this.id + "--" + d.concept)
                .html(d => `<span>${ellipsis(d.name, 20)}</span> <span class="vzb-hint">${d.availabilitySize ? "(" + d.availabilitySize + ")" : ""}</span>`);
            }),
          update => update.selectAll("input")
            .property("checked", d => this.isCurrentSetting(d))
        );

      this.DOM.hint.text("number shows how many measures are available in dataset " + this.model.data.source.id + " for each of the options above");
    }


    example() {
      const data = this.items;
      const randomItem = data[Math.floor(Math.random() * data.length)];
      return randomItem.name;
    }

    setFilter({dim, concept, concept_type}) {
      const filter = this.model.data.filter.config.dimensions;
      if (!filter) return false;
      if (dim === concept)
        filter[dim] = null;
      else 
        filter[dim] = {
          "$or": [{
            [concept_type === "boolean" ? concept : ("is--" + concept)]: true
          }]
        };
    }

    updateSearch(text = "") {
      let hiddenItems = 0;
      const items = this.DOM.list.selectAll(".vzb-item")
        .classed("vzb-hidden", d => {
          const hidden = this.isCurrentSetting(d) && !this.parent.isFullscreenish()
          || text && !d.name.toString().toLowerCase().includes(text);
          hiddenItems += +hidden;
          return hidden;
        });
      this.showHideHeader(items.size() - hiddenItems);
      this.DOM.hint.classed("vzb-hidden", !(items.size() - hiddenItems));
    }

    concludeSearch(text = "") {
      mobx.runInAction(() => {
        const data = [...this.parent.markersData.values()];
        const filtered = data.filter(f => (f.name || "").toString().toLowerCase().includes(text));
        if (filtered.length === 1) {
          this.MDL.selected.data.filter.toggle(filtered[0]);
          this.updateSearch();
        }
      });
    }

  }

  const decorated$3 = mobx.decorate(SectionSwitch, {
    "items": mobx.observable
  });

  function spacesAreEqual(a, b){
    return a.toSorted().join() === b.toSorted().join();
  }

  const longestFirst = (a,b) => b.length - a.length;
  const shortestFirst = (a,b) => a.length - b.length;

  function getMatchingSpace(spaces, targetSpace){
    return spaces.find(s => spacesAreEqual(s, targetSpace));
  }

  function getSubspaces(spaces, targetSpace){
    return spaces.filter(s => s.every(dim => targetSpace.includes(dim)))
      .toSorted(longestFirst);
  }

  function getSuperspaces(spaces, targetSpace){
    return spaces.filter(s => targetSpace.every(dim => s.includes(dim)))
      .toSorted(shortestFirst);
  }

  function getPartiallyOverlappingSpaces(spaces, targetSpace){
    return spaces.filter(s => targetSpace.some(dim => s.includes(dim)))
      .toSorted(shortestFirst);
  }

  function removeDulicates(space){
    const result = [];
    space.forEach(space => {
      if(!result.some(s => spacesAreEqual(s.space, space.space)))
        result.push(space);
    });
    return result;
  }

  class SectionSlice extends MarkerControlsSection {
    constructor(config) {
      super(config);

      this.showAllEncs = false;
      this.proposedSpace = null;
      this.goodToGo = false;
    }

    setup(options) {
      super.setup(options);
      this.DOM.title.text("Slice by");
      this.DOM.list = this.DOM.content.append("div").attr("class", "vzb-list");
      
      this.DOM.actionSummary = this.DOM.content.append("div").attr("class", "vzb-spaceconfig-actionsummary");

      this.DOM.encodings = this.DOM.content.append("div").attr("class", "vzb-spaceconfig-encodings");

      this.DOM.buttonShowAllEncs = this.DOM.content.append("div").attr("class", "vzb-spaceconfig-showallencs")
        .text("•••")
        .on("click", () => { this.showAllEncs = !this.showAllEncs; });

      this.DOM.buttons = this.DOM.content.append("div").attr("class", "vzb-spaceconfig-buttons");
      this.DOM.buttonapply = this.DOM.buttons.append("div").attr("class", "vzb-spaceconfig-button-apply");
      this.DOM.buttoncancel = this.DOM.buttons.append("div").attr("class", "vzb-spaceconfig-button-cancel");
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.createList);
      this.addReaction(this.updateEncodigns);
      this.addReaction(this.updateUIstrings);
      this.addReaction(this.updateApplyCancelButtons);
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame,
      };
    }


    updateUIstrings(){
      this.DOM.buttoncancel.text("Cancel");
      this.DOM.buttonapply.text("Apply");
    }

    _getMarkerSpaceAvailability(){
      const items = [];
      const allowedConcetTypes = ["entity_domain", "time"];
      this._getAllDataSources().forEach(ds => {
        ds.availability.keyLookup.forEach(space => {
          if (space.every(f => allowedConcetTypes.includes(ds.getConcept(f).concept_type))) items.push({space, dsId: ds.id});
        });
      });
      const currentSpace = this.model.data.space;
      const frameConcept = this.MDL.frame.data.concept;

      return items.map(item => ({
        dsId: item.dsId,
        space: item.space.toSorted((a) => {
          //first element in current space will be listed first
          if (currentSpace.indexOf(a) === 0) return -1;
          //elements missing from current space will be listed in the middle
          if (currentSpace.indexOf(a) === -1) return 0;
          //time concepts go last
          if (a === frameConcept) return 1;
        })
      }));
    }

    createList() {
      this.proposedSpace; //watch to successfully reset radiobuttons on cancel/back
      const frameConcept = this.MDL.frame.data.concept;
      const spaceAvailability = removeDulicates(this._getMarkerSpaceAvailability().filter(f => f.space.includes(frameConcept)));
      
      this.DOM.list.selectAll("div")
        .data(spaceAvailability, this._getItemId)
        .join(
          enter => enter.append("div")
            .attr("class", "vzb-item")
            .call(view => {
              view.append("input")
                .attr("type", "radio")
                .attr("id", this._getItemId)
                .attr("name", this.id + "--radiogroup")
                .on("change", (event, d) => {
                  this._proposeSpace(d);
                });

              view.append("label")
                .attr("for", this._getItemId)
                .text(this._getText.bind(this));
            }),
          update => update.select("input")
            .property("checked", d => spacesAreEqual(d.space, this.proposedSpace?.space || this.model.data.space))
          //   .
        );
    }

    _proposeSpace(proposedSpace) {
      if(!this.parent.isFullscreenish()) this.parent.toggleFullscreenish(this);
      this.proposedSpace = proposedSpace;
    }

    getEncodings(){
      const encs = this.model.encoding;
      return Object.keys(encs).filter(enc => {
        if (!this.model.requiredEncodings || this.model.requiredEncodings.includes(enc)) return true;
        if (enc == "color") return true;
        if (enc == "label") return true;
      });
    }

    _getDataModels(dsConfig) {
      return Object.keys(dsConfig).map(dsName => this.services.Vizabi.Vizabi.stores.dataSources.get(dsName));
    }

    _getAvailability(){
      const items = [];
      this._getDataModels(this.root.model.config.dataSources).forEach(ds => {
        ds.availability.data.forEach(kv => {
          items.push({ key: kv.key, value: ds.getConcept(kv.value), source: ds });
        });
      });
      return items;
    }  

    //returns concepts and their spaces (availbility keys), 
    //such that only strict superspaces, strict subspaces and matching spaces remain
    _conceptsCompatibleWithMarkerSpace(availabilityMapByConcepts, markerSpace, strict){
      const filteredValueLookup = new Map();
      const markerSpaceSet = new Set(markerSpace);
      const intersect = (a,b) => a.filter(e => b.has(e));
      for (const [concept, {source, spaces}] of availabilityMapByConcepts) {  
        const filteredSpaces = [...spaces].filter(space => {
          const intersection = intersect(space, markerSpaceSet);
          const fullOverlap = space.length == markerSpaceSet.size;
          const partialOverlap = intersection.length == markerSpaceSet.size || intersection.length == space.length;
          return strict && fullOverlap || !strict && partialOverlap;
        });
        if (filteredSpaces.length) filteredValueLookup.set(concept, {source, spaces: filteredSpaces});
      }
      return filteredValueLookup;
    }

    _convertConceptMapToArray(conceptmap){
      return [...conceptmap].map(([concept, {source, spaces}]) => ({concept, source, spaces: [...spaces]}));
    }

    _nestAvailabilityByConcepts(availability){
      return availability.reduce((map, kv) => {
        const key = kv.value;
        const space = kv.key;
        if (!map.has(key)) map.set(key, {source: kv.source, spaces: new Set()});
        map.get(key).spaces.add(space);
        return map;
      }, new Map());
    }

    updateEncodigns(proposedSpace = this.proposedSpace){
      const _this = this;
      const encs = this.model.encoding;

      const nest = this._nestAvailabilityByConcepts(this._getAvailability());
      //const filtervl = this._conceptsCompatibleWithMarkerSpace(nest, this.model.data.space);
      this.concepts = this._convertConceptMapToArray(nest);
      this.encNewConfig = {};

      const encodingStatus = this.getEncodings().map(enc => ({
        enc,
        status: _this.getSpaceCompatibilityStatus(encs[enc], proposedSpace?.space)
      }));

      const isRequired = (enc) => !this.model.requiredEncodings || this.model.requiredEncodings.includes(enc);
      const allRequiredAreInSubspace = this.model.requiredEncodings && this.model.requiredEncodings.length > 0 
        && encodingStatus.every(({enc, status}) => status.status === "subspaceAvailable" || !isRequired(enc));

      const someActionRequired = encodingStatus.some(({status}) => status.actionReqired);
      const alreadyInSpace = proposedSpace?.space && spacesAreEqual(proposedSpace.space, this.model.data.space);

      this.DOM.actionSummary
        .classed("vzb-hidden", !proposedSpace)
        .text(
          someActionRequired
            ? "Pls review the following:"
            : allRequiredAreInSubspace 
              ? "Options below have no data for the chosen slicing. "
                  + "To proceed, switch at least one of them to a different variable, that has data " 
                  + _this._getText(proposedSpace) 
                  + ":"
              : alreadyInSpace
                ? "This is the current configuration"
                : "Good to go!"
        );

      this.goodToGo = !someActionRequired && !allRequiredAreInSubspace && !alreadyInSpace;

      this.DOM.encodings
        .html("")
        .selectAll("div")
        .data(encodingStatus, d => d.enc)
        .enter().append("div")
        .attr("class", "vzb-spaceconfig-enc")
        .each(function({enc, status}){
          const view = d3.select(this);

          const encoding = encs[enc];
          const concept = _this.concepts.find(f => f.concept.concept == encoding.data.concept);
          const isSpaceSet = encoding.data.config.space;
          const newConfig = _this.encNewConfig[enc] = {};

          const DOM = {
            status: view.append("div")
              .attr("class", "vzb-spaceconfig-enc-status")
              .attr("title", status.status)
              .classed("vzb-hidden", !_this.showAllEncs)
              .text(_this.statusIcons(status)),

            name: view.append("div")
              .attr("class", "vzb-spaceconfig-enc-name")
              .text(enc),
            concept: view.append("div")
              .attr("class", "vzb-spaceconfig-enc-concept"),
            spaceCurrent: view.append("div")
              .attr("for", "vzb-spaceconfig-enc-space-current")
              .classed("vzb-hidden", !_this.showAllEncs),
            spaceNew: view.append("div")
              .attr("for", "vzb-spaceconfig-enc-space-new")
              .classed("vzb-hidden", !_this.showAllEncs),
          };
          

          
          if(status.status == "constant"){
            DOM.concept.text("constant: " + encoding.data.constant);

          }else {

            DOM.concept
              .text(concept?.concept?.name || encoding.data.concept);
            DOM.spaceCurrent
              .text("current space: " + encoding.data.space.join() + (isSpaceSet? " (set)" : " (inherited)") );
            
            if(status.status == "alreadyInSpace" || status.status == "entityPropertyDataConfig") {
              DOM.spaceNew.text("new space: " + (isSpaceSet ? " will reset to marker space" : "no change"));

              if(isSpaceSet) newConfig["space"] = null;
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }

            if(status.status == "matchingSpaceAvailable") {
              DOM.spaceNew.text("new space: " + status.spaces[0].join() + (isSpaceSet? " (set)" : " (inherited)"));

              if(isSpaceSet) newConfig["space"] = null;
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }     
            
            if(status.status == "subspaceAvailable") {
              DOM.spaceNew.text("new space: " + status.spaces[0].join() + " (set)");

              newConfig["space"] = status.spaces[0];
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }  

            if(status.status == "superspaceAvailable") {
              DOM.spaceNew.text("new space: " + status.spaces[0].join() + " (set)");

              newConfig["space"] = status.spaces[0];
              if(encoding.data.config.filter) newConfig["filter"] = {};
            }  

            if(status.status == "patialOverlap" || status.status == "noOverlap" || allRequiredAreInSubspace && isRequired(enc)) {
              DOM.concept.classed("vzb-hidden", true);
              DOM.spaceNew.text("new space: not avaiable");

              const filtervl = _this._conceptsCompatibleWithMarkerSpace(nest, proposedSpace.space, allRequiredAreInSubspace && isRequired(enc));
              const concepts = [concept].concat(_this._convertConceptMapToArray(filtervl));
    
              const select = view.append("select")
                .attr("class", "vzb-spaceconfig-enc-concept-new")
                .attr("id", "vzb-spaceconfig-enc-space-select")
                .on("change", function(){
                  _this.goodToGo = true;
                  newConfig["concept"] = d3.select(this).property("value");
                  newConfig["space"] = null;
                  newConfig["filter"] = {};
                });
                
              select
                .selectAll("option")
                .data(concepts)
                .enter().append("option")
                .property("selected", option => option.concept.concept === concept.concept.concept)
                .property("disabled", option => option.concept.concept === concept.concept.concept)
                .attr("value", option => option.concept.concept)
                .text(option => option.concept.name);
    
            }  
          }

          view.classed("vzb-hidden", !status.actionReqired && !_this.showAllEncs && !(allRequiredAreInSubspace && isRequired(enc)));
        });
    }

    getSpaceCompatibilityStatus(encoding, space){
      const spaces = this.concepts.find(f => f.concept.concept == encoding.data.concept)?.spaces || [];

      if (!space) return {status: true, spaces: []};
      if (encoding.data.isConstant) return {status: "constant"};

      if (encoding.data.config.modelType == "entityPropertyDataConfig")
        return {status: "entityPropertyDataConfig", spaces: [space]};

      if (spacesAreEqual(encoding.data.space, space)) 
        return {status: "alreadyInSpace", spaces: [space]};

      if (getMatchingSpace(spaces, space)) 
        return {status: "matchingSpaceAvailable", spaces: [space]};

      const subspaces = getSubspaces(spaces, space);
      if (subspaces.length > 0) 
        return {status: "subspaceAvailable", spaces: subspaces};

      const superspaces = getSuperspaces(spaces, space);
      if (superspaces.length > 0) 
        return {status: "superspaceAvailable", spaces: superspaces};

      const partialOverlap = getPartiallyOverlappingSpaces(spaces, space);
      if (partialOverlap.length > 0) 
        return {status: "patialOverlap", actionReqired: true, spaces: []};
      if (partialOverlap.length == 0) 
        return {status: "noOverlap", actionReqired: true, spaces: []};

      return {status: false, spaces: []};
    }

    statusIcons(compatibility){
      return {
        true: "⚫",
        constant: "✳️",
        alreadyInSpace: "✅", //reset filter on enc
        entityPropertyDataConfig: "🏷", //reset filter on enc
        matchingSpaceAvailable: "⏩",
        subspaceAvailable: "🔽",
        superspaceAvailable: "🔼", //request connstants 
        patialOverlap: "🚧", //request another concept
        noOverlap: "🚧", //request another concept
        false: "❌"
      }[""+compatibility.status];
    }


    example() {
      const frameConcept = this.MDL.frame.data.concept;
      const spaceAvailability = removeDulicates(this._getMarkerSpaceAvailability().filter(f => f.space.includes(frameConcept)));
      const currentSpace = this.model.data.space;

      const examples = spaceAvailability.map(m => m.space).flat().filter(f => !currentSpace.includes(f));
      return examples[0] || "";
    }

    updateApplyCancelButtons(proposedSpace = this.proposedSpace){
      const hide = !proposedSpace || spacesAreEqual(proposedSpace.space, this.model.data.space);
      this.DOM.buttoncancel.classed("vzb-hidden", hide)
        .on("click", () => {this.cancelChanges();});
      this.DOM.buttonapply.classed("vzb-hidden", hide)
        .classed("vzb-disabled", !this.goodToGo)
        .on("click", () => {this.applyChanges(proposedSpace);});
    }
    cancelChanges(){
      this.parent.toggleFullscreenish();
      this.proposedSpace = null;
      this.showAllEncs = false;
    }

    applyChanges(proposedSpace){
      if (!proposedSpace) return;
      mobx.runInAction(()=>{
        this.model.config.data.space = proposedSpace.space;
        this.model.encoding["label"].data.config.source = proposedSpace.dsId;
        Object.keys(this.encNewConfig).forEach(enc => {
          const newConfig = this.encNewConfig[enc];

          if (newConfig.concept) {
            this.model.encoding[enc].config.data.concept = newConfig.concept;

            this.model.encoding[enc].config.scale.domain = null;
            this.model.encoding[enc].config.scale.type = null;
            this.model.encoding[enc].config.scale.zoomed = null;
            this.model.encoding[enc].config.scale.palette = {};
          }

          if (newConfig.space)
            this.model.encoding[enc].config.data.space = newConfig.space;
          else if (newConfig.hasOwnProperty("space"))
            delete this.model.encoding[enc].config.data.space;

          if (newConfig.filter)
            this.model.encoding[enc].config.data.filter = newConfig.filter;
          else if (newConfig.hasOwnProperty("filter"))
            delete this.model.encoding[enc].config.data.filter;
            
        });
      });
      this.parent.toggleFullscreenish();
      this.proposedSpace = null;
      this.showAllEncs = false;
    }  

    _getItemId(space) {
      return this.id + "--radioitem--" + space.space.toSorted().join("-");
    }
    _getText(space) {
      const dataSources = this._getAllDataSources();
      const ELLIPSIS = 10;

      return space.space
        .map(d => dataSources.find(ds => ds.getConcept(d)).getConcept(d)?.name || d)
        .map(m => m.length > ELLIPSIS ? m.substring(0, ELLIPSIS) + "…" : m)
        .join(", ");
    }

    _getAllDataSources(dsConfig = this.root.model.config.dataSources) {
      return Object.keys(dsConfig).map(dsName => this.services.Vizabi.Vizabi.stores.dataSources.get(dsName));
    }

    updateSearch(text = "") {
      let hiddenItems = 0;
      const items = this.DOM.list.selectAll(".vzb-item")
        .classed("vzb-hidden", d => {
          const hidden = spacesAreEqual(d.space, this.model.data.space) && !this.parent.isFullscreenish()
            || text && !this._getText(d).toString().toLowerCase().includes(text) && !d.space.includes(text);
          hiddenItems += +hidden;
          return hidden;
        });
      this.showHideHeader(items.size() - hiddenItems);
    }
  }

  const decorated$2 = mobx.decorate(SectionSlice, {
    "MDL": mobx.computed,
    "showAllEncs": mobx.observable,
    "proposedSpace": mobx.observable,
    "goodToGo": mobx.observable,
  });

  const KEY = Symbol.for("key");

  class _MarkerControls extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="markercontrols" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="markercontrols" data-click="dragDialog"></span>
        <div class="vzb-dialog-header">
          <span class="vzb-dialog-title"></span>

          <span class="vzb-dialog-content vzb-filter">
            <form novalidate>
              <input class="vzb-search" type="search" required/>
              <button class="vzb-cancel-button" type="reset"></button>
            </form>
          </span>

          <span class="vzb-info"></span>

        </div>

        <div class="vzb-dialog-content vzb-dialog-content-fixed vzb-dialog-scrollable">
          <div class="vzb-dialog-content vzb-dialog-scrollable vzb-dialog-panel vzb-dialog-panel-markercontrols vzb-active">
            <div class="vzb-section vzb-find"></div>
            <div class="vzb-section vzb-add"></div>
            <div class="vzb-section vzb-remove"></div>
            <div class="vzb-section vzb-switch"></div>
            <div class="vzb-section vzb-slice"></div>
          </div>
        </div>

        <div class="vzb-dialog-buttons">
          <div class="vzb-dialog-bubbleopacity vzb-dialog-control" data-panel="markercontrols"></div>
          <div class="vzb-dialog-button vzb-deselect" data-panel="markercontrols">
            <span data-localise="buttons/deselect"></span>
          </div>

          <div data-dialogtype="markercontrols" data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>  

        <div class="vzb-info-popup vzb-hidden"></div>

      </div>      
    `;

      config.subcomponents = [{
        type: SingleHandleSlider,
        placeholder: ".vzb-dialog-bubbleopacity",
        options: {
          value: "opacitySelectDim",
          submodel: "root.ui.chart"
        }
      },{
        type: decorated$6,
        placeholder: ".vzb-find"
      },{
        type: decorated$5,
        placeholder: ".vzb-add"
      },{
        type: decorated$4,
        placeholder: ".vzb-remove"
      }];
      
      if (!config.default_ui.disableSwitch)
        config.subcomponents.push({
          type: decorated$3,
          placeholder: ".vzb-switch"
        });
        
      if (!config.default_ui.disableSlice)
        config.subcomponents.push({
          type: decorated$2,
          placeholder: ".vzb-slice"
        });

      super(config);
    }

    setup(options) {
      super.setup(options);

      this.DOM.input_search = this.element.select(".vzb-search");
      this.DOM.deselect_all = this.element.select(".vzb-deselect");
      this.DOM.opacity_nonselected = this.element.select(".vzb-dialog-bubbleopacity");
      this.DOM.title = this.element.select(".vzb-dialog-title");
      this.DOM.info = this.element.select(".vzb-info");
      this.DOM.infoPopup = this.element.select(".vzb-info-popup");

      this.sections = this.children.filter(f => Object.getPrototypeOf(f.constructor).name === "MarkerControlsSection");
      this.sectionFind = this.children.find(f => f.constructor.name === "SectionFind");
      this.magicCommands = this.sections.map(section => section.magicCommand);
      this._getSearchTerm = () => {
        const text = this.DOM.input_search.node().value.trim().toLowerCase();
        const command = this.magicCommands.find(f => text === f || text.indexOf(f + " ") === 0) || false;
        const arg = command ? text.replace(command, "").trim() : text;
        return {command, arg};
      };
      this._clearSearch = () => {this.DOM.input_search.node().value = "";};


      this.DOM.input_search
        .on("keyup", event => {
          if (event.keyCode == 13) {
            this.concludeSearch();
            this._clearSearch();
          }
        })
        .on("input", () => {
          this.updateSearch();
        });

      //is this needed?
      d3.select(this.DOM.input_search.node().parentNode)
        .on("reset", () => {
          this._clearSearch();
          this.updateSearch();
        })
        .on("submit", event => {
          event.preventDefault();
          return false;
        });


      setIcon(this.DOM.info, ICON_QUESTION)
        .on("click", (event) => {
          this.toggleInfoPopup();
          event.stopPropagation();
        });

      this.DOM.infoPopup.on("click", () => {this.toggleInfoPopup(false);});

      this.DOM.dialog.on("click", () => {this.toggleInfoPopup(false);});
      
      this.DOM.deselect_all.on("click", () => this.MDL.selected.data.filter.clear());
    }

    draw() {
      super.draw();
      this.addReaction(this.showHideButtons);
      this.addReaction(this.updateSearch);
      this.addReaction(this.updateUIStrings);
    }
    
    updateUIStrings() {
      this.DOM.input_search.attr("placeholder", this.localise("placeholder/search") + "...");
      this.DOM.title.text(this.localise("marker-plural/" + this.model.id.replace("-splash", "")));
    }

    updateSearch({command, arg} = this._getSearchTerm()) {
      this.element.classed("vzb-clean-search", this.isCleanSearch()); 
      this.sections.forEach(section => {
        section.hide( command && section.magicCommand !== command 
          // when clean search, keep only find
          || !command && !arg && section.magicCommand !== "find" && section.magicCommand !== "add"
          //hide section "and" when "find" had many items
          || !command && !arg && section.magicCommand === "add" && this.sectionFind.getListItemCount() > 10
        );
        section.updateSearch(arg);
      });
    }

    toggleFullscreenish(section) {
      const isFS = this.isFullscreenish();
      this.element.classed("vzb-fullscreenish", !isFS);
      this._clearSearch();
      this.updateSearch({command: section?.magicCommand});
    }

    isFullscreenish(){
      return this.element.classed("vzb-fullscreenish");
    }

    concludeSearch({arg} = this._getSearchTerm()) {
      this.sections.forEach(section => section.concludeSearch(arg));
    }

    isCleanSearch({command, arg} = this._getSearchTerm()){
      return !command && !arg;
    }

    toggleInfoPopup(showhide = this.DOM.infoPopup.classed("vzb-hidden")){
      
      this.DOM.infoPopup.classed("vzb-hidden", !showhide);
      if (!showhide) return;

      const globalExample = this.findChild({type: "SectionFind"}).example().toLowerCase().substr(0,5);
      const sectionFindRemoveExample = this.findChild({type: "SectionFind"}).example().toLowerCase().substr(0,7) + "...";
      const sectionAddExample = this.findChild({type: "SectionAdd"}).example().toLowerCase().substr(0,7) + "...";
      const sectionSwitchExample = this.findChild({type: "SectionSwitch"})?.example?.().toLowerCase();
      const sectionSliceExample = this.findChild({type: "SectionSlice"})?.example?.().toLowerCase();
      const infoHints = [
        {text: "Examples and tips", instruction: true},
        {text: "Search in all commands like so:", instruction: true},
        {action: globalExample, ellipsis: "..."},
        {text: "or use a specific command:", instruction: true},
        {icon: "👀", action: "find", example: sectionFindRemoveExample},
        {icon: "➕", action: "add", example: sectionAddExample},
        {icon: "❌", action: "remove", example: sectionFindRemoveExample},
        {icon: "➡️", action: "switch", example: sectionSwitchExample},
        {icon: "🧩", action: "slice", example: sectionSliceExample},
      ].filter(v => !v.icon || v.example);
      
      

      this.DOM.infoPopup.selectAll("div")
        .data(infoHints, (d, i) => i).join("div")
        .attr("class", d => d.instruction ? "vzb-instruction" : "vzb-clickable")
        .html(d => `
        <span class="vzb-icon">${d.icon||""}</span> 
        <span class="vzb-action">${d.action || d.text ||""}</span>
        <span class = "vzb-ellipsis">${d.ellipsis || ""}</span> 
        <span class="vzb-example">${d.example || ""}</span>`
        )
        .on("click", (e, d) => {
          if(!d.action) return;
          this.DOM.input_search.node().value = d.action + (d.example ? " " : "");
          this.toggleInfoPopup();
          this.updateSearch();
          this.DOM.input_search.node().focus();
        });

    }


    showHideButtons() {
      const someSelected = this.MDL.selected.data.filter.any();
      this.DOM.deselect_all.classed("vzb-hidden", !someSelected);
      this.DOM.opacity_nonselected.classed("vzb-hidden", !someSelected);
      if (someSelected) {
        mobx.runInAction(() => {
          const opacityNonSelectedSlider = this.findChild({ type: "SingleHandleSlider" });
          opacityNonSelectedSlider._updateSize();
          opacityNonSelectedSlider._updateView();
        });
      }
    }

    _closeClick() {}

    _getCompoundLabelText(d) {
      const markerSpace = this.model.data.space;

      if (typeof d.label == "object") {
        return Object.entries(d.label)
          .filter(([k]) => k != this.MDL.frame.data.concept)
          //sort parts of the name along the marker space array, so we get geo, gender instead of gender, geo
          .sort(([a], [b]) => markerSpace.indexOf(a) - markerSpace.indexOf(b))
          //add keys where values are numbers, such as "age: 69"
          .map(([k, v]) => isNumber(v) ? k + ": " + v : v)
          .join(", ");
      }
      if (d.label != null) return "" + d.label;
      return d[KEY];
    }

    get markersData() {
      const data = new Map();
      const space = this.model.data.space.filter(f => f !== this.model.encoding.frame.data.concept);
      this.model.getTransformedDataMap("filterRequired").each(frame => frame.forEach((valuesObj, key) => {
        if (!data.has(key)) {
          const newItem = { 
            [KEY]: key,
            name: this._getCompoundLabelText(valuesObj),
            label: valuesObj.label || {}
          };
          space.forEach(dim => newItem[dim] = valuesObj[dim]);
          data.set(key, newItem);
        }
      }));
      return data;
    }

    get dimMarkersData() {
      const data = new Map();
      const space = this.ui.primaryDim 
        ? [this.ui.primaryDim] 
        : this.model.data.space.filter(f => f !== this.model.encoding.frame.data.concept);
      space.forEach(dim => {
        this.markersData.forEach(valuesObj => {
          const key = "" + valuesObj[dim];
          if (!data.has(key)) {
            data.set(key, {
              [KEY]: key,
              name: valuesObj.label[dim],
              [dim]: valuesObj[dim],
              prop: dim,
              dim
            });
          }
        });
      });
      return data;
    }
  }

  _MarkerControls.DEFAULT_UI = {
    "disableSwitch": false,
    "disableSlice": false
  };

  const MarkerControls = mobx.decorate(_MarkerControls, {
    "markersData": mobx.computed,
    "dimMarkersData": mobx.computed
  });


  decorated$b.add("markercontrols", MarkerControls);

  /*
   * More options dialog
   */

  class MoreOptions extends decorated$b {
    constructor(config) {
      const { moreoptions = [], popup = []} = config.parent.ui.dialogs;
      const templateArray  = [];
      const subcomponents = [{
        type: OptionsButtonList,
        placeholder: ".vzb-dialog-options-buttonlist",
      }];

      const dialogList = moreoptions === true ? popup : moreoptions;

      dialogList.forEach(dlg => {      
        subcomponents.push({
          type: decorated$b.get(dlg),
          placeholder: '.vzb-dialogs-dialog[data-dlg="' + dlg + '"]',
          model: config.model,
          name: dlg,
        });

        templateArray.push(
          `<div data-dlg="${dlg}" class="vzb-dialogs-dialog  vzb-moreoptions vzb-accordion-section"></div>`
        );
      });

      config.subcomponents = subcomponents;

      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="moreoptions" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="moreoptions" data-click="dragDialog"></span>

        <div class="vzb-dialog-title">
          <span></span>
        </div>

        <div class="vzb-dialog-content vzb-dialog-scrollable">
          <div class='vzb-dialog-options-buttonlist'>
          </div>
          <div class="vzb-accordion">
            ${templateArray.join("\n")}
          </div>
        </div>

        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span></span>
          </div>
        </div>

      </div>
    `;

      super(config);
    }

    setup(options) {
      super.setup(options);

      this.element.on("custom-dragend", () => {
        this._setMaxHeight();
      });

      const _this = this;
      this.DOM.accordion = this.DOM.content.select(".vzb-accordion");

      //accordion
      if (this.DOM.accordion) {
        const sections = this.DOM.accordion.selectAll(".vzb-accordion-section");
        sections.data(this.children.slice(1).map(c => ({ 
          name: c.name
        })));
        const titleEl = sections
          .select(".vzb-dialog-title>span:first-child");
        titleEl.on("click", (event, d) => {
          const sectionEl = _this.findChild({ name: d.name }).element;
          const activeEl = _this.DOM.accordion.select(".vzb-accordion-active");
          if (activeEl) {
            activeEl.classed("vzb-accordion-active", false);
          }
          if (sectionEl.node() !== activeEl.node()) {
            sectionEl.classed("vzb-accordion-active", true);
            _this.transitionEvents.forEach(event => {
              sectionEl.on(event, () => {
                _this.transitionEvents.forEach(event => {
                  sectionEl.on(event, null);
                });
                //_this.components[d.component].trigger("resize");
              });
            });
          }
        });
      }
    }

    draw() {
      super.draw();

      this.DOM.title.select("span").text(this.localise("buttons/more_options"));
      this.DOM.buttons.select("span").text(this.localise("buttons/ok"));

    }
  }

  decorated$b.add("moreoptions", MoreOptions);

  /*
   * Size dialog
   */

  class Opacity extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title"> 
          <span data-localise="buttons/opacity"></span>
        </div>
            
        <div class="vzb-dialog-content">
          <p class="vzb-dialog-sublabel">
            <span data-localise="buttons/opacityRegular"></span>
          </p>
          <div class="vzb-dialog-bubbleopacity-regular"></div>

          <p class="vzb-dialog-sublabel">
            <span data-localise="buttons/opacityNonselect"></span>
          </p>
          <div class="vzb-dialog-bubbleopacity-selectdim"></div>
          </div>
        </div>

      </div>
    `;

      config.subcomponents = [{
        type: SingleHandleSlider,
        placeholder: ".vzb-dialog-bubbleopacity-regular",
        options: {
          value: "opacityRegular",
          submodel: "root.ui.chart"
        }
      },{
        type: SingleHandleSlider,
        placeholder: ".vzb-dialog-bubbleopacity-selectdim",
        options: {
          value: "opacitySelectDim",
          submodel: "root.ui.chart"
        }
      }];

      super(config);
    }
  }

  decorated$b.add("opacity", Opacity);

  /*
   * Size dialog
   */

  class Presentation extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title"> 
          <span data-localise="dialogs/presentation"></span>
        </div>

        <div class="vzb-dialog-content">
          <div class="vzb-presentationmode-switch"></div>
          <div class="vzb-decorations-switch"></div>
          <div class="vzb-time-background-switch"></div>
          <div class="vzb-titles-switch"></div>
          <div class="vzb-time-trails-switch"></div>
          <div class="vzb-overhang-switch"></div>
          <div class="vzb-format-si-prefix-switch"></div>
        </div>

      </div>
    `;

      config.subcomponents = [{
        type: SimpleCheckbox,
        placeholder: ".vzb-presentationmode-switch",
        options: {
          checkbox: "projector",
          submodel: "services.layout"
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-decorations-switch",
        options: {
          checkbox: "enabled",
          prefix: "decorations",
          submodel: "root.ui.chart.decorations"
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-time-background-switch",
        options: {
          checkbox: "timeInBackground",
          submodel: "root.ui.chart"
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-titles-switch",
        options: {
          checkbox: "showTitles",
          submodel: "root.ui.chart"
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-time-trails-switch",
        options: {
          checkbox: "timeInTrails",
          submodel: "root.ui.chart"
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-overhang-switch",
        options: {
          checkbox: "overhang",
          submodel: "root.ui.chart"
        }
      }, {
        type: SimpleCheckbox,
        placeholder: ".vzb-format-si-prefix-switch",
        options: {
          checkbox: "shortNumberFormat",
          submodel: "root.services.locale"
        }
      }];

      super(config);
    }


  }

  decorated$b.add("presentation", Presentation);

  /*
   * Size dialog
   */

  class Size extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="size" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="size" data-click="dragDialog"></span>
        <div class="vzb-dialog-title"> 
          <span data-localise="buttons/size"></span>
          <div class="vzb-dialog-bubblesize"></div>
          <span class="vzb-saxis-selector"></span>
        </div>
        <div class="vzb-dialog-content">
          <span class="vzb-dialog-subtitle"></span>
        </div>
        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>
      </div>    
    `;

      config.subcomponents = [{
        type: IndicatorPicker,
        placeholder: ".vzb-saxis-selector",
        options: {
          submodel: "encoding",
          targetProp: "size",
          showHoverValues: true
        }
      },{
        type: BubbleSize,
        placeholder: ".vzb-dialog-bubblesize",
        options: {
          showArcs: true,
          submodelFunc: () => this.model.encoding.size.scale,
        }
      }];

      super(config);
    }

    draw() {
      super.draw();

      this.addReaction(this._updateSubtitle);
    }

    _updateSubtitle() {
      const conceptProps = this.model.encoding.size.data.conceptProps;
      const subtitle = getSubtitle(conceptProps?.name, conceptProps?.name_short);

      this.element.select(".vzb-dialog-subtitle").text(subtitle || "");
    }
  }

  decorated$b.add("size", Size);

  class Technical extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title"> 
          <span data-localise="dialogs/technical"></span>
        </div>

        <div class="vzb-dialog-content">
          <div class="vzb-advancedshowandselect-switch"></div>
          <div class="vzb-advancedmarkerspace-switch"></div>
          <div class="vzb-showdatasources-switch"></div>
        </div>

      </div>
    `;

      config.subcomponents = [{
      //   type: SimpleCheckbox,
      //   placeholder: ".vzb-advancedshowandselect-switch",
      //   options: {
      //     checkbox: "enableSelectShowSwitch",
      //     submodelFunc: () => this.root
      //       .findChild({name: "dialogs"})
      //       .findChild({name: "find"}).ui
      //   }
      // },{
      //   type: SimpleCheckbox,
      //   placeholder: ".vzb-advancedmarkerspace-switch",
      //   options: {
      //     checkbox: "enableMarkerSpaceOptions",
      //     submodelFunc: () => this.root
      //       .findChild({name: "dialogs"})
      //       .findChild({name: "find"}).ui
      //   }
      // },{
        type: SimpleCheckbox,
        placeholder: ".vzb-showdatasources-switch",
        options: {
          checkbox: "showDataSources",
          submodelFunc: () => this.root
            .findChild({name: "tree-menu"}).ui
        }
      }];

      super(config);
    }

  }

  decorated$b.add("technical", Technical);

  /*
   * Zoom dialog
   */

  class Zoom extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="label" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="label" data-click="dragDialog"></span>
        <div class="vzb-dialog-title"> 
          <span></span>
          <div class="vzb-dialog-zoom-buttonlist"></div>
        </div>
            
            
        <div class="vzb-dialog-content">
          <div class="vzb-panwitharrow-switch"></div>
          <div class="vzb-zoomonscrolling-switch"></div>
          <div class="vzb-adaptminmaxzoom-switch"></div>
        </div>
      
        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span><span/>
          </div>
        </div>
      
      </div>    
    `;

      config.subcomponents = [{
        type: ZoomButtonList,
        placeholder: ".vzb-dialog-zoom-buttonlist"
      },{
        type: SimpleCheckbox,
        placeholder: ".vzb-panwitharrow-switch",
        options: {
          checkbox: "panWithArrow",
          submodel: "root.ui.chart"
        }
      },{
        type: SimpleCheckbox,
        placeholder: ".vzb-zoomonscrolling-switch",
        options: {
          checkbox: "zoomOnScrolling",
          submodel: "root.ui.chart"
        }
      },{
        type: SimpleCheckbox,
        placeholder: ".vzb-adaptminmaxzoom-switch",
        options: {
          checkbox: "adaptMinMaxZoom",
          submodel: "root.ui.chart"
        }
      }];

      super(config);
    }

    draw() {
      super.draw();

      this.DOM.title.select("span").text(this.localise("buttons/zoom"));
      this.DOM.buttons.select("span").text(this.localise("buttons/ok"));
    }
  }

  decorated$b.add("zoom", Zoom);

  /*
   * Timedisplay dialog
   */
  class TimeDisplay extends decorated$b {
    constructor(config) {
      config.template = `
      <div class="vzb-dialog-modal">
        <div class="vzb-dialog-title"></div>
        <div class="vzb-dialog-content vzb-dialog-content-fixed"></div>
        <div class="vzb-dialog-buttons"></div>
      </div>`;
    
      config.subcomponents = [{
        type: decorated$d,
        placeholder: ".vzb-dialog-content"
      }];
      
      super(config);
    }
  }

  decorated$b.add("timedisplay", TimeDisplay);

  /*
   * Repeat dialog
   */


  class Repeat extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="colors" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="colors" data-click="dragDialog"></span>

        <div class="vzb-dialog-title"> 
          <span data-localise="buttons/repeat"></span>
        </div>

        <div class="vzb-dialog-content">
          <div class="vzb-repeat-header">
            <div class="vzb-useConnectedRowsAndColumns-switch"></div>
          </div>
          <div class="vzb-repeat-body">
            <div class="vzb-repeat-grid"></div>
          </div>
        </div>
    
        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>
      </div>
    `;

      config.subcomponents = [{
        type: SimpleCheckbox,
        placeholder: ".vzb-useConnectedRowsAndColumns-switch",
        options: {
          checkbox: "useConnectedRowsAndColumns",
          submodelFunc: () => this.MDL.repeat,
          setCheckboxFunc: (value) => this.MDL.repeat.config.useConnectedRowsAndColumns = value
        }
      }];

      super(config);
    }

    setup(options) {
      super.setup(options);

      this.DOM.header = this.element.select(".vzb-repeat-header");
      this.DOM.body = this.element.select(".vzb-repeat-body");
      this.DOM.grid = this.element.select(".vzb-repeat-grid");
    }

    get MDL(){
      return {
        repeat: this.model.encoding.repeat
      };
    }

    draw(){
      super.draw();

      this.addReaction(this.drawHeader);
      this.addReaction(this.drawBody);
    }


    drawHeader(){
      const header = this.DOM.header;
      const localise = this.services.locale.auto();
      const {allowEnc, row, column, useConnectedRowsAndColumns} = this.MDL.repeat;

      header.selectAll("p").remove();

      header.insert("p", "div")
        .attr("class", "vzb-dialog-sublabel")
        .html(localise("hint/repeat/addremovecharts"));

      header.select(".vzb-useConnectedRowsAndColumns-switch")
        .classed("vzb-hidden", !(row && row.length && column && column.length && allowEnc.length === 2));

      if (useConnectedRowsAndColumns) {
        header.append("p")
          .html(allowEnc[0] + " " + localise("hint/repeat/issharedacrossrows"));
        header.append("p")
          .html(allowEnc[1] + " " + localise("hint/repeat/issharedacroscolumns"));
      }
    }

    drawBody(){
      const {rowcolumn, ncolumns, nrows} = this.MDL.repeat;
      const repeat = this.MDL.repeat;
      const localise = this.services.locale.auto();

      this.DOM.grid
        .style("grid-template-rows", "1fr ".repeat(nrows) + "30px")
        .style("grid-template-columns", "1fr ".repeat(ncolumns) + "30px");

      this.DOM.grid.selectAll("div").remove();

      this.DOM.grid.selectAll("div")
        .data(rowcolumn, d => repeat.getName(d))
        .enter().append("div")
        .attr("class", "vzb-repeat-segment")
        .attr("title", d => JSON.stringify(d, null, 1))
        .style("grid-row-start", (_, i) => repeat.getRowIndex(i) + 1)
        .style("grid-column-start", (_, i) => repeat.getColumnIndex(i) + 1)
        .html(() => ncolumns == 1 && nrows == 1 ? localise("hint/repeat/pressplus") : "")
        .on("mouseover", (event, d) => {
          this.root.element.select(".vzb-" + repeat.getName(d))
            .classed("vzb-chart-highlight", true);
        })
        .on("mouseout", (event, d) => {
          this.root.element.select(".vzb-" + repeat.getName(d))
            .classed("vzb-chart-highlight", false);
        });

      if (ncolumns > 1) {
        this.DOM.grid.selectAll("div.vzb-repeat-removecolumn")
          .data(d3.range(ncolumns))
          .enter().append("div")
          .attr("class", "vzb-repeat-removecolumn")
          .html("✖︎")
          .style("grid-column-start", (_, i) => i + 1)
          .on("click", (_, i) => {
            this._remove("column", i);
            this._clearHoverClasses(rowcolumn);
          })
          .on("mouseover", (_, i) => {
            rowcolumn.forEach((d, index) => {
              if (index % ncolumns == i)
                this.root.element.select(".vzb-" + repeat.getName(d))
                  .classed("vzb-chart-removepreview", true);
            });
          })
          .on("mouseout", () => {
            this._clearHoverClasses(rowcolumn, "vzb-chart-removepreview");
          });
      }

      if (nrows > 1) {
        this.DOM.grid.selectAll("div.vzb-repeat-removerow")
          .data(d3.range(nrows))
          .enter().append("div")
          .attr("class", "vzb-repeat-removerow")
          .html("✖︎")
          .style("grid-row-start", (_, i) => i + 1)
          .on("click", (_, i) => {
            this._remove("row", i);
            this._clearHoverClasses(rowcolumn);
          })
          .on("mouseover", (_, i) => {
            rowcolumn.forEach((d, index) => {
              if (Math.floor(index / ncolumns) == i)
                this.root.element.select(".vzb-" + repeat.getName(d))
                  .classed("vzb-chart-removepreview", true);
            });
          })
          .on("mouseout", () => {
            this._clearHoverClasses(rowcolumn, "vzb-chart-removepreview");
          });
      }

      this.DOM.grid.append("div")
        .attr("class", "vzb-repeat-addcolumn")
        .html("✚")
        .style("grid-row-start", 1)
        .style("grid-row-end", nrows + 1)
        .style("grid-column-start", ncolumns + 1)
        .on("click", () => {
          this._createNew("column");
          this._clearHoverClasses(rowcolumn);
        })
        .on("mouseover", () => {
          rowcolumn.forEach((d, i) => {
            if ((i + 1) % ncolumns == 0)
              this.root.element.select(".vzb-" + repeat.getName(d))
                .classed("vzb-chart-addrightpreview", true);
          });
        })
        .on("mouseout", () => {
          this._clearHoverClasses(rowcolumn, "vzb-chart-addrightpreview");
        });

      this.DOM.grid.append("div")
        .attr("class", "vzb-repeat-addrow")
        .html("✚")
        .style("grid-row-start", nrows + 1)
        .style("grid-column-start", 1)
        .style("grid-column-end", ncolumns + 1)
        .on("click", () => {
          this._createNew("row");
          this._clearHoverClasses(rowcolumn);
        })
        .on("mouseover", () => {
          rowcolumn.forEach((d, i) => {
            if (Math.floor(i / ncolumns) + 1 == nrows)
              this.root.element.select(".vzb-" + repeat.getName(d))
                .classed("vzb-chart-addbelowpreview", true);
          });
        })
        .on("mouseout", () => {
          this._clearHoverClasses(rowcolumn, "vzb-chart-addbelowpreview");
        });
    }

    _clearHoverClasses(array, cssclass){
      array.forEach(d => {
        const selection = this.root.element.select(".vzb-" + this.MDL.repeat.getName(d));

        if(!cssclass || cssclass == "vzb-chart-highlight")
          selection.classed("vzb-chart-highlight", false);

        if(!cssclass || cssclass == "vzb-chart-removepreview")
          selection.classed("vzb-chart-removepreview", false);

        if(!cssclass || cssclass == "vzb-chart-addbelowpreview")
          selection.classed("vzb-chart-addbelowpreview", false);

        if(!cssclass || cssclass == "vzb-chart-addrightpreview")
          selection.classed("vzb-chart-addrightpreview", false);
      });
    }

    _remove(direction, index){
      if(direction !== "row" && direction !== "column") return console.error("incorrect use of function _remove in repeat dialog");
      const {ncolumns, nrows, useConnectedRowsAndColumns} = this.MDL.repeat;
      mobx.runInAction(() => {
        if(useConnectedRowsAndColumns) {
          this.MDL.repeat.config[direction].splice(index, 1);
        } else {
          if(direction == "column"){
            for (let i = 1; i <= nrows; i++) {
              this.MDL.repeat.config.rowcolumn.splice(i * index, 1);
            }
            this.MDL.repeat.config.ncolumns = ncolumns - 1;
          }
          if (direction == "row") {
            this.MDL.repeat.config.rowcolumn.splice(ncolumns * index, ncolumns);
          }   
        }
      });
    }

    _createNew(direction){
      if(direction !== "row" && direction !== "column") return console.error("incorrect use of function _createNew in repeat dialog");
      const {ncolumns, nrows, allowEnc, useConnectedRowsAndColumns} = this.MDL.repeat;
      mobx.runInAction(() => {
        if(useConnectedRowsAndColumns) {
          const newEncName = this._generateEncodingNames(direction);
          this.model.config.encoding[newEncName] = {data: this._getConceptAndSourceAndSpaceOfLast(direction)};
          this.MDL.repeat.config[direction].push(newEncName);
        } else {
          this.MDL.repeat.config.rowcolumn = this.MDL.repeat.rowcolumn;
          if(direction == "column"){
            for (let i = 1; i <= nrows; i++) {
              const newEncNames = this._generateEncodingNames();
              allowEnc.forEach(e => {
                this.model.config.encoding[newEncNames[e]] = {data: this._getConceptAndSourceAndSpaceOfLast(e)};
              });
              this.MDL.repeat.config.rowcolumn.splice(i * ncolumns, 0, newEncNames);
            }
            this.MDL.repeat.config.ncolumns = ncolumns + 1;
          }
          if (direction == "row") {
            for (let i = 1; i <= ncolumns; i++) {
              const newEncNames = this._generateEncodingNames();
              allowEnc.forEach(e => {
                this.model.config.encoding[newEncNames[e]] = {data: this._getConceptAndSourceAndSpaceOfLast(e)};
              });
              this.MDL.repeat.config.rowcolumn.push(newEncNames);
            }
          }   
        }
      });
    }

    _getConceptAndSourceAndSpaceOfLast(arg){
      const {rowcolumn, allowEnc} = this.MDL.repeat;

      let alias = arg;

      if(arg == "row") 
        alias = allowEnc[0];
        
      if(arg == "column") 
        alias = allowEnc[1];

      return rowcolumn
        .map(d => this.model.encoding[d[alias]]?.data)
        .filter(f => f?.concept)
        .map(d => Object.assign({ concept: d.concept }, d.config.source ? { source: d.config.source } : {}, d.config.space ? { space: d.config.space.slice(0) } : {}))
        .at(-1) || { concept: "population_total" };
    }

    _generateEncodingNames(direction){
      const {allowEnc} = this.MDL.repeat;

      if(direction == "row") 
        return this._generateEncodingName(allowEnc[0]);

      if(direction == "column") 
        return this._generateEncodingName(allowEnc[1]);
      
      return allowEnc.reduce((obj, alias) => {
        obj[alias] = this._generateEncodingName(alias);
        return obj;
      }, {});
    }
    _generateEncodingName(alias){
      const {rowcolumn} = this.MDL.repeat;
      const prefix = alias; //can be "repeat_"+alias or something
      return prefix + (d3.max(rowcolumn.map(d => +d[alias].replace(prefix,"") || 0)) + 1);
    }



  }


  const decorated$1 = mobx.decorate(Repeat, {
    "MDL": mobx.computed
  });
    
  decorated$b.add("repeat", decorated$1);

  class Speed extends decorated$b {
    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title"> 
            <span data-localise="buttons/time"></span>
        </div>
            
        <div class="vzb-dialog-content">
          <p class="vzb-dialog-sublabel">
            <span data-localise="hints/speed"></span>
          </p>
            
          <form class="vzb-dialog-paragraph">
            <div class="vzb-speed-slider"></div>
          </form>
          
          <p class="vzb-dialog-sublabel">
            <span data-localise="hints/forecastoptions"></span>
          </p>

          <form class="vzb-dialog-paragraph">
            <div class="vzb-showforecast-switch"></div>
            <div class="vzb-pausebeforeforecast-switch"></div>
            <div class="vzb-showstripedpatternwhenforecast-switch"></div>
            <div>
              <span data-localise="hints/endbeforeforecast"></span>
              <input type="text" class="vzb-endbeforeforecast-field" name="endbeforeforecast"/>
            </div>
            <div>
              <span class="vzb-timeformatexample-hint" data-localise="hints/timeformatexample"></span>
              <span class="vzb-timeformatexample-label"></span>
            </div>
          </form>

          <p class="vzb-dialog-sublabel">
          <span data-localise="hints/sparsedata"></span>
          </p>

          <form class="vzb-dialog-paragraph">
            <span class="vzb-extrapolate-hint"></span>
            <div class="vzb-extrapolate-slider"></div>
          </form>
        </div>
      </div>  
    `;

      config.subcomponents = [{
        type: SingleHandleSlider,
        placeholder: ".vzb-speed-slider",
        //model: ["state.time", "locale"],
        options: {
          value: "speed",
          setValueFunc: "setSpeed",
          domain: [1200, 900, 450, 200, 150, 100],
          ROUND_DIGITS: 0,
          submodel: "model.encoding.frame"
        }
      },{
        type: SimpleCheckbox,
        placeholder: ".vzb-showforecast-switch",
        //model: ["state.time", "locale"],
        options: {
          checkbox: "showForecast",
          submodel: "root.ui.chart"
        }
      },{
        type: SimpleCheckbox,
        placeholder: ".vzb-pausebeforeforecast-switch",
        //model: ["state.time", "locale"],
        options: {
          checkbox: "pauseBeforeForecast",
          submodel: "root.ui.chart",
        }
      },{
        type: SimpleCheckbox,
        placeholder: ".vzb-showstripedpatternwhenforecast-switch",
        //model: ["ui.chart", "locale"],
        options: {
          checkbox: "showForecastOverlay",
          submodel: "root.ui.chart"
        }
      },{
        type: SingleHandleSlider,
        placeholder: ".vzb-extrapolate-slider",
        name: "extrapolate-slider",
        options: {
          value: "extrapolate",
          setValueFunc: "setExtrapolate",
          domain: d3.range(100),
          ROUND_DIGITS: 0,
          submodel: "model.encoding.frame"
        }
      }];

      super(config);
    }

    setup() {
      this.DOM = {
        timeFormatExample: this.element.select(".vzb-timeformatexample-label"),
        forecastField: this.element.select(".vzb-endbeforeforecast-field"),
        extrapolateHint: this.element.select(".vzb-extrapolate-hint")
      };

      const _this = this;
      this.DOM.forecastField
        .on("keypress", function(event) {
          if (event.charCode == 13 || event.keyCode == 13) {
            //this prevents form submission action with subsequent page reload
            event.preventDefault();
            this.blur();
          }
        })
        .on("change", function() {
          //TODO: where is time parser nowdays
          const frame = _this.MDL.frame;
          const parsed = frame.parseValue(this.value);
          if (isDate(parsed)) {
            _this.root.ui.chart.endBeforeForecast = this.value;
          }
        });

    }


    get MDL() {
      return {
        frame: this.model.encoding.frame
      };
    }

    draw() {
      this.localise = this.services.locale.auto();

      this.addReaction(this.updateForecastField);
      this.addReaction(this.updateExtrapolateSlider);
    }

    updateForecastField() {
      this.DOM.forecastField.property("value",
        this.localise(this.root.ui.chart.endBeforeForecast)
      );
      this.DOM.timeFormatExample.text(this.localise(new Date()));
    }

    updateExtrapolateSlider(){
      const sliderSize = this.MDL.frame.stepCount <= 2 ? 2 : this.MDL.frame.stepCount;
      this.findChild({name: "extrapolate-slider"})
        ._setDomain(d3.range(sliderSize));

      const hintText = this.MDL.frame.extrapolate ? 
        this.localise("hints/extendDataNSteps").replace("{n}", this.MDL.frame.extrapolate)
        : this.localise("hints/dontExtendData");

      this.DOM.extrapolateHint
        .text(hintText)
        .attr("title", this.localise("hints/extrapolation"));
    }

  }

  const decorated = mobx.decorate(Speed, {
    "MDL": mobx.computed
  });

  decorated$b.add("speed", decorated);

  exports.About = About;
  exports.AddGeo = AddGeo;
  exports.Axes = Axes;
  exports.BaseComponent = BaseComponent;
  exports.BaseService = BaseService;
  exports.BrushSlider = decorated$f;
  exports.BubbleSize = BubbleSize;
  exports.Button = Button;
  exports.ButtonList = ButtonList;
  exports.CapitalVizabiService = CapitalVizabiService;
  exports.Chart = Chart;
  exports.ColorLegend = decorated$e;
  exports.Colors = Colors;
  exports.DataNotes = DataNotes;
  exports.DataWarning = DataWarning;
  exports.DateTimeBackground = decorated$d;
  exports.DeepLeaf = DeepLeaf;
  exports.Dialog = decorated$b;
  exports.Dialogs = Dialogs;
  exports.ErrorMessage = ErrorMessage;
  exports.Facet = Facet;
  exports.Find = decorated$7;
  exports.Icons = Icons;
  exports.IndicatorPicker = IndicatorPicker;
  exports.Label = Label;
  exports.Labels = decorated$c;
  exports.LayoutService = LayoutService;
  exports.LegacyUtils = LegacyUtils;
  exports.LocaleService = LocaleService;
  exports.MarkerControls = MarkerControls;
  exports.MarkerControlsSection = MarkerControlsSection;
  exports.Menu = Menu;
  exports.MinMaxInputs = decorated$a;
  exports.MoreOptions = MoreOptions;
  exports.Opacity = Opacity;
  exports.OptionsButtonList = OptionsButtonList;
  exports.PlayButton = PlayButton;
  exports.Presentation = Presentation;
  exports.Repeat = decorated$1;
  exports.Repeater = Repeater;
  exports.SectionAdd = decorated$5;
  exports.SectionFind = decorated$6;
  exports.SectionRemove = decorated$4;
  exports.SectionSlice = decorated$2;
  exports.SectionSwitch = decorated$3;
  exports.Show = Show;
  exports.SimpleCheckbox = SimpleCheckbox;
  exports.SingleHandleSlider = SingleHandleSlider;
  exports.Size = Size;
  exports.SizeSlider = SizeSlider;
  exports.SpaceConfig = SpaceConfig;
  exports.Speed = decorated;
  exports.SteppedSlider = decorated$9;
  exports.Technical = Technical;
  exports.TextEllipsis = TextEllipsis;
  exports.TimeDisplay = TimeDisplay;
  exports.TimeSlider = decorated$8;
  exports.TreeMenu = TreeMenu;
  exports.Utils = Utils;
  exports.Zoom = Zoom;
  exports.ZoomButtonList = ZoomButtonList;
  exports._AddGeo = _AddGeo;
  exports.axisSmart = axisSmart;
  exports.collisionResolver = collisionResolver;
  exports.updateRainbowLegend = updateRainbowLegend;
  exports.versionInfo = versionInfo;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/linechart#readme v4.0.0 build 1687772739474 Copyright 2023 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('d3'), require('mobx')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'd3', 'mobx'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.LineChart = {}, global.VizabiSharedComponents, global.d3, global.mobx));
})(window, (function (exports, sharedComponents, d3, mobx) {
  const COLOR_BLACKISH = "#333";
  const COLOR_GREYISH = "#888";

  const {ICON_QUESTION} = sharedComponents.Icons;
  const PROFILE_CONSTANTS = {
    SMALL: {
      margin: {
        top: 30,
        right: 100,
        left: 40,
        bottom: 20
      },
      infoElHeight: 16,
      yAxisTitleBottomMargin: 6,
      tick_spacing: 60,
      text_padding: 12,
      lollipopRadius: 6,
      limitMaxTickNumberX: 5
    },
    MEDIUM: {
      margin: {
        top: 40,
        right: 125,
        left: 60,
        bottom: 25
      },
      infoElHeight: 20,
      yAxisTitleBottomMargin: 6,
      tick_spacing: 80,
      text_padding: 15,
      lollipopRadius: 7,
      limitMaxTickNumberX: 10
    },
    LARGE: {
      margin: {
        top: 50,
        right: 150,
        left: 75,
        bottom: 30
      },
      infoElHeight: 22,
      yAxisTitleBottomMargin: 6,
      tick_spacing: 100,
      text_padding: 20,
      lollipopRadius: 9,
      limitMaxTickNumberX: 0 // unlimited
    }
  };

  const PROFILE_CONSTANTS_FOR_PROJECTOR = {
    MEDIUM: {
      margin: {
        top: 70,
        bottom: 40,
        left: 70,
        right: 180
      },
      yAxisTitleBottomMargin: 20,
      xAxisTitleBottomMargin: 20,
      infoElHeight: 26,
      text_padding: 30
    },
    LARGE: {
      margin: {
        top: 70,
        bottom: 50,
        left: 70,
        right: 220
      },
      yAxisTitleBottomMargin: 20,
      xAxisTitleBottomMargin: 20,
      infoElHeight: 32,
      text_padding: 36,
      hideSTitle: true
    }
  };

  //
  // LINE CHART COMPONENT
  class _VizabiLineChart extends sharedComponents.BaseComponent {

    constructor(config) {
      config.template = `
      <svg class="vzb-linechart-svg vzb-export">
          <g class="vzb-lc-graph">

              <svg class="vzb-lc-axis-x"><g></g></svg>
              <svg class="vzb-lc-axis-y"><g></g></svg>
              <text class="vzb-lc-axis-x-value"></text>
              <text class="vzb-lc-axis-y-value"></text>
              <svg class="vzb-lc-lines-crop">
                  <svg class="vzb-lc-lines"></svg>
                  <line class="vzb-lc-projection-x"></line>
                  <line class="vzb-lc-projection-y"></line>
              </svg>
              <svg class="vzb-lc-labels-crop">
                  <g class="vzb-lc-labels">
                      <line class="vzb-lc-vertical-now"></line>
                  </g>
              </svg>

              <g class="vzb-lc-axis-y-title">
                <text></text>
              </g>
              <g class="vzb-lc-axis-x-title">
                <text></text>
              </g>
              <g class="vzb-lc-axis-y-info vzb-noexport"></g>

              <g class="no-data-message vzb-hidden">                  
                  <text></text>
              </g>

              <!--filter id="vzb-lc-filter-dropshadow"> 
                <feOffset result="offOut" in="SourceGraphic" dx="0" dy="2" />
                <feColorMatrix result = "matrixOut" in = "offOut" type = "matrix"
                              values = "0.3 .0 .0 .0 .0
                                        .0 .3 .0 .0 .0
                                        .0 .0 .3 .0 .0
                                        1.0 1.0 1.0 1.0 .0"/>
                <feGaussianBlur result="blurOut" in="matrixOut" stdDeviation="0.8" />
                <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />
              </filter-->

              <rect class="vzb-lc-forecastoverlay vzb-hidden" fill="url(#vzb-lc-pattern-lines-${config.id})" pointer-events='none'></rect>
          </g>
          <g class="vzb-datawarning-button vzb-noexport"></g>
      </svg>
      <div class="vzb-tooltip vzb-hidden"></div>
      <svg>
        <defs>
            <pattern class="vzb-noexport" id="vzb-lc-pattern-lines-${config.id}" x="0" y="0" patternUnits="userSpaceOnUse" width="50" height="50" viewBox="0 0 10 10"> 
                <path d='M-1,1 l2,-2M0,10 l10,-10M9,11 l2,-2' stroke='red' stroke-width='3' opacity='0.08'/>
            </pattern> 
        </defs>
      </svg>
    `;
      super(config);
    }

    setup() {
      this.DOM = {
        element: this.element,
        graph: this.element.select(".vzb-lc-graph"),

        xAxisElContainer: this.element.select(".vzb-lc-axis-x"),
        yAxisElContainer: this.element.select(".vzb-lc-axis-y"),
    
        xTitle: this.element.select(".vzb-lc-axis-x-title"),
        yTitle: this.element.select(".vzb-lc-axis-y-title"),
        yInfo: this.element.select(".vzb-lc-axis-y-info"),
        linesContainerCrop: this.element.select(".vzb-lc-lines-crop"),
        linesContainer: this.element.select(".vzb-lc-lines"),
        labelsContainerCrop: this.element.select(".vzb-lc-labels-crop"),
        labelsContainer: this.element.select(".vzb-lc-labels"),
        noDataMessage: this.element.select(".no-data-message"),

        tooltip: this.element.select(".vzb-tooltip"),
        //filterDropshadowEl: this.element.select('#vzb-lc-filter-dropshadow'),
        projectionX: this.element.select(".vzb-lc-projection-x"),
        projectionY: this.element.select(".vzb-lc-projection-y"),
        forecastOverlay: this.element.select(".vzb-lc-forecastoverlay")
      };
      this.DOM.xAxisEl = this.DOM.xAxisElContainer.select("g");
      this.DOM.yAxisEl = this.DOM.yAxisElContainer.select("g");
      this.DOM.verticalNow = this.DOM.labelsContainer.select(".vzb-lc-vertical-now");
    
      this.totalLength_1 = {};

      this.KEY = Symbol.for("key");

      this.collisionResolver = sharedComponents.collisionResolver()
        .selector(".vzb-lc-label")
        .value("valueY")
        .filter(function(d, time){
          return (d.valueX - time === 0 && !d.hidden);
        })
        .KEY(this.KEY);

      this._initInfoElements();

      //line path generator
      this.line = d3.line()
        //see https://bl.ocks.org/mbostock/4342190
        //"monotone" can also work. "basis" would skip the points on the sharp turns. "linear" is ugly
        .curve(d3[(this.isFrameOnXaxis && this.ui.curve) ? this.ui.curve : "curveLinear"])
        .x(d => this.xScale(d[0]))
        .y(d => this.yScale(d[1]));

      this.lineWidthScale = d3.scaleLinear().domain([0, 20]).range([7, 1]).clamp(true);
      this.xAxis = sharedComponents.axisSmart("bottom");
      this.yAxis = sharedComponents.axisSmart("left");

      this.DOM.graph.on("click", () => {
        const {
          selected: { data: { filter: selectedFilter } },
          highlighted: { data: { filter: highlightedFilter} }
        } = this.MDL;
        if (highlightedFilter.any()) {
          selectedFilter.toggle(
            highlightedFilter.markers.keys().next().value
          );
        }
      });
      this.DOM.linesContainerCrop
        .on("mousemove", this._entityMousemove.bind(this))
        .on("mouseleave", this._entityMouseout.bind(this));

    }

    get MDL() {
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted,
        x: this.model.encoding[this.state.alias.x || "x"],
        y: this.model.encoding[this.state.alias.y || "y"],
        color: this.model.encoding.color,
        label: this.model.encoding.label,
        repeat: this.model.encoding.repeat
      };
    }


    get profileConstants() {
      this.services.layout.size;

      return this.services.layout.getProfileConstants(PROFILE_CONSTANTS, PROFILE_CONSTANTS_FOR_PROJECTOR);
    }

    get height(){
      this.services.layout.size;

      return this.element.node().clientHeight || 0;
    }

    get width(){
      this.services.layout.size;

      return this.element.node().clientWidth || 0;
    }

    checkLayout() {
      if (!this.height || !this.width) return sharedComponents.LegacyUtils.warn("Chart _updateProfile() abort: container is too little or has display:none");
    }

    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);
      
      this.TIMEDIM = this.MDL.frame.data.concept;
          
      if (this.checkLayout()) return; //return if exists with error
      
      this.addReaction(this.updateTime);
      this.addReaction(this.updateUIStrings);
      this.addReaction(this.addOrRemoveLinesAndLabels);
      this.addReaction(this.updateColors);
      this.addReaction(this.updateSize);
      this.addReaction(this.drawForecastOverlay);
      
      this.addReaction(this.redrawDataPoints);
      this.addReaction(this.highlightLines);
      this.addReaction(this.updateNoDataMessage);
    
    }

    drawForecastOverlay() {
      this.services.layout.size;
      this.MDL.x.scale.zoomed;
      this.MDL.y.scale.zoomed;
      if (this.checkLayout()) return; //return if exists with error

      this.DOM.forecastOverlay.classed("vzb-hidden", 
        !this.ui.showForecast || 
        !this.ui.showForecastOverlay || 
        !this.ui.endBeforeForecast || 
          (this.MDL.frame.value <= this.MDL.frame.parseValue(this.ui.endBeforeForecast))
      );

      const x = this.isFrameOnXaxis
        ? Math.min(this.xScale.range()[1], this.xScale(this.MDL.frame.parseValue(this.ui.endBeforeForecast)))
        : this.xScale.range()[0];
      const w = this.xScale.range()[1] - x;
      
      this.DOM.forecastOverlay
        .attr("x",  x) 
        .attr("width", w)
        .attr("y", this.yScale.range()[1])
        .attr("height", this.yScale.range()[0]);
    }

    _initInfoElements() {
      const _this = this;
      const dataNotesDialog = () => this.root.findChild({type: "DataNotes"});
      const timeSlider = () => this.root.findChild({type: "TimeSlider"});

      sharedComponents.LegacyUtils.setIcon(this.DOM.yInfo, ICON_QUESTION)
        .on("click", () => {
          dataNotesDialog().pin();
        })
        .on("mouseover", function() {
          if (timeSlider().ui.dragging) return;
          const rect = this.getBBox();
          const coord = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
          const toolRect = _this.root.element.node().getBoundingClientRect();
          const chartRect = _this.element.node().getBoundingClientRect();
          dataNotesDialog()
            .setEncoding(_this.MDL.y)
            .show()
            .setPos(coord.x + chartRect.left - toolRect.left, coord.y);
        })
        .on("mouseout", () => {
          if (timeSlider().ui.dragging) return;
          dataNotesDialog().hide();
        });
    }

    _getLabelText(d) {
      if(d.values) d = d.values[0];

      if (typeof d.label == "object") 
        return Object.entries(d.label)
          .filter(entry => entry[0] != this.MDL.frame.data.concept)
          .map(entry => sharedComponents.LegacyUtils.isNumber(entry[1]) ? (entry[0] + ": " + entry[1]) : entry[1])
          .join(", ");
      if (d.label != null) return "" + d.label;
      return d[Symbol.for("key")];
    }

    updateUIStrings() {

      const strings = {
        title: {
          Y: sharedComponents.Utils.getConceptName(this.MDL.y, this.localise),
          X: sharedComponents.Utils.getConceptName(this.MDL.x, this.localise)
        }
      };

      const treemenu = this.root.findChild({type: "TreeMenu"});

      this.DOM.yTitle
        .classed("vzb-disabled", treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .on("click", () => {
          treemenu
            .encoding(this._alias("y"))
            .alignX("left")
            .alignY("top")
            .updateView()
            .toggle();
        })
        .select("text").text(strings.title.Y);

      this.DOM.xTitle
        .classed("vzb-disabled", treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .on("click", () => {
          treemenu
            .encoding(this._alias("x"))
            .alignX("right")
            .alignY("bottom")
            .updateView()
            .toggle();
        })
        .select("text").text(strings.title.X);

      const conceptPropsY = this.MDL.y.data.conceptProps;
      this.DOM.yInfo.classed("vzb-hidden", !conceptPropsY.description && !conceptPropsY.sourceLink);
    }

    updateTime() {
      const { frame } = this.MDL;
      const time_1 = (this.time === null) ? frame.value : this.time;
      this.time = frame.value;
      this.duration = frame.playing && (this.time - time_1 > 0) ? frame.speed || 0 : 0;

      this.stepIndex = frame.stepScale(this.time);
    }

    updateColors() {
      const _this = this;
      const { color } = this.MDL;     
      color.scale.d3Scale;

      this.labels.each(function(d) {
        const {color, colorShadow} = _this._getColorsByValue(d.values[0].color);

        this.circle.style("fill", color);
        this.labelGroup.style("fill", colorShadow);
      });

      this.lines.each(function(d) {
        const {color, colorShadow} = _this._getColorsByValue(d.values[0].color);
        
        if (this.path1) this.path1.style("stroke", colorShadow);
        this.path2.style("stroke", _this.shadowWidth ? color : colorShadow);
      });
    }

    _getColorsByValue(colorValue) {
      const cScale = this.MDL.color.scale.d3Scale;
      return {
        color: colorValue != null && !sharedComponents.LegacyUtils.isNaN(colorValue) ? cScale(colorValue) : COLOR_GREYISH,
        colorShadow: this.MDL.color.scale.palette.getColorShade({colorID: colorValue}) || COLOR_BLACKISH
      };
    }

    _processFramesData() {
      const KEY = this.KEY;
      const data = new Map();
      this.model.getTransformedDataMap("filterRequired").each(frame => frame.forEach((valuesObj, key) => {
        if (!data.has(key)) data.set(key, { [KEY]: key, values:[] });
        data.get(key).values.push(valuesObj);
      }));
      
      return [...data.values()].map(d => {
        d.shiftIndex = this.MDL.frame.stepScale(d.values[0][this.TIMEDIM]);
        return d;
      });
    }

    updateNoDataMessage(){
      this.services.layout.size;
      this.DOM.noDataMessage
        .classed("vzb-hidden", this._processFramesData().length);

      if (this._processFramesData().length) return;

      this.DOM.noDataMessage
        .attr("transform", `translate(${this.width/2 - this.profileConstants.margin.left}, ${this.height/2})`)
        .select("text")
        .text(this.localise("hints/no-data-available"));
    }

    get isFrameOnXaxis(){
      return this.MDL.frame.data.concept === this.MDL.x.data.concept;
    }

    /*
     * UPDATE SHOW:
     * Ideally should only update when show parameters change or data changes
     */
    addOrRemoveLinesAndLabels() {
      this.MDL.x.scale.zoomed;

      const _this = this;
      const KEY = this.KEY;
      
      this.cached = {};
      
      this.data = this._processFramesData();

      this.lineWidth = this.lineWidthScale(this.data.length);
      this.shadowWidth = this.lineWidth >= 2 ? this.lineWidth * 1.3 : null;
      this.DOM.labelsContainer.classed("small", !this.shadowWidth);

      mobx.runInAction(() => {

        if (this.lines) this.lines.remove();
        this.lines = this.DOM.linesContainer.selectAll(".vzb-lc-entity")
          .data(this.data, d => d[KEY])
          .enter().append("g")
          .attr("class", d => "vzb-lc-entity vzb-lc-entity-" + d[KEY])
          .each(function () {
            this.view = d3.select(this);
            if(_this.shadowWidth) 
              this.path1 = this.view.append("path").attr("class", "vzb-lc-line-shadow");
            this.path2 = this.view.append("path").attr("class", "vzb-lc-line");
          });
          

        if (this.labels) this.labels.remove();
        this.labels = this.DOM.labelsContainer.selectAll(".vzb-lc-entity")
          .data(this.data, d => d[KEY])
          .enter().append("g")
          .attr("class", "vzb-lc-entity")
          .on("mouseover", (event, d) => {
            _this.MDL.highlighted.data.filter.set(d, JSON.stringify(d.values[d.values.length - 1]));
          })
          .on("mouseout", (event, d) => {
            _this.MDL.highlighted.data.filter.delete(d);
          })
          .each(function() {
            this.view = d3.select(this);
            
            this.title = this.view.append("title");

            this.circle = this.view.append("circle")
              .attr("class", "vzb-lc-circle")
              .attr("cx", 0);

            this.labelGroup = this.view.append("g").attr("class", "vzb-lc-label");

            this.labelText = this.labelGroup.append("text")
              .attr("class", "vzb-lc-labeltext")
              .attr("dy", ".35em");
          });
      });
    }

    /*
     * REDRAW DATA POINTS:
     * Here plotting happens
     */
    redrawDataPoints() {
      this.services.layout.size;
      this.MDL.x.scale.type;
      this.MDL.y.scale.type;
      this.MDL.x.scale.zoomed;
      this.MDL.y.scale.zoomed;

      const checkX = this.xScale.domain();
      const checkY = this.yScale.domain();
      if (!checkX.length || !checkY.length || [...checkX, ...checkY].some(s => s == null || isNaN(s)))
        return sharedComponents.LegacyUtils.warn(`Line chart redrawDataPoints() short circuit because scale domain looks bad`, checkX, checkY);

      const _this = this;
      const KEY = this.KEY;
      const {
        verticalNow,
        xAxisEl
      } = this.DOM;
      const {
        frame
      } = this.MDL;

      this.lines
        .each(function(d) {
            
          const xy = d.values.slice(0, Math.ceil((_this.stepIndex - d.shiftIndex) <= 0 ? 0 : _this.stepIndex - d.shiftIndex))
            .map(point => [point[_this._alias("x")], point[_this._alias("y")]])
            .filter(d => d[1] || d[1] === 0);

          // add last point
          let currentPoint = _this.model.dataMap.getByStr(d[KEY]) || {};
          currentPoint = {
            x: currentPoint[_this._alias("x")],
            y: currentPoint[_this._alias("y")]
          };
          if ((currentPoint.y || currentPoint.y === 0) && (currentPoint.x || currentPoint.x === 0)) {
            xy.push([currentPoint.x, currentPoint.y]);
          }

          if (xy.length > 0) {
            _this.cached[d[KEY]] = {
              valueX: xy[xy.length - 1][0],
              valueY: xy[xy.length - 1][1]
            };
          } else {
            delete _this.cached[d[KEY]];
          }

          if (this.path1) this.path1
            .style("stroke-width", _this.shadowWidth + "px")
            .attr("transform", "translate(0, " + (_this.shadowWidth - _this.lineWidth) + ")")
            .attr("d", _this.line(xy) || "");

          this.path2
            .style("stroke-width", _this.lineWidth + "px")
            .attr("d", _this.line(xy) || "");

          if (frame.playing && _this.totalLength_1[d[KEY]] === null) {
            _this.totalLength_1[d[KEY]] = this.path2.node().getTotalLength();
          }

          // this section ensures the smooth transition while playing and not needed otherwise
          if (frame.playing) {
            const totalLength = this.path2.node().getTotalLength();

            if (this.path1) this.path1
              .interrupt()
              .attr("stroke-dasharray", totalLength)
              .attr("stroke-dashoffset", totalLength - _this.totalLength_1[d[KEY]])
              .transition()
              .delay(0)
              .duration(_this.duration)
              .ease(d3.easeLinear)
              .attr("stroke-dashoffset", 0);
            this.path2
              .interrupt()
              .attr("stroke-dasharray", totalLength)
              .attr("stroke-dashoffset", totalLength - _this.totalLength_1[d[KEY]])
              .transition()
              .delay(0)
              .duration(_this.duration)
              .ease(d3.easeLinear)
              .attr("stroke-dashoffset", 0);

            _this.totalLength_1[d[KEY]] = totalLength;
          } else {
            //reset saved line lengths
            _this.totalLength_1[d[KEY]] = null;

            if (this.path1) this.path1
              .attr("stroke-dasharray", "none")
              .attr("stroke-dashoffset", "none");

            this.path2
              .attr("stroke-dasharray", "none")
              .attr("stroke-dashoffset", "none");
          }

        });

      const showValueInLabel = this.data.length < this.ui.labels.min_number_of_entities_when_values_hide;

      this.labels
        .each(function(d) {

          if (!_this.cached[d[KEY]]) {
            //data missing
            this.view.classed("vzb-hidden", true);

          } else if(_this.isFrameOnXaxis && _this.time > d3.max(_this.xScale.domain())) {
            //time out of bounds
            this.view.classed("vzb-hidden", true);

          } else {

            const labelText = _this._getLabelText(d);
            const maxSymbolCount = showValueInLabel ? 7 : 13;
            const label = labelText.length <= maxSymbolCount ? labelText : labelText.substring(0, maxSymbolCount).trim() + "…";//"…";

            d.valueX = _this.xScale(_this.cached[d[KEY]]["valueX"]);
            d.valueY = _this.yScale(_this.cached[d[KEY]]["valueY"]);
            this.view
              .classed("vzb-hidden", false)
              .transition()
              .duration(_this.duration)
              .ease(d3.easeLinear)
              .attr("transform", "translate(" + d.valueX + ",0)");

            this.circle
              .transition()
              .duration(_this.duration)
              .ease(d3.easeLinear)
              .attr("cy", d.valueY + 1);

            const labelAndValue = label + " " + _this.yAxis.tickFormat()(_this.cached[d[KEY]]["valueY"]);

            this.labelText.text(showValueInLabel ? labelAndValue : label);
            this.title.text(labelAndValue);

            this.labelGroup
              .transition()
              .duration(_this.duration)
              .ease(d3.easeLinear)
              .attr("transform", "translate(0," + d.valueY + ")");
          }   
        });


      if (this.isFrameOnXaxis){
        verticalNow
          .transition()
          .duration(_this.duration)
          .ease(d3.easeLinear)
          .attr("transform", "translate(" + _this.xScale(_this.time) + ",0)");
      }

      if (this.isFrameOnXaxis && !this.hoveringNow && this.time - frame.start !== 0 && this.time <= d3.max(_this.xScale.domain())) {
        if (!_this.ui.hideXAxisValue) xAxisEl.call(
          this.xAxis
            .highlightTransDuration(this.duration)
            .highlightValue(this.time)
        );
        verticalNow.style("opacity", 1);
      } else {
        if (!this.ui.hideXAxisValue) xAxisEl.call(
          this.xAxis
            .highlightValue("none")
        );
        verticalNow.style("opacity", 0);
      }

      // Call flush() after any zero-duration transitions to synchronously flush the timer queue
      // and thus make transition instantaneous. See https://github.com/mbostock/d3/issues/1951
      if (this.duration == 0) {
        d3.timerFlush();
      }

      // cancel previously queued simulation if we just ordered a new one
      // then order a new collision resolving
      clearTimeout(this.collisionTimeout);
      this.collisionTimeout = setTimeout(() => {
        this.labels.call(this.collisionResolver.time(this.xScale(this.time)));
      }, this.duration * 1.5);

    }


    get xScale() {
      this.services.layout.size; //watch
      
      const {margin} = this.profileConstants;
      const cropWidth = (this.width - margin.left -  margin.right) || 0;
      let zoomed = this.MDL.x.scale.zoomed;
      if (zoomed && this.MDL.x.scale.type === "time") zoomed = zoomed.map(m => this.MDL.frame.parseValue(m));

      return this.MDL.x.scale.d3Scale.domain(zoomed).range([0, cropWidth]);
    }


    get yScale() {
      this.services.layout.size; //watch
      
      const {margin, lollipopRadius} = this.profileConstants;
      const cropHeight = (this.height - margin.top - margin.bottom) || 0;
      const zoomed = this.MDL.y.scale.zoomed;
      
      return this.MDL.y.scale.d3Scale.domain(zoomed).range([cropHeight - lollipopRadius, lollipopRadius]);
    }

    /*
     * RESIZE:
     * Executed whenever the container is resized
     * Ideally, it contains only operations related to size
     */
    updateSize() {
      this.services.layout.size;
      this.MDL.x.scale.zoomed;
      this.MDL.y.scale.zoomed;
      if (this.checkLayout()) return; //return if exists with error

      const {
        x,
        y
      } = this.MDL;
      
      const {
        graph,
        linesContainerCrop,
        labelsContainerCrop,
        xAxisElContainer,
        xAxisEl,
        yAxisElContainer,
        yAxisEl,
        xTitle,
        yTitle,
        yInfo,
        tooltip,
        verticalNow,
        projectionX,
        projectionY
      } = this.DOM;

      const {
        margin,
        text_padding,
        lollipopRadius,
        limitMaxTickNumberX,
        yAxisTitleBottomMargin,
        infoElHeight
      } = this.profileConstants;

      const isRTL = this.services.locale.isRTL();

      this.labels.selectAll(".vzb-lc-circle")
        .attr("r", this.shadowWidth ? lollipopRadius : lollipopRadius * 0.8);

      this.labels.selectAll(".vzb-lc-labeltext")
        .attr("dx", this.shadowWidth ? lollipopRadius * 2 : lollipopRadius * 0.8 * 2);

      if(this.MDL.repeat.ncolumns == 1)
        this.services.layout.setHGrid([this.width - margin.right]);

      //stage
      this.cropHeight = (this.height - margin.top - margin.bottom) || 0;
      this.cropWidth = (this.width - margin.left -  margin.right) || 0;

      //if (this.cropHeight <= 0 || this.cropWidth <= 0) return utils.warn("Line chart updateSize() abort: vizabi container is too little or has display:none");
      
      linesContainerCrop
        .attr("width", this.cropWidth)
        .attr("height", Math.max(0, this.cropHeight));

      labelsContainerCrop
        .attr("width", this.cropWidth + margin.right)
        .attr("height", Math.max(0, this.cropHeight));

      this.collisionResolver.scale(this.yScale).height(this.cropHeight);

      graph
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      this.yAxis.scale(this.yScale)
        .tickSizeInner(-this.cropWidth)
        .tickSizeOuter(0)
        .tickPadding(6)
        .tickSizeMinor(-this.cropWidth, 0)
        .labelerOptions({
          scaleType: y.scale.type,
          toolMargin: margin,
          limitMaxTickNumber: 6,
          viewportLength: this.cropHeight,
          formatter: this.localise
        });

      this.xAxis.scale(this.xScale)
        .tickSizeInner(-this.cropHeight)
        .tickSizeOuter(0)
        .tickSizeMinor(-this.cropHeight, 0)
        .tickPadding(6)
        .labelerOptions({
          scaleType: x.scale.type,
          limitMaxTickNumber: limitMaxTickNumberX,
          toolMargin: margin,
          bump: text_padding * 2,
          formatter: this.localise,
          //showOuter: true
        });

      xAxisElContainer
        .attr("width", this.cropWidth + text_padding * 2)
        .attr("height", margin.bottom + this.cropHeight)
        .attr("y", -1)
        .attr("x", -text_padding);

      xAxisEl
        .attr("transform", "translate(" + (text_padding - 1) + "," + (this.cropHeight + 1) + ")");

      yAxisElContainer
        .attr("width", margin.left + this.cropWidth)
        .attr("height", Math.max(0, this.cropHeight))
        .attr("x", -margin.left);
      yAxisEl
        .attr("transform", "translate(" + (margin.left - 1) + "," + 0 + ")");

      yAxisEl.call(this.yAxis);
      xAxisEl.call(this.xAxis);

      const xTitleBBox = this.DOM.xTitle.select("text").node().getBBox();
      const xTitleDoesntFit = xTitleBBox.width + text_padding + yAxisTitleBottomMargin > margin.right; 
      xTitle
        .style("font-size", infoElHeight + "px")
        .style("text-anchor", xTitleDoesntFit ? "end" : "start")
        .attr("transform", "translate(" +
          (this.cropWidth + text_padding + yAxisTitleBottomMargin) + "," +
          (this.cropHeight + xTitleBBox.height * (xTitleDoesntFit ? -0.3 : 0.72)) + ")");


      yTitle
        .style("font-size", infoElHeight + "px")
        .attr("transform", "translate(" + (10 - margin.left + (isRTL ? infoElHeight * 1.4 : 0 )) + ", -" + yAxisTitleBottomMargin + ")");

      const titleBBox = yTitle.node().getBBox();
      const t = sharedComponents.LegacyUtils.transform(yTitle.node());

      yInfo.attr("transform", "translate("
        + (isRTL ? 10 - margin.left : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4) + ","
        + (t.translateY - infoElHeight * 0.8) + ")")
        .select("svg").attr("width", infoElHeight + "px").attr("height", infoElHeight + "px");

      // adjust the vertical dashed line
      verticalNow.attr("y1", this.yScale.range()[0]).attr("y2", this.yScale.range()[1])
        .attr("x1", 0).attr("x2", 0);
      projectionX.attr("y1", this.yScale.range()[0]);
      projectionY.attr("x2", this.xScale.range()[0]);

      if (sharedComponents.LegacyUtils.isTouchDevice()) {
        tooltip.classed("vzb-hidden", true);
        verticalNow.style("opacity", 1);
        projectionX.style("opacity", 0);
        projectionY.style("opacity", 0);
        xAxisEl.call(this.xAxis.highlightValue(this.isFrameOnXaxis ? this.time : "none"));
        yAxisEl.call(this.yAxis.highlightValue("none"));
        graph.selectAll(".vzb-lc-entity").each(function() {
          d3.select(this).classed("vzb-dimmed", false).classed("vzb-hovered", false);
        });

        this.hoveringNow = null;
      }

      this.root.findChild({type: "_DataWarning"}).setOptions({
        width: this.width,
        height: this.height,
        vertical: "top", 
        horizontal: "right", 
        right: 30,
        top: margin.top + titleBBox.y,
        wLimit: this.width - titleBBox.width - infoElHeight * 2
      });
    }

    _entityMousemove(event) {
      const _this = this;
      const KEY = _this.KEY;
      const {
        frame,
        highlighted: { data: { filter: highlightedFilter } },
      } = this.MDL;


      const mouse = d3.pointer(event, _this.element.node());

      let resolvedTime = _this.xScale.invert(mouse[0] - _this.profileConstants.margin.left);
      if (_this.time - resolvedTime < 0) {
        resolvedTime = _this.time;
      } else if (resolvedTime < frame.scale.domain[0]) {
        resolvedTime = frame.scale.domain[0];
      }
      const mousePos = mouse[1] - _this.profileConstants.margin.top;

      //if (!utils.isDate(resolvedTime)) resolvedTime = this.time.parse(resolvedTime);

      const data = _this.model.getDataMapByFrameValue(resolvedTime);
      const nearestKey = _this._getNearestKey(mousePos, data, _this._alias("y"), _this.yScale.bind(_this));
      if (!data.hasByStr(nearestKey)) return;
      const resolvedValue = data.getByStr(nearestKey)[_this._alias("y")];
      const hoveringNow = {[KEY]: nearestKey};
      if (!highlightedFilter.has(hoveringNow)) {
        mobx.runInAction(() => {
          highlightedFilter.config.markers = {};
          highlightedFilter.set(hoveringNow);
        });
      }
      _this.hoveringNow = hoveringNow;

      if (sharedComponents.LegacyUtils.isNaN(resolvedValue)) return;

      const scaledTime = _this.xScale(resolvedTime);
      const scaledValue = _this.yScale(resolvedValue);
      const {
        tooltip,
        verticalNow,
        projectionX,
        projectionY,
        xAxisEl,
        yAxisEl
      } = this.DOM;

      if (_this.ui.whenHovering.showTooltip) {
        //position tooltip
        tooltip
          .style("left", (scaledTime + _this.profileConstants.margin.left) + "px")
          .style("bottom", (_this.cropHeight - scaledValue + _this.profileConstants.margin.bottom) + "px")
          .text(_this.yAxis.tickFormat()(resolvedValue))
          .classed("vzb-hidden", false);
      }

      // bring the projection lines to the hovering point
      if (_this.ui.whenHovering.hideVerticalNow) {
        verticalNow.style("opacity", 0);
      }

      if (_this.ui.whenHovering.showProjectionLineX) {
        projectionX
          .style("opacity", 1)
          .attr("y2", scaledValue)
          .attr("x1", scaledTime)
          .attr("x2", scaledTime);
      }
      if (_this.ui.whenHovering.showProjectionLineY) {
        projectionY
          .style("opacity", 1)
          .attr("y1", scaledValue)
          .attr("y2", scaledValue)
          .attr("x1", scaledTime);
      }

      if (_this.ui.whenHovering.higlightValueX) xAxisEl.call(
        _this.xAxis.highlightValue(this.isFrameOnXaxis ? resolvedTime : "none").highlightTransDuration(0)
      );

      if (_this.ui.whenHovering.higlightValueY) yAxisEl.call(
        _this.yAxis.highlightValue(this.isFrameOnXaxis ? resolvedValue : "none").highlightTransDuration(0)
      );

      clearTimeout(_this.unhoverTimeout);
    }

    _entityMouseout(event) {
      const _this = this;    
      if (event.relatedTarget && d3.select(event.relatedTarget).classed("vzb-tooltip")) return;

      // hide and show things like it was before hovering
      _this.unhoverTimeout = setTimeout(() => {
        const DOM = _this.DOM;

        DOM.tooltip.classed("vzb-hidden", true);
        DOM.verticalNow.style("opacity", 1);
        DOM.projectionX.style("opacity", 0);
        DOM.projectionY.style("opacity", 0);
        DOM.xAxisEl.call(_this.xAxis.highlightValue(this.isFrameOnXaxis ? _this.time : "none"));
        DOM.yAxisEl.call(_this.yAxis.highlightValue("none"));

        if (_this.hoveringNow) _this.MDL.highlighted.data.filter.delete(_this.hoveringNow);

        _this.hoveringNow = null;
      }, 300);

    }

    /*
     * Highlights all hovered lines
     */
    highlightLines() {
      const _this = this;
      const KEY = this.KEY;
      const OPACITY_HIGHLT = 1.0;
      const OPACITY_HIGHLT_DIM = 0.3;
      const OPACITY_SELECT = 1.0;
      const OPACITY_REGULAR = this.ui.opacityRegular;
      const OPACITY_SELECT_DIM = this.ui.opacitySelectDim;

      const {
        selected: { data: { filter: selectedFilter } },
        highlighted: { data: { filter: highlightedFilter } },
      } = this.MDL;
      
      const someHighlighted = (highlightedFilter.any());
      this.someSelected = (selectedFilter.any());

      // when pointer events need update...

      this.nonSelectedOpacityZero = OPACITY_SELECT_DIM < 0.01;
      const selectedHash = {};
      selectedFilter.markers.forEach((v, k) => {
        selectedHash[k] = true;
      }
      );
      this.lines.style("opacity", (d) => {
        if (highlightedFilter.has(d)) return OPACITY_HIGHLT;
        if (_this.someSelected) {
          return selectedHash[d[KEY]] ? OPACITY_SELECT : OPACITY_SELECT_DIM;
        }
        if (someHighlighted) return OPACITY_HIGHLT_DIM;
        return OPACITY_REGULAR;
      });
      this.labels.style("opacity", (d) => {
        if (highlightedFilter.has(d)) {
          d.sortValue = 1;
          return OPACITY_HIGHLT;
        } else {
          d.sortValue = 0;
        }
        if (_this.someSelected) {
          return selectedHash[d[KEY]] ? OPACITY_SELECT : OPACITY_SELECT_DIM;
        }
        if (someHighlighted) return OPACITY_HIGHLT_DIM;
        return OPACITY_REGULAR;
      }).attr("pointer-events", d => {
        if(!_this.someSelected || !_this.nonSelectedOpacityZero || selectedHash[d[KEY]]) {
          d.hidden = false;
          return "visible";   
        } else {
          d.hidden = true;
          return "none";
        }
      })
        .sort(function(a, b){
          return d3.ascending(a.sortValue, b.sortValue);
        });

    }


    /**
     * Returns key from obj which value from values has the smallest difference with val
     */
    _getNearestKey(val, values, propName, fn) {
      const keys = (this.someSelected && this.nonSelectedOpacityZero) ?
        [...this.MDL.selected.data.filter.markers.keys()].filter(key => values.hasByStr(key))
        :
        [...values.keys()];

      let resKey = keys[0];
      for (let i = 1; i < keys.length; i++) {
        let key = keys[i];
        
        if (Math.abs((fn ? fn(values.getByStr(key)[propName]) : values.getByStr(key)[propName]) - val) < Math.abs((fn ? fn(values.getByStr(resKey)[propName]) : values.getByStr(resKey)[propName]) - val)) {
          resKey = key;
        }
      }
      return resKey;
    }

    _alias(enc) {
      return this.state.alias[enc] || enc;
    }

  }

  _VizabiLineChart.DEFAULT_UI = {
    showForecast: false,
    showForecastOverlay: true,
    pauseBeforeForecast: true,
    opacityHighlight: 1.0,
    opacitySelect: 1.0,
    opacityHighlightDim: 0.1,
    opacitySelectDim: 0.3,
    opacityRegular: 0.5,
    hideXAxisValue: false,
    curve: "curveMonotoneX",
    whenHovering: {
      showTooltip: false,
      hideVerticalNow: false,
      showProjectionLineX: false,
      showProjectionLineY: false,
      higlightValueX: false,
      higlightValueY: false
    },
    labels: {
      min_number_of_entities_when_values_hide: 3,
    }
  };

  const VizabiLineChart = mobx.decorate(_VizabiLineChart, {
    "MDL": mobx.computed,
    "height": mobx.computed,
    "width": mobx.computed,
    "xScale": mobx.computed,
    "yScale": mobx.computed,
    "lines": mobx.observable,
    "labels": mobx.observable,
    "profileConstants": mobx.computed,
    "isFrameOnXaxis": mobx.computed
  });

  class LineChart extends sharedComponents.BaseComponent {

    constructor(config){

      const markerName = config.options?.markerNames?.line || "line";
      config.Vizabi.utils.applyDefaults(config.model.markers[markerName].config, LineChart.DEFAULT_CORE(markerName));  

      const marker = config.model.markers[markerName];

      config.name = "linechart";

      config.subcomponents = [{
        type: sharedComponents.Repeater,
        placeholder: ".vzb-repeater",
        model: marker,
        options: {
          repeatedComponent: VizabiLineChart,
          repeatedComponentCssClass: "vzb-linechart"
        },
        name: "chart"
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        model: marker,
        name: "time-slider"
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        model: marker,
        name: "speed-slider"
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        model: marker,
        name: "tree-menu"
      },{
        type: sharedComponents.DataWarning,
        placeholder: ".vzb-datawarning",
        options: {button: ".vzb-datawarning-button"},
        model: marker,
        name: "data-warning"
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        model: marker,
        name: "buttons"
      },{
        type: sharedComponents.SpaceConfig,
        placeholder: ".vzb-spaceconfig",
        options: {button: ".vzb-spaceconfig-button"},
        model: marker,
        name: "space-config"
      },{
        type: sharedComponents.ErrorMessage,
        placeholder: ".vzb-errormessage",
        model: marker,
        name: "error-message"
      }];

      config.template = `
      <div class="vzb-repeater"></div>
      <div class="vzb-animationcontrols">
        <div class="vzb-timeslider"></div>
        <div class="vzb-speedslider"></div>
      </div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datawarning"></div>
      <div class="vzb-spaceconfig"></div>
      <div class="vzb-datanotes"></div>
      <div class="vzb-errormessage"></div>
    `;

      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);
    }
  }

  LineChart.DEFAULT_UI = {
    chart: {
    },
  };
  LineChart.DEFAULT_CORE = (markerName) => ({
    requiredEncodings: ["x", "y"],
    encoding: {
      "selected": {
        modelType: "selection"
      },
      "highlighted": {
        modelType: "selection"
      },
      "y": {
        scale: {
          allowedTypes: ["linear", "log", "genericLog", "pow"]
        }
      },
      "x": {
        data: {
          concept: { 
            ref: `markers.${markerName}.encoding.frame.data.concept`
          }
        },
        scale: {
          allowedTypes: ["linear", "log", "genericLog", "pow", "time"]
        }
      },
      "color": {
        data: {
          concept: { filter: { concept_type: { $in: ["entity_set", "entity_domain"]} } },
          
          allow: {
            space: {
              filter: {
                concept_type: { $ne: "time" }
              }
            }
          }
        },
        scale: {
          modelType: "color"
        }
      },
      "label": {
        data: {
          modelType: "entityPropertyDataConfig",
        }
      },
      "repeat": {
        modelType: "repeat",
        allowEnc: ["y", "x"]
      },
      frame: {
        modelType: "frame"
      }
    }
  });

  LineChart.versionInfo = { version: "4.0.0", build: 1687772739474, package: {"homepage":"https://github.com/vizabi/linechart#readme","name":"@vizabi/linechart","description":"Vizabi line chart"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = LineChart;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/barrank#readme v4.0.1 build 1693653828189 Copyright 2023 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('mobx'), require('d3')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'mobx', 'd3'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BarRank = {}, global.VizabiSharedComponents, global.mobx, global.d3));
})(window, (function (exports, sharedComponents, mobx, d3) {
  const {ICON_QUESTION} = sharedComponents.Icons;
  const COLOR_BLACKISH = "rgb(51, 51, 51)";
  const COLOR_WHITEISH = "rgb(253, 253, 253)";

  const PROFILE_CONSTANTS = {
    SMALL: {
      margin: {top: 60, right: 20, left: 5, bottom: 20},
      headerMargin: {top: 10, right: 20, bottom: 20, left: 20},
      infoElHeight: 16,
      infoElMargin: 5,
      barHeight: 18,
      barMargin: 3,
      barLabelMargin: 5,
      barValueMargin: 5,
      barRankMargin: 6,
      scrollMargin: 25,
      longestLabelLength: 12 //chars
    },
    MEDIUM: {
      margin: {top: 60, right: 25, left: 5, bottom: 20},
      headerMargin: {top: 10, right: 20, bottom: 20, left: 20},
      infoElHeight: 16,
      infoElMargin: 5,
      barHeight: 21,
      barMargin: 3,
      barLabelMargin: 5,
      barValueMargin: 5,
      barRankMargin: 10,
      scrollMargin: 30,
      longestLabelLength: 12 //chars
    },
    LARGE: {
      margin: {top: 60, right: 30, left: 5, bottom: 20},
      headerMargin: {top: 10, right: 20, bottom: 20, left: 20},
      infoElHeight: 16,
      infoElMargin: 5,
      barHeight: 28,
      barMargin: 4,
      barLabelMargin: 5,
      barValueMargin: 5,
      barRankMargin: 10,
      scrollMargin: 30,
      longestLabelLength: 12 //chars
    }
  };

  const PROFILE_CONSTANTS_FOR_PROJECTOR = {
    MEDIUM: {
      margin: {top: 60, right: 30, left: 10, bottom: 40},
      headerMargin: {top: 10, right: 20, bottom: 20, left: 20},
      infoElHeight: 25,
      infoElMargin: 10,
      barHeight: 25,
      barMargin: 6
    },
    LARGE: {
      margin: {top: 60, right: 35, left: 10, bottom: 40},
      headerMargin: {top: 10, right: 20, bottom: 20, left: 20},
      infoElHeight: 16,
      infoElMargin: 10,
      barHeight: 30,
      barMargin: 6
    }
  };

  class _VizabiBarRank extends sharedComponents.BaseComponent {

    constructor(config) {
      config.template = `
      <svg class="vzb-br-header">
        <g class="vzb-br-title">
          <text></text>
        </g>
        <g class="vzb-br-total">
          <text></text>
        </g>
        <g class="vzb-br-axis-info vzb-noexport"></g>
      </svg>

      <div class="vzb-br-barsviewport vzb-dialog-scrollable">
        <svg class="vzb-br-bars-svg vzb-export">
          <g class="vzb-br-bars"></g>
          <rect class="vzb-br-forecastoverlay vzb-hidden" x="0" y="0" width="100%" height="100%" fill="url(#vzb-br-pattern-lines-${config.id})" pointer-events='none'></rect>
        </svg>
      </div>

      <svg class="vzb-br-footer">
        <g class="vzb-datawarning-button vzb-noexport"></g>
      </svg>

      <svg class="vzb-br-tooltip-svg vzb-hidden">
        <g class="vzb-br-tooltip vzb-hidden">
          <rect class="vzb-tooltip-border"></rect>
          <text class="vzb-tooltip-text"></text>
        </g>
      </svg>
      
      <svg>
        <defs>
            <pattern class="vzb-noexport" id="vzb-br-pattern-lines-${config.id}" x="0" y="0" patternUnits="userSpaceOnUse" width="50" height="50" viewBox="0 0 10 10"> 
                <path d='M-1,1 l2,-2M0,10 l10,-10M9,11 l2,-2' stroke='black' stroke-width='3' opacity='0.08'/>
            </pattern> 
        </defs>
      </svg>
    `;
      super(config);
    }


    setup() {
      this.DOM = {
        header: this.element.select(".vzb-br-header"),
        title: this.element.select(".vzb-br-title"),
        lilFrameDisplay: this.element.select(".vzb-br-total"),
        info: this.element.select(".vzb-br-axis-info"),
    
        barViewport: this.element.select(".vzb-br-barsviewport"),
        barSvg: this.element.select(".vzb-br-bars-svg"),
        barContainer: this.element.select(".vzb-br-bars"),
        forecastOverlay: this.element.select(".vzb-br-forecastoverlay"),
    
        footer: this.element.select(".vzb-br-footer"),
    
        tooltipSvg: this.element.select(".vzb-br-tooltip-svg"),
        tooltip: this.element.select(".vzb-br-tooltip")
      };

      this._cache = {};
    }

    get MDL(){
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected.data.filter,
        highlighted: this.model.encoding.highlighted.data.filter,
        x: this.model.encoding[this.state.alias.x || "x"],
        color: this.model.encoding.color,
        label: this.model.encoding.label
      };
    }

    


    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);

      this.addReaction(this._drawForecastOverlay);
      
      if (this._updateLayoutProfile()) return; //return if exists with error
      this.addReaction(this._getDuration);
      this.addReaction(this._drawHeader);
      this.addReaction(this._drawInfoEl);
      this.addReaction(this._drawFooter);
      this.addReaction(this._estimateLabelAndValueWidth);

      //this.addReaction(this._processFrameData);
      //this.addReaction(this._createAndDeleteBars);
      this.addReaction(this._drawData);
      this.addReaction(this._updateOpacity);
      this.addReaction(this._resizeSvg);
      this.addReaction(this._scroll);

      this.addReaction(this._drawForecastOverlay);
      this.addReaction(this._updateFrameDisplay);
    }

    _getDuration() {
      //smooth animation is needed when playing, except for the case when time jumps from end to start
      if(!this.MDL.frame) return 0;
      this.frameValue_1 = this.frameValue;
      this.frameValue = this.MDL.frame.value;
      return this.__duration = this.MDL.frame.playing && (this.frameValue - this.frameValue_1 > 0) ? this.MDL.frame.speed : 0;
    }
    
    _drawForecastOverlay() {
      this.DOM.forecastOverlay.classed("vzb-hidden", 
        !this.ui.showForecast || 
        !this.ui.showForecastOverlay || 
        !this.ui.endBeforeForecast || 
          (this.MDL.frame.value <= this.MDL.frame.parseValue(this.ui.endBeforeForecast))
      );
    }

    _updateLayoutProfile(){
      this.services.layout.size;

      this.profileConstants = this.services.layout.getProfileConstants(PROFILE_CONSTANTS, PROFILE_CONSTANTS_FOR_PROJECTOR);
      this.height = this.element.node().clientHeight || 0;
      this.width = this.element.node().clientWidth || 0;
      if (!this.height || !this.width) return sharedComponents.LegacyUtils.warn("Chart _updateProfile() abort: container is too little or has display:none");
    }

    _updateFrameDisplay() {
      const duration = this._getDuration();
      if (duration) {
        this.DOM.lilFrameDisplay.select("text")
          .transition("text")
          .delay(duration)
          .text(this.localise(this.MDL.frame.value));
      } else {
        this.DOM.lilFrameDisplay.select("text")
          .interrupt()
          .text(this.localise(this.MDL.frame.value));
      }
    }

    _drawHeader() {
      const {
        margin,
        headerMargin,
        infoElHeight,
        infoElMargin,
      } = this.profileConstants;

      this.services.layout.size;
      this.services.layout.projector;

      // header
      this.DOM.header.attr("height", margin.top);
      const headerTitle = this.DOM.title;

      // change header titles for new data
      headerTitle.select("text")
        .text(sharedComponents.Utils.getConceptName(this.MDL.x, this.localise));

      const headerTitleBBox = headerTitle.node().getBBox();

      const titleTx = headerMargin.left;
      const titleTy = headerMargin.top + headerTitleBBox.height;
      headerTitle
        .attr("transform", `translate(${titleTx}, ${titleTy})`);

      const headerInfo = this.DOM.info;

      headerInfo.select("svg")
        .attr("width", `${infoElHeight}px`)
        .attr("height", `${infoElHeight}px`);

      const infoTx = titleTx + headerTitle.node().getBBox().width + infoElMargin;
      const infoTy = headerMargin.top + infoElHeight / 4;
      headerInfo.attr("transform", `translate(${infoTx}, ${infoTy})`);
     
      const lilFrameBBox = this.DOM.lilFrameDisplay.node().getBBox();
      const lilFrameTx = this.width - headerMargin.right - lilFrameBBox.width;
      const lilFrameTy = headerMargin.top + lilFrameBBox.height;
      this.DOM.lilFrameDisplay
        .attr("transform", `translate(${lilFrameTx}, ${lilFrameTy})`)
        .classed("vzb-hidden", 
          this.ui.lilFrameDisplayAlwaysHidden ||
          this.services.layout.profile !== "LARGE" ||
          headerTitleBBox.width + lilFrameBBox.width + 10 > this.width
        );

      this.treemenu = this.root.findChild({type: "TreeMenu"});

      headerTitle
        .classed("vzb-disabled", this.treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .on("click", () =>
          this.treemenu
            .encoding(this._alias("x"))
            .alignX("left")
            .alignY("top")
            .updateView()
            .toggle()
        );

    }

    _drawInfoEl(){
      const dataNotes = this.root.findChild({type: "DataNotes"});
      const conceptPropsX = this.MDL.x.data.conceptProps;
      const infoElHeight = this.profileConstants.infoElHeight;
      const _this = this;

      this.DOM.info
        .on("click", () => {
          dataNotes.pin();
        })
        .on("mouseover", function() {
          const rect = this.getBBox();
          const ctx = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement);
          const coord = ctx(rect.x - 10, rect.y + rect.height + 10);
          dataNotes
            .setEncoding(_this.MDL.x)
            .show()
            .setPos(coord.x, coord.y);
        })
        .on("mouseout", () => {
          dataNotes.hide();
        })
        .html(ICON_QUESTION)
        .select("svg")
        .attr("width", infoElHeight + "px").attr("height", infoElHeight + "px")
        .classed("vzb-hidden", !conceptPropsX.description && !conceptPropsX.sourceLink);
    }

    _drawFooter(){
      const { margin } = this.profileConstants;
      this.services.layout.size;
      this.services.layout.projector;

      this.DOM.footer
        .style("height", `${margin.bottom}px`);

      this.root.findChild({type: "_DataWarning"}).setOptions({
        width: this.width,
        height: this.height,
        vertical: "top", 
        horizontal: "right", 
        right: margin.right
      });

    }

    _getLabelText(d) {
      const markerSpace = this.model.data.space;
      if (typeof d.label == "object") 
        return Object.entries(d.label)
          .filter(([k, v]) => k != this.MDL.frame.data.concept)
          //sort parts of the name along the marker space array, so we get geo, gender instead of gender, geo
          .sort(([ak, av], [bk, bv]) => markerSpace.indexOf(ak) - markerSpace.indexOf(bk))
          //add keys where values are numbers, such as "age: 69"
          .map(([k, v]) => sharedComponents.LegacyUtils.isNumber(v) ? k + ": " + v : v)
          .join(", ");
      if (d.label != null) return "" + d.label;
      return d[Symbol.for("key")];
    }

    _getShortLabelText(d){
      let label = this._getLabelText(d);
      const longestLabelLength = this.profileConstants.longestLabelLength;
      return (label.length > longestLabelLength) 
        ? label.substring(0, longestLabelLength - 1) + "…"
        : label;
    }

    get __dataProcessed() {
      this.nullValuesCount = 0;

      //purge cache from the items that are no longer in data, to have them set as "new" when re-added
      Object.keys(this._cache).forEach(cacheItem => {
        if (!this.model.dataMap.hasByStr(cacheItem))
          delete this._cache[cacheItem];      
      });

      return this.model.dataArray
        //copy array in order to not sort in place
        .concat()
        //sort array by x value
        .sort((a, b) => d3.descending(a[this._alias("x")], b[this._alias("x")]))
        //reduce allows looking at the previous value to calcaulte the rank, as we go
        .reduce((result, d, index) => {
          const id = d[Symbol.for("key")];
          const cached = this._cache[id];
          const value = d[this._alias("x")];
          const color = d.color;
          const valueValid = value || value === 0;
          if (!valueValid) this.nullValuesCount++;
          const formattedValue = valueValid? this.localise(value) : this.localise("hints/nodata");
          const shortLabelText = this._getShortLabelText(d);
          const rank = !index || result[index - 1].formattedValue !== formattedValue ? index + 1 : result[index - 1].rank;
    
          //cache allows to know which aspects we need to update in particular per DOM marker
          if (cached) {
            result.push(Object.assign(cached, {
              value,
              formattedValue,
              shortLabelText,
              index,
              rank,
              color,
              changedFormattedValue: formattedValue !== cached.formattedValue,
              changedShortLabelText: shortLabelText !== cached.shortLabelText,
              changedValue: value !== cached.value,
              changedIndex: index !== cached.index,
              changedColor: color !== cached.color,
              isNew: false
            }));
          } else {
            result.push(this._cache[id] = Object.assign({}, d, {
              value,
              formattedValue,
              shortLabelText,
              index,
              rank,
              color,
              changedFormattedValue: true,
              changedShortLabelText: true,
              changedValue: true,
              changedIndex: true,
              changedColor: true,
              isNew: true
            }));
          }

          return result;
        }, []);
    }

    _drawData() {

      //TODO this is ugly, make this.w and h computed instead
      const sizes = JSON.stringify(this.services.layout.size) + this.width + this.height + this.services.layout.projector;
      const sizeChanged = sizes !== this.sizes_1;
      this.sizes_1 = sizes;
      
      this._createAndDeleteBars();
      
      const { barLabelMargin, barValueMargin, barRankMargin, scrollMargin, margin, longestLabelLength } = this.profileConstants;
      let limits = this.MDL.x.scale.domain;
      limits = {min: d3.min(limits), max: d3.max(limits)};
      const ltr = Math.abs(limits.max) >= Math.abs(limits.min);
      const hasNegativeValues = ltr ? limits.min < 0 : limits.max > 0;

      const longestLabelW = this.__labelCharWidth * longestLabelLength;

      const rightEdge = (
        this.width
        - margin.right
        - margin.left
        - barLabelMargin
        - scrollMargin
        - (hasNegativeValues ? 0 : longestLabelW)
      ) / (hasNegativeValues ? 2 : 1);

      const xScale = this.MDL.x.scale.d3Scale;

      xScale.range([0, rightEdge]);
      
      if (this.MDL.x.scale.type !== "log") {
        xScale.domain([0, Math.max(...xScale.domain())]);
      }

      const shift = hasNegativeValues ? rightEdge : longestLabelW;

      const isLtrValue = value => ltr ? value >= 0 : value > 0;

      const transition = (selection) =>
        this.__duration ? selection.transition().duration(this.__duration).ease(d3.easeLinear) : selection.interrupt();

      const labelAnchor = value => isLtrValue(value) ? "end" : "start";
      const valueAnchor = value => isLtrValue(value) ? "start" : "end";

      const labelX = value => isLtrValue(value) ? -barLabelMargin : barLabelMargin;
      const valueX = value => isLtrValue(value) ? barValueMargin : -barValueMargin;

      this.DOM.barContainer.attr("transform", `translate(${shift + (ltr ? margin.left : margin.right) + barLabelMargin}, 0)`);

      this.__dataProcessed.forEach((bar) => {
        const { value } = bar;
        const { barHeight } = this.profileConstants;
        const width = Math.max(0, value && xScale(Math.abs(value))) || 0;

        if (bar.isNew || sizeChanged || bar.changedValue)
          bar.DOM.label
            .attr("x", labelX(value))
            .attr("y", barHeight / 2)
            .attr("text-anchor", labelAnchor(value));

        if (bar.isNew || bar.changedShortLabelText) {
          bar.DOM.label
            .text(bar.shortLabelText);
          bar.DOM.title
            .text(this._getLabelText(bar));
        }

        if (bar.isNew || sizeChanged)
          bar.DOM.rect
            .attr("rx", barHeight / 4)
            .attr("ry", barHeight / 4)
            .attr("height", barHeight);

        if (bar.isNew || sizeChanged || bar.changedValue)
          bar.DOM.value
            .attr("x", valueX(value))
            .attr("y", barHeight / 2)
            .attr("text-anchor", valueAnchor(value));

        if (bar.isNew || sizeChanged || bar.changedFormattedValue) {
          bar.DOM.value
            .text(bar.formattedValue);
          bar.valueWidth = barValueMargin + bar.formattedValue.length * this.__valueCharWidth;
        }

        if (bar.isNew || sizeChanged || bar.changedIndex || bar.changedValue)
          bar.DOM.rank
            .text(value || value === 0 ? "#" + bar.rank : "")
            .attr("y", barHeight / 2)
            .attr("text-anchor", valueAnchor(value));

        if (bar.isNew || sizeChanged || bar.changedIndex)
          transition(bar.DOM.group)
            .attr("transform", `translate(0, ${this._getBarPosition(bar.index)})`);
        
        if (bar.isNew || sizeChanged || bar.changedValue)
          transition(bar.DOM.rect)
            .attr("width", width)
            .attr("x", value < 0 ? -width : 0);

        if (bar.isNew || sizeChanged || bar.changedValue){
          transition(bar.DOM.rank)
            .attr("x", (Math.max(width, bar.valueWidth || 0) + barRankMargin) * (isLtrValue(value) ? 1 : -1));
        }

        if (bar.isNew || bar.changedColor)
          this._updateColor(bar);      
      });
    }


    _createAndDeleteBars() {
      const _this = this;

      const updatedBars = this.DOM.barContainer.selectAll(".vzb-br-bar")
        .data(this.__dataProcessed, d => d[Symbol.for("key")]);

      // remove groups for entities that are gone
      updatedBars.exit().remove();

      // make the groups for the entities which were not drawn yet (.data.enter() does this)
      updatedBars.enter().append("g")
        .each(function(d) {
          const id = d[Symbol.for("key")];

          const group = d3.select(this)
            .attr("class", "vzb-br-bar")
            .attr("id", `vzb-br-bar-${id}-${_this.id}`)
            .classed("vzb-selected", () => _this.MDL.selected.has(d))
            .on("mousemove", () => _this.MDL.highlighted.set(d))
            .on("mouseout", () => _this.MDL.highlighted.delete(d))
            .on("click", () => _this.MDL.selected.toggle(d));

          const label = group.append("text")
            .attr("class", "vzb-br-label")
            .attr("dy", ".325em");

          const rect = group.append("rect")
            .attr("stroke", "transparent");

          const value = group.append("text")
            .attr("class", "vzb-br-value")
            .attr("dy", ".325em");

          const rank = group.append("text")
            .attr("class", "vzb-br-rank")
            .attr("dy", ".325em");

          const title = group.append("title");

          Object.assign(d, {
            DOM: {
              group,
              label,
              rect,
              value,
              rank,
              title
            }
          });
        });
    }

    _estimateLabelAndValueWidth() {
      //updates on resize
      this.services.layout.size;
      this.services.layout.projector;

      const probe = this.DOM.barContainer
        .append("g").attr("class", "vzb-br-bar vzb-br-probe vzb-invisible");

      this.__labelCharWidth = probe.append("text")
        .attr("class", "vzb-br-label")
        .text("0").node().getBBox().width;

      this.__valueCharWidth = probe.append("text")
        .attr("class", "vzb-br-value")
        .text("~").node().getBBox().width;

      probe.remove();
    }

    _getBarPosition(i) {
      return (this.profileConstants.barHeight + this.profileConstants.barMargin) * i;
    }

    _resizeSvg() {
      const { barHeight, barMargin } = this.profileConstants;

      // this.DOM.barViewport
      //   .style("height", `${this.height - margin.bottom - margin.top}px`);

      this.DOM.barSvg
        .attr("height", `${(barHeight + barMargin) * this.__dataProcessed.length}px`);
    }


    _scroll() {
      const follow = this.DOM.barContainer.select(".vzb-selected");
      if (!follow.empty()) {
        const d = follow.datum();
        const yPos = this._getBarPosition(d.index);

        const { margin } = this.profileConstants;
        const height = this.height - margin.top - margin.bottom;

        const scrollTo = yPos - (height + this.profileConstants.barHeight) / 2;
        this.DOM.barViewport.transition().duration(this.__duration)
          .tween("scrollfor" + d.entity, this._scrollTopTween(scrollTo));
      }
    }

    _scrollTopTween(scrollTop) {
      return function() {
        const node = this, i = d3.interpolateNumber(this.scrollTop, scrollTop);
        return function(t) {
          node.scrollTop = i(t);
        };
      };
    }

    _updateColor(bar) {
      const colorValue = bar.color;
      const isColorValid = colorValue || colorValue === 0;

      const fillColor = isColorValid ? this._getColor(colorValue) : COLOR_WHITEISH;
      const strokeColor = isColorValid ? "transparent" : COLOR_BLACKISH;
      const darkerColor = isColorValid ? this._getDarkerColor(bar.color) : COLOR_BLACKISH;

      bar.DOM.rect
        .style("fill", fillColor)
        .style("stroke", strokeColor);

      bar.DOM.value.style("fill", darkerColor);
      bar.DOM.label.style("fill", darkerColor);
      bar.DOM.rank.style("fill", darkerColor);
    }

    _getColor(value) {
      return d3.rgb(this.MDL.color.scale.d3Scale(value));
    }

    _getDarkerColor(d) {
      return this._getColor(d).darker(2);
    }

    _updateOpacity() {
      const _this = this;

      const {
        opacityHighlightDim,
        opacitySelectDim,
        opacityRegular,
      } = this.ui;

      const someHighlighted = this.MDL.highlighted.markers.size > 0;
      const someSelected = this.MDL.selected.markers.size > 0;

      this.DOM.barContainer.selectAll(".vzb-br-bar")
        .style("opacity", d => {
          if (_this.MDL.highlighted.has(d)) return opacityRegular;
          if (_this.MDL.selected.has(d)) return opacityRegular;

          if (someSelected) return opacitySelectDim;
          if (someHighlighted) return opacityHighlightDim;

          return opacityRegular;
        });
    }

    _alias(enc) {
      return this.state.alias[enc] || enc;
    }
  }

  _VizabiBarRank.DEFAULT_UI = {
    lilFrameDisplayAlwaysHidden: false,
    showForecast: false,
    showForecastOverlay: true,
    pauseBeforeForecast: true,
    opacityHighlight: 1.0,
    opacitySelect: 1.0,
    opacityHighlightDim: 0.3,
    opacitySelectDim: 0.5,
    opacityRegular: 1.0
  };

  //export default chart;
  const VizabiBarRank = mobx.decorate(_VizabiBarRank, {
    "MDL": mobx.computed,
    "__dataProcessed": mobx.computed
  });

  class BarRank extends sharedComponents.BaseComponent {
    
    constructor(config){
      
      const markerName = config.options?.markerNames?.bar || "bar";
      const fullMarker = config.model.markers[markerName];
      config.Vizabi.utils.applyDefaults(fullMarker.config, BarRank.DEFAULT_CORE(markerName));

      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);

      config.model.markers[markerName] = marker;

      config.name = "barrank";

      config.subcomponents = [{
        type: sharedComponents.Repeater,
        placeholder: ".vzb-repeater",
        model: marker,
        options: {
          repeatedComponent: VizabiBarRank,
          repeatedComponentCssClass: "vzb-barrank"
        },
        name: "chart",
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        name: "time-slider",
        model: marker
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        name: "speed-slider",
        model: marker
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        name: "tree-menu",
        model: marker
      },{
        type: sharedComponents.DataWarning,
        placeholder: ".vzb-datawarning",
        options: {button: ".vzb-datawarning-button"},
        model: marker,
        name: "data-warning"
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        name: "buttons",
        model: marker
      },{
        type: sharedComponents.SpaceConfig,
        placeholder: ".vzb-spaceconfig",
        options: {button: ".vzb-spaceconfig-button"},
        model: marker,
        name: "space-config"
      },{
        type: sharedComponents.ErrorMessage,
        placeholder: ".vzb-errormessage",
        model: marker,
        name: "error-message"
      }];

      config.template = `
      <div class="vzb-repeater"></div>
      <div class="vzb-animationcontrols">
        <div class="vzb-timeslider"></div>
        <div class="vzb-speedslider"></div>
      </div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datanotes"></div>
      <div class="vzb-datawarning"></div>
      <div class="vzb-spaceconfig"></div>
      <div class="vzb-errormessage"></div>
    `;

      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);

      this.splashMarker = splashMarker;
    }
  }


  BarRank.DEFAULT_UI = {
    chart: {
    }
  };

  BarRank.DEFAULT_CORE = () => ({
    encoding: {
      selected: {
        modelType: "selection"
      },
      highlighted: {
        modelType: "selection"
      },
      x: {
        scale: {
          allowedTypes: ["linear", "log", "genericLog", "pow"]
        }
      },
      color: {
        scale: {
          modelType: "color"
        }
      },
      label: {
        data: {
          modelType: "entityPropertyDataConfig"
        }
      },
      frame: {
        modelType: "frame",
      },
      repeat: {
        modelType: "repeat",
        allowEnc: ["x"]
      }
    }
  });

  BarRank.versionInfo = { version: "4.0.1", build: 1693653828189, package: {"homepage":"https://github.com/vizabi/barrank#readme","name":"@vizabi/barrank","description":"Vizabi bar rank chart"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = BarRank;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/bubblechart#readme v4.1.4 build 1703287731331 Copyright 2023 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('d3'), require('mobx')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'd3', 'mobx'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BubbleChart = {}, global.VizabiSharedComponents, global.d3, global.mobx));
})(window, (function (exports, sharedComponents, d3, mobx) {
  class PanZoom {

    constructor(context) {
      this.context = context;

      this.dragRectangle = d3.drag();
      this.zoomer = d3.zoom();

      // this.dragLock = false;

      this.dragRectangle
        .filter(event => !event.button)
        .subject(this.dragSubject())
        .on("start", this.drag().start)
        .on("drag", this.drag().go)
        .on("end", this.drag().stop);

      this.zoomer
        .filter(this.zoomFilter())
        .scaleExtent([0.0625, +Infinity])
        .on("start", this.zoom().start)
        .on("zoom", this.zoom().go)
        .on("end", this.zoom().stop);

      this.zoomer.ratioX = 1;
      this.zoomer.ratioY = 1;

      this.context._zoomedXYMinMax = {
        x: { zoomedMin: null, zoomedMax: null },
        y: { zoomedMin: null, zoomedMax: null }
      };
    }

    dragSubject() {
      const _this = this.context;

      return function(event) {
        /*
         * Do not drag if the Ctrl key, Meta key, or plus cursor mode is
         * not enabled. Also do not drag if zoom-pinching on touchmove
         * events.
         */
        if (!(event.sourceEvent.ctrlKey || event.sourceEvent.metaKey ||
          _this.ui.cursorMode === "plus") || (_this.ui.cursorMode === "minus") ||
          (event.sourceEvent.type === "touchmove" || event.sourceEvent.type === "touchstart") &&
          (event.sourceEvent.touches.length > 1 || event.sourceEvent.targetTouches.length > 1)) {
          return null;
        }

        return {
          x: d3.pointer(event, this)[0],
          y: d3.pointer(event, this)[1]
        };
      };
    }

    drag() {
      const _this = this.context;
      const self = this;

      return {
        start(event) {
          /*
           * Do not drag if the Ctrl key, Meta key, or plus cursor mode is
           * not enabled. Also do not drag if zoom-pinching on touchmove
           * events.
           */
          //   if(!(event.sourceEvent.ctrlKey || event.sourceEvent.metaKey ||
          //          _this.ui.cursorMode === "plus") ||
          //          (event.sourceEvent.type === "touchmove" || event.sourceEvent.type === "touchstart") &&
          //          (event.sourceEvent.touches.length > 1 || event.sourceEvent.targetTouches.length > 1)) {
          //         return;
          //     }

          // self.dragLock = true;
          this.origin = {
            x: d3.pointer(event, this)[0],
            y: d3.pointer(event, this)[1]
          };
          _this.DOM.zoomRect.classed("vzb-invisible", false);
        },

        go(event) {
          const origin = this.origin;
          const mouse = {
            x: event.x,
            y: event.y
          };

          _this.DOM.zoomRect
            .attr("x", Math.min(mouse.x, origin.x))
            .attr("y", Math.min(mouse.y, origin.y))
            .attr("width", Math.abs(mouse.x - origin.x))
            .attr("height", Math.abs(mouse.y - origin.y));
        },

        stop(event) {
          // if (!self.dragLock) return;
          // self.dragLock = false;

          _this.DOM.zoomRect
            .attr("width", 0)
            .attr("height", 0)
            .classed("vzb-invisible", true);

          this.target = {
            x: d3.pointer(event, this)[0],
            y: d3.pointer(event, this)[1]
          };
          if (Math.abs(this.origin.x - this.target.x) < 10 || Math.abs(this.origin.y - this.target.y) < 10) return;

          /*
           * Only compensate for dragging when the Ctrl key or Meta key
           * are pressed, or if the cursorMode is not in plus mode.
           */
          const compensateDragging = event.sourceEvent.ctrlKey ||
            event.sourceEvent.metaKey ||
            _this.ui.cursorMode === "plus";

          self._zoomOnRectangle(
            d3.select(this),
            this.origin.x,
            this.origin.y,
            this.target.x,
            this.target.y,
            compensateDragging, 500
          );
        }
      };
    }

    zoomFilter() {
      const _this = this.context;

      return function(event) {

        if (event.ctrlKey || event.metaKey) return false;

        // Cancel drag lock when zoom-pinching via touchmove events.
        if ((event.type === "touchmove" || event.type === "touchstart") &&
          (event.touches.length > 1 || event.targetTouches.length > 1)) return true;

        if ((event.type === "wheel" || event.type === "mousewheel") &&
          _this.ui.zoomOnScrolling) {
          return true;
        }

        if ((event.type === "mousedown" || event.type === "touchstart") &&
          (_this.ui.cursorMode !== "plus") && (_this.ui.cursorMode !== "minus") &&
          (_this.ui.panWithArrow || _this.ui.cursorMode === "hand")) return true;

        return false;
      };
    }

    zoom() {
      const _this = this.context;
      const zoomer = this.zoomer;
      const self = this;

      return {
        start() {
          //this.savedScale = zoomer.scale;
          if ((_this.ui.cursorMode !== "plus") && (_this.ui.cursorMode !== "minus")) {
            _this.DOM.chartSvg.classed("vzb-zooming", true);
          }

        },
        go(event) {

          const sourceEvent = event.sourceEvent;

          let zoom = event.transform.k;

          let pan = [event.transform.x, event.transform.y];//event.translate;
          let ratioY = zoomer.ratioY;
          let ratioX = zoomer.ratioX;

          _this.draggingNow = true;

          //value protections and fallbacks
          if (isNaN(zoom) || zoom == null) zoom = zoomer.scale;
          if (isNaN(zoom) || zoom == null) zoom = 1;

          //TODO: this is a patch to fix #221. A proper code review of zoom and zoomOnRectangle logic is needed
          /*
           * Mouse wheel and touchmove events set the zoom value
           * independently of axis ratios. If the zoom event was triggered
           * by a mouse wheel event scrolling down or touchmove event with
           * more than 1 contact that sets zoom to 1, then set the axis
           * ratios to 1 as well, which will fully zoom out.
           */
          if (zoom === 1 && sourceEvent !== null &&
            ((sourceEvent.type === "wheel" || sourceEvent.type === "mousewheel") && (sourceEvent.deltaY || -sourceEvent.wheelDelta) > 0 ||
            sourceEvent.type === "touchmove" && sourceEvent.touches.length > 1)) {
            zoomer.ratioX = 1;
            ratioX = 1;
            zoomer.ratioY = 1;
            ratioY = 1;
          }

          if (isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = [0, 0];

          // limit the zooming, so that it never goes below min value of zoom for any of the axes
          const minZoomScale = zoomer.scaleExtent()[0];
          if (zoom * ratioY < minZoomScale) {
            ratioY = minZoomScale / zoom;
            zoomer.ratioY = ratioY;
          }
          if (zoom * ratioX < minZoomScale) {
            ratioX = minZoomScale / zoom;
            zoomer.ratioX = ratioX;
          }

          const zoomXOut = zoom * ratioX < 1;
          const zoomYOut = zoom * ratioY < 1;

          //limit the panning, so that we are never outside the possible range
          if (!zoomXOut) {
            if (pan[0] > 0) pan[0] = 0;
            if (pan[0] < (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;
          } else {
            if (pan[0] < 0) pan[0] = 0;
            if (pan[0] > (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;
          }

          if (!zoomYOut) {
            if (pan[1] > 0) pan[1] = 0;
            if (pan[1] < (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;
          } else {
            if (pan[1] < 0) pan[1] = 0;
            if (pan[1] > (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;
          }

          //limit zoom translate
          self.zoomSelection.property("__zoom", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));

          const xPanOffset = _this.width * zoom * ratioX;
          const yPanOffset = _this.height * zoom * ratioY;

          const xRange = [0 * zoom * ratioX + pan[0], xPanOffset + pan[0]];
          const yRange = [yPanOffset + pan[1], 0 * zoom * ratioY + pan[1]];

          const xRangeBumped = _this._rangeBump(xRange);
          const yRangeBumped = _this._rangeBump(yRange);

          /*
           * Shift xRange and yRange by the difference between the bumped
           * ranges, which is scaled by the zoom factor. This accounts for
           * the range bump, which controls a gutter around the
           * bubblechart, while correctly zooming.
           */
          const xRangeMinOffset = (xRangeBumped[0] - xRange[0]) * zoom * ratioX;
          const xRangeMaxOffset = (xRangeBumped[1] - xRange[1]) * zoom * ratioX;

          const yRangeMinOffset = (yRangeBumped[0] - yRange[0]) * zoom * ratioY;
          const yRangeMaxOffset = (yRangeBumped[1] - yRange[1]) * zoom * ratioY;

          xRange[0] += xRangeMinOffset;
          xRange[1] += xRangeMaxOffset;

          yRange[0] += yRangeMinOffset;
          yRange[1] += yRangeMaxOffset;

          // Calculate the maximum xRange and yRange available.
          const xRangeBounds = [0, _this.width];
          const yRangeBounds = [_this.height, 0];

          const xRangeBoundsBumped = _this._rangeBump(xRangeBounds);
          const yRangeBoundsBumped = _this._rangeBump(yRangeBounds);

          /*
           * Set the pan to account for the range bump by subtracting
           * offsets and preventing panning past the range bump gutter.
           */
          if (!zoomXOut) {
            if (xRange[0] > xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;
            if (xRange[1] < xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;
          } else {
            if (xRange[0] < xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;
            if (xRange[1] > xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;
          }

          if (!zoomYOut) {
            if (yRange[0] < yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;
            if (yRange[1] > yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;
          } else {
            if (yRange[0] > yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;
            if (yRange[1] < yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;
          }

          //zoomer.translate = pan;
          //self.zoomSelection.property("__zoom", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));

          /*
           * Clamp the xRange and yRange by the amount that the bounds
           * that are range bumped.
           *
           * Additionally, take the amount clamped on the end of the range
           * and either subtract or add it to the range's other end. This
           * prevents visible stretching of the range when only panning.
           */
          if (!zoomXOut) {
            if (xRange[0] > xRangeBoundsBumped[0]) {
              xRange[1] -= Math.abs(xRange[0] - xRangeBoundsBumped[0]);
              xRange[0] = xRangeBoundsBumped[0];
            }

            if (xRange[1] < xRangeBoundsBumped[1]) {
              xRange[0] += Math.abs(xRange[1] - xRangeBoundsBumped[1]);
              xRange[1] = xRangeBoundsBumped[1];
            }
          } else {
            if (xRange[0] < xRangeBoundsBumped[0]) {
              xRange[1] += Math.abs(xRange[0] - xRangeBoundsBumped[0]);
              xRange[0] = xRangeBoundsBumped[0];
            }

            if (xRange[1] > xRangeBoundsBumped[1]) {
              xRange[0] -= Math.abs(xRange[1] - xRangeBoundsBumped[1]);
              xRange[1] = xRangeBoundsBumped[1];
            }
          }

          if (!zoomYOut) {
            if (yRange[0] < yRangeBoundsBumped[0]) {
              yRange[1] += Math.abs(yRange[0] - yRangeBoundsBumped[0]);
              yRange[0] = yRangeBoundsBumped[0];
            }

            if (yRange[1] > yRangeBoundsBumped[1]) {
              yRange[0] -= Math.abs(yRange[1] - yRangeBoundsBumped[1]);
              yRange[1] = yRangeBoundsBumped[1];
            }
          } else {
            if (yRange[0] > yRangeBoundsBumped[0]) {
              yRange[1] -= Math.abs(yRange[0] - yRangeBoundsBumped[0]);
              yRange[0] = yRangeBoundsBumped[0];
            }

            if (yRange[1] < yRangeBoundsBumped[1]) {
              yRange[0] += Math.abs(yRange[1] - yRangeBoundsBumped[1]);
              yRange[1] = yRangeBoundsBumped[1];
            }
          }

          if (_this.MDL.x.scale.type === "ordinal") {
            _this.xScale.rangeBands(xRange);
          } else {
            _this.xScale.range(xRange);
          }

          if (_this.MDL.y.scale.type === "ordinal") {
            _this.yScale.rangeBands(yRange);
          } else {
            _this.yScale.range(yRange);
          }

          const formatter = function(n) {
            return sharedComponents.LegacyUtils.isDate(n) ? n : +n.toFixed(2);
          };

          const zoomedXRange = xRangeBoundsBumped;
          const zoomedYRange = yRangeBoundsBumped;

          /*
           * Set the zoomed min/max to the correct value depending on if the
           * min/max values lie within the range bound regions.
           */
          /*
           if(!zoomXOut) {
           zoomedXRange[0] = xRangeBounds[0] > xRange[0] ? xRangeBounds[0] : xRange[0];
           zoomedXRange[1] = xRangeBounds[1] < xRange[1] ? xRangeBounds[1] : xRange[1];
           }

           if(!zoomYOut) {
           zoomedYRange[0] = yRangeBounds[0] < yRange[0] ? yRangeBounds[0] : yRange[0];
           zoomedYRange[1] = yRangeBounds[1] > yRange[1] ? yRangeBounds[1] : yRange[1];
           }
           */

          _this._zoomedXYMinMax = {
            x: {
              zoomedMin: formatter(_this.xScale.invert(zoomedXRange[0])),
              zoomedMax: formatter(_this.xScale.invert(zoomedXRange[1]))
            },
            y: {
              zoomedMin: formatter(_this.yScale.invert(zoomedYRange[0])),
              zoomedMax: formatter(_this.yScale.invert(zoomedYRange[1]))
            }
          };

          //TODO/*avoid storing it in URL*/
          if (!zoomer.dontFeedToState) {
            // _this.ui.panzoom = {
            //   x: Object.assign({}, _this._zoomedXYMinMax.x),
            //   y: Object.assign({}, _this._zoomedXYMinMax.y),          
            // }
            _this.MDL.x.scale.zoomed = [_this._zoomedXYMinMax.x.zoomedMin, _this._zoomedXYMinMax.x.zoomedMax];
            _this.MDL.y.scale.zoomed = [_this._zoomedXYMinMax.y.zoomedMin, _this._zoomedXYMinMax.y.zoomedMax];
          }

          const optionsY = _this.yAxis.labelerOptions();
          const optionsX = _this.xAxis.labelerOptions();
          optionsY.limitMaxTickNumber = zoom * ratioY < 1.5 ? 8 : zoom * ratioY * 8;
          optionsX.limitMaxTickNumber = zoom * ratioX < 1.5 ? 8 : zoom * ratioX * 8;
          optionsY.transitionDuration = zoomer.duration;
          optionsX.transitionDuration = zoomer.duration;

          _this.DOM.xAxisEl.call(_this.xAxis.labelerOptions(optionsX));
          _this.DOM.yAxisEl.call(_this.yAxis.labelerOptions(optionsY));
          _this.redrawData(zoomer.duration);
          //_this._trails.run("resize", null, zoomer.duration);

          zoomer.duration = 0;
        },

        stop() {
          _this.DOM.chartSvg.classed("vzb-zooming", false);
          // if (this.quitZoom) return;

          //Force the update of the URL and history, with the same values
          if (!zoomer.dontFeedToState) {
            // _this.ui.panzoom = {
            //   x: Object.assign({}, _this._zoomedXYMinMax.x),
            //   y: Object.assign({}, _this._zoomedXYMinMax.y),          
            // }
            _this.MDL.x.scale.zoomed = [_this._zoomedXYMinMax.x.zoomedMin, _this._zoomedXYMinMax.x.zoomedMax];
            _this.MDL.y.scale.zoomed = [_this._zoomedXYMinMax.y.zoomedMin, _this._zoomedXYMinMax.y.zoomedMax];
            //_this.model.marker.set(_this._zoomedXYMinMax, true, true);
          }
          zoomer.dontFeedToState = null;

          _this.draggingNow = false;
        }
      };
    }

    expandCanvas(duration) {
      const _this = this.context;
      if (!duration) duration = _this.duration;

      //d3 extent returns min and max of the input array as [min, max]
      const mmX = d3.extent(sharedComponents.LegacyUtils.values(_this.frame.x));
      const mmY = d3.extent(sharedComponents.LegacyUtils.values(_this.frame.y));

      //protection agains unreasonable min-max results -- abort function
      if (!mmX[0] && mmX[0] !== 0 || !mmX[1] && mmX[1] !== 0 || !mmY[0] && mmY[0] !== 0 || !mmY[1] && mmY[1] !== 0) {
        return sharedComponents.LegacyUtils.warn("panZoom.expandCanvas: X or Y min/max are broken. Aborting with no action");
      }
      /*
       * Use a range bumped scale to correctly accommodate the range bump
       * gutter.
       */
      const suggestedFrame = {
        x1: _this.xScale(mmX[0]),
        y1: _this.yScale(mmY[0]),
        x2: _this.xScale(mmX[1]),
        y2: _this.yScale(mmY[1])
      };
      const xBounds = [0, _this.width];
      const yBounds = [_this.height, 0];

      // Get the current zoom frame based on the current dimensions.
      const frame = {
        x1: xBounds[0],
        x2: xBounds[1],
        y1: yBounds[0],
        y2: yBounds[1]
      };

      const TOLERANCE = 0.0;

      /*
       * If there is no current zoom frame, or if any of the suggested frame
       * points extend outside of the current zoom frame, then expand the
       * canvas.
       */
      if (!_this.isCanvasPreviouslyExpanded ||
        suggestedFrame.x1 < frame.x1 * (1 - TOLERANCE) || suggestedFrame.x2 > frame.x2 * (1 + TOLERANCE) ||
        suggestedFrame.y2 < frame.y2 * (1 - TOLERANCE) || suggestedFrame.y1 > frame.y1 * (1 + TOLERANCE)) {
        /*
         * If there is already a zoom frame, then clamp the suggested frame
         * points to only zoom out and expand the canvas.
         *
         * If any of x1, x2, y1, or y2 is within the current frame
         * boundaries, then clamp them to the frame boundaries. If any of
         * the above values will translate into a data value that is outside
         * of the possible data range, then clamp them to the frame
         * coordinate that corresponds to the maximum data value that can
         * be displayed.
         */
        if (_this.isCanvasPreviouslyExpanded) {
          /*
           * Calculate bounds and bumped scale for calculating the data boundaries
           * to which the suggested frame points need to be clamped.
           */
          const xBoundsBumped = _this._rangeBump(xBounds);
          const yBoundsBumped = _this._rangeBump(yBounds);

          if (suggestedFrame.x1 > xBoundsBumped[0]) suggestedFrame.x1 = xBoundsBumped[0];
          if (suggestedFrame.x2 < xBoundsBumped[1]) suggestedFrame.x2 = xBoundsBumped[1];
          if (suggestedFrame.y1 < yBoundsBumped[0]) suggestedFrame.y1 = yBoundsBumped[0];
          if (suggestedFrame.y2 > yBoundsBumped[0]) suggestedFrame.y2 = yBoundsBumped[1];
        }

        _this.isCanvasPreviouslyExpanded = true;
        this._zoomOnRectangle(_this.element, suggestedFrame.x1, suggestedFrame.y1,
          suggestedFrame.x2, suggestedFrame.y2, false, duration);
      } else {
        _this.redrawDataPoints(duration);
      }
    }

    zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, duration, dontFeedToState) {
      const _this = this.context;
      let minX = zoomedMinX;
      let maxX = zoomedMaxX;
      let minY = zoomedMinY;
      let maxY = zoomedMaxY;

      const xDomain = _this.xScale.domain();
      const yDomain = _this.yScale.domain();

      /*
       * Prevent zoomout if only one of zoom edges set outside domain
       */
      if (minX < xDomain[0] && maxX < xDomain[1]) minX = xDomain[0];
      if (minX > xDomain[0] && maxX > xDomain[1]) maxX = xDomain[1];
      if (minY < yDomain[0] && maxY < yDomain[1]) minY = yDomain[0];
      if (minY > yDomain[0] && maxY > yDomain[1]) maxY = yDomain[1];


      const xRange = [_this.xScale(minX), _this.xScale(maxX)];
      const yRange = [_this.yScale(minY), _this.yScale(maxY)];


      this._zoomOnRectangle(_this.element, xRange[0], yRange[0], xRange[1], yRange[1], false, duration, dontFeedToState);
    }

    _zoomOnRectangle(element, zoomedX1, zoomedY1, zoomedX2, zoomedY2, compensateDragging, duration, dontFeedToState) {
      const _this = this.context;
      const zoomer = this.zoomer;
      const transform = d3.zoomTransform(this.zoomSelection.node());

      const x1 = zoomedX1;
      const y1 = zoomedY1;
      const x2 = zoomedX2;
      const y2 = zoomedY2;

      /*
       * When dragging to draw a rectangle, the translate vector has (x2 - x1)
       * added to zoomer.translate()[0], and (y2 - 1) added to
       * zoomer.translate()[1].
       *
       * We need to compensate for this addition when
       * zooming with a rectangle, because zooming with a rectangle will
       * update the translate vector with new values based on the rectangle
       * dimensions.
       */
      if (compensateDragging) {
        transform.translate(
          x1 - x2,
          y1 - y2
        );
      }

      const xRangeBounds = [0, _this.width];
      const yRangeBounds = [_this.height, 0];

      const xRangeBoundsBumped = _this._rangeBump(xRangeBounds);
      const yRangeBoundsBumped = _this._rangeBump(yRangeBounds);

      const minZoom = zoomer.scaleExtent()[0];
      const maxZoom = zoomer.scaleExtent()[1];
      let zoom, ratioX, ratioY;

      if (x1 == x2 || y1 == y2 || xRangeBoundsBumped[0] == xRangeBoundsBumped[1] || yRangeBoundsBumped[0] == yRangeBoundsBumped[1]) {
        return sharedComponents.LegacyUtils.warn("_zoomOnRectangle(): can not proceed because this may result in infinity zooms");
      }

      if (Math.abs(x1 - x2) > Math.abs(y1 - y2)) {
        zoom = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k;

        /*
         * Clamp the zoom scalar to the maximum zoom allowed before
         * calculating the next ratioX and ratioY.
         */
        if (zoom < minZoom) {
          zoomer.ratioY *= zoom / transform.k;
          zoom = minZoom;
        }
        if (zoom > maxZoom) zoom = maxZoom;

        ratioX = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k / zoom * zoomer.ratioX;
        ratioY = zoomer.ratioY;
      } else {
        zoom = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k;

        /*
         * Clamp the zoom scalar to the maximum zoom allowed before
         * calculating the next ratioX and ratioY.
         */
        if (zoom < minZoom) {
          zoomer.ratioX *= zoom / transform.k;
          zoom = minZoom;
        }
        if (zoom > maxZoom) zoom = maxZoom;

        ratioY = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k / zoom * zoomer.ratioY;
        ratioX = zoomer.ratioX;
      }

      const pan = [
        (transform.x - Math.min(x1, x2)) / transform.k / zoomer.ratioX * zoom * ratioX + (xRangeBoundsBumped[0] - xRangeBounds[0]),
        (transform.y - Math.min(y1, y2)) / transform.k / zoomer.ratioY * zoom * ratioY + (yRangeBoundsBumped[1] - yRangeBounds[1])
      ];

      zoomer.dontFeedToState = dontFeedToState;
      zoomer.ratioY = ratioY || 1; //NaN defaults to 1
      zoomer.ratioX = ratioX || 1; //NaN defaults to 1
      zoomer.duration = duration ? duration : 0;

      this.zoomSelection.call(zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));
    }

    /*
     * Incrementally zoom in or out and pan the view so that it never looses the point where click happened
     * this function is a modified d3's own zoom behavior on double click
     * for the original code see https://github.com/mbostock/d3/blob/master/src/behavior/zoom.js
     * function dblclicked() and what it refers to
     */
    zoomByIncrement(event, direction, duration) {
      const transform = d3.zoomTransform(this.zoomSelection.node());

      let ratio = transform.k;
      const pan = [transform.x, transform.y];

      const mouse = d3.pointer(event, this.zoomSelection.node());
      let k = Math.log(ratio) / Math.LN2;

      //change factor direction based on the input. default is no direction supplied
      if (direction == "plus" || !direction) k = Math.floor(k) + 1;
      if (direction == "minus") k = Math.ceil(k) - 1;

      //decode panning
      let locus = [(mouse[0] - pan[0]) / ratio, (mouse[1] - pan[1]) / ratio];

      //recalculate zoom ratio
      const scaleExtent = this.zoomer.scaleExtent();
      if (ratio == scaleExtent[0]) {
        this.zoomer.ratioY = 1;
        this.zoomer.ratioX = 1;
      }
      ratio = Math.max(scaleExtent[0], Math.min(scaleExtent[1], Math.pow(2, k)));

      //recalculate panning
      locus = [locus[0] * ratio + pan[0], locus[1] * ratio + pan[1]];
      pan[0] += mouse[0] - locus[0];
      pan[1] += mouse[1] - locus[1];

      this.zoomer.duration = duration || 0;
      this.zoomSelection.call(this.zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(ratio));

    }

    /*
     * Reset zoom values without triggering a zoom event.
     */
    resetZoomState(element) {
      this.zoomer.ratioY = 1;
      this.zoomer.ratioX = 1;
      (element || this.zoomSelection).property("__zoom", d3.zoomIdentity);
    }

    reset(element, duration) {
      const _this = this.context;
      _this.isCanvasPreviouslyExpanded = false;

      this.zoomer.ratioY = 1;
      this.zoomer.ratioX = 1;
      this.zoomer.duration = duration || 0;
      (element || this.zoomSelection).call(this.zoomer.transform, d3.zoomIdentity);
    }

    rerun(element) {
      (element || this.zoomSelection).call(this.zoomer.scaleBy, 1);
    }

    zoomSelection(element) {
      this.zoomSelection = element;
    }

  }

  const {ICON_QUESTION} = sharedComponents.Icons;

  class BCAxisTitles extends sharedComponents.BaseComponent {

    constructor(config) {
      config.template = `
      <g class="vzb-bc-axis-x-title"><text></text></g>
      <g class="vzb-bc-axis-y-title"><text></text></g>
      <g class="vzb-bc-axis-s-title"><text></text></g>
      <g class="vzb-bc-axis-x-subtitle"><text></text></g>
      <g class="vzb-bc-axis-y-subtitle"><text></text></g>
      <g class="vzb-bc-axis-x-info vzb-noexport"></g>
      <g class="vzb-bc-axis-y-info vzb-noexport"></g>
    `;
      super(config);
    }

    setup(){
      this.DOM = {
        xTitle: this.element.select(".vzb-bc-axis-x-title"),
        yTitle: this.element.select(".vzb-bc-axis-y-title"),
        sTitle: this.element.select(".vzb-bc-axis-s-title"),
        xSubTitle: this.element.select(".vzb-bc-axis-x-subtitle"),
        ySubTitle: this.element.select(".vzb-bc-axis-y-subtitle"),
        xInfo: this.element.select(".vzb-bc-axis-x-info"),
        yInfo: this.element.select(".vzb-bc-axis-y-info")
      };

      this.axisTitleComplimentStrings = {Y: "", X: "", S: "", C: ""};

      this._initInfoElements();
    }

    draw(){
      this.localise = this.services.locale.auto();

      this.addReaction(this.updateUIStrings);
      this.addReaction(this.updateTreemenu);
      this.addReaction(this.updateSize);
      this.addReaction(this.updateInfoElements);
    }

    get MDL(){
      return {
        y: this.model.encoding[this.parent.state.alias?.y || "y"],
        x: this.model.encoding[this.parent.state.alias?.x || "x"],
        size: this.model.encoding.size,
        color: this.model.encoding.color
      };
    }

    updateTreemenu(){
      const treemenu = this.root.findChild({type: "TreeMenu"});

      this.DOM.yTitle
        .classed("vzb-disabled", treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .on("click", () => {
          treemenu
            .encoding(this.parent._alias("y"))
            .alignX(this.services.locale.isRTL() ? "right" : "left")
            .alignY("top")
            .updateView()
            .toggle();
        });

      this.DOM.xTitle
        .classed("vzb-disabled", treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .on("click", () => {
          treemenu
            .encoding(this.parent._alias("x"))
            .alignX(this.services.locale.isRTL() ? "right" : "left")
            .alignY("bottom")
            .updateView()
            .toggle();
        });    
    }

    updateUIStrings() {
      const {
        y, x, size, color
      } = this.MDL;

      this.strings = {
        title: {
          Y: sharedComponents.Utils.getConceptName(y, this.localise),
          X: sharedComponents.Utils.getConceptName(x, this.localise),
          S: sharedComponents.Utils.getConceptName(size, this.localise),
          C: sharedComponents.Utils.getConceptName(color, this.localise)
        },
        title_short: {
          Y: sharedComponents.Utils.getConceptShortName(y, this.localise),
          X: sharedComponents.Utils.getConceptShortName(x, this.localise),
          S: sharedComponents.Utils.getConceptShortName(size, this.localise),
          C: sharedComponents.Utils.getConceptShortName(color, this.localise)
        },
        subtitle: {
          Y: sharedComponents.Utils.getConceptNameMinusShortName(y, this.localise),
          X: sharedComponents.Utils.getConceptNameMinusShortName(x, this.localise)
        },
        unit: {
          Y: sharedComponents.Utils.getConceptUnit(y),
          X: sharedComponents.Utils.getConceptUnit(x),
          S: sharedComponents.Utils.getConceptUnit(size),
          C: sharedComponents.Utils.getConceptUnit(color)
        }
      };

      Promise.all([
        sharedComponents.Utils.getConceptNameCompliment(y),
        sharedComponents.Utils.getConceptNameCompliment(x),
        sharedComponents.Utils.getConceptNameCompliment(size),
        sharedComponents.Utils.getConceptNameCompliment(color)
      ]).then(mobx.action(response => {        
        [ 
          this.axisTitleComplimentStrings.Y,
          this.axisTitleComplimentStrings.X,
          this.axisTitleComplimentStrings.S,
          this.axisTitleComplimentStrings.C
        ] = response;
      }));
    }


    _initInfoElements() {
      const _this = this;
      const dataNotesDialog = () => this.root.findChild({type: "DataNotes"});
      const timeSlider = () => this.root.findChild({type: "TimeSlider"});

      sharedComponents.LegacyUtils.setIcon(this.DOM.yInfo, ICON_QUESTION)
        .on("click", () => {
          dataNotesDialog().pin();
        })
        .on("mouseover", function() {
          if (timeSlider().ui.dragging) return;
          const rect = this.getBBox();
          const coord = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
          const toolRect = _this.root.element.node().getBoundingClientRect();
          const chartRect = _this.element.node().getBoundingClientRect();
          dataNotesDialog()
            .setEncoding(_this.MDL.y)
            .show()
            .setPos(coord.x + chartRect.left - toolRect.left, coord.y);
        })
        .on("mouseout", () => {
          if (timeSlider().ui.dragging) return;
          dataNotesDialog().hide();
        });

      sharedComponents.LegacyUtils.setIcon(this.DOM.xInfo, ICON_QUESTION)
        .on("click", () => {
          dataNotesDialog().pin();
        })
        .on("mouseover", function() {
          if (timeSlider().ui.dragging) return;
          const rect = this.getBBox();
          const coord = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
          const toolRect = _this.root.element.node().getBoundingClientRect();
          const chartRect = _this.element.node().getBoundingClientRect();
          dataNotesDialog()
            .setEncoding(_this.MDL.x)
            .show()
            .setPos(coord.x + chartRect.left - toolRect.left, coord.y);
        })
        .on("mouseout", () => {
          if (timeSlider().ui.dragging) return;
          dataNotesDialog().hide();
        });
    }

    updateInfoElements() {
      this.services.layout.size;
      this.axisTitleComplimentStrings.X;
      this.axisTitleComplimentStrings.Y;

      const {xInfo, yInfo, xTitle, yTitle} = this.DOM;
      const {x, y} = this.MDL;
      const isRTL = this.services.locale.isRTL();
      const infoElHeight = this.parent.profileConstants.infoElHeight;
      const layoutProfile = this.services.layout.profile;

      if (yInfo.select("svg").node()) {
        const titleBBox = yTitle.node().getBBox();
        const t = sharedComponents.LegacyUtils.transform(yTitle.node());
        const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);
        const vTranslate = isRTL ? (t.translateY + infoElHeight * 1.4 + titleBBox.width * 0.5) : (t.translateY - infoElHeight * 0.4 - titleBBox.width * 0.5);
        const conceptPropsY = y.data.conceptProps;

        yInfo
          .classed("vzb-hidden", !conceptPropsY.description && !conceptPropsY.sourceLink || this.services.layout.projector)
          .attr("transform", layoutProfile !== "SMALL" ?
            `translate(${ t.translateX - infoElHeight * 0.8 }, ${ vTranslate }) rotate(-90)` :
            `translate(${ hTranslate },${ t.translateY - infoElHeight * 0.8 })`)
          .select("svg")
          .attr("width", infoElHeight + "px")
          .attr("height", infoElHeight + "px");
      }

      if (xInfo.select("svg").node()) {
        const titleBBox = xTitle.node().getBBox();
        const t = sharedComponents.LegacyUtils.transform(xTitle.node());
        const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);
        const conceptPropsX = x.data.conceptProps;

        xInfo
          .classed("vzb-hidden", !conceptPropsX.description && !conceptPropsX.sourceLink || this.services.layout.projector)
          .attr("transform", `translate(${ hTranslate }, ${ t.translateY - infoElHeight * 0.8 })`)
          .select("svg")
          .attr("width", infoElHeight + "px")
          .attr("height", infoElHeight + "px");
      }
    }


    _updateSTitle(width = this.parent.width, height = this.parent.height) {
      const { sTitle } = this.DOM;
      const { size, color } = this.MDL;
      const compl = this.axisTitleComplimentStrings;
      
      // vertical text about size and color
      const invisible = this.parent.profileConstants.hideSTitle
        && this.root.ui.dialogs.dialogs.sidebar.includes("colors")
        && this.root.ui.dialogs.dialogs.sidebar.includes("size");

      sTitle.classed("vzb-invisible", invisible);
      if (invisible) return;

      const sTitleContent = !size.data.constant 
        ? this.localise("buttons/size") + ": " + this.strings.title.S + (compl.S ? " · " + compl.S : "")
        : "";
      const cTitleContent = !color.data.constant 
        ? this.localise("buttons/colors") + ": " + this.strings.title.C + (compl.C ? " · " + compl.C : "") 
        : "";

      const sTitleText = sTitle
        .attr("text-anchor", "end")
        .attr("transform", "translate(" + width + "," + 20 + ") rotate(-90)")
        .select("text")
        .style("font-size", null) // reset font size to remove jumpy measurement
        .text(sTitleContent + (sTitleContent && cTitleContent ? ", " : "") + cTitleContent);

      // reduce font size if the caption doesn't fit
      const sTitleWidth = sTitleText.node().getBBox().width;
      const padding = 30;
      const font = parseInt(sTitleText.style("font-size")) * (height - padding) / sTitleWidth;
      sTitleText.style("font-size", sTitleWidth > (height - padding) ? font + "px" : null);
    }


    _updateYTitle(width = this.parent.width, height = this.parent.height) {
      const { yTitle, ySubTitle } = this.DOM;

      const { 
        margin, 
        infoElHeight, 
        yAxisTitleBottomMargin, 
      } = this.parent.profileConstants;

      const layoutProfile = this.services.layout.profile;

      const compl = this.axisTitleComplimentStrings;
      const isRTL = this.services.locale.isRTL();

      if (layoutProfile !== "SMALL") {
        ySubTitle
          .attr("transform", "translate(" + 0 + "," + 0 + ") rotate(-90)")
          .select("text")
          .attr("dy", infoElHeight * 0.6)
          .style("font-size", (infoElHeight * 0.8) + "px")
          .text(this.strings.subtitle.Y);
        
        const yTitleText = yTitle.select("text")
          .style("font-size", infoElHeight + "px")
          .text(this.strings.title_short.Y + (compl.Y ? " · " + compl.Y : ""));

        yTitleText.append("tspan")
          .classed("vzb-noexport", true)
          .style("font-size", (infoElHeight * 0.7) + "px")
          .attr("dx", ( (isRTL ? -1 : 1) * infoElHeight * 0.25) + "px")
          .text("▼");

        const doesntFit = yTitle.node().getBBox().width > height; 
        
        yTitle
          .attr("text-anchor", doesntFit ? "start" : "middle")
          .attr("transform", "translate(" + (-margin.left - yAxisTitleBottomMargin)  + "," + (doesntFit ? (isRTL ? 0 : height) : height / 2 ) + ") rotate(-90)");

      } else {
        ySubTitle.select("text").text("");

        const yTitleText = yTitle
          .select("text")
          .text(this.strings.title.Y + (compl.Y ? " · " + compl.Y : ""));
          
        const doesntFit = yTitleText.node().getBBox().width > width; 
        if (doesntFit) yTitleText.text(this.strings.title_short.Y + (compl.Y ? " · " + compl.Y : ""));
        
        yTitle
          .attr("text-anchor", "start")
          .attr("transform", "translate(" + (isRTL ? width : 10 - margin.left) + ", -" + yAxisTitleBottomMargin + ")");
      }
    }


    _updateXTitle(width = this.parent.width, height = this.parent.height) {
      const { xTitle, xSubTitle } = this.DOM;

      const { 
        margin, 
        infoElHeight, 
        xAxisTitleBottomMargin, 
      } = this.parent.profileConstants;

      const layoutProfile = this.services.layout.profile;

      const compl = this.axisTitleComplimentStrings;
      const isRTL = this.services.locale.isRTL();

      if (layoutProfile !== "SMALL") {
        xSubTitle
          .attr("transform", "translate(" + width + "," + height + ")")
          .select("text")
          .attr("dy", -infoElHeight * 0.3)
          .style("font-size", (infoElHeight * 0.8) + "px")
          .text(this.strings.subtitle.X);
        
        const xTitleText = xTitle.select("text")
          .style("font-size", infoElHeight + "px")
          .text(this.strings.title_short.X + (compl.X ? " · " + compl.X : ""));

        xTitleText 
          .append("tspan")
          .classed("vzb-noexport", true)
          .style("font-size", (infoElHeight * 0.7) + "px")
          .attr("dx", ( (isRTL ? -1 : 1) * infoElHeight * 0.25) + "px")
          .text("▼");

      } else {
        xSubTitle.select("text").text("");

        xTitle.select("text")        
          .text(this.strings.title.X + (compl.X ? " · " + compl.X : ""));
      }

      const doesntFit = xTitle.node().getBBox().width > width - 100;
      xTitle
        .attr("text-anchor", doesntFit ? "start" : "middle")
        .attr("transform", "translate(" + (doesntFit ? (isRTL ? width : 0) : width / 2) + "," + (height + margin.bottom - xAxisTitleBottomMargin) + ")");
      
      if (doesntFit && layoutProfile === "SMALL") xTitle.select("text").text(this.strings.title_short.X) + (compl.X ? " · " + compl.X : ""); 
    }


    updateSize() {
      this.services.layout.size;
   
      const { 
        margin, 
        leftMarginRatio 
      } = this.parent.profileConstants;

      const height = (this.parent.elementHeight - margin.top - margin.bottom) || 0;
      const width = (this.parent.elementWidth - margin.left * leftMarginRatio - margin.right) || 0;

      this._updateSTitle(width, height);
      this._updateYTitle(width, height);
      this._updateXTitle(width, height);
      
    }
  }

  const decorated = mobx.decorate(BCAxisTitles, {
    "MDL": mobx.computed,
    "axisTitleComplimentStrings": mobx.observable
  });

  class BCDecorations{
    constructor(){
    }
    
    update(duration) {
      const _this = this;

      const uiSetting = this.ui.decorations;
      const layoutProfile = this.services.layout.profile;
      const margin = this.profileConstants.margin;
      
      // x axis groups used for incomes
      const showxAxisGroups = uiSetting.xAxisGroups 
        && uiSetting.xAxisGroups[this.MDL.x.data.concept] 
        && uiSetting.enabled
        && layoutProfile !== "SMALL";
      
      this.DOM.xAxisGroupsEl.classed("vzb-invisible", !showxAxisGroups);
      if (showxAxisGroups) {
        const axisGroupsData = sharedComponents.Utils.injectIndexes(uiSetting.xAxisGroups[this.MDL.x.data.concept]);
        let xAxisGroups = this.DOM.xAxisGroupsEl.selectAll(".vzb-bc-x-axis-group").data(axisGroupsData);
        
        xAxisGroups.exit().remove();
        xAxisGroups = xAxisGroups.enter().append("g").attr("class", "vzb-bc-x-axis-group")
          .each(function(){
            const view = d3.select(this);
            view.append("text").attr("class", "vzb-bc-x-axis-group-line").text("◆").style("text-anchor","middle");
            view.append("text").attr("class", "vzb-bc-x-axis-group-text");
          })
          .merge(xAxisGroups);
        
        const xAxisGroups_calcs = [];
        let useShorterLabels = false;
        
        // first pass: calculate label text sizes and margins
        xAxisGroups.each(function(d, i){
          const view = d3.select(this);
          
          const text = view.select("text.vzb-bc-x-axis-group-text")
            .text(_this.localise(d.label));
          
          const calcs = {min: d.min, max: d.max};
          
          calcs.textHeight = text.node().getBBox().height;
          calcs.textWidth = text.node().getBBox().width;
          
          calcs.boundaryMinX_px = _this.xScale(d.min || d.min === 0? d.min : d3.min(_this.xScale.domain())) || 0;
          calcs.boundaryMaxX_px = _this.xScale(d.max || d.max === 0? d.max : d3.max(_this.xScale.domain())) || 0;
          
          calcs.centerX_px = (calcs.boundaryMinX_px + calcs.boundaryMaxX_px) / 2;
          calcs.marginX_px = (Math.abs(calcs.boundaryMinX_px - calcs.boundaryMaxX_px) - calcs.textWidth) / 2;
          
          if (calcs.marginX_px - calcs.textHeight < 0) useShorterLabels = true;
          
          xAxisGroups_calcs[i] = calcs;
        });
        
        // second pass: if at least one of labels doesn't fit, switch to compact mode and recalculate text sizes and margins
        if (useShorterLabels) {
          xAxisGroups.each(function(d, i){
            const view = d3.select(this);

            const text = view.select("text.vzb-bc-x-axis-group-text")
              .text(_this.localise(d.label_short));

            const calcs = xAxisGroups_calcs[i];

            calcs.textWidth = text.node().getBBox().width;
            calcs.marginX_px = (Math.abs(calcs.boundaryMinX_px - calcs.boundaryMaxX_px) - calcs.textWidth) / 2;

            xAxisGroups_calcs[i] = calcs;
          });
        }
        
        // third pass: actually put labels in places
        xAxisGroups.each(function(d, i){
          const view = d3.select(this);
          
          const isFirst = (i == 0);
          const isLast = (i == xAxisGroups_calcs.length - 1);
          const calcs = xAxisGroups_calcs[i];
          const minMargin = calcs.textHeight/4;
          let x = calcs.centerX_px;
          
          if (isFirst) x = xAxisGroups_calcs[i+1].boundaryMinX_px - Math.max(xAxisGroups_calcs[i+1].marginX_px, minMargin);
          if (isLast) x = xAxisGroups_calcs[i-1].boundaryMaxX_px + Math.max(xAxisGroups_calcs[i-1].marginX_px, minMargin);
          
          view.select("text.vzb-bc-x-axis-group-text")
            .style("text-anchor", isFirst ? "end" : isLast ? "start" : "middle")
            .transition()
            .duration(duration || 0)
            .attr("dy", "-0.2em")
            .attr("y", calcs.textHeight)
            .attr("x", x);
          
          view.select("text.vzb-bc-x-axis-group-line")
            .classed("vzb-invisible", isLast)
            .transition()
            .duration(duration || 0)
            .attr("dy", "-0.2em")
            .attr("y", calcs.textHeight * 0.9)
            .attr("x", calcs.boundaryMaxX_px);
        });
        
        xAxisGroups.select("text.vzb-bc-x-axis-group-text").on("mouseenter", function(event, d) {
          const calcs = xAxisGroups_calcs[d.i];
          const parentView = d3.select(this.parentNode);
    
          d3.select(this).attr("font-weight", "bold");
          parentView.append("rect").lower()
            .attr("x", calcs.boundaryMinX_px)
            .attr("width", calcs.boundaryMaxX_px - calcs.boundaryMinX_px)
            .attr("y", - margin.top)
            .attr("height", _this.height + margin.top);
    
          if (calcs.min || calcs.min === 0) parentView.append("line").lower()
            .attr("x1", calcs.boundaryMinX_px)
            .attr("x2", calcs.boundaryMinX_px)
            .attr("y1", - margin.top)
            .attr("y2", _this.height);
    
          if (calcs.max || calcs.max === 0) parentView.append("line").lower()
            .attr("x1", calcs.boundaryMaxX_px)
            .attr("x2", calcs.boundaryMaxX_px)
            .attr("y1", - margin.top)
            .attr("y2", _this.height);
    
        }).on("mouseleave", function() {
          const parentView = d3.select(this.parentNode);
    
          d3.select(this).attr("font-weight", null);
          parentView.selectAll("rect").remove();
          parentView.selectAll("line").remove();
        });
      }    
      
      // diagonal line that is used when the same idicator ID is used for both axis X and Y
      const showLineEqualXY = 
        this.MDL.x.data.concept == this.MDL.y.data.concept 
        && uiSetting.enabled
        && layoutProfile !== "SMALL";
      
      this.DOM.lineEqualXY.classed("vzb-invisible", !showLineEqualXY);

      if (showLineEqualXY) {
        this.MDL.x.scale.type; //watch
        this.MDL.y.scale.type; //watch

        const domains = this.yScale.domain().concat(this.xScale.domain()),
          min = d3.min(domains), 
          max = d3.max(domains), 
          step = (max-min)/100;

        const sequence = d3.range(min, max, step).concat(max);

        const line = d3.line()
          .curve(d3.curveBasis)
          .x(d => this.xScale(d))
          .y(d => this.yScale(d));

        this.DOM.lineEqualXY
          .transition()
          .duration(duration || 0)
          .attr("d", line(sequence));
      }
    }
  }

  const COLOR_WHITEISH = "rgb(253, 253, 253)";
  const COLOR_BLACKISH = "rgb(51, 51, 51)";
  const THICK_LINE_THRESHOLD_FOR_DARKER_COLOR = 3;

  const marginScaleH = (marginMin, ratio = 0) => height => marginMin + height * ratio;
  const marginScaleW = (marginMin, ratio = 0) => width => marginMin + width * ratio;

  function isTrailBubble(d){
    return !!d[Symbol.for("trailHeadKey")];
  }

  const MAX_RADIUS_EM = 0.05;

  const PROFILE_CONSTANTS = (width, height) => ({
    SMALL: {
      margin: { top: 30, bottom: 35, left: 30, right: 10},
      leftMarginRatio: 1,
      padding: 2,
      minRadiusPx: 0.5,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
      minTrailThicknessPx: 1,
      maxTrailThicknessPx: 4,
      infoElHeight: 16,
      yAxisTitleBottomMargin: 6,
      xAxisTitleBottomMargin: 4
    },
    MEDIUM: {
      margin: { top: 15, bottom: 40, left: 40, right: 15},
      leftMarginRatio: 1.6,
      padding: 2,
      minRadiusPx: 1,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
      minTrailThicknessPx: 2,
      maxTrailThicknessPx: 6,
      infoElHeight: 20,
      yAxisTitleBottomMargin: 3,
      xAxisTitleBottomMargin: 4
    },
    LARGE: {
      margin: { top: 15, bottom: marginScaleH(30, 0.03)(height), left: marginScaleW(31, 0.015)(width), right: 20},
      leftMarginRatio: 1.8,
      padding: 2,
      minRadiusPx: 1,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
      minTrailThicknessPx: 2,
      maxTrailThicknessPx: 8,
      infoElHeight: 22,
      yAxisTitleBottomMargin: 3,//marginScaleH(4, 0.01)(height),
      xAxisTitleBottomMargin: marginScaleH(0, 0.01)(height),
      hideSTitle: true
    }
  });

  const PROFILE_CONSTANTS_FOR_PROJECTOR = (width, height) => ({
    MEDIUM: {
      margin: { top: 20, bottom: 55, left: 50, right: 20 },
      yAxisTitleBottomMargin: 3,
      xAxisTitleBottomMargin: 4,
      infoElHeight: 26,
    },
    LARGE: {
      margin: { top: 30, bottom: marginScaleH(45, 0.03)(height), left: marginScaleW(35, 0.025)(width), right: 30 },
      yAxisTitleBottomMargin: 3,//marginScaleH(4, 0.01)(height),
      xAxisTitleBottomMargin: marginScaleH(-5, 0.01)(height),
      infoElHeight: 32,
      hideSTitle: true
    }
  });

  // BUBBLE CHART COMPONENT
  class _VizabiBubbleChart extends sharedComponents.Chart {

    constructor(config) {
      config.subcomponents = [{
        type: sharedComponents.Labels,
        placeholder: ".vzb-bc-labels",      
        options: {
          CSS_PREFIX: "vzb-bc",
          LABELS_CONTAINER_CLASS: "vzb-bc-labels",
          LINES_CONTAINER_CLASS: "vzb-bc-lines",
          SUPPRESS_HIGHLIGHT_DURING_PLAY: false
        },
        name: "labels"
      },{
        type: sharedComponents.DateTimeBackground,
        placeholder: ".vzb-bc-date"
      },{
        type: decorated,
        placeholder: ".vzb-bc-axis-titles"
      }];

      config.template = `
      <svg class="vzb-bubblechart-svg vzb-export">
          <svg class="vzb-bubblechart-svg-back">
              <g class="vzb-bc-graph">
                  <g class="vzb-bc-date"></g>
                  <svg class="vzb-bc-axis-x"><g></g></svg>
                  <svg class="vzb-bc-axis-y"><g></g></svg>
                  <line class="vzb-bc-projection-x"></line>
                  <line class="vzb-bc-projection-y"></line>
              </g>
          </svg>
          <svg class="vzb-bubblechart-svg-main">
              <g class="vzb-bc-graph">
                  <g class="vzb-bc-axis-titles"></g>

                  <svg class="vzb-bc-bubbles-crop">
                      <g class="vzb-zoom-selection"></g>
                      <rect class="vzb-bc-eventarea"></rect>
                      <g class="vzb-bc-trails"></g>
                      <g class="vzb-bc-bubbles"></g>
                      <rect class="vzb-bc-forecastoverlay vzb-hidden" x="0" y="0" width="100%" height="100%" fill="url(#vzb-bc-pattern-lines-${config.id})" pointer-events='none'></rect>
                  </svg>

                  <rect class="vzb-bc-zoom-rect"></rect>
              </g>
              <g class="vzb-datawarning-button vzb-noexport"></g>
          </svg>
          <svg class="vzb-bubblechart-svg-front">
              <g class="vzb-bc-graph">
                  <svg class="vzb-bc-bubbles-crop">
                      <g class="vzb-bc-decorations">
                          <path class="vzb-bc-line-equal-xy vzb-invisible"></path>
                          <g class="vzb-bc-x-axis-groups"></g>
                      </g>   
                      <g class="vzb-bc-lines"></g>
                      <g class="vzb-bc-bubble-crown vzb-hidden">
                          <circle class="vzb-crown-glow"></circle>
                          <circle class="vzb-crown"></circle>
                      </g>        
                  </svg>
                  <svg class="vzb-bc-labels-crop">
                      <g class="vzb-bc-labels"></g>
                  </svg>
              </g>
          </svg>
          <svg width="0" height="0">
              <defs>
                  <filter class="vzb-noexport" id="vzb-glow-filter-${config.id}" x="-50%" y="-50%" width="200%" height="200%">
                      <feGaussianBlur in="SourceGraphic" stdDeviation="2"></feGaussianBlur>
                  </filter>
                  <pattern class="vzb-noexport" id="vzb-bc-pattern-lines-${config.id}" x="0" y="0" patternUnits="userSpaceOnUse" width="50" height="50" viewBox="0 0 10 10"> 
                      <path d='M-1,1 l2,-2M0,10 l10,-10M9,11 l2,-2' stroke='black' stroke-width='3' opacity='0.08'/>
                  </pattern> 
              </defs>
          </svg>
      </svg>
      <div class="vzb-tooltip vzb-hidden vzb-tooltip-mobile"></div>
    `;

      super(config);
    }

    setup() {

      this.DOM = {
        element: this.element,
        chartSvg: this.element.select("svg.vzb-bubblechart-svg-main"),
        chartSvgFront: this.element.select("svg.vzb-bubblechart-svg-front"),
        chartSvgBack: this.element.select("svg.vzb-bubblechart-svg-back"),
        chartSvgAll: this.element.selectAll("svg.vzb-bubblechart-svg"),
        graphAll: this.element.selectAll(".vzb-bc-graph"),
        bubbleContainerCropAll: this.element.selectAll(".vzb-bc-bubbles-crop"),
        zoomRect: this.element.select(".vzb-bc-zoom-rect"),
        eventArea: this.element.select(".vzb-bc-eventarea"),
        forecastOverlay: this.element.select(".vzb-bc-forecastoverlay"),
        tooltipMobile: this.element.select(".vzb-tooltip-mobile"),
        defs: this.element.select("defs")
      };
      this.DOM.chartSvg.select(".vzb-bc-graph").call(graph => 
        Object.assign(this.DOM, {
          graph: graph,
          trailsContainer: graph.select(".vzb-bc-trails"),
          bubbleContainer: graph.select(".vzb-bc-bubbles"),
          bubbleContainerCrop: graph.select(".vzb-bc-bubbles-crop"),
          zoomSelection: graph.select(".vzb-zoom-selection"),
        })
      );
      this.DOM.chartSvgFront.select(".vzb-bc-graph").call(graphFront => {
        Object.assign(this.DOM, {
          graphFront: graphFront,
          labelsContainer: graphFront.select(".vzb-bc-labels"),
          labelsContainerCrop: graphFront.select(".vzb-bc-labels-crop"),
          linesContainer: graphFront.select(".vzb-bc-lines"),
          bubbleCrown: graphFront.select(".vzb-bc-bubble-crown"),
          decorationsEl: graphFront.select(".vzb-bc-decorations"),
        });
        this.DOM.lineEqualXY = this.DOM.decorationsEl.select(".vzb-bc-line-equal-xy");
        this.DOM.xAxisGroupsEl = this.DOM.decorationsEl.select(".vzb-bc-x-axis-groups");
      });
      this.DOM.chartSvgBack.select(".vzb-bc-graph").call(graphBack => {
        Object.assign(this.DOM, {
          yAxisElContainer: graphBack.select(".vzb-bc-axis-y"),
          xAxisElContainer: graphBack.select(".vzb-bc-axis-x"),
          date: graphBack.select(".vzb-bc-date"),
          projectionX: graphBack.select(".vzb-bc-projection-x"),
          projectionY: graphBack.select(".vzb-bc-projection-y"),
        });
        this.DOM.yAxisEl = this.DOM.yAxisElContainer.select("g");
        this.DOM.xAxisEl = this.DOM.xAxisElContainer.select("g");
      });

      //set filter
      this.DOM.bubbleCrown.selectAll(".vzb-crown-glow")
        .attr("filter", `url(#vzb-glow-filter-${this.id})`);

      this._date = this.findChild({type: "DateTimeBackground"});
      this._labels = this.findChild({type: "Labels"});
      this._panZoom = new PanZoom(this);    
      this.decorations = new BCDecorations(this);
    
      this.xAxis = sharedComponents.axisSmart("bottom");
      this.yAxis = sharedComponents.axisSmart("left");


      this.isCanvasPreviouslyExpanded = false;
      this.draggingNow = null;

      this.hoverBubble = false;
      this.__lastStep = 0;

      const _this = this;
      //keyboard listeners
      d3.select("body")
        .on("keydown", (event) => {
          if (_this.ui.cursorMode !== "arrow" && _this.ui.cursorMode !== "hand") return;
          if (event.metaKey || event.ctrlKey) _this.DOM.chartSvgAll.classed("vzb-zoomin", true);
        })
        .on("keyup", (event) => {
          if (_this.ui.cursorMode !== "arrow" && _this.ui.cursorMode !== "hand") return;
          if (!event.metaKey && !event.ctrlKey) _this.DOM.chartSvgAll.classed("vzb-zoomin", false);
        })
        //this is for the case when user would press ctrl and move away from the browser tab or window
        //keyup event would happen somewhere else and won't be captured, so zoomin class would get stuck
        .on("mouseenter", (event) => {
          if (_this.ui.cursorMode !== "arrow" && _this.ui.cursorMode !== "hand") return;
          if (!event.metaKey && !event.ctrlKey) _this.DOM.chartSvgAll.classed("vzb-zoomin", false);
        });
    
      this.root.element.on("custom-resetZoom", () => {
        _this._panZoom.reset(null, 500);
      });

      this._panZoom.zoomSelection(this.DOM.bubbleContainerCrop);
      this.DOM.bubbleContainerCrop
        .call(this._panZoom.dragRectangle)
        .call(this._panZoom.zoomer)
        .on("dblclick.zoom", null)
        .on("mouseup", () => {
          _this.draggingNow = false;
        })
        .on("click", (event) => {
          const cursor = _this.ui.cursorMode;
          if (!event.defaultPrevented && cursor !== "arrow" && cursor !== "hand") {
            _this._panZoom.zoomByIncrement(event, cursor, 500);
          }
        });

    }


    get MDL(){
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted,
        superHighlighted: this.model.encoding.superhighlighted,
        y: this.model.encoding[this.state.alias?.y || "y"],
        x: this.model.encoding[this.state.alias?.x || "x"],
        size: this.model.encoding.size,
        color: this.model.encoding.color,
        label: this.model.encoding.label,
        trail: this.model.encoding.trail
      };
    }

    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);

      //this.MDL.trail.config.show = false;
      //this.ui.cursorMode = "plus";
      this.sScale = this.MDL.size.scale.d3Scale;
      this.trailSizeScale = this.MDL.size.scale.d3Scale.copy();

      this.TIMEDIM = this.MDL.frame.data.concept;
      this.KEYS = this.model.data.space.filter(dim => dim !== this.TIMEDIM);

      if (this._updateLayoutProfile()) return; //return if exists with error
      this.addReaction(this._updateScales);
      this.addReaction(this._updateSize);
      //    this.addReaction(this._resetZoomMinMaxXReaction, this._resetZoomMinMaxX);
      //    this.addReaction(this._resetZoomMinMaxYReaction, this._resetZoomMinMaxY);
      this.addReaction(this._updateOpacity);
      this.addReaction(this.updateColorPatterns);
      this.addReaction(this._updateShowYear);
      this.addReaction(this._updateYear);
      this.addReaction(this.drawData);
      this.addReaction(this._zoomToMarkerMaxMin);
      this.addReaction(this.redrawData);

      this.addReaction(this._selectDataPoints);
      this.addReaction(this._highlightDataPoints);
      this.addReaction(this._blinkSuperHighlighted);
      this.addReaction(this._drawForecastOverlay);
      this.addReaction(this._setupCursorMode);
      this.addReaction(this.updateDecorations);
    }

    drawData() {
      this.processFrameData();
      this._updateMarkerSizeLimits();
      this._createAndDeleteBubbles();
      //this.redrawData();
    }

    updateColorPatterns() {
      if (this.MDL.color.scale.isPattern) {
        const colorConcept = this.MDL.color.data.concept;
        this.DOM.defs.selectAll(".flag")
          .data(this.MDL.color.data.domainData, d => d[0])
          .enter()
          .append("pattern")
          .attr("id", d => `flag-${d[0]}-${this.id}`)
          .attr("class", "flag")
          .attr("width", "100%")
          .attr("height", "100%")
          .attr("patternContentUnits", "objectBoundingBox")
          .html(d => d[1][colorConcept])
          .each(function() {
            const svg = d3.select(this).select("svg");
            if (svg.empty()) return;
            
            if (!svg.attr("viewBox"))
              svg.attr("viewBox", `0 0 ${svg.attr("width")} ${svg.attr("height")}`);

            // xMidYMid: center the image in the circle
            // slice: scale the image to fill the circle
            if (!svg.attr("preserveAspectRatio"))
              svg.attr("preserveAspectRatio", "xMidYMid slice");

            svg.attr("width", 1).attr("height", 1);
          });
      } else {
        this.DOM.defs.selectAll(".flag").remove();
      }
    }

    _updateShowYear() {
      this.DOM.date.classed("vzb-hidden", !this.ui.timeInBackground);
    }

    _updateYear() {
      const duration = this._getDuration();
      this._date.setText(this.MDL.frame.value, duration);    
    }

    __getColor(key, valueC) {
      return valueC != null && !sharedComponents.LegacyUtils.isNaN(valueC) 
        ? (this.MDL.color.scale.isPattern ? `url(#flag-${key}-${this.id})` : this.cScale(valueC)) 
        : COLOR_WHITEISH;
    }
    __getColorForTrail(valueC, valueS) {
      if(valueC == null || sharedComponents.LegacyUtils.isNaN(valueC) || this.MDL.color.scale.isPattern) return COLOR_BLACKISH; 
      if(this.trailSizeScale(valueS) > THICK_LINE_THRESHOLD_FOR_DARKER_COLOR) return this.cScale(valueC);
      return this.MDL.color.scale.palette.getColorShade({colorID: valueC}) || COLOR_BLACKISH;
    }

    _createAndDeleteBubbles() {
      const _this = this;
      const duration = this._getDuration();
      const transition = this._getTransition(duration);
      const data = this.__dataProcessed;
      let trailRedrawDate;

      mobx.runInAction(()=>{
        trailRedrawDate = this.MDL.frame.stepScale.invert(Math.min(this.__lastStep, this.__lastStep = this.MDL.frame.step << 0) - 1);
      });

      this.bubbles = this.DOM.bubbleContainer.selectAll(".vzb-bc-entity")
        .data(this.__dataProcessed, d => d[Symbol.for("key")])
        .join(
          enter => enter
            .append(d => {
              const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
              const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              const trailLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
              const diagonalLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
              trailLine.classList.add("vzb-trail-line");
              diagonalLine.classList.add("vzb-diagonal-line");
              g.appendChild(circle);
              g.appendChild(diagonalLine);
              if (isTrailBubble(d)) g.appendChild(trailLine);
              return g;
            })
            .attr("class", "vzb-bc-entity")
            .attr("id", d => `vzb-bc-bubble-${d[Symbol.for("key")]}-${this.id}`)
            .style("opacity", d => d[Symbol.for("opacity")] = this._getBubbleOpacity(d))
            .call(selection => {
              if(!sharedComponents.LegacyUtils.isTouchDevice()){
                selection
                  .on("mouseover", (event, d) => {
                    if (this.ui.cursorMode !== "arrow" && this.ui.cursorMode !== "hand") return;
                    if (this._labels.dragging) return;
                    this._bubblesInteract().mouseover(event, d);
                  })
                  .on("mouseout", (event, d) => {
                    if (this.ui.cursorMode !== "arrow" && this.ui.cursorMode !== "hand") return;
                    if (this._labels.dragging) return;
                    this._bubblesInteract().mouseout(event, d);
                  })
                  .on("click", (event, d) => {
                    if (this.ui.cursorMode !== "arrow" && this.ui.cursorMode !== "hand") return;
                    this._bubblesInteract().click(event, d);
                  });
              } else {
                selection
                  .onTap((event, d) => {
                    event.stopPropagation();
                    this._bubblesInteract().click(event, d);
                  })
                  .onLongTap(() => {});
              }
            })
            .each(function(d, index) {
              const dataNext = data[index + 1] || {};
              const isTrail = isTrailBubble(d);
              const isExtrapolated = d[Symbol.for("extrapolated")];
              const headTrail = isTrail && !dataNext[Symbol.for("trailHeadKey")];
              const view = d3.select(this);
              const circle = view.select("circle");
              const diagonalLine = view.select(".vzb-diagonal-line");
        
              const valueX = d[_this._alias("x")];
              const valueY = d[_this._alias("y")];
              const valueS = d.size;
              const valueC = d.color;
        
              //d.hidden = (!valueS && valueS !== 0) || valueX == null || valueY == null;
        
              //view.classed("vzb-hidden", d.hidden);
              d.r = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(valueS || 0));
              const scaledX = _this.xScale(valueX);
              const scaledY = _this.yScale(valueY);
              const scaledC = _this.__getColor(d[Symbol.for(isTrail ? "trailHeadKey" : "key")], valueC);
        
              if (!duration || !headTrail) {
                circle
                  .attr("r", d.r)
                  .attr("fill", scaledC)
                  .attr("cy", scaledY)
                  .attr("cx", scaledX);
                //.transition(transition)

                if(isExtrapolated)
                  diagonalLine
                    .attr("x1", scaledX + d.r/Math.sqrt(2))
                    .attr("y1", scaledY + d.r/Math.sqrt(2))
                    .attr("x2", scaledX - d.r/Math.sqrt(2))
                    .attr("y2", scaledY - d.r/Math.sqrt(2));
                diagonalLine
                  .classed("vzb-hidden", !isExtrapolated);
        
                //trail line
                if (isTrail) {
                  const trailLine = view.select(".vzb-trail-line");

                  const scaledX0 = _this.xScale(dataNext[_this._alias("x")]);
                  const scaledY0 = _this.yScale(dataNext[_this._alias("y")]);
                  const scaledCT = _this.__getColorForTrail(dataNext.color, dataNext.size);

                  const nextR = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(dataNext.size || 0));
                  const length = Math.sqrt( (scaledX - scaledX0)**2 + (scaledY - scaledY0)**2 ) - d.r - nextR;
                  
                  trailLine
                    .attr("x1", scaledX)
                    .attr("y1", scaledY)
                    .attr("x2", scaledX0)
                    .attr("y2", scaledY0)                  
                    .attr("stroke-dasharray", `0 ${d.r} ${length > 0 ? length : 0} ${nextR}`)
                    .style("stroke-width", _this.trailSizeScale(dataNext.size))
                    .style("stroke", scaledCT);
                }
              }
        
              if (duration && !isTrail) {
                view
                  .style("opacity", 0)
                  .transition().duration(duration*0.9)
                  .style("opacity", d[Symbol.for("opacity")]);
              }
        
              if (!isTrail) {
                _this._updateLabel(d, valueX, valueY, duration, true, false);
              }
            }),

          update => update
            .each(function(d, index) {
              
              const isTrail = isTrailBubble(d);
              const isExtrapolated = d[Symbol.for("extrapolated")];
              const dataNext = data[index + 1] || {};
              const headTrail = isTrail && !dataNext[Symbol.for("trailHeadKey")];
        
              const valueS = d.size;
              d.r = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(valueS || 0));
              if (isTrail && d["frame"] < trailRedrawDate) return;
        
              const valueX = d[_this._alias("x")];
              const valueY = d[_this._alias("y")];
              const valueC = d.color;
        
              //d.hidden = (!valueS && valueS !== 0) || valueX == null || valueY == null;
        
              //view.classed("vzb-hidden", d.hidden);
              const scaledX = _this.xScale(valueX);
              const scaledY = _this.yScale(valueY);
              const scaledC = _this.__getColor(d[Symbol.for(isTrail ? "trailHeadKey" : "key")], valueC);
        
              const group = d3.select(this);
              if (!duration || !headTrail) {
                const circle = group.select("circle");
                if (duration && !isTrail) {
                  circle.transition(transition)
                    .attr("r", d.r)
                    .attr("fill", scaledC)
                    .attr("cy", scaledY)
                    .attr("cx", scaledX);
                } else {
                  circle.interrupt()
                    .attr("r", d.r)
                    .attr("fill", scaledC)
                    .attr("cy", scaledY)
                    .attr("cx", scaledX);
                }
                  
                const diagonalLine = group.select(".vzb-diagonal-line");
                diagonalLine
                  .classed("vzb-hidden", !isExtrapolated);
                if(isExtrapolated){
                  if (duration && !isTrail){
                    diagonalLine.transition(transition)
                      .attr("x1", scaledX + d.r/Math.sqrt(2))
                      .attr("y1", scaledY + d.r/Math.sqrt(2))
                      .attr("x2", scaledX - d.r/Math.sqrt(2))
                      .attr("y2", scaledY - d.r/Math.sqrt(2));
                  } else {
                    diagonalLine.interrupt()
                      .attr("x1", scaledX + d.r/Math.sqrt(2))
                      .attr("y1", scaledY + d.r/Math.sqrt(2))
                      .attr("x2", scaledX - d.r/Math.sqrt(2))
                      .attr("y2", scaledY - d.r/Math.sqrt(2));
                  }
                }
                
                //trail line
                if (isTrail) {
                  const trailLine = group.select(".vzb-trail-line");
                  const scaledX0 = _this.xScale(dataNext[_this._alias("x")]);
                  const scaledY0 = _this.yScale(dataNext[_this._alias("y")]);
                  const scaledCT = _this.__getColorForTrail(dataNext.color, dataNext.size);
                  
                  trailLine
                    .attr("x1", scaledX)
                    .attr("y1", scaledY);
                  if (duration && !data[index + 2][Symbol.for("trailHeadKey")]) {
                    trailLine
                      .attr("x2", scaledX)
                      .attr("y2", scaledY)
                      .transition(transition)
                      .attr("x2", scaledX0)
                      .attr("y2", scaledY0);
                  } else {
                    trailLine.interrupt()
                      .attr("x2", scaledX0)
                      .attr("y2", scaledY0);
                  }
        
                  const nextR = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(dataNext.size || 0));
                  const length = Math.sqrt( (scaledX - scaledX0)**2 + (scaledY - scaledY0)**2 ) - d.r - nextR;

                  trailLine
                    .style("stroke", scaledCT)
                    .style("stroke-width", _this.trailSizeScale(dataNext.size))
                    .attr("stroke-dasharray", `0 ${d.r} ${length > 0 ? length : 0} ${nextR}`);
                }
              }
              
              if (!isTrail)
                _this._updateLabel(d, valueX, valueY, duration, false, false);    
            }),    

          exit => exit
            .each(function(d) {
              const isTrail = isTrailBubble(d);
              
              const view = duration && !isTrail ?
                d3.select(this).transition(transition)
                  .duration(duration*0.9)
                  .style("opacity", 0)
                :
                d3.select(this).interrupt();
        
              view
                .remove();
              
              if (!isTrail) 
                _this._updateLabel(d, d[_this._alias("x")], d[_this._alias("y")], duration, true, true);
            })
        )
        .order();

    }


    redrawData(duration) {
      //this.services.layout.size;
      //this.MDL.x.scale.type;
      //this.MDL.y.scale.type;
      this.MDL.color.scale.type;
      this.MDL.size.scale.type;
      this.MDL.size.scale.extent;

      const _this = this;
      const data = this.__dataProcessed;
      const transition = this._getTransition(duration);

      if (this.bubbles) this.bubbles.each(function(d, index) {
        const isTrail = isTrailBubble(d);
        const dataNext = data[index + 1] || {};
        const headTrail = isTrail && !dataNext[Symbol.for("trailHeadKey")];
        const isExtrapolated = d[Symbol.for("extrapolated")];

        const valueX = d[_this._alias("x")];
        const valueY = d[_this._alias("y")];
        const valueS = d.size;
        const valueC = d.color;

        d.r = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(valueS || 0));
        const scaledX = _this.xScale(valueX);
        const scaledY = _this.yScale(valueY);
        const scaledC = _this.__getColor(d[Symbol.for(isTrail ? "trailHeadKey" : "key")], valueC);

        const group = d3.select(this);

        if (duration && headTrail) {
          group.style("opacity", 0)
            .transition().delay(duration).duration(0)
            .style("opacity", d[Symbol.for("opacity")]);
        }

        const circle = group.select("circle");                            
        if (duration && !headTrail) {
          circle.transition(transition)
            .attr("r", d.r)
            .attr("fill", scaledC)
            .attr("cy", scaledY)
            .attr("cx", scaledX);
        } else {
          circle.interrupt()
            .attr("r", d.r)
            .attr("fill", scaledC)
            .attr("cy", scaledY)
            .attr("cx", scaledX);
        }

        const diagonalLine = group.select(".vzb-diagonal-line");
        diagonalLine
          .classed("vzb-hidden", !isExtrapolated);
        if(isExtrapolated){
          if (duration && !headTrail){
            diagonalLine.transition(transition)
              .attr("x1", scaledX + d.r/Math.sqrt(2))
              .attr("y1", scaledY + d.r/Math.sqrt(2))
              .attr("x2", scaledX - d.r/Math.sqrt(2))
              .attr("y2", scaledY - d.r/Math.sqrt(2));
          } else {
            diagonalLine.interrupt()
              .attr("x1", scaledX + d.r/Math.sqrt(2))
              .attr("y1", scaledY + d.r/Math.sqrt(2))
              .attr("x2", scaledX - d.r/Math.sqrt(2))
              .attr("y2", scaledY - d.r/Math.sqrt(2));
          }
        }
        

        if (isTrail) {
          const trailLine = (duration  && !headTrail) ? 
            group.select(".vzb-trail-line")
              .transition(transition)
            : group.select(".vzb-trail-line").interrupt();

          const dataNext = data[index + 1];
          const scaledX0 = _this.xScale(dataNext[_this._alias("x")]);
          const scaledY0 = _this.yScale(dataNext[_this._alias("y")]);
          const scaledCT = _this.__getColorForTrail(dataNext.color, dataNext.size);

          const nextR = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(dataNext.size || 0));
          const length = Math.sqrt( (scaledX - scaledX0)**2 + (scaledY - scaledY0)**2 ) - d.r - nextR;

          trailLine
            .attr("x1", scaledX)
            .attr("y1", scaledY)
            .attr("x2", scaledX0)
            .attr("y2", scaledY0)
            .style("stroke", scaledCT)
            .style("stroke-width", _this.trailSizeScale(dataNext.size))
            .attr("stroke-dasharray", `0 ${d.r} ${length > 0 ? length : 0} ${nextR}`);
        }
      });

      mobx.runInAction(() => _this._updateLabels(duration));
    }

    __getZoomed(type, zoomed, domain) {
      //const zoomed = values[`zoomed${type}`];
      return d3[type.toLowerCase()](zoomed !== null ? zoomed : domain);
    }

    __getZoomedMin(values, domain) {
      return this.__getZoomed("Min", values, domain);
    }

    __getZoomedMax(values, domain) {
      return this.__getZoomed("Max", values, domain);
    }

    /*
     * Zoom to the min and max values given in the URL axes markers.
     */
    _zoomToMarkerMaxMin() {
      this.services.layout.size;
      this.MDL.x.scale.type;
      this.MDL.y.scale.type;

      const panzoom = //this.ui.panzoom;
      {
        x: this.MDL.x.scale.zoomed,
        y: this.MDL.y.scale.zoomed
      };
      
      const xDomain = this.MDL.x.data.domain;
      const yDomain = this.MDL.y.data.domain;

      if (this.draggingNow) return;

      /*
       * Reset just the zoom values without triggering a zoom event. This ensures
       * a clean zoom state for the subsequent zoom event.
       */
      this._panZoom.resetZoomState();

      this.yScale.range(this._rangeBump([this.height, 0]));
      this.xScale.range(this._rangeBump([0, this.width]));
     
      /*
       * The axes may return null when there is no value given for the zoomed
       * min and max values. In that case, fall back to the axes' domain values.
       */
      const zoomedMinX = this.__getZoomedMin(panzoom.x, xDomain);
      const zoomedMaxX = this.__getZoomedMax(panzoom.x, xDomain);
      const zoomedMinY = this.__getZoomedMin(panzoom.y, yDomain);
      const zoomedMaxY = this.__getZoomedMax(panzoom.y, yDomain);

      //by default this will apply no transition and feed values back to state
      mobx.runInAction(() => {
        this._panZoom.zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, 0, "don't feed these zoom values back to state");
      });
    }

    _resetZoomMinMaxXReaction() {
      return { concept: this.MDL.x.data.concept };
    }

    _resetZoomMinMaxX() {
      this.ui.panzoom.x = {zoomedMin: null, zoomedMax: null};
    }

    _resetZoomMinMaxYReaction() {
      return { concept: this.MDL.y.data.concept };
    }

    _resetZoomMinMaxY() {
      this.ui.panzoom.y = {zoomedMin: null, zoomedMax: null};
    }

    _drawForecastOverlay() {
      this.DOM.forecastOverlay.classed("vzb-hidden", 
        !this.ui.showForecast || 
        !this.ui.showForecastOverlay || 
        !this.ui.endBeforeForecast || 
          (this.MDL.frame.value <= this.MDL.frame.parseValue(this.ui.endBeforeForecast))
      );
    }

    _updateLayoutProfile(){
      this.services.layout.size;

      this.elementHeight = (this.element.node().clientHeight) || 0;
      this.elementWidth = (this.element.node().clientWidth) || 0;

      this.profileConstants = this.services.layout.getProfileConstants(
        PROFILE_CONSTANTS(this.elementWidth, this.elementHeight), 
        PROFILE_CONSTANTS_FOR_PROJECTOR(this.elementWidth, this.elementHeight)
      );

      if (!this.elementHeight || !this.elementWidth) return sharedComponents.LegacyUtils.warn("Chart _updateProfile() abort: container is too little or has display:none");
    }

    _getDuration() {
      return this.MDL.frame.playing ? this.MDL.frame.speed || 0 : 0;
    }

    _updateScales() {
      this.yScale = this.MDL.y.scale.d3Scale.copy();
      this.xScale = this.MDL.x.scale.d3Scale.copy();
      this._labels.setScales(this.xScale, this.yScale);
    }

    get cScale() {
      return this.MDL.color.scale.d3Scale;
    }
    


    _updateSize() {
      this.services.layout.size;

      const {
        x,
        y
      } = this.MDL;
      
      this.model.encoding.y.scale.d3Scale;
      
      const {
        graphAll,
        eventArea,
        bubbleContainerCropAll,
        labelsContainerCrop,
        xAxisElContainer,
        xAxisEl,
        yAxisElContainer,
        yAxisEl,
        projectionX,
        projectionY,
        xAxisGroupsEl,
      } = this.DOM;

      const _this = this;

      const layoutProfile = this.services.layout.profile;

      const margin = this.profileConstants.margin;
      const infoElHeight = this.profileConstants.infoElHeight;
      const xAxisTitleBottomMargin = this.profileConstants.xAxisTitleBottomMargin;

      //stage
      const height = this.height = (this.elementHeight - margin.top - margin.bottom) || 0;
      const width = this.width = (this.elementWidth - margin.left * this.profileConstants.leftMarginRatio - margin.right) || 0;

      // if (height <= 0 || width <= 0) {
      //   height = 0;
      //   width = 0;
      //   utils.warn("Bubble chart updateSize(): vizabi container is too little or has display:none");
      // }

      //graph group is shifted according to margins (while svg element is at 100 by 100%)
      graphAll
        .attr("transform", "translate(" + (margin.left * this.profileConstants.leftMarginRatio) + "," + margin.top + ")");

      this._date.resizeText(width, height);
      
      eventArea
        .attr("width", width)
        .attr("height", Math.max(0, height));

      this.yScale.range(this._rangeBump([height, 0]));
      this.xScale.range(this._rangeBump([0, width]));

      //only applied to swimming lane sclae
      const rankScaleModifications = y.scale.type === "rank" 
        ? {
          ticks: y.rollup.map(m => m.tickPosition),
          formatter: (d) => y.rollup.find(f => f.tickPosition === d).name,
          textAnchor: "start",
          repositionLabels: Object.fromEntries(y.rollup.map(m => ([m.tickPosition, { x: 1.5 * infoElHeight, y: -infoElHeight }]))) 
        }
        : {};

      //apply scales to axes and redraw
      this.yAxis.scale(this.yScale)
        .tickSizeInner(-width)
        .tickSizeOuter(0)
        .tickPadding(6)
        .tickSizeMinor(-width, 0)
        .labelerOptions(Object.assign({
          scaleType: y.scale.type,
          toolMargin: margin,
          limitMaxTickNumber: 6,
          bump: this.profileConstants.maxRadiusPx / 2,
          viewportLength: height,
          formatter: this.localise
        }, rankScaleModifications));

      this.xAxis.scale(this.xScale)
        .tickSizeInner(-height)
        .tickSizeOuter(0)
        .tickPadding(6)
        .tickSizeMinor(-height, 0)
        .labelerOptions({
          scaleType: x.scale.type,
          toolMargin: margin,
          bump: this.profileConstants.maxRadiusPx / 2,
          viewportLength: width,
          formatter: this.localise
        });


      bubbleContainerCropAll
        .attr("width", width)
        .attr("height", Math.max(0, height));

      labelsContainerCrop
        .attr("width", width)
        .attr("height", Math.max(0, height));

      xAxisElContainer
        .attr("width", width + 1)
        .attr("height", this.profileConstants.margin.bottom + height)
        .attr("y", -1)
        .attr("x", -1);
      xAxisEl
        .attr("transform", "translate(1," + (1 + height) + ")");

      yAxisElContainer
        .attr("width", this.profileConstants.margin.left + width)
        .attr("height", Math.max(0, height))
        .attr("x", -this.profileConstants.margin.left);
      yAxisEl
        .attr("transform", "translate(" + (this.profileConstants.margin.left - 1) + "," + 0 + ")");

      yAxisEl.call(this.yAxis);
      xAxisEl.call(this.xAxis);

      const rangeBump = this.profileConstants.maxRadiusPx;
      projectionX.attr("y1", _this.yScale.range()[0] + rangeBump);
      projectionY.attr("x2", _this.xScale.range()[0] - rangeBump);

      xAxisGroupsEl
        .style("font-size", infoElHeight * 0.8 + "px");

      this.root.findChild({type: "_DataWarning"}).setOptions({
        width: this.elementWidth,
        height: this.elementHeight,
        vertical: "bottom", 
        horizontal: "right", 
        right: margin.right,
        bottom: xAxisTitleBottomMargin,
        wLimit: (layoutProfile !== "SMALL" ? 0.5 : 1) *
          (this.elementWidth - this.DOM.graph.select(".vzb-bc-axis-x-title").node().getBBox().width - infoElHeight * 3)
      });

    }


    _rangeBump(arg, undo) {
      const bump = this.profileConstants.maxRadiusPx;
      undo = undo ? -1 : 1;
      if (sharedComponents.LegacyUtils.isArray(arg) && arg.length > 1) {
        let z1 = arg[0];
        let z2 = arg[arg.length - 1];

        //the sign of bump depends on the direction of the scale
        if (z1 < z2) {
          z1 += bump * undo;
          z2 -= bump * undo;
          // if the scale gets inverted because of bump, set it to avg between z1 and z2
          if (z1 > z2) z1 = z2 = (z1 + z2) / 2;
        } else if (z1 > z2) {
          z1 -= bump * undo;
          z2 += bump * undo;
          // if the scale gets inverted because of bump, set it to avg between z1 and z2
          if (z1 < z2) z1 = z2 = (z1 + z2) / 2;
        } else ;
        return [z1, z2];
      }
      sharedComponents.LegacyUtils.warn("rangeBump error: input is not an array or empty");
    }


    processFrameData() {
      return this.__dataProcessed = this.model.dataArray;
    }

    _getTransition(duration) {
      return duration ? d3.transition()
        .duration(duration)
        .ease(d3.easeLinear) : d3.transition();
    }  

    _bubblesInteract() {
      const _this = this;

      return {
        mouseover(event, d) {
          _this.hoverBubble = true;
          _this.MDL.highlighted.data.filter.set(d);
          _this._labels.showCloseCross(d, true);
        },

        mouseout(event, d) {
          _this.hoverBubble = false;
          _this.MDL.highlighted.data.filter.delete(d);
          //_this._setTooltip();
          _this._labels.showCloseCross(d, false);
        },

        click(event, d) {
          if (_this.draggingNow) return;
          // // const isSelected = d.isSelected;
          if (!isTrailBubble(d)) _this.MDL.selected.data.filter.toggle(d);
          //_this.MDL.selected.data.filter.toggle(d);
          // // //return to highlighted state
          // // if (!utils.isTouchDevice()) {
          // //   if (isSelected) _this.model.marker.highlightMarker(d);
          // //   _this.highlightDataPoints();
        }
      };
    }
    

    _updateMarkerSizeLimits() {
      this.services.layout.size;
      this.MDL.size.scale.domain;

      const {
        minRadiusPx,
        maxRadiusPx,
        minTrailThicknessPx,
        maxTrailThicknessPx,
      } = this.profileConstants;

      //transfer min max radius to size dialog via root ui observable (probably a cleaner way is possible)
      this.root.ui.minMaxRadius = {min: minRadiusPx, max: maxRadiusPx};
      
      const extent = this.MDL.size.scale.extent || [0, 1];
      
      let minArea = sharedComponents.LegacyUtils.radiusToArea(Math.max(maxRadiusPx * extent[0], minRadiusPx));
      let maxArea = sharedComponents.LegacyUtils.radiusToArea(Math.max(maxRadiusPx * extent[1], minRadiusPx));

      this.sScale.range([minArea, maxArea]);
      this.trailSizeScale.domain(this.MDL.size.scale.domain).range([minTrailThicknessPx, maxTrailThicknessPx]);
    }

    _setTooltip(tooltipText, x, y, s, c, d) {
      if (tooltipText) {
        const labelValues = {};
        if (d) {
          labelValues.valueY = d[this._alias("y")];
          labelValues.valueX = d[this._alias("x")];
          labelValues.valueS = d.size;
          labelValues.valueC = d.color;
          labelValues.valueLST = d.size_label || null;
          labelValues.labelText = this.__labelWithoutFrame(d, this.localise);
        }

        const tooltipCache = {};
        tooltipCache.labelX0 = this.xScale.invert ? this.xScale.invert(x) : d.x;
        tooltipCache.labelY0 = this.yScale.invert ? this.yScale.invert(y) : d.y;
        tooltipCache.scaledS0 = s;
        tooltipCache.scaledC0 = null;

        this._labels.setTooltip(d, tooltipText, tooltipCache, labelValues);
      } else {
        this._labels.setTooltip();
      }
    }

    _getLabelText(d) {
      return this.KEYS.map(key => d.label[key]).join(",");
      ////  + (this.model.ui.chart.timeInTrails && time && (this.model.time.start - this.model.time.end !== 0) ? " " + time : "");
    }

    _updateOpacity(selection) {
      //this.MDL.frame.value; //listen

      const highlightedFilter = this.MDL.highlighted.data.filter;
      const selectedFilter = this.MDL.selected.data.filter;

      this.__highlightedMarkers = new Map(highlightedFilter.markers);
      this.__selectedMarkers = new Map(selectedFilter.markers);
      this.__someSelected = this.__selectedMarkers.size != 0;
      this.__someHighlighted = this.__highlightedMarkers.size != 0;

      const _selection = selection || this.bubbles;
      if(!_selection) return;
      _selection
        .style("opacity", d => this._getBubbleOpacity(d, this.ui))
        .style("pointer-events", d => this._getBubbleOpacity(d, this.ui) === 0 ? "none" : "visible");
    }

    _getBubbleOpacity(d) { 
      const ui = this.ui;

      if (this.__highlightedMarkers.has(d[Symbol.for("key")])) return ui.opacityHighlight;
      if (isTrailBubble(d)) return ui.opacityRegular;
      if (this.__selectedMarkers.has(d[Symbol.for("key")])) return ui.opacitySelect;

      if (this.__someSelected) return ui.opacitySelectDim;
      if (this.__someHighlighted) return ui.opacityHighlightDim;

      return ui.opacityRegular;
    }

    _setBubbleCrown(x, y, r, glow, skipInnerFill) {
      const bubbleCrown = this.DOM.bubbleCrown;
      if (x != null) {
        bubbleCrown.classed("vzb-hidden", false);
        bubbleCrown.select(".vzb-crown")
          .attr("cx", x)
          .attr("cy", y)
          .attr("r", r)
          .attr("fill", skipInnerFill ? "none" : glow);
        bubbleCrown.selectAll(".vzb-crown-glow")
          .attr("cx", x)
          .attr("cy", y)
          .attr("r", r + 10)
          .attr("stroke", glow);

      } else {
        bubbleCrown.classed("vzb-hidden", true);
      }

    }

    /*
     * Shows and hides axis projections
     */
    _axisProjections(d) {
      const {
        projectionX,
        projectionY,
        xAxisEl,
        yAxisEl
      } = this.DOM;

      if (d != null) {

        const valueY = d[this._alias("y")];
        const valueX = d[this._alias("x")];
        const radius = d.r;

        //if (!valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) return;

        if (this.ui.whenHovering.showProjectionLineX
          && this.xScale(valueX) > 0 && this.xScale(valueX) < this.width
          && (this.yScale(valueY) + radius) < this.height) {
          projectionX
            .style("opacity", 1)
            .attr("y2", this.yScale(valueY) + radius)
            .attr("x1", this.xScale(valueX))
            .attr("x2", this.xScale(valueX));
        }

        if (this.ui.whenHovering.showProjectionLineY
          && this.yScale(valueY) > 0 && this.yScale(valueY) < this.height
          && (this.xScale(valueX) - radius) > 0) {
          projectionY
            .style("opacity", 1)
            .attr("y1", this.yScale(valueY))
            .attr("y2", this.yScale(valueY))
            .attr("x1", this.xScale(valueX) - radius);
        }

        if (this.ui.whenHovering.higlightValueX && this.MDL.x.scale.type !== "rank") xAxisEl.call(
          this.xAxis.highlightValue(valueX)
        );

        if (this.ui.whenHovering.higlightValueY && this.MDL.y.scale.type !== "rank") yAxisEl.call(
          this.yAxis.highlightValue(valueY)
        );


      } else {

        projectionX.style("opacity", 0);
        projectionY.style("opacity", 0);
        xAxisEl.call(this.xAxis.highlightValue("none"));
        yAxisEl.call(this.yAxis.highlightValue("none"));

      }

    }

    /*
     * Highlights all hovered bubbles
     */
    _highlightDataPoints() {
      const _this = this;

      const highlightedFilter = this.MDL.highlighted.data.filter;
      const selectedFilter = this.MDL.selected.data.filter;
      this.someHighlighted = highlightedFilter.any();

      //this.updateBubbleOpacity();
      const trailShow = this.MDL.trail.show;
      const trailStarts = this.MDL.trail.starts;
      const trailGroupDim = this.MDL.trail.groupDim;

      if (highlightedFilter.markers.size === 1) {
        const highlightedKey = highlightedFilter.markers.keys().next().value;
        const d = Object.assign(this.model.dataMap.getByStr(highlightedKey));
        const selectedKey = d[Symbol.for("trailHeadKey")] || d[Symbol.for("key")];

        const x = _this.xScale(d[_this._alias("x")]);
        const y = _this.yScale(d[_this._alias("y")]);
        const s = d.r;
        const c = _this.__getColor(selectedKey, d.color);
        let entityOutOfView = false;

        if (x + s < 0 || x - s > this.width || y + s < 0 || y - s > this.height) {
          entityOutOfView = true;
        }

        //show tooltip
        // const trailShow = this.MDL.trail.show;
        // const trailStarts = this.MDL.trail.starts;
        // const trailGroupDim = this.MDL.trail.groupDim;
        const isSelected = selectedFilter.has(selectedKey);
        const isTailTrail = !(trailStarts[selectedKey] - d[trailGroupDim]);
        const isTrail = isTrailBubble(d);

        let text = "";
        
        text = isSelected ? 
          !trailShow || isTailTrail || (!isTrail && !this.hoverBubble) ? "": this.localise(d[trailGroupDim])
          : 
          this.__labelWithoutFrame(d);
        
        _this._labels.highlight(null, false);
        _this._labels.highlight({ [Symbol.for("key")]: selectedKey }, true);
        if (isSelected) {
          const skipCrownInnerFill = !isTrail;
          //!d.trailStartTime || d.trailStartTime == _this.model.time.formatDate(_this.time);
          _this._setBubbleCrown(x, y, s, c, skipCrownInnerFill);
        }

        if (!entityOutOfView) {
          _this._axisProjections(d);
        }

        //set tooltip and show axis projections
        if (text && !entityOutOfView) {
          _this._setTooltip(text, x, y, s + 3, c, d);
        }

        // // const selectedData = utils.find(_this.model.marker.select, f => utils.getKey(f, KEYS) == d[KEY]);
        // // if (selectedData) {
        // //   const clonedSelectedData = utils.clone(selectedData);
        // //   //change opacity to OPACITY_HIGHLT = 1.0;
        // //   clonedSelectedData.opacity = 1.0;
        // //   _this._trails.run(["opacityHandler"], clonedSelectedData);
        // // }
      } else {
        this._axisProjections();
        ////this._trails.run(["opacityHandler"]);
        //hide tooltip
        this._setTooltip();
        this._setBubbleCrown();
        this._labels.highlight(null, false);
      }

    }

    _blinkSuperHighlighted() {
      if (!this.MDL.superHighlighted) return;

      const superHighlightFilter = this.MDL.superHighlighted.data.filter;

      this.bubbles
        .classed("vzb-super-highlighted", d => superHighlightFilter.has(d));
    }

    _selectDataPoints() {
      const _this = this;
      const selectedFilter = this.MDL.selected.data.filter;
      
      if (sharedComponents.LegacyUtils.isTouchDevice()) {
        _this.MDL.highlighted.data.filter.clear();
        _this._labels.showCloseCross(null, false);
      } else {
        //hide tooltip
        _this._setTooltip();
        ////_this._setBubbleCrown();
      }

      // utils.forEach(_this.bubbles.data(), d => {
      //   d.isSelected = _this.model.marker.isSelected(d);
      // });

      _this.someSelected = selectedFilter.any();
      _this.nonSelectedOpacityZero = false;

    }

    _setupCursorMode() {
      const svg = this.DOM.chartSvgAll;
      if (this.ui.cursorMode === "plus") {
        svg.classed("vzb-zoomin", true);
        svg.classed("vzb-zoomout", false);
        svg.classed("vzb-panhand", false);
      } else if (this.ui.cursorMode === "minus") {
        svg.classed("vzb-zoomin", false);
        svg.classed("vzb-zoomout", true);
        svg.classed("vzb-panhand", false);
      } else if (this.ui.cursorMode === "hand") {
        svg.classed("vzb-zoomin", false);
        svg.classed("vzb-zoomout", false);
        svg.classed("vzb-panhand", true);
      } else {
        svg.classed("vzb-zoomin", false);
        svg.classed("vzb-zoomout", false);
        svg.classed("vzb-panhand", false);
      }
    }

    updateDecorations(){
      this.services.layout.size;
      this.MDL.x.scale.zoomed;
      this.MDL.y.scale.zoomed;
      this.decorations.update.bind(this)(this._getDuration());
    }

    _updateLabel(d, x, y, duration, showhide, hidden) {
      const selectedMarkers = this.MDL.selected.data.filter.markers;
      const key = d[Symbol.for("key")];
      // only for selected markers
      if (selectedMarkers.has(key)) {
        const trail = this.MDL.trail;
    
        const cache = {};

        let labelText = "";

        //if (showhide && hidden && trail.show && trailStartTime && (trailStartTime < _this.time)) showhide = false;
        if (hidden && !trail.show) showhide = true;

        if (trail.show && key in trail.starts) {
          const trailStart = trail.starts[key];
          //console.log("trailstart", trailStart)
          // if this bubble is trail start bubble
          if (trailStart >= this.MDL.frame.value || showhide) {
            const trailData = this.model.getDataMapByFrameValue(trailStart, "trail.addTrails").getByStr(key);
            
            cache.labelText = labelText = this.__labelWithFrame(trailData);
            cache.labelX0 = trailData[this._alias("x")];
            cache.labelY0 = trailData[this._alias("y")];
            cache.scaledC0 = trailData.color != null ? this.cScale(trailData.color) : COLOR_WHITEISH,
            cache.scaledS0 = (trailData.size || trailData.size === 0) ? sharedComponents.LegacyUtils.areaToRadius(this.sScale(trailData.size)) : null;
            cache.valueS0 = trailData.size;
            trailData.hidden = hidden;
            this._labels.updateLabel(trailData, cache, cache.labelX0, cache.labelY0, trailData.size, trailData.color, labelText, trailData.size_label, duration, showhide);
          }
        } else {
          cache.labelText = labelText = this.__labelWithoutFrame(d);
          cache.labelX0 = x;
          cache.labelY0 = y;
          cache.scaledC0 = d.color != null ? this.cScale(d.color) : COLOR_WHITEISH,
          cache.scaledS0 = (d.size || d.size === 0) ? sharedComponents.LegacyUtils.areaToRadius(this.sScale(d.size)) : null;
          cache.valueS0 = d.size;
          d.hidden = hidden;
          this._labels.updateLabel(d, cache, x, y, d.size, d.color, labelText, d.size_label, duration, showhide);
        }
      }
    }
    
    _updateLabels(duration) {
      //console.log("updateLabels");

      const selectedFilter = this.MDL.selected.data.filter;
      const trail = this.MDL.trail;

      for (const key of selectedFilter.markers.keys()) {
        if (!(key in trail.starts))
          continue;

        if (!this._labels.cached[key]) this._labels.cached[key] = {};
        const cache = this._labels.cached[key];

        const datamap = (trail.show ? this.model.getDataMapByFrameValue(trail.starts[key], "trail.addTrails") : this.model.dataMap);
        if (!datamap.hasByStr(key))
          continue;

        const d = datamap.getByStr(key);
        
        cache.labelText = this[(trail.show && this.ui.timeInTrails ? "__labelWithFrame" : "__labelWithoutFrame")](d);
        cache.labelX0 = d[this._alias("x")];
        cache.labelY0 = d[this._alias("y")];
        cache.scaledC0 = d.color != null ? this.cScale(d.color) : COLOR_WHITEISH,
        cache.scaledS0 = (d.size || d.size === 0) ? sharedComponents.LegacyUtils.areaToRadius(this.sScale(d.size)) : null;
        cache.valueS0 = d.size;
        cache.initTextBBox = null;
        cache.initFontSize = null;
        this._labels.updateLabel({ [Symbol.for("key")]: key }, null, null, null, null, null, null, d.size_label, duration);
      }
    }

    __labelWithoutFrame(d) {
      const markerSpace = this.model.data.space;
      if (typeof d.label == "object") 
        return Object.entries(d.label)
          .filter(([k, v]) => k != this.MDL.frame.data.concept)
          //sort parts of the name along the marker space array, so we get geo, gender instead of gender, geo
          .sort(([ak, av], [bk, bv]) => markerSpace.indexOf(ak) - markerSpace.indexOf(bk))
          //add keys where values are numbers, such as "age: 69"
          .map(([k, v]) => sharedComponents.LegacyUtils.isNumber(v) ? k + ": " + v : v)
          .join(", ");
      if (d.label != null) return "" + d.label;
      return d[Symbol.for("key")];
    }

    __labelWithFrame(d) {
      const frameConcept = this.MDL.frame.data.concept;
      return this.__labelWithoutFrame(d) + " " + this.localise(d && d.label && d.label[frameConcept] || d && d.frame || this.MDL.frame.value);
    }

    _alias(enc) {
      return this.state.alias?.[enc] || enc;
    }
  }

  _VizabiBubbleChart.DEFAULT_UI = {
    show_ticks: true,
    showForecast: false,
    showForecastOverlay: true,
    pauseBeforeForecast: true,
    opacityHighlight: 1.0,
    opacitySelect: 1.0,
    opacityHighlightDim: 0.1,
    opacitySelectDim: 0.3,
    opacityRegular: 0.5,
    timeInBackground: true,
    timeInTrails: true,
    lockNonSelected: 0,
    panWithArrow: false,
    adaptMinMaxZoom: false,
    cursorMode: "arrow",
    zoomOnScrolling: true,
    decorations: {
      enabled: true,
      xAxisGroups: null //left to be set by external page
    },
    superhighlightOnMinimapHover: true,
    whenHovering: {
      showProjectionLineX: true,
      showProjectionLineY: true,
      higlightValueX: true,
      higlightValueY: true
    },
    labels: {
      enabled: true,
      dragging: true,
      removeLabelBox: false
    },
    margin: {
      left: 0,
      top: 0
    }
  };

  //export default BubbleChart;
  const VizabiBubbleChart = mobx.decorate(_VizabiBubbleChart, {
    "MDL": mobx.computed,
    "cScale": mobx.computed
  });

  sharedComponents.Chart.add("bubblechart", VizabiBubbleChart);

  class BubbleChart extends sharedComponents.BaseComponent {

    constructor(config){

      const markerName = config.options?.markerNames?.bubble || "bubble";
      const fullMarker = config.model.markers[markerName];
      config.Vizabi.utils.applyDefaults(fullMarker.config, BubbleChart.DEFAULT_CORE(markerName));   

      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);
      
      config.model.markers[markerName] = marker;

      config.name = "bubblechart";

      config.subcomponents = [{
        type: sharedComponents.Repeater,
        placeholder: ".vzb-repeater",
        model: marker,
        options: {
          repeatedComponent: VizabiBubbleChart,
          repeatedComponentCssClass: "vzb-bubblechart"
        },
        name: "chart",
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        model: marker,
        name: "time-slider"
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        model: marker,
        name: "speed-slider"
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        model: marker,
        name: "tree-menu"
      },{
        type: sharedComponents.DataWarning,
        placeholder: ".vzb-datawarning",
        options: {button: ".vzb-datawarning-button"},
        model: marker,
        name: "data-warning"
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        model: marker,
        name: "buttons"
      },{
        type: sharedComponents.SpaceConfig,
        placeholder: ".vzb-spaceconfig",
        options: {button: ".vzb-spaceconfig-button"},
        model: marker,
        name: "space-config"
      },{
        type: sharedComponents.ErrorMessage,
        placeholder: ".vzb-errormessage",
        model: marker,
        name: "error-message"
      }];

      config.template = `
      <div class="vzb-repeater"></div>
      <div class="vzb-animationcontrols">
        <div class="vzb-timeslider"></div>
        <div class="vzb-speedslider"></div>
      </div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datawarning"></div>
      <div class="vzb-spaceconfig"></div>
      <div class="vzb-datanotes"></div>
      <div class="vzb-errormessage"></div>
    `;

      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);

      this.splashMarker = splashMarker;
    }
  }

  BubbleChart.DEFAULT_UI = {
    chart: {
    }
  };

  BubbleChart.mainComponent = VizabiBubbleChart;

  BubbleChart.DEFAULT_CORE = (markerName) => ({
    requiredEncodings: ["x", "y", "size"],
    encoding: {
      "selected": {
        modelType: "selection",
        data: { 
          filter: { 
            ref: `markers.${markerName}.encoding.trail.data.filter`
          }
        }
      },
      "highlighted": { modelType: "selection" },
      "superhighlighted": { modelType: "selection" },
      "x": {
        scale: {
          allowedTypes: ["linear", "log", "genericLog", "pow", "time"]
        }
      },
      "y": {
        modelType: "lane",
        scale: {
          allowedTypes: ["linear", "log", "genericLog", "pow", "time", "rank"]
        }
      },
      "order": { modelType: "order",
        data: { 
          ref: `markers.${markerName}.encoding.size.data.config`
        }
      },
      "size": {
        scale: {
          modelType: "size",
          allowedTypes: ["linear", "log", "genericLog", "pow", "point"],
          range: [0, 50]
        }
      },
      "color": { scale: { modelType: "color" } },
      "label": { data: { modelType: "entityPropertyDataConfig" } },
      "frame": { modelType: "frame" },
      "trail": { modelType: "trail" },             
      "size_label": {
        data: {
          constant: "_default"
        },
        scale: {
          modelType: "size",
          allowedTypes: ["linear", "log", "genericLog", "pow", "point"]
        }
      },
      "repeat": {
        modelType: "repeat",
        allowEnc: ["y", "x"]
      }
    }
  });

  BubbleChart.versionInfo = { version: "4.1.4", build: 1703287731331, package: {"homepage":"https://github.com/vizabi/bubblechart#readme","name":"@vizabi/bubblechart","description":"Vizabi bubble chart"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = BubbleChart;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/bubblemap#readme v4.3.2 build 1706309492096 Copyright 2024 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('d3'), require('mobx')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'd3', 'mobx'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BubbleMap = {}, global.VizabiSharedComponents, global.d3, global.mobx));
})(window, (function (exports, sharedComponents, d3$1, mobx) {
  // topojson
  var topojson = (function() {
    var topojson = {
      version: "1.6.19",
      mesh: function(topology) {
         return object(topology, meshArcs.apply(this, arguments));
      },
      meshArcs: meshArcs,
      merge: function(topology) {
        return object(topology, mergeArcs.apply(this, arguments));
      },
      mergeArcs: mergeArcs,
      feature: featureOrCollection,
      neighbors: neighbors,
      presimplify: presimplify
    };

    function stitchArcs(topology, arcs) {
      var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

      // Stitch empty arcs first, since they may be subsumed by other arcs.
      arcs.forEach(function(i, j) {
        var arc = topology.arcs[i < 0 ? ~i : i],
          t;
        if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
          t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
        }
      });

      arcs.forEach(function(i) {
        var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

        if (f = fragmentByEnd[start]) {
          delete fragmentByEnd[f.end];
          f.push(i);
          f.end = end;
          if (g = fragmentByStart[end]) {
            delete fragmentByStart[g.start];
            var fg = g === f ? f : f.concat(g);
            fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else if (f = fragmentByStart[end]) {
          delete fragmentByStart[f.start];
          f.unshift(i);
          f.start = start;
          if (g = fragmentByEnd[start]) {
            delete fragmentByEnd[g.end];
            var gf = g === f ? f : g.concat(f);
            fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else {
          f = [i];
          fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
        }
      });

      function ends(i) {
        var arc = topology.arcs[i < 0 ? ~i : i],
          p0 = arc[0],
          p1;
        if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
          p1[0] += dp[0], p1[1] += dp[1];
        });
        else p1 = arc[arc.length - 1];
        return i < 0 ? [p1, p0] : [p0, p1];
      }

      function flush(fragmentByEnd, fragmentByStart) {
        for (var k in fragmentByEnd) {
          var f = fragmentByEnd[k];
          delete fragmentByStart[f.start];
          delete f.start;
          delete f.end;
          f.forEach(function(i) {
            stitchedArcs[i < 0 ? ~i : i] = 1;
          });
          fragments.push(f);
        }
      }

      flush(fragmentByEnd, fragmentByStart);
      flush(fragmentByStart, fragmentByEnd);
      arcs.forEach(function(i) {
        if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
      });

      return fragments;
    }

    function meshArcs(topology, o, filter) {
      var arcs = [];

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({
          i: i,
          g: geom
        });
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      if (arguments.length > 1) {
        var geomsByArc = [],
          geom;

        var geometryType = {
          LineString: line,
          MultiLineString: polygon,
          Polygon: polygon,
          MultiPolygon: function(arcs) {
            arcs.forEach(polygon);
          }
        };

        geometry(o);

        geomsByArc.forEach(arguments.length < 3 ? function(geoms) {
          arcs.push(geoms[0].i);
        } : function(geoms) {
          if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
        });
      } else {
        for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
      }

      return {
        type: "MultiLineString",
        arcs: stitchArcs(topology, arcs)
      };
    }

    function mergeArcs(topology, objects) {
      var polygonsByArc = {},
        polygons = [],
        components = [];

      objects.forEach(function(o) {
        if (o.type === "Polygon") register(o.arcs);
        else if (o.type === "MultiPolygon") o.arcs.forEach(register);
      });

      function register(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
          });
        });
        polygons.push(polygon);
      }

      function exterior(ring) {
        return cartesianRingArea(object(topology, {
          type: "Polygon",
          arcs: [ring]
        }).coordinates[0]) > 0; // TODO allow spherical?
      }

      polygons.forEach(function(polygon) {
        if (!polygon._) {
          var component = [],
            neighbors = [polygon];
          polygon._ = 1;
          components.push(component);
          while (polygon = neighbors.pop()) {
            component.push(polygon);
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                  if (!polygon._) {
                    polygon._ = 1;
                    neighbors.push(polygon);
                  }
                });
              });
            });
          }
        }
      });

      polygons.forEach(function(polygon) {
        delete polygon._;
      });

      return {
        type: "MultiPolygon",
        arcs: components.map(function(polygons) {
          var arcs = [];

          // Extract the exterior (unique) arcs.
          polygons.forEach(function(polygon) {
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                  arcs.push(arc);
                }
              });
            });
          });

          // Stitch the arcs into one or more rings.
          arcs = stitchArcs(topology, arcs);

          // If more than one ring is returned,
          // at most one of these rings can be the exterior;
          // this exterior ring has the same winding order
          // as any exterior ring in the original polygons.
          if ((n = arcs.length) > 1) {
            var sgn = exterior(polygons[0][0]);
            for (var i = 0, t; i < n; ++i) {
              if (sgn === exterior(arcs[i])) {
                t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
                break;
              }
            }
          }

          return arcs;
        })
      };
    }

    function featureOrCollection(topology, o) {
      return o.type === "GeometryCollection" ? {
        type: "FeatureCollection",
        features: o.geometries.map(function(o) {
          return feature(topology, o);
        })
      } : feature(topology, o);
    }

    function feature(topology, o) {
      var f = {
        type: "Feature",
        id: o.id,
        properties: o.properties || {},
        geometry: object(topology, o)
      };
      if (o.id == null) delete f.id;
      return f;
    }

    function object(topology, o) {
      var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

      function arc(i, points) {
        if (points.length) points.pop();
        for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
          points.push(p = a[k].slice());
          absolute(p, k);
        }
        if (i < 0) reverse(points, n);
      }

      function point(p) {
        p = p.slice();
        absolute(p, 0);
        return p;
      }

      function line(arcs) {
        var points = [];
        for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
        if (points.length < 2) points.push(points[0].slice());
        return points;
      }

      function ring(arcs) {
        var points = line(arcs);
        while (points.length < 4) points.push(points[0].slice());
        return points;
      }

      function polygon(arcs) {
        return arcs.map(ring);
      }

      function geometry(o) {
        var t = o.type;
        return t === "GeometryCollection" ? {
          type: t,
          geometries: o.geometries.map(geometry)
        } : t in geometryType ? {
          type: t,
          coordinates: geometryType[t](o)
        } : null;
      }

      var geometryType = {
        Point: function(o) {
          return point(o.coordinates);
        },
        MultiPoint: function(o) {
          return o.coordinates.map(point);
        },
        LineString: function(o) {
          return line(o.arcs);
        },
        MultiLineString: function(o) {
          return o.arcs.map(line);
        },
        Polygon: function(o) {
          return polygon(o.arcs);
        },
        MultiPolygon: function(o) {
          return o.arcs.map(polygon);
        }
      };

      return geometry(o);
    }

    function reverse(array, n) {
      var t, j = array.length,
        i = j - n;
      while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
    }

    function bisect(a, x) {
      var lo = 0,
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (a[mid] < x) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    }

    function neighbors(objects) {
      var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() {
          return [];
        });

      function line(arcs, i) {
        arcs.forEach(function(a) {
          if (a < 0) a = ~a;
          var o = indexesByArc[a];
          if (o) o.push(i);
          else indexesByArc[a] = [i];
        });
      }

      function polygon(arcs, i) {
        arcs.forEach(function(arc) {
          line(arc, i);
        });
      }

      function geometry(o, i) {
        if (o.type === "GeometryCollection") o.geometries.forEach(function(o) {
          geometry(o, i);
        });
        else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs, i) {
          arcs.forEach(function(arc) {
            polygon(arc, i);
          });
        }
      };

      objects.forEach(geometry);

      for (var i in indexesByArc) {
        for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
          for (var k = j + 1; k < m; ++k) {
            var ij = indexes[j],
              ik = indexes[k],
              n;
            if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
            if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
          }
        }
      }

      return neighbors;
    }

    function presimplify(topology, triangleArea) {
      var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

      if (!triangleArea) triangleArea = cartesianTriangleArea;

      topology.arcs.forEach(function(arc) {
        var triangles = [],
          maxArea = 0,
          triangle;

        // To store each point鈥檚 effective area, we create a new array rather than
        // extending the passed-in point to workaround a Chrome/V8 bug (getting
        // stuck in smi mode). For midpoints, the initial effective area of
        // Infinity will be computed in the next step.
        for (var i = 0, n = arc.length, p; i < n; ++i) {
          p = arc[i];
          absolute(arc[i] = [p[0], p[1], Infinity], i);
        }

        for (var i = 1, n = arc.length - 1; i < n; ++i) {
          triangle = arc.slice(i - 1, i + 2);
          triangle[1][2] = triangleArea(triangle);
          triangles.push(triangle);
          heap.push(triangle);
        }

        for (var i = 0, n = triangles.length; i < n; ++i) {
          triangle = triangles[i];
          triangle.previous = triangles[i - 1];
          triangle.next = triangles[i + 1];
        }

        while (triangle = heap.pop()) {
          var previous = triangle.previous,
            next = triangle.next;

          // If the area of the current point is less than that of the previous point
          // to be eliminated, use the latter's area instead. This ensures that the
          // current point cannot be eliminated without eliminating previously-
          // eliminated points.
          if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
          else maxArea = triangle[1][2];

          if (previous) {
            previous.next = next;
            previous[2] = triangle[2];
            update(previous);
          }

          if (next) {
            next.previous = previous;
            next[0] = triangle[0];
            update(next);
          }
        }

        arc.forEach(relative);
      });

      function update(triangle) {
        heap.remove(triangle);
        triangle[1][2] = triangleArea(triangle);
        heap.push(triangle);
      }

      return topology;
    }

    function cartesianRingArea(ring) {
      var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

      while (++i < n) {
        a = b;
        b = ring[i];
        area += a[0] * b[1] - a[1] * b[0];
      }

      return area * .5;
    }

    function cartesianTriangleArea(triangle) {
      var a = triangle[0],
        b = triangle[1],
        c = triangle[2];
      return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
    }

    function compareArea(a, b) {
      return a[1][2] - b[1][2];
    }

    function minAreaHeap() {
      var heap = {},
        array = [],
        size = 0;

      heap.push = function(object) {
        up(array[object._ = size] = object, size++);
        return size;
      };

      heap.pop = function() {
        if (size <= 0) return;
        var removed = array[0],
          object;
        if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
        return removed;
      };

      heap.remove = function(removed) {
        var i = removed._,
          object;
        if (array[i] !== removed) return; // invalid request
        if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] =
          object, i);
        return i;
      };

      function up(object, i) {
        while (i > 0) {
          var j = ((i + 1) >> 1) - 1,
            parent = array[j];
          if (compareArea(object, parent) >= 0) break;
          array[parent._ = i] = parent;
          array[object._ = i = j] = object;
        }
      }

      function down(object, i) {
        while (true) {
          var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
          if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
          if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
          if (j === i) break;
          array[child._ = i] = child;
          array[object._ = i = j] = object;
        }
      }

      return heap;
    }

    function transformAbsolute(transform) {
      if (!transform) return noop;
      var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
      return function(point, i) {
        if (!i) x0 = y0 = 0;
        point[0] = (x0 += point[0]) * kx + dx;
        point[1] = (y0 += point[1]) * ky + dy;
      };
    }

    function transformRelative(transform) {
      if (!transform) return noop;
      var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
      return function(point, i) {
        if (!i) x0 = y0 = 0;
        var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
        point[0] = x1 - x0;
        point[1] = y1 - y0;
        x0 = x1;
        y0 = y1;
      };
    }

    function noop() {}

    return topojson;
  }());

  function d3GeoProjection() {
    d3.geoProject = function(object, projection) {
      var stream = projection.stream;
      if (!stream) throw new Error("not yet supported");
      return (object && d3_geo_projectObjectType.hasOwnProperty(object.type) ? d3_geo_projectObjectType[object.type] : d3_geo_projectGeometry)(object, stream);
    };
    function d3_geo_projectFeature(object, stream) {
      return {
        type: "Feature",
        id: object.id,
        properties: object.properties,
        geometry: d3_geo_projectGeometry(object.geometry, stream)
      };
    }
    function d3_geo_projectGeometry(geometry, stream) {
      if (!geometry) return null;
      if (geometry.type === "GeometryCollection") return {
        type: "GeometryCollection",
        geometries: object.geometries.map(function(geometry) {
          return d3_geo_projectGeometry(geometry, stream);
        })
      };
      if (!d3_geo_projectGeometryType.hasOwnProperty(geometry.type)) return null;
      var sink = d3_geo_projectGeometryType[geometry.type];
      d3.geoUstream(geometry, stream(sink));
      return sink.result();
    }
    var d3_geo_projectObjectType = {
      Feature: d3_geo_projectFeature,
      FeatureCollection: function(object, stream) {
        return {
          type: "FeatureCollection",
          features: object.features.map(function(feature) {
            return d3_geo_projectFeature(feature, stream);
          })
        };
      }
    };
    var d3_geo_projectPoints = [], d3_geo_projectLines = [];
    var d3_geo_projectPoint = {
      point: function(x, y) {
        d3_geo_projectPoints.push([x, y]);
      },
      result: function() {
        var result = !d3_geo_projectPoints.length ? null : d3_geo_projectPoints.length < 2 ? {
          type: "Point",
          coordinates: d3_geo_projectPoints[0]
        } : {
          type: "MultiPoint",
          coordinates: d3_geo_projectPoints
        };
        d3_geo_projectPoints = [];
        return result;
      }
    };
    var d3_geo_projectLine = {
      lineStart: d3_geo_projectNoop,
      point: function(x, y) {
        d3_geo_projectPoints.push([x, y]);
      },
      lineEnd: function() {
        if (d3_geo_projectPoints.length) d3_geo_projectLines.push(d3_geo_projectPoints),
        d3_geo_projectPoints = [];
      },
      result: function() {
        var result = !d3_geo_projectLines.length ? null : d3_geo_projectLines.length < 2 ? {
          type: "LineString",
          coordinates: d3_geo_projectLines[0]
        } : {
          type: "MultiLineString",
          coordinates: d3_geo_projectLines
        };
        d3_geo_projectLines = [];
        return result;
      }
    };
    var d3_geo_projectPolygon = {
      polygonStart: d3_geo_projectNoop,
      lineStart: d3_geo_projectNoop,
      point: function(x, y) {
        d3_geo_projectPoints.push([x, y]);
      },
      lineEnd: function() {
        var n = d3_geo_projectPoints.length;
        if (n) {
          do d3_geo_projectPoints.push(d3_geo_projectPoints[0].slice()); while (++n < 4);
          d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];
        }
      },
      polygonEnd: d3_geo_projectNoop,
      result: function() {
        if (!d3_geo_projectLines.length) return null;
        var polygons = [], holes = [];
        d3_geo_projectLines.forEach(function(ring) {
          if (d3_geo_projectClockwise(ring)) polygons.push([ring]); else holes.push(ring);
        });
        holes.forEach(function(hole) {
          var point = hole[0];
          polygons.some(function(polygon) {
            if (d3_geo_projectContains(polygon[0], point)) {
              polygon.push(hole);
              return true;
            }
            return false;
          }) || polygons.push([hole]);
        });
        d3_geo_projectLines = [];
        return !polygons.length ? null : polygons.length > 1 ? {
          type: "MultiPolygon",
          coordinates: polygons
        } : {
          type: "Polygon",
          coordinates: polygons[0]
        };
      }
    };
    var d3_geo_projectGeometryType = {
      Point: d3_geo_projectPoint,
      MultiPoint: d3_geo_projectPoint,
      LineString: d3_geo_projectLine,
      MultiLineString: d3_geo_projectLine,
      Polygon: d3_geo_projectPolygon,
      MultiPolygon: d3_geo_projectPolygon,
      Sphere: d3_geo_projectPolygon
    };
    function d3_geo_projectNoop() {}
    function d3_geo_projectClockwise(ring) {
      if ((n = ring.length) < 4) return false;
      var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area <= 0;
    }
    function d3_geo_projectContains(ring, point) {
      var x = point[0], y = point[1], contains = false;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;
      }
      return contains;
    }
    var ε = 1e-6, ε2 = ε * ε, π = Math.PI, halfπ = π / 2, sqrtπ = Math.sqrt(π), radians = π / 180, degrees = 180 / π;
    function sinci(x) {
      return x ? x / Math.sin(x) : 1;
    }
    function sgn(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function asin(x) {
      return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function acos(x) {
      return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function asqrt(x) {
      return x > 0 ? Math.sqrt(x) : 0;
    }
    var projection = d3.geoProjection, projectionMutator = d3.geoProjectionMutator;
    d3.geoInterrupt = function(project) {
      var lobes = [[[[-π, 0], [0, halfπ], [π, 0]]], [[[-π, 0], [0, -halfπ], [π, 0]]]];
      var bounds;
      function forward(λ, φ) {
        var sign = φ < 0 ? -1 : +1, hemilobes = lobes[+(φ < 0)];
        for (var i = 0, n = hemilobes.length - 1; i < n && λ > hemilobes[i][2][0]; ++i) ;
        var coordinates = project(λ - hemilobes[i][1][0], φ);
        coordinates[0] += project(hemilobes[i][1][0], sign * φ > sign * hemilobes[i][0][1] ? hemilobes[i][0][1] : φ)[0];
        return coordinates;
      }
      function reset() {
        bounds = lobes.map(function(hemilobes) {
          return hemilobes.map(function(lobe) {
            var x0 = project(lobe[0][0], lobe[0][1])[0], x1 = project(lobe[2][0], lobe[2][1])[0], y0 = project(lobe[1][0], lobe[0][1])[1], y1 = project(lobe[1][0], lobe[1][1])[1], t;
            if (y0 > y1) t = y0, y0 = y1, y1 = t;
            return [[x0, y0], [x1, y1]];
          });
        });
      }
      if (project.invert) forward.invert = function(x, y) {
        var hemibounds = bounds[+(y < 0)], hemilobes = lobes[+(y < 0)];
        for (var i = 0, n = hemibounds.length; i < n; ++i) {
          var b = hemibounds[i];
          if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
            var coordinates = project.invert(x - project(hemilobes[i][1][0], 0)[0], y);
            coordinates[0] += hemilobes[i][1][0];
            return pointEqual(forward(coordinates[0], coordinates[1]), [x, y]) ? coordinates : null;
          }
        }
      };
      var projection = d3.geoProjection(forward), stream_ = projection.stream;
      projection.stream = function(stream) {
        var rotate = projection.rotate(), rotateStream = stream_(stream), sphereStream = (projection.rotate([0, 0]),
        stream_(stream));
        projection.rotate(rotate);
        rotateStream.sphere = function() {
          d3.geoStream(sphere(), sphereStream);
        };
        return rotateStream;
      };
      projection.lobes = function(_) {
        if (!arguments.length) return lobes.map(function(lobes) {
          return lobes.map(function(lobe) {
            return [[lobe[0][0] * 180 / π, lobe[0][1] * 180 / π], [lobe[1][0] * 180 / π, lobe[1][1] * 180 / π], [lobe[2][0] * 180 / π, lobe[2][1] * 180 / π]];
          });
        });
        lobes = _.map(function(lobes) {
          return lobes.map(function(lobe) {
            return [[lobe[0][0] * π / 180, lobe[0][1] * π / 180], [lobe[1][0] * π / 180, lobe[1][1] * π / 180], [lobe[2][0] * π / 180, lobe[2][1] * π / 180]];
          });
        });
        reset();
        return projection;
      };
      function sphere() {
        var ε = 1e-6, coordinates = [];
        for (var i = 0, n = lobes[0].length; i < n; ++i) {
          var lobe = lobes[0][i], λ0 = lobe[0][0] * 180 / π, φ0 = lobe[0][1] * 180 / π, φ1 = lobe[1][1] * 180 / π, λ2 = lobe[2][0] * 180 / π, φ2 = lobe[2][1] * 180 / π;
          coordinates.push(resample([[λ0 + ε, φ0 + ε], [λ0 + ε, φ1 - ε], [λ2 - ε, φ1 - ε], [λ2 - ε, φ2 + ε]], 30));
        }
        for (var i = lobes[1].length - 1; i >= 0; --i) {
          var lobe = lobes[1][i], λ0 = lobe[0][0] * 180 / π, φ0 = lobe[0][1] * 180 / π, φ1 = lobe[1][1] * 180 / π, λ2 = lobe[2][0] * 180 / π, φ2 = lobe[2][1] * 180 / π;
          coordinates.push(resample([[λ2 - ε, φ2 - ε], [λ2 - ε, φ1 + ε], [λ0 + ε, φ1 + ε], [λ0 + ε, φ0 - ε]], 30));
        }
        return {
          type: "Polygon",
          coordinates: [d3.merge(coordinates)]
        };
      }
      function resample(coordinates, m) {
        var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];
        while (++i < n) {
          p1 = coordinates[i];
          dx = (p1[0] - p0[0]) / m;
          dy = (p1[1] - p0[1]) / m;
          for (var j = 0; j < m; ++j) resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
          p0 = p1;
        }
        resampled.push(p1);
        return resampled;
      }
      function pointEqual(a, b) {
        return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
      }
      return projection;
    };
    function airy(β) {
      var tanβ_2 = Math.tan(.5 * β), B = 2 * Math.log(Math.cos(.5 * β)) / (tanβ_2 * tanβ_2);
      function forward(λ, φ) {
        var cosλ = Math.cos(λ), cosφ = Math.cos(φ), sinφ = Math.sin(φ), cosz = cosφ * cosλ, K = -((1 - cosz ? Math.log(.5 * (1 + cosz)) / (1 - cosz) : -.5) + B / (1 + cosz));
        return [K * cosφ * Math.sin(λ), K * sinφ];
      }
      forward.invert = function(x, y) {
        var ρ = Math.sqrt(x * x + y * y), z = β * -.5, i = 50, δ;
        if (!ρ) return [0, 0];
        do {
          var z_2 = .5 * z, cosz_2 = Math.cos(z_2), sinz_2 = Math.sin(z_2), tanz_2 = Math.tan(z_2), lnsecz_2 = Math.log(1 / cosz_2);
          z -= δ = (2 / tanz_2 * lnsecz_2 - B * tanz_2 - ρ) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - B / (2 * cosz_2 * cosz_2));
        } while (Math.abs(δ) > ε && --i > 0);
        var sinz = Math.sin(z);
        return [Math.atan2(x * sinz, ρ * Math.cos(z)), asin(y * sinz / ρ)];
      };
      return forward;
    }
    function airyProjection() {
      var β = halfπ, m = projectionMutator(airy), p = m(β);
      p.radius = function(_) {
        if (!arguments.length) return β / π * 180;
        return m(β = _ * π / 180);
      };
      return p;
    }
    (d3.geoAiry = airyProjection).raw = airy;
    function aitoff(λ, φ) {
      var cosφ = Math.cos(φ), sinciα = sinci(acos(cosφ * Math.cos(λ /= 2)));
      return [2 * cosφ * Math.sin(λ) * sinciα, Math.sin(φ) * sinciα];
    }
    aitoff.invert = function(x, y) {
      if (x * x + 4 * y * y > π * π + ε) return;
      var λ = x, φ = y, i = 25;
      do {
        var sinλ = Math.sin(λ), sinλ_2 = Math.sin(λ / 2), cosλ_2 = Math.cos(λ / 2), sinφ = Math.sin(φ), cosφ = Math.cos(φ), sin_2φ = Math.sin(2 * φ), sin2φ = sinφ * sinφ, cos2φ = cosφ * cosφ, sin2λ_2 = sinλ_2 * sinλ_2, C = 1 - cos2φ * cosλ_2 * cosλ_2, E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = 2 * E * cosφ * sinλ_2 - x, fy = E * sinφ - y, δxδλ = F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ), δxδφ = F * (.5 * sinλ * sin_2φ - E * 2 * sinφ * sinλ_2), δyδλ = F * .25 * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ), δyδφ = F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ), denominator = δxδφ * δyδλ - δyδφ * δxδλ;
        if (!denominator) break;
        var δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ, φ -= δφ;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return [λ, φ];
    };
    (d3.geoAitoff = function() {
      return projection(aitoff);
    }).raw = aitoff;
    function armadillo(φ0) {
      var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sφ0 = φ0 > 0 ? 1 : -1, tanφ0 = Math.tan(sφ0 * φ0), k = (1 + sinφ0 - cosφ0) / 2;
      function forward(λ, φ) {
        var cosφ = Math.cos(φ), cosλ = Math.cos(λ /= 2);
        return [(1 + cosφ) * Math.sin(λ), (sφ0 * φ > -Math.atan2(cosλ, tanφ0) - .001 ? 0 : -sφ0 * 10) + k + Math.sin(φ) * cosφ0 - (1 + cosφ) * sinφ0 * cosλ];
      }
      forward.invert = function(x, y) {
        var λ = 0, φ = 0, i = 50;
        do {
          var cosλ = Math.cos(λ), sinλ = Math.sin(λ), cosφ = Math.cos(φ), sinφ = Math.sin(φ), A = 1 + cosφ, fx = A * sinλ - x, fy = k + sinφ * cosφ0 - A * sinφ0 * cosλ - y, δxδλ = .5 * A * cosλ, δxδφ = -sinλ * sinφ, δyδλ = .5 * sinφ0 * A * sinλ, δyδφ = cosφ0 * cosφ + sinφ0 * cosλ * sinφ, denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = .5 * (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
          λ -= δλ, φ -= δφ;
        } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
        return sφ0 * φ > -Math.atan2(Math.cos(λ), tanφ0) - .001 ? [λ * 2, φ] : null;
      };
      return forward;
    }
    function armadilloProjection() {
      var φ0 = π / 9, sφ0 = φ0 > 0 ? 1 : -1, tanφ0 = Math.tan(sφ0 * φ0), m = projectionMutator(armadillo), p = m(φ0), stream_ = p.stream;
      p.parallel = function(_) {
        if (!arguments.length) return φ0 / π * 180;
        tanφ0 = Math.tan((sφ0 = (φ0 = _ * π / 180) > 0 ? 1 : -1) * φ0);
        return m(φ0);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          sphereStream.polygonStart(), sphereStream.lineStart();
          for (var λ = sφ0 * -180; sφ0 * λ < 180; λ += sφ0 * 90) sphereStream.point(λ, sφ0 * 90);
          while (sφ0 * (λ -= φ0) >= -180) {
            sphereStream.point(λ, sφ0 * -Math.atan2(Math.cos(λ * radians / 2), tanφ0) * degrees);
          }
          sphereStream.lineEnd(), sphereStream.polygonEnd();
        };
        return rotateStream;
      };
      return p;
    }
    (d3.geoArmadillo = armadilloProjection).raw = armadillo;
    function tanh(x) {
      x = Math.exp(2 * x);
      return (x - 1) / (x + 1);
    }
    function sinh(x) {
      return .5 * (Math.exp(x) - Math.exp(-x));
    }
    function cosh(x) {
      return .5 * (Math.exp(x) + Math.exp(-x));
    }
    function arsinh(x) {
      return Math.log(x + asqrt(x * x + 1));
    }
    function arcosh(x) {
      return Math.log(x + asqrt(x * x - 1));
    }
    function august(λ, φ) {
      var tanφ = Math.tan(φ / 2), k = asqrt(1 - tanφ * tanφ), c = 1 + k * Math.cos(λ /= 2), x = Math.sin(λ) * k / c, y = tanφ / c, x2 = x * x, y2 = y * y;
      return [4 / 3 * x * (3 + x2 - 3 * y2), 4 / 3 * y * (3 + 3 * x2 - y2)];
    }
    august.invert = function(x, y) {
      x *= 3 / 8, y *= 3 / 8;
      if (!x && Math.abs(y) > 1) return null;
      var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3η = Math.sqrt(.5 * (s - Math.sqrt(s * s - 4 * y * y))), η = asin(sin3η) / 3, ξ = sin3η ? arcosh(Math.abs(y / sin3η)) / 3 : arsinh(Math.abs(x)) / 3, cosη = Math.cos(η), coshξ = cosh(ξ), d = coshξ * coshξ - cosη * cosη;
      return [sgn(x) * 2 * Math.atan2(sinh(ξ) * cosη, .25 - d), sgn(y) * 2 * Math.atan2(coshξ * Math.sin(η), .25 + d)];
    };
    (d3.geoAugust = function() {
      return projection(august);
    }).raw = august;
    var bakerφ = Math.log(1 + Math.SQRT2);
    function baker(λ, φ) {
      var φ0 = Math.abs(φ);
      return φ0 < π / 4 ? [λ, Math.log(Math.tan(π / 4 + φ / 2))] : [λ * Math.cos(φ0) * (2 * Math.SQRT2 - 1 / Math.sin(φ0)), sgn(φ) * (2 * Math.SQRT2 * (φ0 - π / 4) - Math.log(Math.tan(φ0 / 2)))];
    }
    baker.invert = function(x, y) {
      if ((y0 = Math.abs(y)) < bakerφ) return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      var sqrt8 = Math.sqrt(8), φ = π / 4, i = 25, δ, y0;
      do {
        var cosφ_2 = Math.cos(φ / 2), tanφ_2 = Math.tan(φ / 2);
        φ -= δ = (sqrt8 * (φ - π / 4) - Math.log(tanφ_2) - y0) / (sqrt8 - .5 * cosφ_2 * cosφ_2 / tanφ_2);
      } while (Math.abs(δ) > ε2 && --i > 0);
      return [x / (Math.cos(φ) * (sqrt8 - 1 / Math.sin(φ))), sgn(y) * φ];
    };
    (d3.geoBaker = function() {
      return projection(baker);
    }).raw = baker;
    var berghausAzimuthalEquidistant = d3.geoAzimuthalEquidistant.raw;
    function berghaus(n) {
      var k = 2 * π / n;
      function forward(λ, φ) {
        var p = berghausAzimuthalEquidistant(λ, φ);
        if (Math.abs(λ) > halfπ) {
          var θ = Math.atan2(p[1], p[0]), r = Math.sqrt(p[0] * p[0] + p[1] * p[1]), θ0 = k * Math.round((θ - halfπ) / k) + halfπ, α = Math.atan2(Math.sin(θ -= θ0), 2 - Math.cos(θ));
          θ = θ0 + asin(π / r * Math.sin(α)) - α;
          p[0] = r * Math.cos(θ);
          p[1] = r * Math.sin(θ);
        }
        return p;
      }
      forward.invert = function(x, y) {
        var r = Math.sqrt(x * x + y * y);
        if (r > halfπ) {
          var θ = Math.atan2(y, x), θ0 = k * Math.round((θ - halfπ) / k) + halfπ, s = θ > θ0 ? -1 : 1, A = r * Math.cos(θ0 - θ), cotα = 1 / Math.tan(s * Math.acos((A - π) / Math.sqrt(π * (π - 2 * A) + r * r)));
          θ = θ0 + 2 * Math.atan((cotα + s * Math.sqrt(cotα * cotα - 3)) / 3);
          x = r * Math.cos(θ), y = r * Math.sin(θ);
        }
        return berghausAzimuthalEquidistant.invert(x, y);
      };
      return forward;
    }
    function berghausProjection() {
      var n = 5, m = projectionMutator(berghaus), p = m(n), stream_ = p.stream, ε = .01, cr = -Math.cos(ε * radians), sr = Math.sin(ε * radians);
      p.lobes = function(_) {
        if (!arguments.length) return n;
        return m(n = +_);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          sphereStream.polygonStart(), sphereStream.lineStart();
          for (var i = 0, δ = 360 / n, δ0 = 2 * π / n, φ = 90 - 180 / n, φ0 = halfπ; i < n; ++i,
          φ -= δ, φ0 -= δ0) {
            sphereStream.point(Math.atan2(sr * Math.cos(φ0), cr) * degrees, asin(sr * Math.sin(φ0)) * degrees);
            if (φ < -90) {
              sphereStream.point(-90, -180 - φ - ε);
              sphereStream.point(-90, -180 - φ + ε);
            } else {
              sphereStream.point(90, φ + ε);
              sphereStream.point(90, φ - ε);
            }
          }
          sphereStream.lineEnd(), sphereStream.polygonEnd();
        };
        return rotateStream;
      };
      return p;
    }
    (d3.geoBerghaus = berghausProjection).raw = berghaus;
    function mollweideBromleyθ(Cp) {
      return function(θ) {
        var Cpsinθ = Cp * Math.sin(θ), i = 30, δ;
        do θ -= δ = (θ + Math.sin(θ) - Cpsinθ) / (1 + Math.cos(θ)); while (Math.abs(δ) > ε && --i > 0);
        return θ / 2;
      };
    }
    function mollweideBromley(Cx, Cy, Cp) {
      var θ = mollweideBromleyθ(Cp);
      function forward(λ, φ) {
        return [Cx * λ * Math.cos(φ = θ(φ)), Cy * Math.sin(φ)];
      }
      forward.invert = function(x, y) {
        var θ = asin(y / Cy);
        return [x / (Cx * Math.cos(θ)), asin((2 * θ + Math.sin(2 * θ)) / Cp)];
      };
      return forward;
    }
    var mollweideθ = mollweideBromleyθ(π), mollweide = mollweideBromley(Math.SQRT2 / halfπ, Math.SQRT2, π);
    (d3.geoMollweide = function() {
      return projection(mollweide);
    }).raw = mollweide;
    function boggs(λ, φ) {
      var k = 2.00276, θ = mollweideθ(φ);
      return [k * λ / (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)), (φ + Math.SQRT2 * Math.sin(θ)) / k];
    }
    boggs.invert = function(x, y) {
      var k = 2.00276, ky = k * y, θ = y < 0 ? -π / 4 : π / 4, i = 25, δ, φ;
      do {
        φ = ky - Math.SQRT2 * Math.sin(θ);
        θ -= δ = (Math.sin(2 * θ) + 2 * θ - π * Math.sin(φ)) / (2 * Math.cos(2 * θ) + 2 + π * Math.cos(φ) * Math.SQRT2 * Math.cos(θ));
      } while (Math.abs(δ) > ε && --i > 0);
      φ = ky - Math.SQRT2 * Math.sin(θ);
      return [x * (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)) / k, φ];
    };
    (d3.geoBoggs = function() {
      return projection(boggs);
    }).raw = boggs;
    function parallel1Projection(projectAt) {
      var φ0 = 0, m = projectionMutator(projectAt), p = m(φ0);
      p.parallel = function(_) {
        if (!arguments.length) return φ0 / π * 180;
        return m(φ0 = _ * π / 180);
      };
      return p;
    }
    function sinusoidal(λ, φ) {
      return [λ * Math.cos(φ), φ];
    }
    sinusoidal.invert = function(x, y) {
      return [x / Math.cos(y), y];
    };
    (d3.geoSinusoidal = function() {
      return projection(sinusoidal);
    }).raw = sinusoidal;
    function bonne(φ0) {
      if (!φ0) return sinusoidal;
      var cotφ0 = 1 / Math.tan(φ0);
      function forward(λ, φ) {
        var ρ = cotφ0 + φ0 - φ, E = ρ ? λ * Math.cos(φ) / ρ : ρ;
        return [ρ * Math.sin(E), cotφ0 - ρ * Math.cos(E)];
      }
      forward.invert = function(x, y) {
        var ρ = Math.sqrt(x * x + (y = cotφ0 - y) * y), φ = cotφ0 + φ0 - ρ;
        return [ρ / Math.cos(φ) * Math.atan2(x, y), φ];
      };
      return forward;
    }
    (d3.geoBonne = function() {
      return parallel1Projection(bonne).parallel(45);
    }).raw = bonne;
    var bromley = mollweideBromley(1, 4 / π, π);
    (d3.geoBromley = function() {
      return projection(bromley);
    }).raw = bromley;
    function chamberlin(points) {
      points = points.map(function(p) {
        return [p[0], p[1], Math.sin(p[1]), Math.cos(p[1])];
      });
      for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {
        b = points[i];
        a.v = chamberlinDistanceAzimuth(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
        a.point = [0, 0];
      }
      var β0 = chamberlinAngle(points[0].v[0], points[2].v[0], points[1].v[0]), β1 = chamberlinAngle(points[0].v[0], points[1].v[0], points[2].v[0]), β2 = π - β0;
      points[2].point[1] = 0;
      points[0].point[0] = -(points[1].point[0] = .5 * points[0].v[0]);
      var mean = [points[2].point[0] = points[0].point[0] + points[2].v[0] * Math.cos(β0), 2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * Math.sin(β0))];
      function forward(λ, φ) {
        var sinφ = Math.sin(φ), cosφ = Math.cos(φ), v = new Array(3);
        for (var i = 0; i < 3; ++i) {
          var p = points[i];
          v[i] = chamberlinDistanceAzimuth(φ - p[1], p[3], p[2], cosφ, sinφ, λ - p[0]);
          if (!v[i][0]) return p.point;
          v[i][1] = chamberlinLongitude(v[i][1] - p.v[1]);
        }
        var point = mean.slice();
        for (var i = 0; i < 3; ++i) {
          var j = i == 2 ? 0 : i + 1;
          var a = chamberlinAngle(points[i].v[0], v[i][0], v[j][0]);
          if (v[i][1] < 0) a = -a;
          if (!i) {
            point[0] += v[i][0] * Math.cos(a);
            point[1] -= v[i][0] * Math.sin(a);
          } else if (i == 1) {
            a = β1 - a;
            point[0] -= v[i][0] * Math.cos(a);
            point[1] -= v[i][0] * Math.sin(a);
          } else {
            a = β2 - a;
            point[0] += v[i][0] * Math.cos(a);
            point[1] += v[i][0] * Math.sin(a);
          }
        }
        point[0] /= 3, point[1] /= 3;
        return point;
      }
      return forward;
    }
    function chamberlinProjection() {
      var points = [[0, 0], [0, 0], [0, 0]], m = projectionMutator(chamberlin), p = m(points), rotate = p.rotate;
      delete p.rotate;
      p.points = function(_) {
        if (!arguments.length) return points;
        points = _;
        var origin = d3.geoCentroid({
          type: "MultiPoint",
          coordinates: points
        }), r = [-origin[0], -origin[1]];
        rotate.call(p, r);
        return m(points.map(d3.geoRotation(r)).map(chamberlinRadians));
      };
      return p.points([[-150, 55], [-35, 55], [-92.5, 10]]);
    }
    function chamberlinDistanceAzimuth(dφ, c1, s1, c2, s2, dλ) {
      var cosdλ = Math.cos(dλ), r;
      if (Math.abs(dφ) > 1 || Math.abs(dλ) > 1) {
        r = acos(s1 * s2 + c1 * c2 * cosdλ);
      } else {
        var sindφ = Math.sin(.5 * dφ), sindλ = Math.sin(.5 * dλ);
        r = 2 * asin(Math.sqrt(sindφ * sindφ + c1 * c2 * sindλ * sindλ));
      }
      if (Math.abs(r) > ε) {
        return [r, Math.atan2(c2 * Math.sin(dλ), c1 * s2 - s1 * c2 * cosdλ)];
      }
      return [0, 0];
    }
    function chamberlinAngle(b, c, a) {
      return acos(.5 * (b * b + c * c - a * a) / (b * c));
    }
    function chamberlinLongitude(λ) {
      return λ - 2 * π * Math.floor((λ + π) / (2 * π));
    }
    function chamberlinRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }
    (d3.geoChamberlin = chamberlinProjection).raw = chamberlin;
    function collignon(λ, φ) {
      var α = asqrt(1 - Math.sin(φ));
      return [2 / sqrtπ * λ * α, sqrtπ * (1 - α)];
    }
    collignon.invert = function(x, y) {
      var λ = (λ = y / sqrtπ - 1) * λ;
      return [λ > 0 ? x * Math.sqrt(π / λ) / 2 : 0, asin(1 - λ)];
    };
    (d3.geoCollignon = function() {
      return projection(collignon);
    }).raw = collignon;
    function craig(φ0) {
      var tanφ0 = Math.tan(φ0);
      function forward(λ, φ) {
        return [λ, (λ ? λ / Math.sin(λ) : 1) * (Math.sin(φ) * Math.cos(λ) - tanφ0 * Math.cos(φ))];
      }
      forward.invert = tanφ0 ? function(x, y) {
        if (x) y *= Math.sin(x) / x;
        var cosλ = Math.cos(x);
        return [x, 2 * Math.atan2(Math.sqrt(cosλ * cosλ + tanφ0 * tanφ0 - y * y) - cosλ, tanφ0 - y)];
      } : function(x, y) {
        return [x, asin(x ? y * Math.tan(x) / x : y)];
      };
      return forward;
    }
    (d3.geoCraig = function() {
      return parallel1Projection(craig);
    }).raw = craig;
    function craster(λ, φ) {
      var sqrt3 = Math.sqrt(3);
      return [sqrt3 * λ * (2 * Math.cos(2 * φ / 3) - 1) / sqrtπ, sqrt3 * sqrtπ * Math.sin(φ / 3)];
    }
    craster.invert = function(x, y) {
      var sqrt3 = Math.sqrt(3), φ = 3 * asin(y / (sqrt3 * sqrtπ));
      return [sqrtπ * x / (sqrt3 * (2 * Math.cos(2 * φ / 3) - 1)), φ];
    };
    (d3.geoCraster = function() {
      return projection(craster);
    }).raw = craster;
    function cylindricalEqualArea(φ0) {
      var cosφ0 = Math.cos(φ0);
      function forward(λ, φ) {
        return [λ * cosφ0, Math.sin(φ) / cosφ0];
      }
      forward.invert = function(x, y) {
        return [x / cosφ0, asin(y * cosφ0)];
      };
      return forward;
    }
    (d3.geoCylindricalEqualArea = function() {
      return parallel1Projection(cylindricalEqualArea);
    }).raw = cylindricalEqualArea;
    function cylindricalStereographic(φ0) {
      var cosφ0 = Math.cos(φ0);
      function forward(λ, φ) {
        return [λ * cosφ0, (1 + cosφ0) * Math.tan(φ * .5)];
      }
      forward.invert = function(x, y) {
        return [x / cosφ0, Math.atan(y / (1 + cosφ0)) * 2];
      };
      return forward;
    }
    (d3.geoCylindricalStereographic = function() {
      return parallel1Projection(cylindricalStereographic);
    }).raw = cylindricalStereographic;
    function eckert1(λ, φ) {
      var α = Math.sqrt(8 / (3 * π));
      return [α * λ * (1 - Math.abs(φ) / π), α * φ];
    }
    eckert1.invert = function(x, y) {
      var α = Math.sqrt(8 / (3 * π)), φ = y / α;
      return [x / (α * (1 - Math.abs(φ) / π)), φ];
    };
    (d3.geoEckert1 = function() {
      return projection(eckert1);
    }).raw = eckert1;
    function eckert2(λ, φ) {
      var α = Math.sqrt(4 - 3 * Math.sin(Math.abs(φ)));
      return [2 / Math.sqrt(6 * π) * λ * α, sgn(φ) * Math.sqrt(2 * π / 3) * (2 - α)];
    }
    eckert2.invert = function(x, y) {
      var α = 2 - Math.abs(y) / Math.sqrt(2 * π / 3);
      return [x * Math.sqrt(6 * π) / (2 * α), sgn(y) * asin((4 - α * α) / 3)];
    };
    (d3.geoEckert2 = function() {
      return projection(eckert2);
    }).raw = eckert2;
    function eckert3(λ, φ) {
      var k = Math.sqrt(π * (4 + π));
      return [2 / k * λ * (1 + Math.sqrt(1 - 4 * φ * φ / (π * π))), 4 / k * φ];
    }
    eckert3.invert = function(x, y) {
      var k = Math.sqrt(π * (4 + π)) / 2;
      return [x * k / (1 + asqrt(1 - y * y * (4 + π) / (4 * π))), y * k / 2];
    };
    (d3.geoEckert3 = function() {
      return projection(eckert3);
    }).raw = eckert3;
    function eckert4(λ, φ) {
      var k = (2 + halfπ) * Math.sin(φ);
      φ /= 2;
      for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
        var cosφ = Math.cos(φ);
        φ -= δ = (φ + Math.sin(φ) * (cosφ + 2) - k) / (2 * cosφ * (1 + cosφ));
      }
      return [2 / Math.sqrt(π * (4 + π)) * λ * (1 + Math.cos(φ)), 2 * Math.sqrt(π / (4 + π)) * Math.sin(φ)];
    }
    eckert4.invert = function(x, y) {
      var A = .5 * y * Math.sqrt((4 + π) / π), k = asin(A), c = Math.cos(k);
      return [x / (2 / Math.sqrt(π * (4 + π)) * (1 + c)), asin((k + A * (c + 2)) / (2 + halfπ))];
    };
    (d3.geoEckert4 = function() {
      return projection(eckert4);
    }).raw = eckert4;
    function eckert5(λ, φ) {
      return [λ * (1 + Math.cos(φ)) / Math.sqrt(2 + π), 2 * φ / Math.sqrt(2 + π)];
    }
    eckert5.invert = function(x, y) {
      var k = Math.sqrt(2 + π), φ = y * k / 2;
      return [k * x / (1 + Math.cos(φ)), φ];
    };
    (d3.geoEckert5 = function() {
      return projection(eckert5);
    }).raw = eckert5;
    function eckert6(λ, φ) {
      var k = (1 + halfπ) * Math.sin(φ);
      for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
        φ -= δ = (φ + Math.sin(φ) - k) / (1 + Math.cos(φ));
      }
      k = Math.sqrt(2 + π);
      return [λ * (1 + Math.cos(φ)) / k, 2 * φ / k];
    }
    eckert6.invert = function(x, y) {
      var j = 1 + halfπ, k = Math.sqrt(j / 2);
      return [x * 2 * k / (1 + Math.cos(y *= k)), asin((y + Math.sin(y)) / j)];
    };
    (d3.geoEckert6 = function() {
      return projection(eckert6);
    }).raw = eckert6;
    function eisenlohr(λ, φ) {
      var s0 = Math.sin(λ /= 2), c0 = Math.cos(λ), k = Math.sqrt(Math.cos(φ)), c1 = Math.cos(φ /= 2), t = Math.sin(φ) / (c1 + Math.SQRT2 * c0 * k), c = Math.sqrt(2 / (1 + t * t)), v = Math.sqrt((Math.SQRT2 * c1 + (c0 + s0) * k) / (Math.SQRT2 * c1 + (c0 - s0) * k));
      return [eisenlohrK * (c * (v - 1 / v) - 2 * Math.log(v)), eisenlohrK * (c * t * (v + 1 / v) - 2 * Math.atan(t))];
    }
    eisenlohr.invert = function(x, y) {
      var p = d3.geoAugust.raw.invert(x / 1.2, y * 1.065);
      if (!p) return null;
      var λ = p[0], φ = p[1], i = 20;
      x /= eisenlohrK, y /= eisenlohrK;
      do {
        var _0 = λ / 2, _1 = φ / 2, s0 = Math.sin(_0), c0 = Math.cos(_0), s1 = Math.sin(_1), c1 = Math.cos(_1), cos1 = Math.cos(φ), k = Math.sqrt(cos1), t = s1 / (c1 + Math.SQRT2 * c0 * k), t2 = t * t, c = Math.sqrt(2 / (1 + t2)), v0 = Math.SQRT2 * c1 + (c0 + s0) * k, v1 = Math.SQRT2 * c1 + (c0 - s0) * k, v2 = v0 / v1, v = Math.sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * Math.log(v) - x, fy = c * t * vp1v - 2 * Math.atan(t) - y, δtδλ = s1 && Math.SQRT1_2 * k * s0 * t2 / s1, δtδφ = (Math.SQRT2 * c0 * c1 + k) / (2 * (c1 + Math.SQRT2 * c0 * k) * (c1 + Math.SQRT2 * c0 * k) * k), δcδt = -.5 * t * c * c * c, δcδλ = δcδt * δtδλ, δcδφ = δcδt * δtδφ, A = (A = 2 * c1 + Math.SQRT2 * k * (c0 - s0)) * A * v, δvδλ = (Math.SQRT2 * c0 * c1 * k + cos1) / A, δvδφ = -(Math.SQRT2 * s0 * s1) / (k * A), δxδλ = vm1v * δcδλ - 2 * δvδλ / v + c * (δvδλ + δvδλ / v2), δxδφ = vm1v * δcδφ - 2 * δvδφ / v + c * (δvδφ + δvδφ / v2), δyδλ = t * vp1v * δcδλ - 2 * δtδλ / (1 + t2) + c * vp1v * δtδλ + c * t * (δvδλ - δvδλ / v2), δyδφ = t * vp1v * δcδφ - 2 * δtδφ / (1 + t2) + c * vp1v * δtδφ + c * t * (δvδφ - δvδφ / v2), denominator = δxδφ * δyδλ - δyδφ * δxδλ;
        if (!denominator) break;
        var δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ;
        φ = Math.max(-halfπ, Math.min(halfπ, φ - δφ));
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return Math.abs(Math.abs(φ) - halfπ) < ε ? [0, φ] : i && [λ, φ];
    };
    var eisenlohrK = 3 + 2 * Math.SQRT2;
    (d3.geoEisenlohr = function() {
      return projection(eisenlohr);
    }).raw = eisenlohr;
    function fahey(λ, φ) {
      var t = Math.tan(φ / 2);
      return [λ * faheyK * asqrt(1 - t * t), (1 + faheyK) * t];
    }
    fahey.invert = function(x, y) {
      var t = y / (1 + faheyK);
      return [x ? x / (faheyK * asqrt(1 - t * t)) : 0, 2 * Math.atan(t)];
    };
    var faheyK = Math.cos(35 * radians);
    (d3.geoFahey = function() {
      return projection(fahey);
    }).raw = fahey;
    function foucaut(λ, φ) {
      var k = φ / 2, cosk = Math.cos(k);
      return [2 * λ / sqrtπ * Math.cos(φ) * cosk * cosk, sqrtπ * Math.tan(k)];
    }
    foucaut.invert = function(x, y) {
      var k = Math.atan(y / sqrtπ), cosk = Math.cos(k), φ = 2 * k;
      return [x * sqrtπ * .5 / (Math.cos(φ) * cosk * cosk), φ];
    };
    (d3.geoFoucaut = function() {
      return projection(foucaut);
    }).raw = foucaut;
    d3.geoGilbert = function(projection) {
      var e = d3.geoEquirectangular().scale(degrees).translate([0, 0]);
      function gilbert(coordinates) {
        return projection([coordinates[0] * .5, asin(Math.tan(coordinates[1] * .5 * radians)) * degrees]);
      }
      if (projection.invert) gilbert.invert = function(coordinates) {
        coordinates = projection.invert(coordinates);
        coordinates[0] *= 2;
        coordinates[1] = 2 * Math.atan(Math.sin(coordinates[1] * radians)) * degrees;
        return coordinates;
      };
      gilbert.stream = function(stream) {
        stream = projection.stream(stream);
        var s = e.stream({
          point: function(λ, φ) {
            stream.point(λ * .5, asin(Math.tan(-φ * .5 * radians)) * degrees);
          },
          lineStart: function() {
            stream.lineStart();
          },
          lineEnd: function() {
            stream.lineEnd();
          },
          polygonStart: function() {
            stream.polygonStart();
          },
          polygonEnd: function() {
            stream.polygonEnd();
          }
        });
        s.sphere = function() {
          stream.sphere();
        };
        s.valid = false;
        return s;
      };
      return gilbert;
    };
    var gingeryAzimuthalEquidistant = d3.geoAzimuthalEquidistant.raw;
    function gingery(ρ, n) {
      var k = 2 * π / n, ρ2 = ρ * ρ;
      function forward(λ, φ) {
        var p = gingeryAzimuthalEquidistant(λ, φ), x = p[0], y = p[1], r2 = x * x + y * y;
        if (r2 > ρ2) {
          var r = Math.sqrt(r2), θ = Math.atan2(y, x), θ0 = k * Math.round(θ / k), α = θ - θ0, ρcosα = ρ * Math.cos(α), k_ = (ρ * Math.sin(α) - α * Math.sin(ρcosα)) / (halfπ - ρcosα), s_ = arcLength_(α, k_), e = (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
          x = r;
          var i = 50, δ;
          do {
            x -= δ = (ρ + gingeryIntegrate(s_, ρcosα, x) * e - r) / (s_(x) * e);
          } while (Math.abs(δ) > ε && --i > 0);
          y = α * Math.sin(x);
          if (x < halfπ) y -= k_ * (x - halfπ);
          var s = Math.sin(θ0), c = Math.cos(θ0);
          p[0] = x * c - y * s;
          p[1] = x * s + y * c;
        }
        return p;
      }
      forward.invert = function(x, y) {
        var r2 = x * x + y * y;
        if (r2 > ρ2) {
          var r = Math.sqrt(r2), θ = Math.atan2(y, x), θ0 = k * Math.round(θ / k), dθ = θ - θ0, x = r * Math.cos(dθ);
          y = r * Math.sin(dθ);
          var x_halfπ = x - halfπ, sinx = Math.sin(x), α = y / sinx, δ = x < halfπ ? Infinity : 0, i = 10;
          while (true) {
            var ρsinα = ρ * Math.sin(α), ρcosα = ρ * Math.cos(α), sinρcosα = Math.sin(ρcosα), halfπ_ρcosα = halfπ - ρcosα, k_ = (ρsinα - α * sinρcosα) / halfπ_ρcosα, s_ = arcLength_(α, k_);
            if (Math.abs(δ) < ε2 || !--i) break;
            α -= δ = (α * sinx - k_ * x_halfπ - y) / (sinx - x_halfπ * 2 * (halfπ_ρcosα * (ρcosα + α * ρsinα * Math.cos(ρcosα) - sinρcosα) - ρsinα * (ρsinα - α * sinρcosα)) / (halfπ_ρcosα * halfπ_ρcosα));
          }
          r = ρ + gingeryIntegrate(s_, ρcosα, x) * (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
          θ = θ0 + α;
          x = r * Math.cos(θ);
          y = r * Math.sin(θ);
        }
        return gingeryAzimuthalEquidistant.invert(x, y);
      };
      return forward;
    }
    function arcLength_(α, k) {
      return function(x) {
        var y_ = α * Math.cos(x);
        if (x < halfπ) y_ -= k;
        return Math.sqrt(1 + y_ * y_);
      };
    }
    function gingeryProjection() {
      var n = 6, ρ = 30 * radians, cρ = Math.cos(ρ), sρ = Math.sin(ρ), m = projectionMutator(gingery), p = m(ρ, n), stream_ = p.stream, ε = .01, cr = -Math.cos(ε * radians), sr = Math.sin(ε * radians);
      p.radius = function(_) {
        if (!arguments.length) return ρ * degrees;
        cρ = Math.cos(ρ = _ * radians);
        sρ = Math.sin(ρ);
        return m(ρ, n);
      };
      p.lobes = function(_) {
        if (!arguments.length) return n;
        return m(ρ, n = +_);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          sphereStream.polygonStart(), sphereStream.lineStart();
          for (var i = 0, δ = 2 * π / n, φ = 0; i < n; ++i, φ -= δ) {
            sphereStream.point(Math.atan2(sr * Math.cos(φ), cr) * degrees, Math.asin(sr * Math.sin(φ)) * degrees);
            sphereStream.point(Math.atan2(sρ * Math.cos(φ - δ / 2), cρ) * degrees, Math.asin(sρ * Math.sin(φ - δ / 2)) * degrees);
          }
          sphereStream.lineEnd(), sphereStream.polygonEnd();
        };
        return rotateStream;
      };
      return p;
    }
    function gingeryIntegrate(f, a, b) {
      var n = 50, h = (b - a) / n, s = f(a) + f(b);
      for (var i = 1, x = a; i < n; ++i) s += 2 * f(x += h);
      return s * .5 * h;
    }
    (d3.geoGingery = gingeryProjection).raw = gingery;
    function ginzburgPolyconic(a, b, c, d, e, f, g, h) {
      if (arguments.length < 8) h = 0;
      function forward(λ, φ) {
        if (!φ) return [a * λ / π, 0];
        var φ2 = φ * φ, xB = a + φ2 * (b + φ2 * (c + φ2 * d)), yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)), m = (xB * xB + yB * yB) / (2 * yB), α = λ * Math.asin(xB / m) / π;
        return [m * Math.sin(α), φ * (1 + φ2 * h) + m * (1 - Math.cos(α))];
      }
      forward.invert = function(x, y) {
        var λ = π * x / a, φ = y, δλ, δφ, i = 50;
        do {
          var φ2 = φ * φ, xB = a + φ2 * (b + φ2 * (c + φ2 * d)), yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dαdλ = Math.asin(xB / m) / π, α = λ * dαdλ;
          xB2 = xB * xB, dxBdφ = (2 * b + φ2 * (4 * c + φ2 * 6 * d)) * φ, dyBdφ = e + φ2 * (3 * f + φ2 * 5 * g),
          dpdφ = 2 * (xB * dxBdφ + yB * (dyBdφ - 1)), dqdφ = 2 * (dyBdφ - 1), dmdφ = (dpdφ * q - p * dqdφ) / (q * q),
          cosα = Math.cos(α), sinα = Math.sin(α), mcosα = m * cosα, msinα = m * sinα, dαdφ = λ / π * (1 / asqrt(1 - xB2 / m2)) * (dxBdφ * m - xB * dmdφ) / m2,
          fx = msinα - x, fy = φ * (1 + φ2 * h) + m - mcosα - y, δxδφ = dmdφ * sinα + mcosα * dαdφ,
          δxδλ = mcosα * dαdλ, δyδφ = 1 + dmdφ - (dmdφ * cosα - msinα * dαdφ), δyδλ = msinα * dαdλ,
          denominator = δxδφ * δyδλ - δyδφ * δxδλ;
          if (!denominator) break;
          λ -= δλ = (fy * δxδφ - fx * δyδφ) / denominator;
          φ -= δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
        return [λ, φ];
      };
      return forward;
    }
    var ginzburg4 = ginzburgPolyconic(2.8284, -1.6988, .75432, -.18071, 1.76003, -.38914, .042555);
    (d3.geoGinzburg4 = function() {
      return projection(ginzburg4);
    }).raw = ginzburg4;
    var ginzburg5 = ginzburgPolyconic(2.583819, -.835827, .170354, -.038094, 1.543313, -.411435, .082742);
    (d3.geoGinzburg5 = function() {
      return projection(ginzburg5);
    }).raw = ginzburg5;
    var ginzburg6 = ginzburgPolyconic(5 / 6 * π, -.62636, -.0344, 0, 1.3493, -.05524, 0, .045);
    (d3.geoGinzburg6 = function() {
      return projection(ginzburg6);
    }).raw = ginzburg6;
    function ginzburg8(λ, φ) {
      var λ2 = λ * λ, φ2 = φ * φ;
      return [λ * (1 - .162388 * φ2) * (.87 - 952426e-9 * λ2 * λ2), φ * (1 + φ2 / 12)];
    }
    ginzburg8.invert = function(x, y) {
      var λ = x, φ = y, i = 50, δ;
      do {
        var φ2 = φ * φ;
        φ -= δ = (φ * (1 + φ2 / 12) - y) / (1 + φ2 / 4);
      } while (Math.abs(δ) > ε && --i > 0);
      i = 50;
      x /= 1 - .162388 * φ2;
      do {
        var λ4 = (λ4 = λ * λ) * λ4;
        λ -= δ = (λ * (.87 - 952426e-9 * λ4) - x) / (.87 - .00476213 * λ4);
      } while (Math.abs(δ) > ε && --i > 0);
      return [λ, φ];
    };
    (d3.geoGinzburg8 = function() {
      return projection(ginzburg8);
    }).raw = ginzburg8;
    var ginzburg9 = ginzburgPolyconic(2.6516, -.76534, .19123, -.047094, 1.36289, -.13965, .031762);
    (d3.geoGinzburg9 = function() {
      return projection(ginzburg9);
    }).raw = ginzburg9;
    function quincuncialProjection(projectHemisphere) {
      var dx = projectHemisphere(halfπ, 0)[0] - projectHemisphere(-halfπ, 0)[0];
      function projection() {
        var quincuncial = false, m = projectionMutator(projectAt), p = m(quincuncial);
        p.quincuncial = function(_) {
          if (!arguments.length) return quincuncial;
          return m(quincuncial = !!_);
        };
        return p;
      }
      function projectAt(quincuncial) {
        var forward = quincuncial ? function(λ, φ) {
          var t = Math.abs(λ) < halfπ, p = projectHemisphere(t ? λ : λ > 0 ? λ - π : λ + π, φ);
          var x = (p[0] - p[1]) * Math.SQRT1_2, y = (p[0] + p[1]) * Math.SQRT1_2;
          if (t) return [x, y];
          var d = dx * Math.SQRT1_2, s = x > 0 ^ y > 0 ? -1 : 1;
          return [s * x - sgn(y) * d, s * y - sgn(x) * d];
        } : function(λ, φ) {
          var s = λ > 0 ? -.5 : .5, point = projectHemisphere(λ + s * π, φ);
          point[0] -= s * dx;
          return point;
        };
        if (projectHemisphere.invert) forward.invert = quincuncial ? function(x0, y0) {
          var x = (x0 + y0) * Math.SQRT1_2, y = (y0 - x0) * Math.SQRT1_2, t = Math.abs(x) < .5 * dx && Math.abs(y) < .5 * dx;
          if (!t) {
            var d = dx * Math.SQRT1_2, s = x > 0 ^ y > 0 ? -1 : 1, x1 = -s * (x0 + (y > 0 ? 1 : -1) * d), y1 = -s * (y0 + (x > 0 ? 1 : -1) * d);
            x = (-x1 - y1) * Math.SQRT1_2;
            y = (x1 - y1) * Math.SQRT1_2;
          }
          var p = projectHemisphere.invert(x, y);
          if (!t) p[0] += x > 0 ? π : -π;
          return p;
        } : function(x, y) {
          var s = x > 0 ? -.5 : .5, location = projectHemisphere.invert(x + s * dx, y), λ = location[0] - s * π;
          if (λ < -π) λ += 2 * π; else if (λ > π) λ -= 2 * π;
          location[0] = λ;
          return location;
        };
        return forward;
      }
      projection.raw = projectAt;
      return projection;
    }
    function gringorten(λ, φ) {
      var sλ = sgn(λ), sφ = sgn(φ), cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(sφ * φ);
      λ = Math.abs(Math.atan2(y, z));
      φ = asin(x);
      if (Math.abs(λ - halfπ) > ε) λ %= halfπ;
      var point = gringortenHexadecant(λ > π / 4 ? halfπ - λ : λ, φ);
      if (λ > π / 4) z = point[0], point[0] = -point[1], point[1] = -z;
      return point[0] *= sλ, point[1] *= -sφ, point;
    }
    gringorten.invert = function(x, y) {
      var sx = sgn(x), sy = sgn(y), x0 = -sx * x, y0 = -sy * y, t = y0 / x0 < 1, p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0), λ = p[0], φ = p[1];
      if (t) λ = -halfπ - λ;
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ);
      return [sx * (Math.atan2(y, -z) + π), sy * asin(x)];
    };
    function gringortenHexadecant(λ, φ) {
      if (φ === halfπ) return [0, 0];
      var sinφ = Math.sin(φ), r = sinφ * sinφ, r2 = r * r, j = 1 + r2, k = 1 + 3 * r2, q = 1 - r2, z = asin(1 / Math.sqrt(j)), v = q + r * j * z, p2 = (1 - sinφ) / v, p = Math.sqrt(p2), a2 = p2 * j, a = Math.sqrt(a2), h = p * q;
      if (λ === 0) return [0, -(h + r * a)];
      var cosφ = Math.cos(φ), secφ = 1 / cosφ, drdφ = 2 * sinφ * cosφ, dvdφ = (-3 * r + z * k) * drdφ, dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v), dpdφ = .5 * dp2dφ / p, dhdφ = q * dpdφ - 2 * r * p * drdφ, dra2dφ = r * j * dp2dφ + p2 * k * drdφ, μ = -secφ * drdφ, ν = -secφ * dra2dφ, ζ = -2 * secφ * dhdφ, Λ = 4 * λ / π;
      if (λ > .222 * π || φ < π / 4 && λ > .175 * π) {
        var x = (h + r * asqrt(a2 * (1 + r2) - h * h)) / (1 + r2);
        if (λ > π / 4) return [x, x];
        var x1 = x, x0 = .5 * x, i = 50;
        x = .5 * (x0 + x1);
        do {
          var g = Math.sqrt(a2 - x * x), f = x * (ζ + μ * g) + ν * asin(x / a) - Λ;
          if (!f) break;
          if (f < 0) x0 = x; else x1 = x;
          x = .5 * (x0 + x1);
        } while (Math.abs(x1 - x0) > ε && --i > 0);
      } else {
        var x = ε, i = 25, δ;
        do {
          var x2 = x * x, g = asqrt(a2 - x2), ζμg = ζ + μ * g, f = x * ζμg + ν * asin(x / a) - Λ, df = ζμg + (ν - μ * x2) / g;
          x -= δ = g ? f / df : 0;
        } while (Math.abs(δ) > ε && --i > 0);
      }
      return [x, -h - r * asqrt(a2 - x * x)];
    }
    function gringortenHexadecantInvert(x, y) {
      var x0 = 0, x1 = 1, r = .5, i = 50;
      while (true) {
        var r2 = r * r, sinφ = Math.sqrt(r), z = Math.asin(1 / Math.sqrt(1 + r2)), v = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinφ) / v, p = Math.sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = Math.sqrt(g2), y0 = y + h + r * g;
        if (Math.abs(x1 - x0) < ε2 || --i === 0 || y0 === 0) break;
        if (y0 > 0) x0 = r; else x1 = r;
        r = .5 * (x0 + x1);
      }
      if (!i) return null;
      var φ = Math.asin(sinφ), cosφ = Math.cos(φ), secφ = 1 / cosφ, drdφ = 2 * sinφ * cosφ, dvdφ = (-3 * r + z * (1 + 3 * r2)) * drdφ, dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v), dpdφ = .5 * dp2dφ / p, dhdφ = (1 - r2) * dpdφ - 2 * r * p * drdφ, ζ = -2 * secφ * dhdφ, μ = -secφ * drdφ, ν = -secφ * (r * (1 + r2) * dp2dφ + p2 * (1 + 3 * r2) * drdφ);
      return [π / 4 * (x * (ζ + μ * g) + ν * Math.asin(x / Math.sqrt(a2))), φ];
    }
    d3.geoGringorten = quincuncialProjection(gringorten);
    function ellipticJi(u, v, m) {
      if (!u) {
        var b = ellipticJ(v, 1 - m);
        return [[0, b[0] / b[1]], [1 / b[1], 0], [b[2] / b[1], 0]];
      }
      var a = ellipticJ(u, m);
      if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
      var b = ellipticJ(v, 1 - m), denominator = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
      return [[a[0] * b[2] / denominator, a[1] * a[2] * b[0] * b[1] / denominator], [a[1] * b[1] / denominator, -a[0] * a[2] * b[0] * b[2] / denominator], [a[2] * b[1] * b[2] / denominator, -m * a[0] * a[1] * b[0] / denominator]];
    }
    function ellipticJ(u, m) {
      var ai, b, φ, t, twon;
      if (m < ε) {
        t = Math.sin(u);
        b = Math.cos(u);
        ai = .25 * m * (u - t * b);
        return [t - ai * b, b + ai * t, 1 - .5 * m * t * t, u - ai];
      }
      if (m >= 1 - ε) {
        ai = .25 * (1 - m);
        b = cosh(u);
        t = tanh(u);
        φ = 1 / b;
        twon = b * sinh(u);
        return [t + ai * (twon - u) / (b * b), φ - ai * t * φ * (twon - u), φ + ai * t * φ * (twon + u), 2 * Math.atan(Math.exp(u)) - halfπ + ai * (twon - u) / b];
      }
      var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [Math.sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
      b = Math.sqrt(1 - m);
      twon = 1;
      while (Math.abs(c[i] / a[i]) > ε && i < 8) {
        ai = a[i++];
        c[i] = .5 * (ai - b);
        a[i] = .5 * (ai + b);
        b = asqrt(ai * b);
        twon *= 2;
      }
      φ = twon * a[i] * u;
      do {
        t = c[i] * Math.sin(b = φ) / a[i];
        φ = .5 * (asin(t) + φ);
      } while (--i);
      return [Math.sin(φ), t = Math.cos(φ), t / Math.cos(φ - b), φ];
    }
    function ellipticFi(φ, ψ, m) {
      var r = Math.abs(φ), i = Math.abs(ψ), sinhψ = sinh(i);
      if (r) {
        var cscφ = 1 / Math.sin(r), cotφ2 = 1 / (Math.tan(r) * Math.tan(r)), b = -(cotφ2 + m * sinhψ * sinhψ * cscφ * cscφ - 1 + m), c = (m - 1) * cotφ2, cotλ2 = .5 * (-b + Math.sqrt(b * b - 4 * c));
        return [ellipticF(Math.atan(1 / Math.sqrt(cotλ2)), m) * sgn(φ), ellipticF(Math.atan(asqrt((cotλ2 / cotφ2 - 1) / m)), 1 - m) * sgn(ψ)];
      }
      return [0, ellipticF(Math.atan(sinhψ), 1 - m) * sgn(ψ)];
    }
    function ellipticF(φ, m) {
      if (!m) return φ;
      if (m === 1) return Math.log(Math.tan(φ / 2 + π / 4));
      var a = 1, b = Math.sqrt(1 - m), c = Math.sqrt(m);
      for (var i = 0; Math.abs(c) > ε; i++) {
        if (φ % π) {
          var dφ = Math.atan(b * Math.tan(φ) / a);
          if (dφ < 0) dφ += π;
          φ += dφ + ~~(φ / π) * π;
        } else φ += φ;
        c = (a + b) / 2;
        b = Math.sqrt(a * b);
        c = ((a = c) - b) / 2;
      }
      return φ / (Math.pow(2, i) * a);
    }
    function guyou(λ, φ) {
      var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1), k = Math.sqrt(1 - k_ * k_), K = ellipticF(halfπ, k * k), f = -1;
      var ψ = Math.log(Math.tan(π / 4 + Math.abs(φ) / 2)), r = Math.exp(f * ψ) / Math.sqrt(k_), at = guyouComplexAtan(r * Math.cos(f * λ), r * Math.sin(f * λ)), t = ellipticFi(at[0], at[1], k * k);
      return [-t[1], (φ >= 0 ? 1 : -1) * (.5 * K - t[0])];
    }
    function guyouComplexAtan(x, y) {
      var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;
      return [.5 * ((x >= 0 ? halfπ : -halfπ) - Math.atan2(t, 2 * x)), -.25 * Math.log(t * t + 4 * x2) + .5 * Math.log(y_1 * y_1 + x2)];
    }
    function guyouComplexDivide(a, b) {
      var denominator = b[0] * b[0] + b[1] * b[1];
      return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
    }
    guyou.invert = function(x, y) {
      var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1), k = Math.sqrt(1 - k_ * k_), K = ellipticF(halfπ, k * k), f = -1;
      var j = ellipticJi(.5 * K - y, -x, k * k), tn = guyouComplexDivide(j[0], j[1]), λ = Math.atan2(tn[1], tn[0]) / f;
      return [λ, 2 * Math.atan(Math.exp(.5 / f * Math.log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfπ];
    };
    d3.geoGuyou = quincuncialProjection(guyou);
    function hammerRetroazimuthal(φ0) {
      var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), rotate = hammerRetroazimuthalRotation(φ0);
      rotate.invert = hammerRetroazimuthalRotation(-φ0);
      function forward(λ, φ) {
        var p = rotate(λ, φ);
        λ = p[0], φ = p[1];
        var sinφ = Math.sin(φ), cosφ = Math.cos(φ), cosλ = Math.cos(λ), z = acos(sinφ0 * sinφ + cosφ0 * cosφ * cosλ), sinz = Math.sin(z), K = Math.abs(sinz) > ε ? z / sinz : 1;
        return [K * cosφ0 * Math.sin(λ), (Math.abs(λ) > halfπ ? K : -K) * (sinφ0 * cosφ - cosφ0 * sinφ * cosλ)];
      }
      forward.invert = function(x, y) {
        var ρ = Math.sqrt(x * x + y * y), sinz = -Math.sin(ρ), cosz = Math.cos(ρ), a = ρ * cosz, b = -y * sinz, c = ρ * sinφ0, d = asqrt(a * a + b * b - c * c), φ = Math.atan2(a * c + b * d, b * c - a * d), λ = (ρ > halfπ ? -1 : 1) * Math.atan2(x * sinz, ρ * Math.cos(φ) * cosz + y * Math.sin(φ) * sinz);
        return rotate.invert(λ, φ);
      };
      return forward;
    }
    function hammerRetroazimuthalRotation(φ0) {
      var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0);
      return function(λ, φ) {
        var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ);
        return [Math.atan2(y, x * cosφ0 - z * sinφ0), asin(z * cosφ0 + x * sinφ0)];
      };
    }
    function hammerRetroazimuthalProjection() {
      var φ0 = 0, m = projectionMutator(hammerRetroazimuthal), p = m(φ0), rotate_ = p.rotate, stream_ = p.stream, circle = d3.geoCircle();
      p.parallel = function(_) {
        if (!arguments.length) return φ0 / π * 180;
        var r = p.rotate();
        return m(φ0 = _ * π / 180).rotate(r);
      };
      p.rotate = function(_) {
        if (!arguments.length) return _ = rotate_.call(p), _[1] += φ0 / π * 180, _;
        rotate_.call(p, [_[0], _[1] - φ0 / π * 180]);
        circle.center([-_[0], -_[1]]);
        return p;
      };
      p.stream = function(stream) {
        stream = stream_(stream);
        stream.sphere = function() {
          stream.polygonStart();
          var ε = .01, ring = circle.radius(90 - ε)().coordinates[0], n = ring.length - 1, i = -1, p;
          stream.lineStart();
          while (++i < n) stream.point((p = ring[i])[0], p[1]);
          stream.lineEnd();
          ring = circle.radius(90 + ε)().coordinates[0];
          n = ring.length - 1;
          stream.lineStart();
          while (--i >= 0) stream.point((p = ring[i])[0], p[1]);
          stream.lineEnd();
          stream.polygonEnd();
        };
        return stream;
      };
      return p;
    }
    (d3.geoHammerRetroazimuthal = hammerRetroazimuthalProjection).raw = hammerRetroazimuthal;
    var hammerAzimuthalEqualArea = d3.geoAzimuthalEqualArea.raw;
    function hammer(A, B) {
      if (arguments.length < 2) B = A;
      if (B === 1) return hammerAzimuthalEqualArea;
      if (B === Infinity) return hammerQuarticAuthalic;
      function forward(λ, φ) {
        var coordinates = hammerAzimuthalEqualArea(λ / B, φ);
        coordinates[0] *= A;
        return coordinates;
      }
      forward.invert = function(x, y) {
        var coordinates = hammerAzimuthalEqualArea.invert(x / A, y);
        coordinates[0] *= B;
        return coordinates;
      };
      return forward;
    }
    function hammerProjection() {
      var B = 2, m = projectionMutator(hammer), p = m(B);
      p.coefficient = function(_) {
        if (!arguments.length) return B;
        return m(B = +_);
      };
      return p;
    }
    function hammerQuarticAuthalic(λ, φ) {
      return [λ * Math.cos(φ) / Math.cos(φ /= 2), 2 * Math.sin(φ)];
    }
    hammerQuarticAuthalic.invert = function(x, y) {
      var φ = 2 * asin(y / 2);
      return [x * Math.cos(φ / 2) / Math.cos(φ), φ];
    };
    (d3.geoHammer = hammerProjection).raw = hammer;
    function hatano(λ, φ) {
      var c = Math.sin(φ) * (φ < 0 ? 2.43763 : 2.67595);
      for (var i = 0, δ; i < 20; i++) {
        φ -= δ = (φ + Math.sin(φ) - c) / (1 + Math.cos(φ));
        if (Math.abs(δ) < ε) break;
      }
      return [.85 * λ * Math.cos(φ *= .5), Math.sin(φ) * (φ < 0 ? 1.93052 : 1.75859)];
    }
    hatano.invert = function(x, y) {
      var θ = Math.abs(θ = y * (y < 0 ? .5179951515653813 : .5686373742600607)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ);
      return [1.1764705882352942 * x / Math.cos(θ), Math.abs(θ = ((θ += θ) + Math.sin(θ)) * (y < 0 ? .4102345310814193 : .3736990601468637)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ)];
    };
    (d3.geoHatano = function() {
      return projection(hatano);
    }).raw = hatano;
    var healpixParallel = 41 + 48 / 36 + 37 / 3600;
    function healpix(h) {
      var lambert = d3.geoCylindricalEqualArea.raw(0), φ0 = healpixParallel * π / 180, dx0 = 2 * π, dx1 = d3.geoCollignon.raw(π, φ0)[0] - d3.geoCollignon.raw(-π, φ0)[0], y0 = lambert(0, φ0)[1], y1 = d3.geoCollignon.raw(0, φ0)[1], dy1 = d3.geoCollignon.raw(0, halfπ)[1] - y1, k = 2 * π / h;
      function forward(λ, φ) {
        var point, φ2 = Math.abs(φ);
        if (φ2 > φ0) {
          var i = Math.min(h - 1, Math.max(0, Math.floor((λ + π) / k)));
          λ += π * (h - 1) / h - i * k;
          point = d3.geoCollignon.raw(λ, φ2);
          point[0] = point[0] * dx0 / dx1 - dx0 * (h - 1) / (2 * h) + i * dx0 / h;
          point[1] = y0 + (point[1] - y1) * 4 * dy1 / dx0;
          if (φ < 0) point[1] = -point[1];
        } else {
          point = lambert(λ, φ);
        }
        point[0] /= 2;
        return point;
      }
      forward.invert = function(x, y) {
        x *= 2;
        var y2 = Math.abs(y);
        if (y2 > y0) {
          var i = Math.min(h - 1, Math.max(0, Math.floor((x + π) / k)));
          x = (x + π * (h - 1) / h - i * k) * dx1 / dx0;
          var point = d3.geoCollignon.raw.invert(x, .25 * (y2 - y0) * dx0 / dy1 + y1);
          point[0] -= π * (h - 1) / h - i * k;
          if (y < 0) point[1] = -point[1];
          return point;
        }
        return lambert.invert(x, y);
      };
      return forward;
    }
    function healpixProjection() {
      var n = 2, m = projectionMutator(healpix), p = m(n), stream_ = p.stream;
      p.lobes = function(_) {
        if (!arguments.length) return n;
        return m(n = +_);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          d3.geoStream(sphere(), sphereStream);
        };
        return rotateStream;
      };
      function sphere() {
        var step = 180 / n;
        return {
          type: "Polygon",
          coordinates: [d3.range(-180, 180 + step / 2, step).map(function(x, i) {
            return [x, i & 1 ? 90 - 1e-6 : healpixParallel];
          }).concat(d3.range(180, -180 - step / 2, -step).map(function(x, i) {
            return [x, i & 1 ? -90 + 1e-6 : -healpixParallel];
          }))]
        };
      }
      return p;
    }
    (d3.geoHealpix = healpixProjection).raw = healpix;
    function hill(K) {
      var L = 1 + K, sinβ = Math.sin(1 / L), β = asin(sinβ), A = 2 * Math.sqrt(π / (B = π + 4 * β * L)), B, ρ0 = .5 * A * (L + Math.sqrt(K * (2 + K))), K2 = K * K, L2 = L * L;
      function forward(λ, φ) {
        var t = 1 - Math.sin(φ), ρ, ω;
        if (t && t < 2) {
          var θ = halfπ - φ, i = 25, δ;
          do {
            var sinθ = Math.sin(θ), cosθ = Math.cos(θ), β_β1 = β + Math.atan2(sinθ, L - cosθ), C = 1 + L2 - 2 * L * cosθ;
            θ -= δ = (θ - K2 * β - L * sinθ + C * β_β1 - .5 * t * B) / (2 * L * sinθ * β_β1);
          } while (Math.abs(δ) > ε2 && --i > 0);
          ρ = A * Math.sqrt(C);
          ω = λ * β_β1 / π;
        } else {
          ρ = A * (K + t);
          ω = λ * β / π;
        }
        return [ρ * Math.sin(ω), ρ0 - ρ * Math.cos(ω)];
      }
      forward.invert = function(x, y) {
        var ρ2 = x * x + (y -= ρ0) * y, cosθ = (1 + L2 - ρ2 / (A * A)) / (2 * L), θ = acos(cosθ), sinθ = Math.sin(θ), β_β1 = β + Math.atan2(sinθ, L - cosθ);
        return [asin(x / Math.sqrt(ρ2)) * π / β_β1, asin(1 - 2 * (θ - K2 * β - L * sinθ + (1 + L2 - 2 * L * cosθ) * β_β1) / B)];
      };
      return forward;
    }
    function hillProjection() {
      var K = 1, m = projectionMutator(hill), p = m(K);
      p.ratio = function(_) {
        if (!arguments.length) return K;
        return m(K = +_);
      };
      return p;
    }
    (d3.geoHill = hillProjection).raw = hill;
    var sinuMollweideφ = .7109889596207567, sinuMollweideY = .0528035274542;
    function sinuMollweide(λ, φ) {
      return φ > -sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] += sinuMollweideY, λ) : sinusoidal(λ, φ);
    }
    sinuMollweide.invert = function(x, y) {
      return y > -sinuMollweideφ ? mollweide.invert(x, y - sinuMollweideY) : sinusoidal.invert(x, y);
    };
    (d3.geoSinuMollweide = function() {
      return projection(sinuMollweide).rotate([-20, -55]);
    }).raw = sinuMollweide;
    function homolosine(λ, φ) {
      return Math.abs(φ) > sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] -= φ > 0 ? sinuMollweideY : -sinuMollweideY,
      λ) : sinusoidal(λ, φ);
    }
    homolosine.invert = function(x, y) {
      return Math.abs(y) > sinuMollweideφ ? mollweide.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidal.invert(x, y);
    };
    (d3.geoHomolosine = function() {
      return projection(homolosine);
    }).raw = homolosine;
    function kavrayskiy7(λ, φ) {
      return [3 * λ / (2 * π) * Math.sqrt(π * π / 3 - φ * φ), φ];
    }
    kavrayskiy7.invert = function(x, y) {
      return [2 / 3 * π * x / Math.sqrt(π * π / 3 - y * y), y];
    };
    (d3.geoKavrayskiy7 = function() {
      return projection(kavrayskiy7);
    }).raw = kavrayskiy7;
    function lagrange(n) {
      function forward(λ, φ) {
        if (Math.abs(Math.abs(φ) - halfπ) < ε) return [0, φ < 0 ? -2 : 2];
        var sinφ = Math.sin(φ), v = Math.pow((1 + sinφ) / (1 - sinφ), n / 2), c = .5 * (v + 1 / v) + Math.cos(λ *= n);
        return [2 * Math.sin(λ) / c, (v - 1 / v) / c];
      }
      forward.invert = function(x, y) {
        var y0 = Math.abs(y);
        if (Math.abs(y0 - 2) < ε) return x ? null : [0, sgn(y) * halfπ];
        if (y0 > 2) return null;
        x /= 2, y /= 2;
        var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2);
        t = Math.pow((1 + t) / (1 - t), 1 / n);
        return [Math.atan2(2 * x, 1 - x2 - y2) / n, asin((t - 1) / (t + 1))];
      };
      return forward;
    }
    function lagrangeProjection() {
      var n = .5, m = projectionMutator(lagrange), p = m(n);
      p.spacing = function(_) {
        if (!arguments.length) return n;
        return m(n = +_);
      };
      return p;
    }
    (d3.geoLagrange = lagrangeProjection).raw = lagrange;
    function larrivee(λ, φ) {
      return [λ * (1 + Math.sqrt(Math.cos(φ))) / 2, φ / (Math.cos(φ / 2) * Math.cos(λ / 6))];
    }
    larrivee.invert = function(x, y) {
      var x0 = Math.abs(x), y0 = Math.abs(y), π_sqrt2 = π / Math.SQRT2, λ = ε, φ = halfπ;
      if (y0 < π_sqrt2) φ *= y0 / π_sqrt2; else λ += 6 * acos(π_sqrt2 / y0);
      for (var i = 0; i < 25; i++) {
        var sinφ = Math.sin(φ), sqrtcosφ = asqrt(Math.cos(φ)), sinφ_2 = Math.sin(φ / 2), cosφ_2 = Math.cos(φ / 2), sinλ_6 = Math.sin(λ / 6), cosλ_6 = Math.cos(λ / 6), f0 = .5 * λ * (1 + sqrtcosφ) - x0, f1 = φ / (cosφ_2 * cosλ_6) - y0, df0dφ = sqrtcosφ ? -.25 * λ * sinφ / sqrtcosφ : 0, df0dλ = .5 * (1 + sqrtcosφ), df1dφ = (1 + .5 * φ * sinφ_2 / cosφ_2) / (cosφ_2 * cosλ_6), df1dλ = φ / cosφ_2 * (sinλ_6 / 6) / (cosλ_6 * cosλ_6), denom = df0dφ * df1dλ - df1dφ * df0dλ, dφ = (f0 * df1dλ - f1 * df0dλ) / denom, dλ = (f1 * df0dφ - f0 * df1dφ) / denom;
        φ -= dφ;
        λ -= dλ;
        if (Math.abs(dφ) < ε && Math.abs(dλ) < ε) break;
      }
      return [x < 0 ? -λ : λ, y < 0 ? -φ : φ];
    };
    (d3.geoLarrivee = function() {
      return projection(larrivee);
    }).raw = larrivee;
    function laskowski(λ, φ) {
      var λ2 = λ * λ, φ2 = φ * φ;
      return [λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)), φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032))];
    }
    laskowski.invert = function(x, y) {
      var λ = sgn(x) * π, φ = y / 2, i = 50;
      do {
        var λ2 = λ * λ, φ2 = φ * φ, λφ = λ * φ, fx = λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)) - x, fy = φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032)) - y, δxδλ = .975534 - φ2 * (.119161 + 3 * λ2 * .0143059 + φ2 * .0547009), δxδφ = -λφ * (2 * .119161 + 4 * .0547009 * φ2 + 2 * .0143059 * λ2), δyδλ = λφ * (2 * .0802894 + 4 * 199025e-9 * λ2 + 2 * -.02855 * φ2), δyδφ = 1.00384 + λ2 * (.0802894 + 199025e-9 * λ2) + φ2 * (3 * (.0998909 - .02855 * λ2) - 5 * .0491032 * φ2), denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ, φ -= δφ;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return i && [λ, φ];
    };
    (d3.geoLaskowski = function() {
      return projection(laskowski);
    }).raw = laskowski;
    function littrow(λ, φ) {
      return [Math.sin(λ) / Math.cos(φ), Math.tan(φ) * Math.cos(λ)];
    }
    littrow.invert = function(x, y) {
      var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, cosφ = x ? Math.SQRT1_2 * Math.sqrt((y2_1 - Math.sqrt(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1) : 1 / Math.sqrt(y2_1);
      return [asin(x * cosφ), sgn(y) * acos(cosφ)];
    };
    (d3.geoLittrow = function() {
      return projection(littrow);
    }).raw = littrow;
    function loximuthal(φ0) {
      var cosφ0 = Math.cos(φ0), tanφ0 = Math.tan(π / 4 + φ0 / 2);
      function forward(λ, φ) {
        var y = φ - φ0, x = Math.abs(y) < ε ? λ * cosφ0 : Math.abs(x = π / 4 + φ / 2) < ε || Math.abs(Math.abs(x) - halfπ) < ε ? 0 : λ * y / Math.log(Math.tan(x) / tanφ0);
        return [x, y];
      }
      forward.invert = function(x, y) {
        var λ, φ = y + φ0;
        return [Math.abs(y) < ε ? x / cosφ0 : Math.abs(λ = π / 4 + φ / 2) < ε || Math.abs(Math.abs(λ) - halfπ) < ε ? 0 : x * Math.log(Math.tan(λ) / tanφ0) / y, φ];
      };
      return forward;
    }
    (d3.geoLoximuthal = function() {
      return parallel1Projection(loximuthal).parallel(40);
    }).raw = loximuthal;
    function miller(λ, φ) {
      return [λ, 1.25 * Math.log(Math.tan(π / 4 + .4 * φ))];
    }
    miller.invert = function(x, y) {
      return [x, 2.5 * Math.atan(Math.exp(.8 * y)) - .625 * π];
    };
    (d3.geoMiller = function() {
      return projection(miller);
    }).raw = miller;
    function modifiedStereographic(C) {
      var m = C.length - 1;
      function forward(λ, φ) {
        var cosφ = Math.cos(φ), k = 2 / (1 + cosφ * Math.cos(λ)), zr = k * cosφ * Math.sin(λ), zi = k * Math.sin(φ), i = m, w = C[i], ar = w[0], ai = w[1], t;
        while (--i >= 0) {
          w = C[i];
          ar = w[0] + zr * (t = ar) - zi * ai;
          ai = w[1] + zr * ai + zi * t;
        }
        ar = zr * (t = ar) - zi * ai;
        ai = zr * ai + zi * t;
        return [ar, ai];
      }
      forward.invert = function(x, y) {
        var i = 20, zr = x, zi = y;
        do {
          var j = m, w = C[j], ar = w[0], ai = w[1], br = 0, bi = 0, t;
          while (--j >= 0) {
            w = C[j];
            br = ar + zr * (t = br) - zi * bi;
            bi = ai + zr * bi + zi * t;
            ar = w[0] + zr * (t = ar) - zi * ai;
            ai = w[1] + zr * ai + zi * t;
          }
          br = ar + zr * (t = br) - zi * bi;
          bi = ai + zr * bi + zi * t;
          ar = zr * (t = ar) - zi * ai - x;
          ai = zr * ai + zi * t - y;
          var denominator = br * br + bi * bi, δr, δi;
          zr -= δr = (ar * br + ai * bi) / denominator;
          zi -= δi = (ai * br - ar * bi) / denominator;
        } while (Math.abs(δr) + Math.abs(δi) > ε * ε && --i > 0);
        if (i) {
          var ρ = Math.sqrt(zr * zr + zi * zi), c = 2 * Math.atan(ρ * .5), sinc = Math.sin(c);
          return [Math.atan2(zr * sinc, ρ * Math.cos(c)), ρ ? asin(zi * sinc / ρ) : 0];
        }
      };
      return forward;
    }
    var modifiedStereographicCoefficients = {
      alaska: [[.9972523, 0], [.0052513, -.0041175], [.0074606, .0048125], [-.0153783, -.1968253], [.0636871, -.1408027], [.3660976, -.2937382]],
      gs48: [[.98879, 0], [0, 0], [-.050909, 0], [0, 0], [.075528, 0]],
      gs50: [[.984299, 0], [.0211642, .0037608], [-.1036018, -.0575102], [-.0329095, -.0320119], [.0499471, .1223335], [.026046, .0899805], [7388e-7, -.1435792], [.0075848, -.1334108], [-.0216473, .0776645], [-.0225161, .0853673]],
      miller: [[.9245, 0], [0, 0], [.01943, 0]],
      lee: [[.721316, 0], [0, 0], [-.00881625, -.00617325]]
    };
    function modifiedStereographicProjection() {
      var coefficients = modifiedStereographicCoefficients.miller, m = projectionMutator(modifiedStereographic), p = m(coefficients);
      p.coefficients = function(_) {
        if (!arguments.length) return coefficients;
        return m(coefficients = typeof _ === "string" ? modifiedStereographicCoefficients[_] : _);
      };
      return p;
    }
    (d3.geoModifiedStereographic = modifiedStereographicProjection).raw = modifiedStereographic;
    function mtFlatPolarParabolic(λ, φ) {
      var sqrt6 = Math.sqrt(6), sqrt7 = Math.sqrt(7), θ = Math.asin(7 * Math.sin(φ) / (3 * sqrt6));
      return [sqrt6 * λ * (2 * Math.cos(2 * θ / 3) - 1) / sqrt7, 9 * Math.sin(θ / 3) / sqrt7];
    }
    mtFlatPolarParabolic.invert = function(x, y) {
      var sqrt6 = Math.sqrt(6), sqrt7 = Math.sqrt(7), θ = 3 * asin(y * sqrt7 / 9);
      return [x * sqrt7 / (sqrt6 * (2 * Math.cos(2 * θ / 3) - 1)), asin(Math.sin(θ) * 3 * sqrt6 / 7)];
    };
    (d3.geoMtFlatPolarParabolic = function() {
      return projection(mtFlatPolarParabolic);
    }).raw = mtFlatPolarParabolic;
    function mtFlatPolarQuartic(λ, φ) {
      var k = (1 + Math.SQRT1_2) * Math.sin(φ), θ = φ;
      for (var i = 0, δ; i < 25; i++) {
        θ -= δ = (Math.sin(θ / 2) + Math.sin(θ) - k) / (.5 * Math.cos(θ / 2) + Math.cos(θ));
        if (Math.abs(δ) < ε) break;
      }
      return [λ * (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)) / (3 * Math.SQRT2), 2 * Math.sqrt(3) * Math.sin(θ / 2) / Math.sqrt(2 + Math.SQRT2)];
    }
    mtFlatPolarQuartic.invert = function(x, y) {
      var sinθ_2 = y * Math.sqrt(2 + Math.SQRT2) / (2 * Math.sqrt(3)), θ = 2 * asin(sinθ_2);
      return [3 * Math.SQRT2 * x / (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)), asin((sinθ_2 + Math.sin(θ)) / (1 + Math.SQRT1_2))];
    };
    (d3.geoMtFlatPolarQuartic = function() {
      return projection(mtFlatPolarQuartic);
    }).raw = mtFlatPolarQuartic;
    function mtFlatPolarSinusoidal(λ, φ) {
      var A = Math.sqrt(6 / (4 + π)), k = (1 + π / 4) * Math.sin(φ), θ = φ / 2;
      for (var i = 0, δ; i < 25; i++) {
        θ -= δ = (θ / 2 + Math.sin(θ) - k) / (.5 + Math.cos(θ));
        if (Math.abs(δ) < ε) break;
      }
      return [A * (.5 + Math.cos(θ)) * λ / 1.5, A * θ];
    }
    mtFlatPolarSinusoidal.invert = function(x, y) {
      var A = Math.sqrt(6 / (4 + π)), θ = y / A;
      if (Math.abs(Math.abs(θ) - halfπ) < ε) θ = θ < 0 ? -halfπ : halfπ;
      return [1.5 * x / (A * (.5 + Math.cos(θ))), asin((θ / 2 + Math.sin(θ)) / (1 + π / 4))];
    };
    (d3.geoMtFlatPolarSinusoidal = function() {
      return projection(mtFlatPolarSinusoidal);
    }).raw = mtFlatPolarSinusoidal;
    function naturalEarth(λ, φ) {
      var φ2 = φ * φ, φ4 = φ2 * φ2;
      return [λ * (.8707 - .131979 * φ2 + φ4 * (-.013791 + φ4 * (.003971 * φ2 - .001529 * φ4))), φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4)))];
    }
    naturalEarth.invert = function(x, y) {
      var φ = y, i = 25, δ;
      do {
        var φ2 = φ * φ, φ4 = φ2 * φ2;
        φ -= δ = (φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4))) - y) / (1.007226 + φ2 * (.015085 * 3 + φ4 * (-.044475 * 7 + .028874 * 9 * φ2 - .005916 * 11 * φ4)));
      } while (Math.abs(δ) > ε && --i > 0);
      return [x / (.8707 + (φ2 = φ * φ) * (-.131979 + φ2 * (-.013791 + φ2 * φ2 * φ2 * (.003971 - .001529 * φ2)))), φ];
    };
    (d3.geoNaturalEarth = function() {
      return projection(naturalEarth);
    }).raw = naturalEarth;
    function nellHammer(λ, φ) {
      return [λ * (1 + Math.cos(φ)) / 2, 2 * (φ - Math.tan(φ / 2))];
    }
    nellHammer.invert = function(x, y) {
      var p = y / 2;
      for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
        var c = Math.cos(y / 2);
        y -= δ = (y - Math.tan(y / 2) - p) / (1 - .5 / (c * c));
      }
      return [2 * x / (1 + Math.cos(y)), y];
    };
    (d3.geoNellHammer = function() {
      return projection(nellHammer);
    }).raw = nellHammer;
    var pattersonK1 = 1.0148, pattersonK2 = .23185, pattersonK3 = -.14499, pattersonK4 = .02406, pattersonC1 = pattersonK1, pattersonC2 = 5 * pattersonK2, pattersonC3 = 7 * pattersonK3, pattersonC4 = 9 * pattersonK4, pattersonYmax = 1.790857183;
    function patterson(λ, φ) {
      var φ2 = φ * φ;
      return [λ, φ * (pattersonK1 + φ2 * φ2 * (pattersonK2 + φ2 * (pattersonK3 + pattersonK4 * φ2)))];
    }
    patterson.invert = function(x, y) {
      if (y > pattersonYmax) y = pattersonYmax; else if (y < -pattersonYmax) y = -pattersonYmax;
      var yc = y, δ;
      do {
        var y2 = yc * yc;
        yc -= δ = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
      } while (Math.abs(δ) > ε);
      return [x, yc];
    };
    (d3.geoPatterson = function() {
      return projection(patterson);
    }).raw = patterson;
    var peirceQuincuncialProjection = quincuncialProjection(guyou);
    (d3.geoPeirceQuincuncial = function() {
      return peirceQuincuncialProjection().quincuncial(true).rotate([-90, -90, 45]).clipAngle(180 - 1e-6);
    }).raw = peirceQuincuncialProjection.raw;
    function polyconic(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var tanφ = Math.tan(φ), k = λ * Math.sin(φ);
      return [Math.sin(k) / tanφ, φ + (1 - Math.cos(k)) / tanφ];
    }
    polyconic.invert = function(x, y) {
      if (Math.abs(y) < ε) return [x, 0];
      var k = x * x + y * y, φ = y * .5, i = 10, δ;
      do {
        var tanφ = Math.tan(φ), secφ = 1 / Math.cos(φ), j = k - 2 * y * φ + φ * φ;
        φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
      } while (Math.abs(δ) > ε && --i > 0);
      tanφ = Math.tan(φ);
      return [(Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(x * tanφ) : sgn(x) * (acos(Math.abs(x * tanφ)) + halfπ)) / Math.sin(φ), φ];
    };
    (d3.geoPolyconic = function() {
      return projection(polyconic);
    }).raw = polyconic;
    function rectangularPolyconic(φ0) {
      var sinφ0 = Math.sin(φ0);
      function forward(λ, φ) {
        var A = sinφ0 ? Math.tan(λ * sinφ0 / 2) / sinφ0 : λ / 2;
        if (!φ) return [2 * A, -φ0];
        var E = 2 * Math.atan(A * Math.sin(φ)), cotφ = 1 / Math.tan(φ);
        return [Math.sin(E) * cotφ, φ + (1 - Math.cos(E)) * cotφ - φ0];
      }
      forward.invert = function(x, y) {
        if (Math.abs(y += φ0) < ε) return [sinφ0 ? 2 * Math.atan(sinφ0 * x / 2) / sinφ0 : x, 0];
        var k = x * x + y * y, φ = 0, i = 10, δ;
        do {
          var tanφ = Math.tan(φ), secφ = 1 / Math.cos(φ), j = k - 2 * y * φ + φ * φ;
          φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
        } while (Math.abs(δ) > ε && --i > 0);
        var E = x * (tanφ = Math.tan(φ)), A = Math.tan(Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(E) * .5 : acos(E) * .5 + π / 4) / Math.sin(φ);
        return [sinφ0 ? 2 * Math.atan(sinφ0 * A) / sinφ0 : 2 * A, φ];
      };
      return forward;
    }
    (d3.geoRectangularPolyconic = function() {
      return parallel1Projection(rectangularPolyconic);
    }).raw = rectangularPolyconic;
    var robinsonConstants = [[.9986, -.062], [1, 0], [.9986, .062], [.9954, .124], [.99, .186], [.9822, .248], [.973, .31], [.96, .372], [.9427, .434], [.9216, .4958], [.8962, .5571], [.8679, .6176], [.835, .6769], [.7986, .7346], [.7597, .7903], [.7186, .8435], [.6732, .8936], [.6213, .9394], [.5722, .9761], [.5322, 1]];
    robinsonConstants.forEach(function(d) {
      d[1] *= 1.0144;
    });
    function robinson(λ, φ) {
      var i = Math.min(18, Math.abs(φ) * 36 / π), i0 = Math.floor(i), di = i - i0, ax = (k = robinsonConstants[i0])[0], ay = k[1], bx = (k = robinsonConstants[++i0])[0], by = k[1], cx = (k = robinsonConstants[Math.min(19, ++i0)])[0], cy = k[1], k;
      return [λ * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (φ > 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)];
    }
    robinson.invert = function(x, y) {
      var yy = y / halfπ, φ = yy * 90, i = Math.min(18, Math.abs(φ / 5)), i0 = Math.max(0, Math.floor(i));
      do {
        var ay = robinsonConstants[i0][1], by = robinsonConstants[i0 + 1][1], cy = robinsonConstants[Math.min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (Math.abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));
        if (di >= 0 || i0 === 1) {
          φ = (y >= 0 ? 5 : -5) * (di + i);
          var j = 50, δ;
          do {
            i = Math.min(18, Math.abs(φ) / 5);
            i0 = Math.floor(i);
            di = i - i0;
            ay = robinsonConstants[i0][1];
            by = robinsonConstants[i0 + 1][1];
            cy = robinsonConstants[Math.min(19, i0 + 2)][1];
            φ -= (δ = (y >= 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;
          } while (Math.abs(δ) > ε2 && --j > 0);
          break;
        }
      } while (--i0 >= 0);
      var ax = robinsonConstants[i0][0], bx = robinsonConstants[i0 + 1][0], cx = robinsonConstants[Math.min(19, i0 + 2)][0];
      return [x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), φ * radians];
    };
    (d3.geoRobinson = function() {
      return projection(robinson);
    }).raw = robinson;
    function satelliteVertical(P) {
      function forward(λ, φ) {
        var cosφ = Math.cos(φ), k = (P - 1) / (P - cosφ * Math.cos(λ));
        return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
      }
      forward.invert = function(x, y) {
        var ρ2 = x * x + y * y, ρ = Math.sqrt(ρ2), sinc = (P - Math.sqrt(1 - ρ2 * (P + 1) / (P - 1))) / ((P - 1) / ρ + ρ / (P - 1));
        return [Math.atan2(x * sinc, ρ * Math.sqrt(1 - sinc * sinc)), ρ ? asin(y * sinc / ρ) : 0];
      };
      return forward;
    }
    function satellite(P, ω) {
      var vertical = satelliteVertical(P);
      if (!ω) return vertical;
      var cosω = Math.cos(ω), sinω = Math.sin(ω);
      function forward(λ, φ) {
        var coordinates = vertical(λ, φ), y = coordinates[1], A = y * sinω / (P - 1) + cosω;
        return [coordinates[0] * cosω / A, y / A];
      }
      forward.invert = function(x, y) {
        var k = (P - 1) / (P - 1 - y * sinω);
        return vertical.invert(k * x, k * y * cosω);
      };
      return forward;
    }
    function satelliteProjection() {
      var P = 1.4, ω = 0, m = projectionMutator(satellite), p = m(P, ω);
      p.distance = function(_) {
        if (!arguments.length) return P;
        return m(P = +_, ω);
      };
      p.tilt = function(_) {
        if (!arguments.length) return ω * 180 / π;
        return m(P, ω = _ * π / 180);
      };
      return p;
    }
    (d3.geoSatellite = satelliteProjection).raw = satellite;
    function times(λ, φ) {
      var t = Math.tan(φ / 2), s = Math.sin(π / 4 * t);
      return [λ * (.74482 - .34588 * s * s), 1.70711 * t];
    }
    times.invert = function(x, y) {
      var t = y / 1.70711, s = Math.sin(π / 4 * t);
      return [x / (.74482 - .34588 * s * s), 2 * Math.atan(t)];
    };
    (d3.geoTimes = function() {
      return projection(times);
    }).raw = times;
    function twoPointEquidistant(z0) {
      if (!z0) return d3.geoAzimuthalEquidistant.raw;
      var λa = -z0 / 2, λb = -λa, z02 = z0 * z0, tanλ0 = Math.tan(λb), S = .5 / Math.sin(λb);
      function forward(λ, φ) {
        var za = acos(Math.cos(φ) * Math.cos(λ - λa)), zb = acos(Math.cos(φ) * Math.cos(λ - λb)), ys = φ < 0 ? -1 : 1;
        za *= za, zb *= zb;
        return [(za - zb) / (2 * z0), ys * asqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)];
      }
      forward.invert = function(x, y) {
        var y2 = y * y, cosza = Math.cos(Math.sqrt(y2 + (t = x + λa) * t)), coszb = Math.cos(Math.sqrt(y2 + (t = x + λb) * t)), t, d;
        return [Math.atan2(d = cosza - coszb, t = (cosza + coszb) * tanλ0), (y < 0 ? -1 : 1) * acos(Math.sqrt(t * t + d * d) * S)];
      };
      return forward;
    }
    function twoPointEquidistantProjection() {
      var points = [[0, 0], [0, 0]], m = projectionMutator(twoPointEquidistant), p = m(0), rotate = p.rotate;
      delete p.rotate;
      p.points = function(_) {
        if (!arguments.length) return points;
        points = _;
        var interpolate = d3.geoInterpolate(_[0], _[1]), origin = interpolate(.5), p = d3.geoRotation([-origin[0], -origin[1]])(_[0]), b = interpolate.distance * .5, γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
        if (p[0] > 0) γ = π - γ;
        rotate.call(p, [-origin[0], -origin[1], -γ * degrees]);
        return m(b * 2);
      };
      return p;
    }
    (d3.geoTwoPointEquidistant = twoPointEquidistantProjection).raw = twoPointEquidistant;
    function twoPointAzimuthal(d) {
      var cosd = Math.cos(d);
      function forward(λ, φ) {
        var coordinates = d3.geoGnomonic.raw(λ, φ);
        coordinates[0] *= cosd;
        return coordinates;
      }
      forward.invert = function(x, y) {
        return d3.geoGnomonic.raw.invert(x / cosd, y);
      };
      return forward;
    }
    function twoPointAzimuthalProjection() {
      var points = [[0, 0], [0, 0]], m = projectionMutator(twoPointAzimuthal), p = m(0), rotate = p.rotate;
      delete p.rotate;
      p.points = function(_) {
        if (!arguments.length) return points;
        points = _;
        var interpolate = d3.geoInterpolate(_[0], _[1]), origin = interpolate(.5), p = d3.geoRotation([-origin[0], -origin[1]])(_[0]), b = interpolate.distance * .5, γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
        if (p[0] > 0) γ = π - γ;
        rotate.call(p, [-origin[0], -origin[1], -γ * degrees]);
        return m(b);
      };
      return p;
    }
    (d3.geoTwoPointAzimuthal = twoPointAzimuthalProjection).raw = twoPointAzimuthal;
    function vanDerGrinten(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var sinθ = Math.abs(φ / halfπ), θ = asin(sinθ);
      if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, sgn(φ) * π * Math.tan(θ / 2)];
      var cosθ = Math.cos(θ), A = Math.abs(π / λ - λ / π) / 2, A2 = A * A, G = cosθ / (sinθ + cosθ - 1), P = G * (2 / sinθ - 1), P2 = P * P, P2_A2 = P2 + A2, G_P2 = G - P2, Q = A2 + G;
      return [sgn(λ) * π * (A * G_P2 + Math.sqrt(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2, sgn(φ) * π * (P * Q - A * Math.sqrt((A2 + 1) * P2_A2 - Q * Q)) / P2_A2];
    }
    vanDerGrinten.invert = function(x, y) {
      if (Math.abs(y) < ε) return [x, 0];
      if (Math.abs(x) < ε) return [0, halfπ * Math.sin(2 * Math.atan(y / π))];
      var x2 = (x /= π) * x, y2 = (y /= π) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -Math.abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * Math.sqrt(-a1 / 3), θ1 = acos(3 * d / (a1 * m1)) / 3;
      return [π * (x2_y2 - 1 + Math.sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x), sgn(y) * π * (-m1 * Math.cos(θ1 + π / 3) - c2 / (3 * c3))];
    };
    (d3.geoVanDerGrinten = function() {
      return projection(vanDerGrinten);
    }).raw = vanDerGrinten;
    function vanDerGrinten2(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var sinθ = Math.abs(φ / halfπ), θ = asin(sinθ);
      if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, sgn(φ) * π * Math.tan(θ / 2)];
      var cosθ = Math.cos(θ), A = Math.abs(π / λ - λ / π) / 2, A2 = A * A, x1 = cosθ * (Math.sqrt(1 + A2) - A * cosθ) / (1 + A2 * sinθ * sinθ);
      return [sgn(λ) * π * x1, sgn(φ) * π * asqrt(1 - x1 * (2 * A + x1))];
    }
    vanDerGrinten2.invert = function(x, y) {
      if (!x) return [0, halfπ * Math.sin(2 * Math.atan(y / π))];
      var x1 = Math.abs(x / π), A = (1 - x1 * x1 - (y /= π) * y) / (2 * x1), A2 = A * A, B = Math.sqrt(A2 + 1);
      return [sgn(x) * π * (B - A), sgn(y) * halfπ * Math.sin(2 * Math.atan2(Math.sqrt((1 - 2 * A * x1) * (A + B) - x1), Math.sqrt(B + A + x1)))];
    };
    (d3.geoVanDerGrinten2 = function() {
      return projection(vanDerGrinten2);
    }).raw = vanDerGrinten2;
    function vanDerGrinten3(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var sinθ = φ / halfπ, θ = asin(sinθ);
      if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, π * Math.tan(θ / 2)];
      var A = (π / λ - λ / π) / 2, y1 = sinθ / (1 + Math.cos(θ));
      return [π * (sgn(λ) * asqrt(A * A + 1 - y1 * y1) - A), π * y1];
    }
    vanDerGrinten3.invert = function(x, y) {
      if (!y) return [x, 0];
      var y1 = y / π, A = (π * π * (1 - y1 * y1) - x * x) / (2 * π * x);
      return [x ? π * (sgn(x) * Math.sqrt(A * A + 1) - A) : 0, halfπ * Math.sin(2 * Math.atan(y1))];
    };
    (d3.geoVanDerGrinten3 = function() {
      return projection(vanDerGrinten3);
    }).raw = vanDerGrinten3;
    function vanDerGrinten4(λ, φ) {
      if (!φ) return [λ, 0];
      var φ0 = Math.abs(φ);
      if (!λ || φ0 === halfπ) return [0, φ];
      var B = φ0 / halfπ, B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C2 = C * C, BC = B * C, B_C2 = B2 + C2 + 2 * BC, B_3C = B + 3 * C, λ0 = λ / halfπ, λ1 = λ0 + 1 / λ0, D = sgn(Math.abs(λ) - halfπ) * Math.sqrt(λ1 * λ1 - 4), D2 = D * D, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x1 = (D * (B_C2 + C2 - 1) + 2 * asqrt(F)) / (4 * B_C2 + D2);
      return [sgn(λ) * halfπ * x1, sgn(φ) * halfπ * asqrt(1 + D * Math.abs(x1) - x1 * x1)];
    }
    vanDerGrinten4.invert = function(x, y) {
      if (!x || !y) return [x, y];
      y /= π;
      var x1 = sgn(x) * x / halfπ, D = (x1 * x1 - 1 + 4 * y * y) / Math.abs(x1), D2 = D * D, B = 2 * y, i = 50;
      do {
        var B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C_ = (3 * B - B2 * B - 10) / (2 * B2 * B), C2 = C * C, BC = B * C, B_C = B + C, B_C2 = B_C * B_C, B_3C = B + 3 * C, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)), sqrtF = Math.sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
        B -= δ = f / f_;
      } while (δ > ε && --i > 0);
      return [sgn(x) * (Math.sqrt(D * D + 4) + D) * π / 4, halfπ * B];
    };
    (d3.geoVanDerGrinten4 = function() {
      return projection(vanDerGrinten4);
    }).raw = vanDerGrinten4;
    var wagner4 = function() {
      var A = 4 * π + 3 * Math.sqrt(3), B = 2 * Math.sqrt(2 * π * Math.sqrt(3) / A);
      return mollweideBromley(B * Math.sqrt(3) / π, B, A / 6);
    }();
    (d3.geoWagner4 = function() {
      return projection(wagner4);
    }).raw = wagner4;
    function wagner6(λ, φ) {
      return [λ * Math.sqrt(1 - 3 * φ * φ / (π * π)), φ];
    }
    wagner6.invert = function(x, y) {
      return [x / Math.sqrt(1 - 3 * y * y / (π * π)), y];
    };
    (d3.geoWagner6 = function() {
      return projection(wagner6);
    }).raw = wagner6;
    function wagner7(λ, φ) {
      var s = .90631 * Math.sin(φ), c0 = Math.sqrt(1 - s * s), c1 = Math.sqrt(2 / (1 + c0 * Math.cos(λ /= 3)));
      return [2.66723 * c0 * c1 * Math.sin(λ), 1.24104 * s * c1];
    }
    wagner7.invert = function(x, y) {
      var t1 = x / 2.66723, t2 = y / 1.24104, p = Math.sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);
      return [3 * Math.atan2(x * Math.tan(c), 2.66723 * p), p && asin(y * Math.sin(c) / (1.24104 * .90631 * p))];
    };
    (d3.geoWagner7 = function() {
      return projection(wagner7);
    }).raw = wagner7;
    function wiechel(λ, φ) {
      var cosφ = Math.cos(φ), sinφ = Math.cos(λ) * cosφ, sin1_φ = 1 - sinφ, cosλ = Math.cos(λ = Math.atan2(Math.sin(λ) * cosφ, -Math.sin(φ))), sinλ = Math.sin(λ);
      cosφ = asqrt(1 - sinφ * sinφ);
      return [sinλ * cosφ - cosλ * sin1_φ, -cosλ * cosφ - sinλ * sin1_φ];
    }
    wiechel.invert = function(x, y) {
      var w = -.5 * (x * x + y * y), k = Math.sqrt(-w * (2 + w)), b = y * w + x * k, a = x * w - y * k, D = Math.sqrt(a * a + b * b);
      return [Math.atan2(k * b, D * (1 + w)), D ? -asin(k * a / D) : 0];
    };
    (d3.geoWiechel = function() {
      return projection(wiechel);
    }).raw = wiechel;
    function winkel3(λ, φ) {
      var coordinates = aitoff(λ, φ);
      return [(coordinates[0] + λ / halfπ) / 2, (coordinates[1] + φ) / 2];
    }
    winkel3.invert = function(x, y) {
      var λ = x, φ = y, i = 25;
      do {
        var cosφ = Math.cos(φ), sinφ = Math.sin(φ), sin_2φ = Math.sin(2 * φ), sin2φ = sinφ * sinφ, cos2φ = cosφ * cosφ, sinλ = Math.sin(λ), cosλ_2 = Math.cos(λ / 2), sinλ_2 = Math.sin(λ / 2), sin2λ_2 = sinλ_2 * sinλ_2, C = 1 - cos2φ * cosλ_2 * cosλ_2, E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = .5 * (2 * E * cosφ * sinλ_2 + λ / halfπ) - x, fy = .5 * (E * sinφ + φ) - y, δxδλ = .5 * F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ) + .5 / halfπ, δxδφ = F * (sinλ * sin_2φ / 4 - E * sinφ * sinλ_2), δyδλ = .125 * F * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ), δyδφ = .5 * F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ) + .5, denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ, φ -= δφ;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return [λ, φ];
    };
    (d3.geoWinkel3 = function() {
      return projection(winkel3);
    }).raw = winkel3;
  }

  const {ICON_QUESTION} = sharedComponents.Icons;
  const COLOR_WHITEISH = "rgb(253, 253, 253)";
  const COLOR_BLACKISH = "rgb(51, 51, 51)";

  const MAX_RADIUS_EM = 0.05;

  const PROFILE_CONSTANTS = (width, height) => ({
    SMALL: {
      margin: { top: 10, right: 10, left: 10, bottom: 0 },
      headerMargin: {top: 10, right: 20, bottom: 20, left: 10},
      infoElHeight: 16,
      infoElMargin: 5,
      minRadiusPx: 0.5,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
    },
    MEDIUM: {
      margin: { top: 20, right: 20, left: 20, bottom: 30 },
      headerMargin: {top: 10, right: 20, bottom: 20, left: 15},
      infoElHeight: 20,
      infoElMargin: 5,
      minRadiusPx: 1,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
    },
    LARGE: {
      margin: { top: 30, right: 30, left: 30, bottom: 35 },
      headerMargin: {top: 10, right: 20, bottom: 20, left: 20},
      infoElHeight: 22,
      infoElMargin: 5,
      minRadiusPx: 1,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
    }
  });

  const PROFILE_CONSTANTS_FOR_PROJECTOR = () => ({
    MEDIUM: {
      infoElHeight: 26,
      infoElMargin: 10,
    },
    LARGE: {
      infoElHeight: 32,
      infoElMargin: 10,
    }
  });

  class _VizabiBubblemap extends sharedComponents.BaseComponent {

    constructor(config) {

      config.subcomponents = [{
        type: sharedComponents.DateTimeBackground,
        placeholder: ".vzb-bmc-date"
      },{
        type: sharedComponents.Labels,
        placeholder: ".vzb-bmc-labels",      
        options: {
          CSS_PREFIX: "vzb-bmc",
          LABELS_CONTAINER_CLASS: "vzb-bmc-labels",
          LINES_CONTAINER_CLASS: "vzb-bmc-lines",
          SUPPRESS_HIGHLIGHT_DURING_PLAY: false
        },
        name: "labels"
      }];

      config.template = `
      <svg class="vzb-bubblemap-svg vzb-export">
        <g class="vzb-bmc-map-translatecontainer">
          <svg class="vzb-bmc-map-background">
              <g class="vzb-bmc-map-graph"></g>
          </svg>
        </g>
        <svg class="vzb-bubblemap-foreground">
            <g class="vzb-bmc-graph">
                <g class="vzb-bmc-date"></g>

                <g class="vzb-bmc-bubbles"></g>

                <g class="vzb-bmc-axis-s-title">
                    <text></text>
                </g>

                <g class="vzb-bmc-axis-c-title">
                    <text></text>
                </g>

                <g class="vzb-bmc-axis-s-info vzb-noexport"></g>

                <g class="vzb-bmc-axis-c-info vzb-noexport"></g>

                <g class="vzb-bmc-lines"></g>
                <svg class="vzb-bmc-labels-crop">
                  <g class="vzb-bmc-labels"></g>
                </svg>
            </g>
            <rect class="vzb-bmc-forecastoverlay vzb-hidden" x="0" y="0" width="100%" height="100%" fill="url(#vzb-bmc-pattern-lines-${config.id})" pointer-events='none'></rect>
            <g class="vzb-datawarning-button vzb-noexport"></g>
        </svg>
        <svg>
            <defs>
                <pattern class="vzb-noexport" id="vzb-bmc-pattern-lines-${config.id}" x="0" y="0" patternUnits="userSpaceOnUse" width="50" height="50" viewBox="0 0 10 10"> 
                    <path d='M-1,1 l2,-2M0,10 l10,-10M9,11 l2,-2' stroke='black' stroke-width='3' opacity='0.08'/>
                </pattern> 
            </defs>
        </svg>
      </svg>
    `;
      super(config);
    }

    setup() {
      this.DOM = {
        element: this.element,

        graph: this.element.select(".vzb-bmc-graph"),
        date: this.element.select(".vzb-bmc-date"),
        mapTranslateContainer: this.element.select(".vzb-bmc-map-translatecontainer"),
        mapSvg: this.element.select(".vzb-bmc-map-background"),
        mapGraph: this.element.select(".vzb-bmc-map-graph"),
    
        bubbleContainer: this.element.select(".vzb-bmc-bubbles"),
        labelListContainer: this.element.select(".vzb-bmc-bubble-labels"),
    
        sTitle: this.element.select(".vzb-bmc-axis-s-title"),
        cTitle: this.element.select(".vzb-bmc-axis-c-title"),
        sInfo: this.element.select(".vzb-bmc-axis-y-info"),
        cInfo: this.element.select(".vzb-bmc-axis-c-info"),
        forecastOverlay: this.element.select(".vzb-bmc-forecastoverlay")
      };

      
      d3GeoProjection();

      // http://bl.ocks.org/mbostock/d4021aa4dccfd65edffd patterson
      // http://bl.ocks.org/mbostock/3710566 robinson
      // map background

      if(!d3$1[this.ui.map.projection]) return sharedComponents.LegacyUtils.warn(`Projection ${this.ui.map.projection} is not available in d3`);

      // project to bounding box https://bl.ocks.org/mbostock/4707858
      this.projection = d3$1[this.ui.map.projection]()
        .scale(1)
        .translate([0, 0]);

      //guess map bounds (hardcoded for gapminder bubble map world-50m.json)
      this.mapBounds = [
        [-3.036572068908535, -1.4899523136604478],
        [3.0497648407508264, 1.5707963265556506]
      ];
      this.preload().then(()=>{
        this._initMap();
      });
      this._labels = this.findChild({type: "Labels"});
      this._date = this.findChild({type: "DateTimeBackground"});
    }

    get MDL(){
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted,
        size: this.model.encoding[this.state.alias.size || "size"],
        color: this.model.encoding.color,
        label: this.model.encoding.label
      };
    }

    draw(){
      this.localise = this.services.locale.auto(this.MDL.frame.interval);

      // new scales and axes
      this.sScale = this.MDL.size.scale.d3Scale;
      this.cScale = color => color? this.MDL.color.scale.d3Scale(color) : COLOR_WHITEISH;

      if (this._updateLayoutProfile()) return; //return if exists with error
      
      this.addReaction(this.updateSize);    
      this.addReaction(this._rescaleMap);
      this.addReaction(this._drawHeader);
      this.addReaction(this._updateYear);
      this.addReaction(this._updateShapes);
      this.addReaction(this._updateBubbles);
      this.addReaction(this._updateOpacity);
      this.addReaction(this._drawForecastOverlay);
      this.addReaction(this._updateShowYear);
    }

    _getDuration() {
      //smooth animation is needed when playing, except for the case when time jumps from end to start
      if(!this.MDL.frame) return 0;
      this.frameValue_1 = this.frameValue;
      this.frameValue = this.MDL.frame.value;
      return this.__duration = this.MDL.frame.playing && (this.frameValue - this.frameValue_1 > 0) ? this.MDL.frame.speed : 0;
    }

    _updateYear() {
      const duration = this._getDuration();
      this._date.setText(this.MDL.frame.value, duration);
    }

    _updateShowYear() {
      this.DOM.date.classed("vzb-hidden", !this.ui.timeInBackground);
    }

    _drawForecastOverlay() {
      this.DOM.forecastOverlay.classed("vzb-hidden", 
        !this.ui.showForecast || 
        !this.ui.showForecastOverlay || 
        !this.ui.endBeforeForecast || 
          (this.MDL.frame.value <= this.MDL.frame.parseValue(this.ui.endBeforeForecast))
      );
    }

    _updateLayoutProfile(){
      this.services.layout.size;

      this.height = (this.element.node().clientHeight) || 0;
      this.width = (this.element.node().clientWidth) || 0;

      this.profileConstants = this.services.layout.getProfileConstants(
        PROFILE_CONSTANTS(this.width, this.height), 
        PROFILE_CONSTANTS_FOR_PROJECTOR(this.width, this.height)
      );
      
      if (!this.height || !this.width) return sharedComponents.LegacyUtils.warn("Chart _updateProfile() abort: container is too little or has display:none");

    }


    preload() {
      if (this.topology) return Promise.resolve();

      const reader = this.model.data.source.reader;

      //where the path to preload geoshape can be defined either directly in config:
      const topoPath = sharedComponents.LegacyUtils.getProp(this, ["ui", "map", "topology", "path"]);

      //or via an entity property in dataset, but this functionality was never needed, so i removed the implementation
      //const topoWhich = utils.getProp(this, ["ui", "map", "topology", "which"]);
      //const topoKey = utils.getProp(this, ["ui", "map", "topology", "key"]);

      return new Promise((resolve, reject) => {
        if (topoPath) {
          reader.getAsset(topoPath)
            .then(response => {
              this.topology = response;
              resolve();
            })
            .catch(() => {
              reject(new Error("unable to fetch the map"));
            });
        } else {
          reject(new Error("topoPath is not set"));
        }
      });
    }

    _getMarkerItemForShape(dShape = {}) {
      const ID = this.ui.map.topology.geoIdProperty;
      const id = dShape.id || dShape.properties?.[ID];
      return id ? this.model.dataMap.get(id) : undefined;
    }

    _initMap() {
      if (!this.topology) sharedComponents.LegacyUtils.warn("Bubble map is missing the map data:", this.topology);
      const rotate = this.ui.map.rotate;
      const ID = this.ui.map.topology.geoIdProperty;

      this.projection
        .scale(1)
        .rotate(rotate || [0,0])
        .translate([0, 0]);

      this.mapPath = d3$1.geoPath()
        .projection(this.projection);

      this.DOM.mapGraph.html("");

      const mapFeature = topojson.feature(this.topology, this.topology.objects[this.ui.map.topology.objects.boundaries]);
      
      if (mapFeature.features) {
        this.areas = this.DOM.mapGraph.selectAll(".land")
          .data(mapFeature.features)
          .enter().insert("path")
          .attr("d", this.mapPath)
          .attr("id", dShape => dShape.id || dShape.properties?.[ID])
          .attr("class", "land");

        

        if(!sharedComponents.LegacyUtils.isTouchDevice()){
          this.areas
            .on("mouseover", (event, dShape) => {
              if (this.ui.opacityRegular !== 0) return;
              this._interact().mouseover(event, this._getMarkerItemForShape(dShape)); 
            })
            .on("mouseout", (event, dShape) => {
              if (this.ui.opacityRegular !== 0) return;
              this._interact().mouseout(event, this._getMarkerItemForShape(dShape));
            })
            .on("click", (event, dShape) => {
              if (this.ui.opacityRegular !== 0) return;
              this._interact().click(event, this._getMarkerItemForShape(dShape));
            });
        } else {
          this.areas
            .onTap((event, dShape) => {
              if (this.ui.opacityRegular !== 0) return;
              event.stopPropagation();
              this._interact().click(event, this._getMarkerItemForShape(dShape));
            });
        }
      } else {
        this.DOM.mapGraph.insert("path")
          .datum(mapFeature)
          .attr("class", "land");
      }

      this.mapBounds = this.mapPath.bounds(topojson.feature(this.topology, this.topology.objects[this.ui.map.topology.objects.boundaries]));
    }

    _rescaleMap() {
      this.services.layout.size;

      const offset = this.ui.map.offset;
      const {margin} = this.profileConstants;

      // scale to aspect ratio
      // http://bl.ocks.org/mbostock/4707858
      const s = this.ui.map.scale / Math.max((this.mapBounds[1][0] - this.mapBounds[0][0]) / this.width, (this.mapBounds[1][1] - this.mapBounds[0][1]) / this.height);

      // dimensions of the map itself (regardless of cropping)
      const mapWidth = (s * (this.mapBounds[1][0] - this.mapBounds[0][0]));
      const mapHeight = (s * (this.mapBounds[1][1] - this.mapBounds[0][1]));

      // dimensions of the viewport in which the map is shown (can be bigger or smaller than map)
      let viewPortHeight = mapHeight * (1 + offset.top + offset.bottom);
      let viewPortWidth = mapWidth * (1 + offset.left + offset.right);
      const mapTopOffset = mapHeight * offset.top;
      const mapLeftOffset = mapWidth * offset.left;

      // translate projection to the middle of map
      const t = [(mapWidth - s * (this.mapBounds[1][0] + this.mapBounds[0][0])) / 2, (mapHeight - s * (this.mapBounds[1][1] + this.mapBounds[0][1])) / 2];

      this.projection
        .scale(s)
        .translate(t);

      this.DOM.mapGraph
        .selectAll("path").attr("d", this.mapPath);

      // handle scale to fit case
      let widthScale, heightScale;
      if (!this.ui.map.preserveAspectRatio) {

        // wrap viewBox around viewport so map scales to fit viewport
        const viewBoxHeight = viewPortHeight;
        const viewBoxWidth = viewPortWidth;

        // viewport is complete area (apart from scaling)
        viewPortHeight = this.height * this.ui.map.scale;
        viewPortWidth = this.width * this.ui.map.scale;

        this.DOM.mapSvg
          .attr("preserveAspectRatio", "none")
          .attr("viewBox", [0, 0, viewBoxWidth, viewBoxHeight].join(" "));

        //            ratio between map, viewport and offset (for bubbles)
        widthScale = viewPortWidth / (mapWidth || 1) / (1 + offset.left + offset.right);
        heightScale = viewPortHeight / (mapHeight || 1) / (1 + offset.top + offset.bottom);

      } else {

        // no scaling needed
        widthScale = 1;
        heightScale = 1;

      }
      
      // reposition map layer. can't do ehis on the inner g mapGraph because it has a skewy transform applied to the whole mapSvg around it.
      // can not do this on mapSvg either because svg does't support transform attribute
      this.DOM.mapTranslateContainer
        .attr("transform", "translate(" + (margin.left + (this.width - viewPortWidth) / 2) + "," + (margin.top + (this.height - viewPortHeight) / 2) + ")");
      
      this.DOM.mapSvg
        .attr("width", viewPortWidth)
        .attr("height", viewPortHeight);

      // internal offset against parent container (mapSvg)
      this.DOM.mapGraph
        .attr("transform", "translate(" + mapLeftOffset + "," + mapTopOffset + ")");

      this.DOM.graph
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      
      // set skew function used for bubbles in chart
      const _this = this;
      this.skew = (function() {
        const w = _this.width;
        const h = _this.height;
        //input pixel loc after projection, return pixel loc after skew;
        return function(points) {
          //      input       scale         translate                    translate offset
          const x = points[0] * widthScale + ((w - viewPortWidth) / 2) + mapLeftOffset * widthScale;
          const y = points[1] * heightScale + ((h - viewPortHeight) / 2) + mapTopOffset * heightScale;
          return [x, y];
        };
      })();


    }

    _updateShapes() {
      if (this.ui.opacityRegular !== 0)
        this.DOM.mapGraph.selectAll(".land").style("fill", null).style("stroke", null);
      else
        this.model.dataArray.forEach(d => {
          let view = this.DOM.mapGraph.select(".land#" + d[Symbol.for("key")]);
          if(this.__duration) view = view.transition().duration(this.__duration).ease(d3$1.easeLinear);
          view
            .style("stroke", COLOR_BLACKISH)
            .style("fill", (!d.color && d.color !== 0) ? null : this.cScale(d.color));

          d.center = this.skew(this.projection([d.lon || 0, d.lat || 0]));
          this._updateLabel(d, this.__duration);
        });
    }

    _createAndDeleteBubbles() {

      this.bubbles = this.DOM.bubbleContainer.selectAll(".vzb-bmc-bubble")
        .data(this.model.dataArray, d => d[Symbol.for("key")]);

      //exit selection
      this.bubbles.exit().remove();

      //enter selection -- init circles
      this.bubbles = this.bubbles.enter().append("circle")
        .attr("class", "vzb-bmc-bubble")
        .attr("id", (d) => `vzb-br-bar-${d[Symbol.for("key")]}-${this.id}`)
        .merge(this.bubbles)
        .order();

      if(!sharedComponents.LegacyUtils.isTouchDevice()){
        this.bubbles
          .on("mouseover", this._interact().mouseover)
          .on("mouseout", this._interact().mouseout)
          .on("click", this._interact().click);
      } else {
        this.bubbles
          .onTap((event, d) => {
            event.stopPropagation();
            this._interact().click(event, d);
          });
      }
    }

    _interact() {
      const _this = this;

      return {
        mouseover(event, d) {
          if (_this.MDL.frame.dragging || !d) return;

          _this.hovered = d;
          _this.MDL.highlighted.data.filter.set(d);
          //put the exact value in the size title
          //this.updateTitleNumbers();
          //_this.fitSizeOfTitles();
         
          // if not selected, show tooltip
          if (!_this.MDL.selected.data.filter.has(d)) _this._setTooltip(event, d);
        },
        mouseout(event, d) {
          if (_this.MDL.frame.dragging || !d) return;

          _this.hovered = null;
          _this.MDL.highlighted.data.filter.delete(d);
          //_this.updateTitleNumbers();
          //_this.fitSizeOfTitles();

          _this._setTooltip(event);
          //_this._labels.clearTooltip();
        },
        click(event, d) {
          if (_this.MDL.frame.dragging || !d) return;

          _this.MDL.highlighted.data.filter.delete(d);
          _this._setTooltip(event);
          //_this._labels.clearTooltip();
          _this.MDL.selected.data.filter.toggle(d);
          //_this.selectToggleMarker(d);
        },
        tap(event, d) {
          if (_this.MDL.frame.dragging || !d) return;

          _this._setTooltip(event);
          _this.MDL.selected.data.filter.toggle(d);
          //_this.selectToggleMarker(d);
          event.stopPropagation();
        }
      };
    }

    selectToggleMarker(d){
      if(d) this.MDL.selected.data.filter.toggle(d);
    }

    _setTooltip(event, d) {
      if (event && d) {
        const labelValues = {};
        const tooltipCache = {};
        const mouse = d3$1.pointer(event);
        const x = d.center? d.center[0] : mouse[0];
        const y = d.center? d.center[1] : mouse[1];
        const offset = d.r || 0;

        labelValues.valueS = d[this._alias("size")];
        labelValues.labelText = this.__labelWithoutFrame(d);
        tooltipCache.labelX0 = labelValues.valueX = x / this.width;
        tooltipCache.labelY0 = labelValues.valueY = y / this.height;
        tooltipCache.scaledS0 = offset;
        tooltipCache.scaledC0 = null;

        this._labels.setTooltip(d, labelValues.labelText, tooltipCache, labelValues);
      } else {
        this._labels.setTooltip();
      }
    }

    __labelWithoutFrame(d) {
      if (typeof d.label == "object") 
        return Object.entries(d.label)
          .filter(entry => entry[0] != this.MDL.frame.data.concept)
          .map(entry => sharedComponents.LegacyUtils.isNumber(entry[1]) ? (entry[0] + ": " + entry[1]) : entry[1])
          .join(", ");
      if (d.label != null) return "" + d.label;
      return d[Symbol.for("key")];
    }

    _updateBubbles(duration) {
      this.services.layout.size;

      if(this.ui.opacityRegular === 0) {
        this.DOM.bubbleContainer.selectAll(".vzb-bmc-bubble")
          .classed("vzb-hidden", true);
          
        return;
      }
      
      this._createAndDeleteBubbles();
      this.updateMarkerSizeLimits();

      const _this = this;
      if (!duration) duration = this.__duration;
      if (!this.bubbles) return sharedComponents.LegacyUtils.warn("redrawDataPoints(): no entityBubbles defined. likely a premature call, fix it!");

      this.bubbles.each(function(d) {
        const view = d3$1.select(this);

        const sValue = d[_this._alias("size")];
        d.hidden = (!sValue && sValue !== 0) || d.lon == null || d.lat == null;

        d.r = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(sValue)||0);
        d.center = _this.skew(_this.projection([d.lon || 0, d.lat || 0]));

        view
          .classed("vzb-hidden", d.hidden)
          .attr("cx", d.center[0])
          .attr("cy", d.center[1]);
          
        if (view.classed("vzb-hidden") !== d.hidden || !duration) {
          view
            .attr("r", d.r)
            .attr("fill", _this.cScale(d.color));
        } else {
          view.transition().duration(duration).ease(d3$1.easeLinear)
            .attr("r", d.r)
            .attr("fill", _this.cScale(d.color));
        }

        _this._updateLabel(d, duration);
      });

    }


    _updateLabel(d, duration) {
      if (duration == null) duration = this.duration;

      // only for selected entities
      if (this.MDL.selected.data.filter.has(d)) {

        const showhide = d.hidden !== d.hidden_1;
        const valueLST = null;
        const sValue = d[this._alias("size")];
        const cache = {
          labelX0: d.center[0] / this.width,
          labelY0: d.center[1] / this.height,
          scaledS0: sValue ? sharedComponents.LegacyUtils.areaToRadius(this.sScale(sValue)) : null,
          scaledC0: this.cScale(d.color)
        };

        this._labels.updateLabel(d, cache, d.center[0] / this.width, d.center[1] / this.height, sValue, d.color, this.__labelWithoutFrame(d), valueLST, duration, showhide);
      }
    }

    updateSize() {
      this.services.layout.size;

      const {margin} = this.profileConstants;

      this._date.setConditions({ 
        xAlign: "right", 
        yAlign: "top", 
        widthRatio: 2 / 10,
        rightOffset: 30,
        topOffset: 10
      });
      this._date.resizeText(this.width, this.height);
      //this.repositionElements();
      //this.rescaleMap();

      this.root.findChild({type: "_DataWarning"}).setOptions({
        width: this.width,
        height: this.height,
        vertical: "bottom", 
        horizontal: this.services.locale.isRTL() ? "left" : "right",
        right: margin.right,
        left: margin.left,
        bottom: margin.bottom
      });
    }

    updateMarkerSizeLimits() {
      //this is very funny
      this.services.layout.size;
      this.MDL.size.scale.domain;

      const {
        minRadiusPx: minRadius,
        maxRadiusPx: maxRadius
      } = this.profileConstants;

      //transfer min max radius to size dialog via root ui observable (probably a cleaner way is possible)
      this.root.ui.minMaxRadius = {min: minRadius, max: maxRadius};
        
      const extent = this.MDL.size.scale.extent || [0, 1];

      let minArea = sharedComponents.LegacyUtils.radiusToArea(Math.max(maxRadius * extent[0], minRadius));
      let maxArea = sharedComponents.LegacyUtils.radiusToArea(Math.max(maxRadius * extent[1], minRadius));

      this.sScale.range([minArea, maxArea]);
    }


    _updateOpacity() {
      this.MDL.frame.value; //listen

      const {
        opacityHighlightDim,
        opacitySelectDim,
        opacityRegular,
      } = this.ui;

      const _highlighted = this.MDL.highlighted.data.filter;
      const _selected = this.MDL.selected.data.filter;
      
      const someHighlighted = _highlighted.markers.size > 0;
      const someSelected = _selected.markers.size > 0;


      if(this.ui.opacityRegular !== 0) {
        this.bubbles.style("opacity", d => {
          if (_highlighted.has(d)) return opacityRegular;
          if (_selected.has(d)) return opacityRegular;

          if (someSelected) return opacitySelectDim;
          if (someHighlighted) return opacityHighlightDim;

          return opacityRegular;
        });
      } else {
        this.areas.style("opacity", dShape => {
          const d = this._getMarkerItemForShape(dShape);

          if (d && _highlighted.has(d)) return 1;
          if (d && _selected.has(d)) return 1;

          if (someSelected) return opacitySelectDim;
          if (someHighlighted) return opacityHighlightDim;

          return 1;
        });
      }
        
    }

    _unselectBubblesWithNoData() {
      //unselecting bubbles with no data is used for the scenario when
      //some bubbles are selected and user would switch indicator.
      //bubbles would disappear but selection would stay
      const _this = this;
      if (this.MDL.selected.markers.size > 0)
        this.bubbles.each((d)=>{
          const sValue = d[_this._alias("size")];
          if (!sValue && sValue !== 0) _this.MDL.selected.delete(d);
        });
    }

    _drawHeader() {
      const {
        headerMargin,
        infoElHeight,
        infoElMargin,
      } = this.profileConstants;

      this.services.layout.size;

      const sizeInfoHidden = this.ui.opacityRegular === 0 || !this.ui.showTitles;
      const colorInfoHidden = this.services.layout.profile == "LARGE" && !sizeInfoHidden || !this.ui.showTitles;

      const sText = this.options.sTitle || 
        (colorInfoHidden? "" : this.localise("buttons/size") + ": ")
        + sharedComponents.Utils.getConceptName(this.MDL.size, this.localise);
      const cText = this.options.cTitle || 
        (sizeInfoHidden? "" : this.localise("buttons/color") + ": ")  
        + sharedComponents.Utils.getConceptName(this.MDL.color, this.localise);

      const treemenu = this.root.findChild({type: "TreeMenu"});
      const sTitle = this.DOM.sTitle
        .classed("vzb-disabled", treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .classed("vzb-hidden", sizeInfoHidden)
        .on("click", () => {
          treemenu
            .encoding(this._alias("size"))
            .alignX(this.services.locale.isRTL() ? "right" : "left")
            .alignY("top")
            .updateView()
            .toggle();
        })
        .select("text")
        .text(sText);

      const cTitle = this.DOM.cTitle
        .classed("vzb-disabled", treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .classed("vzb-hidden", colorInfoHidden)
        .on("click", () => {
          treemenu
            .encoding(this._alias("color"))
            .alignX(this.services.locale.isRTL() ? "right" : "left")
            .alignY("top")
            .updateView()
            .toggle();
        })
        .select("text")
        .text(cText);

      const sTitleBBox = sTitle.node().getBBox();

      const sTitleTx = headerMargin.left;
      const sTitleTy = headerMargin.top + sTitleBBox.height;
      sTitle.attr("transform", `translate(${sTitleTx}, ${sTitleTy})`);
      
      const sInfoTx = sTitleTx + sTitleBBox.width + infoElMargin;
      const sInfoTy = headerMargin.top + infoElHeight / 4;
      this.DOM.sInfo.attr("transform", `translate(${sInfoTx}, ${sInfoTy})`)
        .classed("vzb-hidden", sizeInfoHidden);
      this._drawInfoEl(this.DOM.sInfo, sTitle, this.MDL.size);


      const cTitleBBox = cTitle.node().getBBox();

      const cTitleTx = headerMargin.left;
      const cTitleTy = sTitleTy + cTitleBBox.height + infoElMargin;
      cTitle.attr("transform", `translate(${cTitleTx}, ${cTitleTy})`);
      
      const cInfoTx = cTitleTx + cTitleBBox.width + infoElMargin;
      const cInfoTy = sTitleTy + infoElHeight / 4 + infoElMargin;
      this.DOM.cInfo.attr("transform", `translate(${cInfoTx}, ${cInfoTy})`)
        .classed("vzb-hidden", colorInfoHidden);
      this._drawInfoEl(this.DOM.cInfo, cTitle, this.MDL.color);


    }

    _drawInfoEl(element, titleElement, model){
      const dataNotes = this.root.findChild({type: "DataNotes"});
      const conceptProps = model.data.conceptProps;
      const infoElHeight = this.profileConstants.infoElHeight;

      element
        .on("click", () => {
          dataNotes.pin();
        })
        .on("mouseover", function() {
          const rect = this.getBBox();
          const ctx = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement);
          const coord = ctx(rect.x - 10, rect.y + rect.height + 10);
          dataNotes
            .setEncoding(model)
            .show()
            .setPos(coord.x, coord.y);
        })
        .on("mouseout", () => {
          dataNotes.hide();
        })
        .html(ICON_QUESTION)
        .select("svg")
        .attr("width", infoElHeight + "px").attr("height", infoElHeight + "px")
        .classed("vzb-hidden", 
          model.data.isConstant || !conceptProps.description && !conceptProps.sourceLink || titleElement.classed("vzb-hidden")
        );
    }

    _alias(enc) {
      return this.state.alias[enc] || enc;
    }

  }




  _VizabiBubblemap.DEFAULT_UI = {
    showTitles: true,
    timeInBackground: true,
    showForecast: false,
    showForecastOverlay: true,
    pauseBeforeForecast: true,
    opacityHighlight: 1.0,
    opacitySelect: 1.0,
    opacityHighlightDim: 0.1,
    opacitySelectDim: 0.3,
    opacityRegular: 0.5,
    datawarning: {
      doubtDomain: [],
      doubtRange: []
    },
    labels: {
      enabled: true,
      dragging: true,
      removeLabelBox: false
    },
    superhighlightOnMinimapHover: true,
    map: {
      path: null,
      colorGeo: false,
      preserveAspectRatio: false,
      scale: 1.1,
      rotate: [-11, 0],
      offset: {
        top: 0.05,
        right: 0.01,
        bottom: 0.05,
        left: -0.12
      },
      projection: "geo" + "Aitoff",
      topology: {
        path: "assets/world-50m.json",
        objects: {
          geo: "land",
          boundaries: "countries"
        },
        geoIdProperty: null,
      }
    }
  };


  //export default BubbleChart;
  const VizabiBubblemap = mobx.decorate(_VizabiBubblemap, {
    "MDL": mobx.computed,
    "mapBounds": mobx.observable,
    "skew": mobx.observable,
    "_initMap": mobx.action
  });

  class BubbleMap extends sharedComponents.BaseComponent {

    constructor(config){

      const markerName = config.options?.markerNames?.bubble || "bubble";
      const fullMarker = config.model.markers[markerName];
      config.Vizabi.utils.applyDefaults(fullMarker.config, BubbleMap.DEFAULT_CORE(markerName));
        
      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);

      config.model.markers[markerName] = marker;

      config.name = "bubblemap";

      config.subcomponents = [{
        type: sharedComponents.Repeater,
        placeholder: ".vzb-repeater",
        model: marker,
        options: {
          repeatedComponent: VizabiBubblemap,
          repeatedComponentCssClass: "vzb-bubblemap"
        },
        name: "chart",
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        name: "time-slider",
        model: marker
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        name: "speed-slider",
        model: marker
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        name: "tree-menu",
        model: marker
      },{
        type: sharedComponents.DataWarning,
        placeholder: ".vzb-datawarning",
        options: {button: ".vzb-datawarning-button"},
        model: marker,
        name: "data-warning"
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        name: "buttons",
        model: marker
      },{
        type: sharedComponents.SpaceConfig,
        placeholder: ".vzb-spaceconfig",
        options: {button: ".vzb-spaceconfig-button"},
        model: marker,
        name: "space-config"
      },{
        type: sharedComponents.ErrorMessage,
        placeholder: ".vzb-errormessage",
        model: marker,
        name: "error-message"
      }];

      config.template = `
      <div class="vzb-repeater"></div>
      <div class="vzb-animationcontrols">
        <div class="vzb-timeslider"></div>
        <div class="vzb-speedslider"></div>
      </div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datawarning"></div>
      <div class="vzb-spaceconfig"></div>
      <div class="vzb-datanotes"></div>
      <div class="vzb-errormessage"></div>
    `;

      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);
      this.splashMarker = splashMarker;
    }
  }
  BubbleMap.DEFAULT_UI = {
    chart: {
    }
  };

  BubbleMap.DEFAULT_CORE = (markerName) => ({
    requiredEncodings: ["lat", "lon", "size"],
    encoding: {
      "selected": {
        modelType: "selection"
      },
      "highlighted": {
        modelType: "selection"
      },
      "size": {
        scale: {
          modelType: "size",
          allowedTypes: ["linear", "log", "genericLog", "pow"],
        }
      },
      "lat": {
        data: {
          space: {},
          concept: {
            filter: { concept: { $in: ["latitude", "lat"] } }
          }
        }
      },
      "lon": {
        data: {
          space: {},
          concept: {
            filter: { concept: { $in: ["longitude", "lon", "lng"] } }
          }
        }
      },
      "color": {
        scale: {
          modelType: "color"
        }
      },
      "label": {
        data: {
          modelType: "entityPropertyDataConfig"
        }
      },
      "size_label": {
        data: {
          constant: "_default"
        },
        scale: {
          modelType: "size",
          allowedTypes: ["linear", "log", "genericLog", "pow", "point"],
        }
      },
      "frame": {
        modelType: "frame"
      },
      "order": {
        modelType: "order",
        direction: "desc",
        data: {
          ref: `markers.${markerName}.encoding.size.data.config`
        }
      },
      "repeat": {
        modelType: "repeat",
        allowEnc: ["size"]
      }
    }
  });

  BubbleMap.versionInfo = { version: "4.3.2", build: 1706309492096, package: {"homepage":"https://github.com/vizabi/bubblemap#readme","name":"@vizabi/bubblemap","description":"Vizabi bubble map"}, sharedComponents: sharedComponents.versionInfo};

  class VizabiClickmap extends VizabiBubblemap {

    _interact() {
      const _this = this;

      
      const interact = super._interact();
      interact.click = function(event, d) {
        if (_this.MDL.frame.dragging || !d) return;

        _this.MDL.highlighted.data.filter.delete(d);
        _this._setTooltip(event);
        if (_this.ui.clickUrl) window.open(_this.ui.clickUrl + d[Symbol.for("key")]);
      };
      return interact;
    }

    __labelWithoutFrame(d) {
      return super.__labelWithoutFrame(d) + ": " + this.localise(d[this._alias("color")]) + "% misunderstanding";
    }
  }

  VizabiClickmap.DEFAULT_UI = VizabiBubblemap.DEFAULT_UI;

  class ClickMap extends sharedComponents.BaseComponent {

    constructor(config){

      const markerName = config.options?.markerNames?.bubble || "bubble";
      const fullMarker = config.model.markers[markerName];
      config.Vizabi.utils.applyDefaults(fullMarker.config, ClickMap.DEFAULT_CORE(markerName));
        
      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);

      config.model.markers[markerName] = marker;

      config.name = "clickmap";

      config.subcomponents = [{
        type: sharedComponents.Repeater,
        placeholder: ".vzb-repeater",
        model: marker,
        options: {
          repeatedComponent: VizabiClickmap,
          repeatedComponentCssClass: "vzb-bubblemap"
        },
        name: "chart",
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        name: "tree-menu",
        model: marker
      },{
        type: sharedComponents.DataWarning,
        placeholder: ".vzb-datawarning",
        options: {button: ".vzb-datawarning-button"},
        model: marker,
        name: "data-warning"
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        name: "buttons",
        model: marker
      },{
        type: sharedComponents.SpaceConfig,
        placeholder: ".vzb-spaceconfig",
        options: {button: ".vzb-spaceconfig-button"},
        model: marker,
        name: "space-config"
      },{
        type: sharedComponents.ErrorMessage,
        placeholder: ".vzb-errormessage",
        model: marker,
        name: "error-message"
      }];

      config.template = `
      <div class="vzb-repeater"></div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datawarning"></div>
      <div class="vzb-spaceconfig"></div>
      <div class="vzb-datanotes"></div>
      <div class="vzb-errormessage"></div>
    `;

      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);
      this.splashMarker = splashMarker;
    }
  }
  ClickMap.DEFAULT_UI = {
    chart: {
    }
  };

  ClickMap.DEFAULT_CORE = (markerName) => ({
    requiredEncodings: ["lat", "lon", "size"],
    encoding: {
      "selected": {
        modelType: "selection"
      },
      "highlighted": {
        modelType: "selection"
      },
      "size": {
        scale: {
          modelType: "size",
          allowedTypes: ["linear", "log", "genericLog", "pow", "point"]
        }
      },
      "lat": {
        data: {
          space: {},
          concept: {
            filter: { concept: { $in: ["latitude", "lat"] } }
          }
        }
      },
      "lon": {
        data: {
          space: {},
          concept: {
            filter: { concept: { $in: ["longitude", "lon", "lng"] } }
          }
        }
      },
      "color": {
        scale: {
          modelType: "color"
        }
      },
      "label": {
        data: {
          modelType: "entityPropertyDataConfig"
        }
      },
      "size_label": {
        data: {
          constant: "_default"
        },
        scale: {
          modelType: "size",
          allowedTypes: ["linear", "log", "genericLog", "pow", "point"],
        }
      },
      "frame": {
        modelType: "frame"
      },
      "order": {
        modelType: "order",
        direction: "desc",
        data: {
          ref: `markers.${markerName}.encoding.size.data.config`
        }
      },
      "repeat": {
        modelType: "repeat",
        allowEnc: ["size"]
      }
    }
  });

  ClickMap.versionInfo = { version: "4.3.2", build: 1706309492096, package: {"homepage":"https://github.com/vizabi/bubblemap#readme","name":"@vizabi/bubblemap","description":"Vizabi bubble map"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = BubbleMap;
  exports.ClickMap = ClickMap;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/mountainchart#readme v7.3.12 build 1706306812826 Copyright 2024 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('d3'), require('mobx')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'd3', 'mobx'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MountainChart = {}, global.VizabiSharedComponents, global.d3, global.mobx));
})(window, (function (exports, sharedComponents, d3, mobx) {
  class MCMath {

    constructor(context) {
      this.context = context;

      this.xScaleFactor = 1;
      this.xScaleShift = 0;
    }

    rescale(x) {
      return Math.exp(this.xScaleFactor * Math.log(x) + this.xScaleShift);
    }
    unscale(x) {
      return Math.exp((Math.log(x) - this.xScaleShift) / this.xScaleFactor);
    }

    generateMesh(length, scaleType, domain) {
      // span a uniform mesh across the entire X scale
      // if the scale is log, the mesh would be exponentially distorted to look uniform

      const rangeFrom = scaleType === "linear" ? domain[0]
        : Math.log(this.unscale(domain[0]));

      const rangeTo = scaleType === "linear" ? domain[1]
        : Math.log(this.unscale(domain[1]));

      const rangeStep = (rangeTo - rangeFrom) / length;

      let mesh = d3.range(rangeFrom, rangeTo, rangeStep).concat(rangeTo);

      if (scaleType !== "linear") {
        mesh = mesh.map(dX => Math.exp(dX));
      } else {
        mesh = mesh.filter(dX => dX > 0);
      }

      return mesh;
    }

    gdpToMu(gdp, sigma) {
      // converting gdp per capita per day into MU for lognormal distribution
      // see https://en.wikipedia.org/wiki/Log-normal_distribution
      return Math.log(gdp / 365) - sigma * sigma / 2;
    }

    giniToSigma(gini) {
      // The ginis are turned into std deviation.
      // Mattias uses this formula in Excel: stddev = NORMSINV( ((gini/100)+1)/2 )*2^0.5
      return this.normsinv(((gini / 100) + 1) / 2) * Math.pow(2, 0.5);
    }

    // this function returns PDF values for a NORMAL distribution
    pdfNormal(x, mu, sigma) {
      return Math.exp(
        -0.5 * Math.log(2 * Math.PI)
        - Math.log(sigma)
        - Math.pow(x - mu, 2) / (2 * sigma * sigma)
      );
    }
    // this function returns PDF values for a LOGNORMAL distribution
    pdfLognormal(x, mu, sigma) {
      return Math.exp(
        -0.5 * Math.log(2 * Math.PI) //should not be different for the two scales- (scaleType=="linear"?Math.log(x):0)
        - Math.log(sigma)
        - Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma)
      );
    }

    normsinv(p) {
      //
      // Lower tail quantile for standard normal distribution function.
      //
      // This function returns an approximation of the inverse cumulative
      // standard normal distribution function.  I.e., given P, it returns
      // an approximation to the X satisfying P = Pr{Z <= X} where Z is a
      // random variable from the standard normal distribution.
      //
      // The algorithm uses a minimax approximation by rational functions
      // and the result has a relative error whose absolute value is less
      // than 1.15e-9.
      //
      // Author:      Peter John Acklam
      // (Javascript version by Alankar Misra @ Digital Sutras (alankar@digitalsutras.com))
      // Time-stamp:  2003-05-05 05:15:14
      // E-mail:      pjacklam@online.no
      // WWW URL:     http://home.online.no/~pjacklam

      // Taken from http://home.online.no/~pjacklam/notes/invnorm/index.html
      // adapted from Java code

      // An algorithm with a relative error less than 1.15*10-9 in the entire region.

      // Coefficients in rational approximations
      const a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
      const b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
      const c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
      const d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];

      // Define break-points.
      const plow = 0.02425;
      const phigh = 1 - plow;

      // Rational approximation for lower region:
      if (p < plow) {
        const q = Math.sqrt(-2 * Math.log(p));
        return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
          ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
      }

      // Rational approximation for upper region:
      if (phigh < p) {
        const q = Math.sqrt(-2 * Math.log(1 - p));
        return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
          ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
      }

      // Rational approximation for central region:
      const q = p - 0.5;
      const r = q * q;
      return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
        (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);

    }


  }

  class MCDecorations{
    constructor(){
    }
      
    update(duration) {

      const _this = this;
      this.services.layout.size; //watch
      this.ui.inpercent;
      
      // x axis groups used for incomes
      const showxAxisGroups = this.ui.decorations.xAxisGroups 
        && this.ui.decorations.xAxisGroups[this.MDL.mu.data.concept || "any"] 
        && this.ui.decorations.enabled
        && this.services.layout.profile !== "SMALL";
      
      this.DOM.xAxisGroups.classed("vzb-invisible", !showxAxisGroups);
      if (showxAxisGroups) {
        const axisGroupsData = sharedComponents.Utils.injectIndexes(this.ui.decorations.xAxisGroups[this.MDL.mu.data.concept || "any"]);
        let xAxisGroups = this.DOM.xAxisGroups.selectAll(".vzb-mc-x-axis-group").data(axisGroupsData);
        
        xAxisGroups.exit().remove();
        xAxisGroups = xAxisGroups.enter().append("g").attr("class", "vzb-mc-x-axis-group")
          .each(function(){
            const view = d3.select(this);
            view.append("text").attr("class", "vzb-mc-x-axis-group-line").text("◆").style("text-anchor","middle");
            view.append("text").attr("class", "vzb-mc-x-axis-group-text");
          })
          .merge(xAxisGroups);
        
        const xAxisGroups_calcs = [];
        let useShorterLabels = false;
        
        // first pass: calculate label text sizes and margins
        xAxisGroups.each(function(d, i){
          const view = d3.select(this);
          
          const text = view.select("text.vzb-mc-x-axis-group-text")
            .text(_this.localise(d.label));
          
          const calcs = {min: d.min, max: d.max};
          
          calcs.textHeight = text.node().getBBox().height;
          calcs.textWidth = text.node().getBBox().width;
          
          calcs.boundaryMinX_px = _this.xScale(d.min || d.min === 0? d.min : d3.min(_this.xScale.domain()));
          calcs.boundaryMaxX_px = _this.xScale(d.max || d.max === 0? d.max : d3.max(_this.xScale.domain()));
          
          calcs.centerX_px = (calcs.boundaryMinX_px + calcs.boundaryMaxX_px) / 2;
          calcs.marginX_px = (Math.abs(calcs.boundaryMinX_px - calcs.boundaryMaxX_px) - calcs.textWidth) / 2;
          
          if (calcs.marginX_px - calcs.textHeight < 0) useShorterLabels = true;
          
          xAxisGroups_calcs[i] = calcs;
        });
        
        // second pass: if at least one of labels doesn't fit, switch to compact mode and recalculate text sizes and margins
        if (useShorterLabels) {
          xAxisGroups.each(function(d, i){
            const view = d3.select(this);

            const text = view.select("text.vzb-mc-x-axis-group-text")
              .text(_this.localise(d.label_short));

            const calcs = xAxisGroups_calcs[i];

            calcs.textWidth = text.node().getBBox().width;
            calcs.marginX_px = (Math.abs(calcs.boundaryMinX_px - calcs.boundaryMaxX_px) - calcs.textWidth) / 2;

            xAxisGroups_calcs[i] = calcs;
          });
        }
        
        // third pass: actually put labels in places
        xAxisGroups.each(function(d, i){
          const view = d3.select(this);
          
          const isFirst = (i == 0);
          const isLast = (i == xAxisGroups_calcs.length - 1);
          const calcs = xAxisGroups_calcs[i];
          const minMargin = calcs.textHeight/4;
          let x = calcs.centerX_px;
          
          if (isFirst) x = xAxisGroups_calcs[i+1].boundaryMinX_px - Math.max(xAxisGroups_calcs[i+1].marginX_px, minMargin);
          if (isLast) x = xAxisGroups_calcs[i-1].boundaryMaxX_px + Math.max(xAxisGroups_calcs[i-1].marginX_px, minMargin);
          
          view.select("text.vzb-mc-x-axis-group-text")
            .transition()
            .duration(duration || 0)
            .style("text-anchor", isFirst ? "end" : isLast ? "start" : "middle")
            .attr("dy", "-1.2em")
            .attr("y", _this.height)
            .attr("x", x);
          
          view.select("text.vzb-mc-x-axis-group-line")
            .classed("vzb-invisible", isLast)
            .transition()
            .duration(duration || 0)
            .attr("dy", "-1.2em")
            .attr("y", _this.height - calcs.textHeight * 0.1)
            .attr("x", calcs.boundaryMaxX_px);
        });

        xAxisGroups.select("text.vzb-mc-x-axis-group-text").on("mouseenter", function(event, d) {
          if (_this._isDragging()) return;
          const calcs = xAxisGroups_calcs[d.i];
          d3.select(this).attr("font-weight", "bold");
          
          _this.runHereOrPossiblyInAllFacets(function(context){
            context.DOM.xAxisGroups.append("rect").lower()
              .attr("x", calcs.boundaryMinX_px)
              .attr("width", calcs.boundaryMaxX_px - calcs.boundaryMinX_px)
              .attr("y", -context.profileConstants.margin.top)
              .attr("height", context.height + context.profileConstants.margin.top);

            if (calcs.min || calcs.min === 0) context.DOM.xAxisGroups.append("line").lower()
              .attr("x1", calcs.boundaryMinX_px)
              .attr("x2", calcs.boundaryMinX_px)
              .attr("y1", -context.profileConstants.margin.top)
              .attr("y2", context.height);

            if (calcs.max || calcs.max === 0) context.DOM.xAxisGroups.append("line").lower()
              .attr("x1", calcs.boundaryMaxX_px)
              .attr("x2", calcs.boundaryMaxX_px)
              .attr("y1", -context.profileConstants.margin.top)
              .attr("y2", context.height);
          });
        }).on("mouseleave", function() {
          if (_this._isDragging()) return;
          d3.select(this).attr("font-weight", null);

          _this.runHereOrPossiblyInAllFacets(function(context){
            context.DOM.xAxisGroups.selectAll("rect").remove();
            context.DOM.xAxisGroups.selectAll("line").remove();
          });
        });
      }
      
    }
  }

  const {ICON_CLOSE} = sharedComponents.Icons;

  class _MCSelectList extends sharedComponents.BaseComponent {


    setup() {

    }

    get MDL(){
      return {
        frame: this.model.encoding.frame,
        color: this.model.encoding.color,
        selectedF: this.model.encoding.selected.data.filter,
        highlightedF: this.model.encoding.highlighted.data.filter
      };
    }

    draw() {


      this.localise = this.services.locale.auto(this.MDL.frame.interval);

      this.addReaction(this.addAndRemoveLabels);
      this.addReaction(this.updateHighlighted);
    }

    isManyFacetsAndLonely(){
      return this.parent.isManyFacets && this.parent.atomicSliceData.length == 1;
    }

    isChartTooSmall(){
      return this.parent.height <= this.parent.profileConstants.minHeight;
    }

    addAndRemoveLabels(){
      const _this = this;
      this.MDL.selectedF.markers; //watch
      this.MDL.frame.value; //watch
      this.services.layout.size; //watch
      this.parent.ui.inpercent;

      const dedupe = new Set();

      const listData = this.isManyFacetsAndLonely() || this.isChartTooSmall()
        ? []
        : this.parent.atomicSliceData
          .concat(this.parent.groupedSliceData)
          .concat(this.parent.stackedSliceData)
          .filter(d => this.MDL.selectedF.has(d) && !dedupe.has(d.KEY()) && dedupe.add(d.KEY()))
          .sort(this._sortLabels);

      this.labels = this.element.selectAll("g.vzb-mc-label")
        .data(listData, d => d.KEY());

      this.labels.exit().remove();
      this.labels = this.labels.enter().append("g")
        .attr("class", "vzb-mc-label")
        .each(function(d) {
          const view = d3.select(this);
          _this._buildOneLabel(view, d);
        })
        .merge(this.labels);
      
      this.redraw();
    }

    _sortLabels(a, b){
      if (a.sortValue && b.sortValue) {
        if (a.sortValue[1] === b.sortValue[1]) {
          return d3.descending(a.sortValue[0], b.sortValue[0]);
        }
        return d3.descending(a.sortValue[1], b.sortValue[1]);
      }

      if (a.aggrLevel != b.aggrLevel) {
        return d3.descending(a.aggrLevel, b.aggrLevel);
      } else if (a.aggrLevel == b.aggrLevel) {
        return d3.descending(a.yMax, b.yMax);
      }

      return 0;
    }

    _buildOneLabel(view, d){
      
      view.append("circle").attr("class", "vzb-mc-label-legend");
      view.append("text").attr("class", "vzb-mc-label-shadow vzb-mc-label-text");
      view.append("text").attr("class", "vzb-mc-label-text");

      const labelCloseGroup = view.append("g")
        .attr("class", "vzb-mc-label-x vzb-label-shadow vzb-invisible")
        .on("click", (event) => {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          event.stopPropagation();
          this.MDL.highlightedF.delete(d);
          this.MDL.selectedF.toggle(d);
        });
        // .onTap(() => {
        //   this.MDL.highlightedF.delete(d);
        //   this.MDL.selectedF.toggle(d);
        // });

      if (!sharedComponents.LegacyUtils.isTouchDevice()) {
        sharedComponents.LegacyUtils.setIcon(labelCloseGroup, ICON_CLOSE)
          .select("svg")
          .attr("class", "vzb-mc-label-x-icon")
          .attr("width", "0px")
          .attr("height", "0px");

        labelCloseGroup.insert("circle", "svg");

      } else {
        labelCloseGroup.append("rect");
        labelCloseGroup.append("text")
          .attr("class", "vzb-mc-label-x-text")
          .text("Deselect");
      }

      view
        .on("mousemove", () => {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          this.showCloseCross(d, true);
          this.MDL.highlightedF.set(d);
        })
        .on("mouseout", () => {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          this.showCloseCross(d, false);
          this.MDL.highlightedF.delete(d);
        })
        .on("click", () => {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          this.MDL.highlightedF.delete(d);
          this.MDL.selectedF.toggle(d);
        });

    }


    updateHighlighted(){
      this.MDL.highlightedF.markers; //watch
      this.labels.classed("vzb-highlight", d => this.MDL.highlightedF.has(d));
    }

    redraw() {
      const _this = this;


      if (!this.labels || !this.MDL.selectedF.any()) return;

      const sample = this.element.append("g")
        .attr("class", "vzb-mc-label")
        .append("text")
        .text("0");

      let fontHeight = sample.node().getBBox().height * 1.2;
      const fontSizeToFontHeight = parseFloat(sample.style("font-size")) / fontHeight;
      d3.select(sample.node().parentNode).remove();

      const titleHeight = this.parent.DOM.yTitle.select("text").node().getBBox().height || 0;

      const maxFontHeight = Math.max(0, (this.parent.height - titleHeight * 3)) / (this.labels.data().length + 2);
      if (fontHeight > maxFontHeight) fontHeight = maxFontHeight;

      let currentAggrLevel = "null";
      let aggrLevelSpacing = 0;

      const isRTL = this.services.locale.isRTL();

      this.labels
        .attr("transform", (d, i) => {
          if (d.aggrLevel != currentAggrLevel) aggrLevelSpacing += fontHeight;
          const spacing = fontHeight * i + titleHeight * 2 + aggrLevelSpacing;
          currentAggrLevel = d.aggrLevel;
          return "translate(" + (isRTL ? this.parent.width : 0) + "," + spacing + ")";
        })
        .each(function(d, i) {

          const view = d3.select(this).attr("id", d.KEY() + "-label-" + _this.parent.id);
          let name = "";
          if (d.key) {
            name = d.key === "all" ? _this.localise("mount/merging/world") : _this.parent._getLabelText(d);
          } else {
            name = _this.parent._getLabelText(d);
          }

          const string = d.norm 
            ? name + ": " + _this.localise(d.norm) + (i === 0 ? " " + _this.localise("mount/people") : "")
            : name;

          const text = view.selectAll(".vzb-mc-label-text")
            .attr("x", (isRTL ? -1 : 1) * fontHeight)
            .attr("y", fontHeight)
            .text(string)
            .style("font-size", fontHeight === maxFontHeight ? (fontHeight * fontSizeToFontHeight + "px") : null);

          const contentBBox = text.node().getBBox();

          const closeGroup = view.select(".vzb-mc-label-x");

          if (sharedComponents.LegacyUtils.isTouchDevice()) {
            const closeTextBBox = closeGroup.select("text").node().getBBox();
            closeGroup
              .classed("vzb-revert-color", true)
              .select(".vzb-mc-label-x-text")
              .classed("vzb-revert-color", true)
              .attr("x", contentBBox.width + contentBBox.height * 1.12 + closeTextBBox.width * 0.5)
              .attr("y", contentBBox.height * 0.55);

            closeGroup.select("rect")
              .attr("width", closeTextBBox.width + contentBBox.height * 0.6)
              .attr("height", contentBBox.height)
              .attr("x", contentBBox.width + contentBBox.height * 0.9)
              .attr("y", 0)
              .attr("rx", contentBBox.height * 0.25)
              .attr("ry", contentBBox.height * 0.25);
          } else {
            closeGroup
              .attr("x", contentBBox.width + contentBBox.height * 1.1)
              .attr("y", contentBBox.height / 3);

            closeGroup.select("circle")
              .attr("r", contentBBox.height * 0.4)
              .attr("cx", (isRTL ? -1 : 1) * (contentBBox.width + contentBBox.height * 1.1))
              .attr("cy", contentBBox.height / 3);

            closeGroup.select("svg")
              .attr("x", (isRTL ? -1 : 1) * (contentBBox.width + contentBBox.height * (1.1 - (isRTL ? -0.4 : 0.4))))
              .attr("y", contentBBox.height * (1 / 3 - 0.4))
              .attr("width", contentBBox.height * 0.8)
              .attr("height", contentBBox.height * 0.8);
          }

          view.select(".vzb-mc-label-legend")
            .attr("r", fontHeight / 3)
            .attr("cx", (isRTL ? -1 : 1) * fontHeight * 0.4)
            .attr("cy", fontHeight / 1.5)
            .style("fill", _this.parent.MDL.color.scale.d3Scale(d.color || d[Symbol.for("key")]));

          // view.onTap((event, d) => {
          //   event.stopPropagation();
          //   _this.model.marker.highlightMarker(d.KEYS());
          //   setTimeout(() => {
          //     _this.model.marker.unhighlightMarker(d.KEYS());
          //   }, 2000);
          // });
        });
    }

    showCloseCross(d, show) {
      const key = d.KEY();
      //show the little cross on the selected label
      this.labels
        .filter(f => f.KEY() == key)
        .select(".vzb-mc-label-x")
        .classed("vzb-invisible", !show);
    }

  }

  const MCSelectList = mobx.decorate(_MCSelectList, {
    "MDL": mobx.computed
  });

  class MCProbe extends sharedComponents.BaseComponent {

    constructor(config){
      config.template = `
      <text class="vzb-mc-probe-extremepoverty"></text>
      <line></line>
      <g class="vzb-mc-probe-details">
        <text class="vzb-mc-probe-value vzb-mc-probe-value-ul"></text>
        <text class="vzb-mc-probe-value vzb-mc-probe-value-ur"></text>
        <text class="vzb-mc-probe-value vzb-mc-probe-value-dl"></text>
        <text class="vzb-mc-probe-value vzb-mc-probe-value-dr"></text>
      </g>
      <text class="vzb-mc-probe-value vzb-mc-probe-value-head"></text>
    `;

      super(config);
    }

    setup(options) {
      this.DOM = {
        probe: this.element,
        probeLine: this.element.select("line"),
        extremepovertyText: this.element.select(".vzb-mc-probe-extremepoverty"),
        probeBlocks: this.element.selectAll(".vzb-mc-probe-details"),
        probeValues: this.element.selectAll(".vzb-mc-probe-value:not(.vzb-mc-probe-value-head)"),
        probeValuesHead: this.element.selectAll(".vzb-mc-probe-value-head")
      };

      this.povertylineMarkerName = options.povertylineMarkerName;
      this.povertylineEncName = options.povertylineEncName;
    }


    get MDL() {
      return {
        frame: this.model.encoding.frame,
        stack: this.model.encoding.stack,
        povertylineMarker: this.root.model.markers[this.povertylineMarkerName]
      };
    }

    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);
      //this.addReaction(this.redraw);
    }

    _isProbeModelReady() {
      return this.MDL.povertylineMarker.state == sharedComponents.Utils.STATUS.READY;
    }

    _getNationalLevel(markerItem){
      const frameConcept = this.MDL.frame.data.concept;
      const dims = this.MDL.povertylineMarker.data.space.filter(f => f != frameConcept);
      const getKey = (d) => dims.map(dim => d[dim]).join("¬");
          
      const povertyLineData = this.MDL.povertylineMarker.dataArray
        //filter only the items that match the mountain in the chart
        .filter(f => getKey(f) === getKey(markerItem) && f[this.povertylineEncName])
        //take nearest item to current frame value
        .sort((a,b) => Math.abs(this.MDL.frame.value - b[frameConcept]) - Math.abs(this.MDL.frame.value - a[frameConcept]))
        .pop() || {};
      
      return {level: povertyLineData[this.povertylineEncName], time: povertyLineData[frameConcept]};
    }

    redraw(options = {}) {
      this.services.layout.size; //watch
      this.parent.ui.inpercent;
      this.MDL.frame.value; //watch

      const height = this.parent.height - this.parent.profileConstants.margin.top - this.parent.profileConstants.margin.bottom;

      const extremeMode = this.parent.ui.probeXType == "extreme";
      const nationalMode = this.parent.ui.probeXType == "national";
      const customMode = this.parent.ui.probeXType == "custom";

      let level = null;
      let time = null;
      if (options.full && options.level){
        level = options.level;       
      }
      else if (nationalMode) {
        if (this.parent.atomicSliceData.length == 1 && this._isProbeModelReady()) {
          ({level, time} = this._getNationalLevel(this.parent.atomicSliceData[0]));
        } else {
          this.DOM.probe.classed("vzb-hidden", true);
          return;
        }
      } else if (customMode && !level) {
        level = this.parent.ui.probeXCustom;
      } else if (!level) {
        level = this.parent.ui.probeX; 
      }

      this.DOM.probe.classed("vzb-hidden", !level || !this.parent.ui.showProbeX);
      if (!level) return;

      this.element.attr("transform", `translate(${this.parent.xScale(level)}, 0)`);
      
      if(this.parent.xAxis.scale())
        this.parent.DOM.xAxis.call(this.parent.xAxis.highlightValue(options.full ? level : "none"));


      const _computeAreas = (mountains) => {       
        let sumValue = 0;
        let totalArea = 0;
        let leftArea = 0;

        mountains.forEach(d => {
          sumValue += d.norm;

          if (!d.shape) return;

          const next = Math.pow(d.shape[1].x / d.shape[0].x, 0.5);
          const prev = Math.pow(d.shape[1].x / d.shape[0].x, -0.5);
          const X = this.parent.xScale;
          const barWidthPX = X(d.shape[1].x) - X(d.shape[0].x);

          d.shape.forEach((vertex) => {
            totalArea += vertex.y;
            
            //for this bit you have to imagine the mountain shape as a histogram
            //each vertex of mountain is the height of the bar, one bar for income bracket          
            const nextMidpoint = vertex.x * next;
            const prevMidpoint = vertex.x * prev;

            //bar partially to the left
            if (prevMidpoint < level && level <= nextMidpoint) leftArea += vertex.y * (X(level) - X(prevMidpoint)) / barWidthPX;
            //bar fully to the left
            if (nextMidpoint < level) leftArea += vertex.y;
          });
        });

        return {sumValue, totalArea, leftArea};
      };

      
      const data = _computeAreas(this.parent.atomicSliceData);

      const formatterPercent = (value) => value < 0.1 ? 0 : d3.format(".2r")(value);

      const notInLargestFacet = () => this.parent.isManyFacets && this.parent.parent.largetstFacetId !== this.parent.name;

      this.DOM.extremepovertyText
        .classed("vzb-hidden", options.full || !extremeMode || notInLargestFacet)
        .text(this.localise("mount/extremepoverty"))
        .attr("x", -height)
        .attr("y", 0)
        .attr("dy", "-1.15em")
        .attr("dx", "0.5em")
        .attr("transform", "rotate(-90)");

      let epTextBBox = extremeMode ? this.DOM.extremepovertyText.node().getBBox() : {width: 0, height: 0};

      if(epTextBBox.width > height * 0.5) {
        this.DOM.extremepovertyText.classed("vzb-hidden", true);
        epTextBBox = {width: 0, height: 0};
      }

      const suffix = !this.parent.isManyFacets || this.parent.state.positionInFacet.row.first ? " " + this.localise("mount/people") : "";
      this.DOM.probeValues
        .text((d, i) => {
          if (!data.totalArea) return "";

          if (i === 0) return formatterPercent(data.leftArea / data.totalArea * 100) + "%";
          if (i === 1) return formatterPercent(100 - data.leftArea / data.totalArea * 100) + "%";
          if (i === 2) {
            const count = this.localise(data.sumValue * data.leftArea / data.totalArea);
            return count != 0 ? count : this.localise("mount/few");
          }
          if (i === 3) {
            const count = this.localise(data.sumValue * (1 - data.leftArea / data.totalArea));
            return (count != 0 ? count : this.localise("mount/few")) + suffix;
          }
        })
        .classed("vzb-hidden", (d, i) => !options.full &&
          (((i === 0) && !this.parent.ui.probeXDetails.belowProc) ||
          ((i === 1) && !this.parent.ui.probeXDetails.aboveProc) ||
          ((i === 2) && !this.parent.ui.probeXDetails.belowCount) ||
          ((i === 3) && !this.parent.ui.probeXDetails.aboveCount))
        )
        .attr("x", (d, i) => ([0, 4, 2, 6].includes(i) ? -6 : +5))
        .attr("dy", (d, i) => [0, 1, 4, 5].includes(i) ? "-2.5em" : "-1.2em");

      this.DOM.probeValuesHead
        .text(`${this.localise(level)}$ (${this.localise(time)})`)
        .classed("vzb-hidden", !nationalMode || options.full)
        .attr("dy", "0.3em")
        .attr("y", 0);

      this.DOM.probeLine
        .attr("x1", 0)
        .attr("x2", 0)
        .attr("y1", height + 6)
        .attr("y2", 0);

      const riseAllValues = height > this.parent.profileConstants.minHeight 
        ? Math.max(epTextBBox.width + epTextBBox.height * 0.5, height / 4 )
        : 0; 
      
      this.DOM.probeBlocks.attr("transform", `translate (0, ${height - riseAllValues})`);
    
    }
  }

  const decorated$7 = mobx.decorate(MCProbe, {
    "MDL": mobx.computed
  });

  var sign = `
    <rect id="stick" x="15.405" y="261.65" width="2.8668" height="35.37" ry="0" fill="#fff" stroke="#000" stroke-linejoin="bevel" stroke-width=".19502"/>

    <foreignObject id="text" width="200px" height="50px">
        <div xmlns="http://www.w3.org/1999/xhtml" width="150px"></div>
    </foreignObject>

    <g id="arrow" transform="translate(0 -10)"><path d="m6.4132 261.09c-2.0396 0-3.7034 1.6638-3.7034 3.7034v6.4297c0 2.0396 1.6638 3.7034 3.7034 3.7034h20.85c2.0396 0 3.7034-1.6638 3.7034-3.7034v-6.4297c0-2.0396-1.6638-3.7034-3.7034-3.7034z" color="#000000" class="fill" stroke="#000" stroke-linejoin="round" stroke-width=".44747"/><path d="m8.9281 265.01 10.714 0.50768-0.35649-1.8446h0.13489l5.3281 4.3322-5.3281 4.3322h-0.13489l0.35649-1.853-10.714 0.5246z" fill="#fff"/><path d="m6.4132 261.09c-2.0396 0-3.7034 1.6638-3.7034 3.7034v6.4297c0 2.0396 1.6638 3.7034 3.7034 3.7034h20.85c2.0396 0 3.7034-1.6638 3.7034-3.7034v-6.4297c0-2.0396-1.6638-3.7034-3.7034-3.7034zm0 1.3983h20.85c1.2891 0 2.3051 1.016 2.3051 2.3051v6.4297c0 1.2891-1.016 2.3051-2.3051 2.3051h-20.85c-1.2891 0-2.3051-1.016-2.3051-2.3051v-6.4297c0-1.2891 1.016-2.3051 2.3051-2.3051z" color="#000000" fill="#fff" stroke-linejoin="round" stroke-width=".11187"/></g>
    </g>

`;

  const {ICON_QUESTION: ICON_QUESTION$1} = sharedComponents.Icons;

  class MCUltraRich extends sharedComponents.BaseComponent {

    constructor(config) {
      config.template = ``;

      super(config);
    }

    setup(options) {
      this.DOM = {
        container: this.element,
        sign: this.element.append("g").attr("class", "vzb-billy-sign"),
        arrow: this.element.append("g").attr("class", "vzb-billy-arrow vzb-hidden").html(`
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
      <g>
      <path d="M256 8c137 0 248 111 248 248S393 504 256 504 8 393 8 256 119 8 256 8zm-28.9 143.6l75.5 72.4H120c-13.3 0-24 10.7-24 24v16c0 13.3 10.7 24 24 24h182.6l-75.5 72.4c-9.7 9.3-9.9 24.8-.4 34.3l11 10.9c9.4 9.4 24.6 9.4 33.9 0L404.3 273c9.4-9.4 9.4-24.6 0-33.9L271.6 106.3c-9.4-9.4-24.6-9.4-33.9 0l-11 10.9c-9.5 9.6-9.3 25.1.4 34.4z"/>
      </g>
      </svg>`),
        deselectClickRect: this.element.append("g").append("rect").attr("class", "vzb-billy-deselect-click-rect"),
        bridgeShapeBlur: this.element.append("g"),
        bridgeShape: this.element.append("g"),
        circlebox: this.element.append("g"),
        zoombox: this.element.append("g"),
        hlFace: this.element.append("circle").attr("class", "vzb-billy-hl"),
        hlLine: this.element.append("line").attr("class", "vzb-billy-hl"),
        unknownCircle: this.element.append("circle"),
        text: this.element.append("g").attr("class", "vzb-billy-text"),
        defs: this.element.append("defs")
      };
      this.DOM.deselectClickRect
        .on("click", () => {
          if (this.someSelected) {
            this.MDL.billySelectedF.clear();
          }
        });
      this.DOM.text.append("text");
      this.DOM.info = this.DOM.zoombox.append("g").attr("class", "vzb-billy-info"),
      this.DOM.boxTopText = this.DOM.zoombox.append("text").attr("class", "vzb-billy-toptext"),
      this.DOM.upperbox = this.DOM.zoombox.append("rect").attr("class", "vzb-billy-upperbox");
      this.DOM.lowerbox = this.DOM.zoombox.append("rect").attr("class", "vzb-billy-lowerbox");
      this.DOM.arc = this.DOM.zoombox.append("path").attr("class", "vzb-billy-arc");
      this.DOM.sign.append("g").attr("transform", `translate(-19, -297)`).html(sign);

      this.DOM.defs.html(`
      <linearGradient id="progFade-${this.parent.id}" x1="0%" x2="100%" y1="0%" y2="0%">
        <stop offset="0%" stop-color="black"/>
        <stop offset="30%" stop-color="white"/>      
      </linearGradient>

      <linearGradient id="progFade1-${this.parent.id}" x1="0%" x2="100%" y1="0%" y2="0%">
        <stop offset="0%" stop-color="#444"/>
        <stop offset="50%" stop-color="white"/>      
      </linearGradient>
      
      <mask class="progFadeMask" id="progFadeMask-${this.parent.id}" >
        <rect fill="url(#progFade-${this.parent.id})"  />
      </mask>

      <mask class="clipMask" id="clipMask-${this.parent.id}" >
        <rect fill="url(#progFade1-${this.parent.id})"  />
      </mask>
      
      <pattern id="vzb-pattern-billy-bridgeshape-${this.parent.id}" style="stroke: white; fill: transparent; stroke-width:10px;" x="0" y="0" patternUnits="userSpaceOnUse" width="25" height="25" viewBox="0 0 500 500"> 
<path d="m308.54 177.46a80 80 0 0 0-80 80 80 80 0 0 0 54.279 75.572 80 80 0 0 1-5.0957-7.959 80 80 0 0 1-0.63867-1.1699 80 80 0 0 1-3.6797-7.7324 80 80 0 0 1-0.83593-2.2422 80 80 0 0 1-2.4277-7.377 80 80 0 0 1-0.76758-3.5195 80 80 0 0 1-1.2832-6.5801 80 80 0 0 1-0.74023-10.371 80 80 0 0 1 3.2402-22.539 80 80 0 0 1 9.459-20.713 80 80 0 0 1 6.8398-9.1367 80 80 0 0 1 8.0723-8.0723 80 80 0 0 1 9.1367-6.8398 80 80 0 0 1 10.02-5.4707 80 80 0 0 1 10.693-3.9883 80 80 0 0 1 22.539-3.2402 80 80 0 0 1 8.6055 0.47851 80 80 0 0 1 0.40626 0.0508 80 80 0 0 1 8.2441 1.3789 80 80 0 0 1 0.32812 0.0742 80 80 0 0 1 8.2812 2.3359 80 80 0 0 0-64.676-32.939m191.46 316.62c-8.9547-3.3531-18.438-5.0737-28-5.0801-10.833 0.0651-29.786 6.2106-39.718 11.265m-350.28-430.26a80 80 0 0 0-27.434 5.0664 80 80 0 0 1 0 0.0059 80 80 0 0 1-15.6 41.514 80 80 0 0 1-0.57617 0.79492 80 80 0 0 1-5.0957 5.9863 80 80 0 0 1-1.416 1.4707 80 80 0 0 1-5.4844 5.127 80 80 0 0 1-1.6582 1.2988 80 80 0 0 1-19.064 11.264 80 80 0 0 1-3.2383 1.4062 80 80 0 0 0-0.43359 6.0664 80 80 0 0 0 80 80 80 80 0 0 0 80-80 80 80 0 0 0-80-80m6 236a80 80 0 0 0-80 80 80 80 0 0 0 80 80 80 80 0 0 0 80-80 80 80 0 0 0-0.2832-6.457 80 80 0 0 1-23.588-50.529 80 80 0 0 0-56.129-23.014m73.994-156.26a80 80 0 0 1 0.00586 0.26172 80 80 0 0 1-80 80 80 80 0 0 1-39.994-10.92 80 80 0 0 0 79.994 79.92 80 80 0 0 0 80-80 80 80 0 0 0-40.006-69.262m205.66-41.738a80 80 0 0 0-79.443 72.225 80 80 0 0 1 20.326-2.7598 80 80 0 0 1 64.676 32.939 80 80 0 0 1 45.297 39.18 80 80 0 0 0 29.145-61.584 80 80 0 0 0-80-80m-143.98 134.65a80 80 0 0 0-27.184 4.9746 80 80 0 0 1-47.305 46.402 80 80 0 0 0-5.5117 28.623 80 80 0 0 0 80 80 80 80 0 0 0 75.115-53.234 80 80 0 0 1-16.197-16.678 80 80 0 0 1-54.055-75.273 80 80 0 0 1 1.5-14.539 80 80 0 0 0-6.3633-0.27539m-161.26 29.613a80 80 0 0 0-12.418 42.736 80 80 0 0 0 0.052734 0.80273 80 80 0 0 1 37.947-9.8027 80 80 0 0 1 56.062 22.957 80 80 0 0 1-0.38867-6.3066 80 80 0 0 1 5.5117-28.623 80 80 0 0 0 0.30078-0.13476 80 80 0 0 1-27.486 5.1074 80 80 0 0 1-59.582-26.736m236.36 77.143a80 80 0 0 1-75.104 53.244 80 80 0 0 1-1.752-0.125 80 80 0 0 0-1.9219 16.475 80 80 0 0 0 80 80 80 80 0 0 0 80-80 80 80 0 0 0-21.002-53.787 80 80 0 0 1-11.65 0.87305 80 80 0 0 1-48.57-16.68m-55.777-224.41a80 80 0 0 0-66.482 35.656 80 80 0 0 1 25.482 58.344 80 80 0 0 1-5.4004 28.592 80 80 0 0 1 27.074-4.9414 80 80 0 0 1 6.3633 0.27539 80 80 0 0 0-0.0449 0.30469 80 80 0 0 1 58.219-63.006 80 80 0 0 1 10.512-32.393 80 80 0 0 0-55.723-22.832m106-66a80 80 0 0 0-79.344 70.816 80 80 0 0 1 29.066 18.016 80 80 0 0 1 68.932-39.832 80 80 0 0 1 61.287 28.605 80 80 0 0 0-79.941-77.605m-201-29a80 80 0 0 0-69.191 40.209 80 80 0 0 1 3.1914-0.20898 80 80 0 0 1 79.994 79.738 80 80 0 0 1 14.52 10.922 80 80 0 0 1 49.357-33.598 80 80 0 0 0 2.1289-17.062 80 80 0 0 0-80-80m-148 355.26a80 80 0 0 1 8.0664 2.0215 80 80 0 0 1-0.066406-1.2793 80 80 0 0 1 16.098-48.035 80 80 0 0 0-0.0098-0.0137l3.5e-5 3e-5a80 80 0 0 1-24.088 8.666m0-157.36a80 80 0 0 1 13.67 3.918 80 80 0 0 0 0.11523-1.4141 80 80 0 0 1-4.1607-7.7092m276.63 315.95a80 80 0 0 1 0.70117-2.1816 80 80 0 0 1-43.27-22.15 80 80 0 0 0-43.535 24.332m-88.682 0a80 80 0 0 1-10.871-32.582 80 80 0 0 0-4.3164-1.8516 80 80 0 0 1-8.2812 0.43359 80 80 0 0 1-22.086-3.209 80 80 0 0 1 0.085938 1.209 80 80 0 0 1-8.7402 36m-42.805 0a80 80 0 0 0-14.455-6.6387m500-303.93c-4.9438-0.94808-9.9661-1.4274-15-1.4316-13.307 0.0391-26.394 3.3969-38.076 9.7695-2.6282 20.176-12.845 38.593-28.572 51.502 5.904 11.374 8.9893 24 8.9961 36.814-0.0577 10.345-2.1212 20.58-6.0762 30.139 10.733 14.174 25.881 24.369 43.053 28.975m35.676 40.232c-4.9438-0.94808-9.9661-1.4274-15-1.4316-38.854 3e-3 -72.087 27.923-78.793 66.193 18.046 11.202 28.228 24.755 34.506 46.168m58.966-149.02c-43.984 4.9051-67.705-17.093-78.372-31.213-10.638 26.272-34.384 44.954-62.422 49.109 13.488 14.666 21.017 33.837 21.115 53.762-0.0361 7.0455-1.0028 14.055-2.875 20.848 0.0825-0.2392 0.1639-0.47878 0.24414-0.71875 10.372 1.8262 20.282 5.6826 29.16 11.348 6.5622-38.264 39.649-66.293 78.471-66.477 5.0339 4e-3 10.056 0.48356 15 1.4316m-68.141-385.43a80 80 0 0 0-39.859 69 80 80 0 0 0 0.1875 2.9883 80 80 0 0 1 34.086 47.352 80 80 0 0 0-2.8477-9.5859 80 80 0 0 1 10.574-0.75391 80 80 0 0 1 65.936 34.74 80 80 0 0 0 0.06445-0.01757m-299.85-143.72a80 80 0 0 0-19.184 37.133 80 80 0 0 1 47.033 72.867 80 80 0 0 1-2.0859 16.826 80 80 0 0 0 0.41406 0.1543 80 80 0 0 1 16.672-1.9805 80 80 0 0 1 28.967 5.8242 80 80 0 0 0-2.3106-1.0078 80 80 0 0 1 38.02-58.771 80 80 0 0 0-2.8047 1.6035 80 80 0 0 1-20.871-53.648 80 80 0 0 1 2.4707-19m-271.42 0a80 80 0 0 1 39.945 69 80 80 0 0 1-0.39258 6.0547 80 80 0 0 1 24.26-4.9395 80 80 0 0 1 65.26-39.867 80 80 0 0 1-32.658-30.248m-54.328 0a80 80 0 0 1-16.955 22.664 80 80 0 0 0-24.881-22.664" />
      </pattern>

      <pattern id="vzb-pattern-billy-bridgeshape-1${this.parent.id}" style="stroke: white; fill: transparent; stroke-width:10px;" x="0" y="0" patternUnits="userSpaceOnUse" width="25" height="25" viewBox="0 0 500 500"> 
          <circle cx="65" cy="39" r="80" />
          <circle cx="180" cy="-41" r="80" />
          <circle cx="259" cy="54" r="80" />
          <circle cx="364" cy="19" r="80" />
          <circle cx="472" cy="69" r="80" />
          <circle cx="434" cy="189" r="80" />
          <circle cx="427" cy="378" r="80" />
          <circle cx="485" cy="464" r="80" />
          <circle cx="485" cy="268" r="80" />
          <circle cx="65" cy="539" r="80" />
          <circle cx="180" cy="459" r="80" />
          <circle cx="259" cy="554" r="80" />
          <circle cx="364" cy="518" r="80" />
          <circle cx="-66" cy="189" r="80" />
          <circle cx="-45" cy="378" r="80" />
          <circle cx="-14" cy="464" r="80" />
          <circle cx="-14" cy="268" r="80" />
          <circle cx="148" cy="110" r="80" />
          <circle cx="349" cy="139" r="80" />
          <circle cx="243" cy="205" r="80" />
          <circle cx="300" cy="419" r="80" />
          <circle cx="345" cy="291" r="80" />
          <circle cx="130" cy="315" r="80" />
          <circle cx="247" cy="335" r="80" />
          <circle cx="85" cy="129" r="80" />
          <circle cx="122" cy="219" r="80" />
          <circle cx="88" cy="386" r="80" />
          <circle cx="82" cy="150" r="80" />
          <circle cx="-14" cy="464" r="80" />
          <circle cx="-14" cy="-36" r="80" />
          <circle cx="472" cy="569" r="80" />
          <circle cx="-25" cy="69" r="80" />
          <circle cx="-26" cy="569" r="80" />
          <circle cx="30" cy="300" r="80" />
          <circle cx="530" cy="300" r="80" />
        </pattern>
    `);


      this.DOM.defs.append("marker")
        .attr("id", "triangle")
        .attr("viewBox", "0 0 15 10")
        .attr("refX", "15")
        .attr("refY", "5")
        .attr("markerUnits", "strokeWidth")
        .attr("markerWidth", "15")
        .attr("markerHeight", "10")
        .attr("orient", "-45deg")
        .html(`<path d="M 0 0 L 15 5 L 0 10 z" fill="grey" stroke="grey"/>`);      

      this.billyMarkerName = options.ultrarichMarkerName;
      this.billyEncName = options.ultrarichEncName;
      this.drilldowns = null;
      this.drilldownsReady = false;
      this.wholeWorld = false;
      this.relevantBilly = new Map();
      this.relevantBillyReady = false;
      this.colorMap = {};
      this.colorMapReady = false;
      this.imagesAvaiable = {};
      this.imagesReady = false;

      
      const start = this.parent.ui.xStart;
      const end = this.parent.ui.xEnd;
      const nbrackets = this.parent.ui.xPoints;
      const step = Math.pow(end/start, 1/nbrackets);
      this.mesh = d3.range(this.parent.ui.billyMeshXPoints).map(m => [start * Math.pow(step, m), start * Math.pow(step, m + 0.5), start * Math.pow(step, m + 1) ]);
      this.bins = this.mesh.map(() => 0);

      this._initInfoElements();
    }

    _initInfoElements() {
      const _this = this;

      this._dataNotes = this.root.findChild({name: "datanotes"});
      sharedComponents.LegacyUtils.setIcon(this.DOM.info, ICON_QUESTION$1)
        .on("click", () => {
          this._dataNotes.pin();
        })
        .on("mouseover", function() {
          const rect = this.getBBox();
          const coord = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
          const toolRect = _this.root.element.node().getBoundingClientRect();
          const chartRect = _this.parent.element.node().getBoundingClientRect();
          _this._dataNotes
            .setEncoding(_this.MDL.billyX)
            .show()
            .setPos(coord.x + chartRect.left - toolRect.left, coord.y + chartRect.top - toolRect.top) ;
        })
        .on("mouseout", () => {
          this._dataNotes.hide();
        })      
        .select("svg").attr("width", "0px").attr("height", "0px");
    }


    get MDL() {
      return {
        frame: this.model.encoding.frame,
        color: this.model.encoding.color,
        billyMarker: this.root.model.markers[this.billyMarkerName],
        billyX: this.root.model.markers[this.billyMarkerName].encoding.x,
        billyFrame: this.root.model.markers[this.billyMarkerName].encoding.frame,
        billySlices: this.root.model.markers[this.billyMarkerName].encoding[this.billyEncName],
        billySelectedF: this.root.model.markers[this.billyMarkerName].encoding.selected.data.filter,
        billyHighlightedF: this.root.model.markers[this.billyMarkerName].encoding.highlighted.data.filter
      };
    }

    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);
      this.addReaction(this.updateSign);
      if(!this.parent.ui.showBilly || !this.MDL.billyX.data.concept) return;
      this.addReaction(this.copyframevalue);
      this.addReaction(this.getDrillDowns);
      this.addReaction(this.getRelevantBillies);
      this.addReaction(this.getColorMapping);
      this.addReaction(this.getBillyImages);
      this.addReaction(this.updateSelected);
      this.addReaction(this.redraw);
      this.addReaction(this.updateOpacity);

      this.addReaction(this.disableReactions);
    }

    disableReactions(){
      this.DOM.deselectClickRect.classed("vzb-hidden", !this.parent.ui.showBilly);
      if(this.parent.ui.showBilly) return;
      this.removeReaction(this.copyframevalue);
      this.removeReaction(this.getDrillDowns);
      this.removeReaction(this.getRelevantBillies);
      this.removeReaction(this.getColorMapping);
      this.removeReaction(this.getBillyImages);
      this.removeReaction(this.updateSelected);
      this.removeReaction(this.redraw);
      this.removeReaction(this.updateOpacity);
      this.DOM.circlebox.selectAll("circle").remove();
      this.DOM.zoombox.classed("vzb-hidden", true);
      this.DOM.text.classed("vzb-hidden", true);
      this.DOM.bridgeShape.classed("vzb-hidden", true);
      this.DOM.bridgeShapeBlur.classed("vzb-hidden", true);
    }

    copyframevalue() {
      this.MDL.billyFrame.config.value = this.localise(this.MDL.frame.value);
    }

    updateSign(){
      this.services.layout.size; //watch
      this.parent.ui.inpercent;
      this.parent.ui.showBilly;
      let scale, shift;
      if(this.services.layout.profile == "LARGE") {scale = 1.3; shift = 500; } 
      if(this.services.layout.profile == "MEDIUM") {scale = 1.3; shift = 500; }
      if(this.services.layout.profile == "SMALL") {scale = 1.0; shift = 450; }
      this.DOM.sign.attr("transform", `translate(${this.parent.xScale(shift)}, ${this.parent.yScale(0)}) scale(${scale})`)
        .on("click", () => { 
          this.root.ui.chart.showBilly = !this.root.ui.chart.showBilly; 
        });

      this.DOM.sign
        .select("#arrow").attr("transform", `rotate(${this.parent.ui.showBilly? 180: 0}) translate(${this.parent.ui.showBilly? "-34 -525": "0 -10"})`);
      this.DOM.sign
        .select("#text")
        .attr("transform", this.parent.ui.showBilly ? "translate(-125 200)" : "translate(-170 200)")
        .select("div")
        .style("text-align", this.parent.ui.showBilly ? "left" : "right")
        .html(this.parent.ui.showBilly ? "hide<br/>billionaires" : "show<br/>billionaires");

      this.DOM.arrow.attr("transform", `translate(${this.parent.xScale.range()[1]}, ${this.parent.yScale(0)})`)
        .on("click", () => { 
          this.root.ui.chart.showBilly = !this.root.ui.chart.showBilly; 
        });

      this.DOM.arrow
        .select("svg")
        .attr("width", this.parent.profileConstants.infoElHeight)
        .attr("height", this.parent.profileConstants.infoElHeight);
      this.DOM.arrow
        .select("g").attr("transform", `rotate(${this.parent.ui.showBilly? 180: 0}) translate(${this.parent.ui.showBilly? "-500 -500": "0 0"})`);


      
    }

    getHardcodedWholeWorldShortcuts(){
      const dim = this.principalDimension;
      const filter = this.model.data.filter.config.dimensions[dim] || false;
      const notFacet = this.model.encoding.facet_row.data.constant === "none";

      return filter["un_state"] && notFacet
        //showing world as one shape
        || filter["is--global"] && notFacet
        //showing world in facet
        || (!notFacet && this.parent.atomicSliceData.length == 1 && this.parent.atomicSliceData[0].facet_row[0] == "is--global");
    }

    getDrillDowns() {
      const dim = this.principalDimension;
      const entity = this.parent.atomicSliceData.map(m => m[dim]);
      
      //prevent recalcualaion if list of entities didn't change
      if(this.drilldownsReady == entity.join("")) return;

      this.drilldownsReady = false;
      const drilldownPromise = this.model.data.source.drilldown({dim, entity})
        .then( catalog => {
          if (catalog) {
            const drilldownEntitySet = Object.keys(catalog)[0]; //"country"
            this.drilldowns = catalog[drilldownEntitySet];
          }
        });

      this.wholeWorld = this.getHardcodedWholeWorldShortcuts();
      const isFullEntitySetPromise = this.wholeWorld ? Promise.resolve()
        : this.model.data.isFullEntitySet(dim, entity)
          .then(fullset => {
            this.wholeWorld = fullset;
          });

      Promise.all([drilldownPromise, isFullEntitySetPromise]).then(() => {
        this.drilldownsReady = entity.join("");
      });
    }

    getRelevantBillies() {
      if(this.MDL.billyMarker.state !== sharedComponents.Utils.STATUS.READY || !this.drilldownsReady) return;

      this.relevantBillyReady = false;
      const allBilly = this.MDL.billySlices.data.domainData;
      const billySliceConcept = this.MDL.billySlices.data.concept;
      this.relevantBilly = new Map();
      for(let [, billy] of allBilly) {
        const intersection = d3.intersection(this.drilldowns, billy[billySliceConcept]?.split(";"));
        if(intersection.size){
          const [firstEntity] = intersection;
          this.relevantBilly.set(billy.person, firstEntity);
        } else {
          this.relevantBilly.delete(billy.person);
        }
      }
      this.relevantBillyReady = true;
    }

    getColorMapping(){
      const dim = this.principalDimension;

      this.colorMapReady = false;
      this.model.data.source.drillupCatalog.then(catalog => {
        const drilldownEntitySet = Object.keys(catalog[dim])[0]; //"country"
        const entities = catalog[dim][drilldownEntitySet].get(Symbol.for("drill_up"));
        for(let [key, entity] of entities) {
          this.colorMap[key] = entity[this.MDL.color.data.concept];
        }
        this.colorMapReady = true;
      });
    }

    getBillyImages(){
      if(this.MDL.billyMarker.state !== sharedComponents.Utils.STATUS.READY || !this.drilldownsReady || !this.relevantBillyReady) return;

      if (!this.isShowFaces) return this.imagesReady = true;
      
      this.imagesReady = false;
      const promises = [];
      for (let billy of this._getBillyData()){
        const promise = this.fetchOneImage(billy.person);
        if (!promise) continue;
        promises.push(promise);
      }
      Promise.all(promises).then(() => {
        this.imagesReady = true;
      });
    }

    fetchOneImage(person){
      //this prevents checking and loading the images again for those who have been checked already
      if(this.imagesAvaiable[person] || this.imagesAvaiable[person] === false) return false;

      const reader = this.MDL.billyMarker.data.source.reader;      
      return reader.checkIfAssetExists(person + ".png")
        .then(response => {
          this.imagesAvaiable[person] = response.status === 200 && response.url;

          if(this.imagesAvaiable[person]){
            this.DOM.defs.append("pattern")
              .attr("id", `vzb-billy-image-${person}-${this.id}`)
              .attr("x", "0%")
              .attr("y", "0%")
              .attr("height", "100%")
              .attr("width", "100%")
              .attr("viewBox", "0 0 100 100")
              .html(`<image x="0%" y="0%" width="100" height="100" xlink:href="${response.url}"></image>`);

            return true;
          }
        })
        .catch(() => {
          throw ("Billy: error when fetching a portrait for: " + person);
        });
    }

    isOutsideOfTimeRange(){
      return this.MDL.billyFrame.scale.domain[0] - this.MDL.frame.value > 0 || this.MDL.frame.value - this.MDL.billyFrame.scale.domain[1] > 0;
    }

    _getBillyData() {     
      const getSortValue = (d) => {
        const color = this.colorMap[this.relevantBilly.get(d.person)];
        return this.parent.sortValuesForGroups[color] || this.parent.stickySortValues[color] || 0;
      };

      const processOneBilly = (d) => {
        d.color = this.colorMap[this.relevantBilly.get(d.person)];

        const isOutOfBounds = (i) => (i === this.mesh.length - 1) && (d.x > d3.max(this.mesh, m => m[2]));

        for (let i=0; i<this.mesh.length; i++){
          if (this.mesh[i][0] < d.x && d.x <= this.mesh[i][2] || isOutOfBounds(i)) {
            d.binNumber = i;
            d.binnedX = this.mesh[i][1];
            d.yInBin = this.bins[i];
            this.bins[i]++;
            if (!this.binsByColor[d.color]) this.binsByColor[d.color] = this.mesh.map(() => 0);
            d.yInBinByColor = this.binsByColor[d.color][i];
            this.binsByColor[d.color][i]++;
          }
        } 
        return d;
      };

      this.bins = this.mesh.map(() => 0);
      this.binsByColor = {};
      if (this.isOutsideOfTimeRange())
        return [];
      else
        return d3.shuffle(
          //shuffle for more pleasant distribution within stacked bars
          this.MDL.billyMarker.dataArray
            .filter(f => this.wholeWorld || this.relevantBilly.has(f.person))
            .slice(0, this.parent.ui.howManyBilly)
        )
          //sort billy to follow the colors of stacked mountains
          .sort((a,b) => getSortValue(a) - getSortValue(b))
          .map(processOneBilly);
    }



    get principalDimension() {
      const frameConcept = this.MDL.frame.data.concept;
      return this.model.data.space.filter(f => f !== frameConcept)[0];
    }

    get isShowFaces() {
      return this.parent.ui.howManyBilly < 11 && this.parent.ui.billyFaces;
    }

    redraw() {
      this.services.layout.size; //watch
      this.parent.ui.inpercent;
      this.imagesReady;
      
      if(this.MDL.billyMarker.state !== sharedComponents.Utils.STATUS.READY || !this.drilldownsReady || !this.relevantBillyReady || !this.colorMapReady) return;

      const data = this._getBillyData();

      const params = this.computeLayout(data);
      const zoomboxParams = this.redrawZoombox(params);
      this.redrawDeselectClickRect(params, zoomboxParams);
      Object.assign(params, zoomboxParams);
      this.redrawBridgeShape(params);
      this.redrawCircles(data, params);
      this.redrawText(this.isOutsideOfTimeRange());
      this.updateBoxTopText(null, params);
      
    }



    computeLayout(data) {
      const DOT_R = 4;

      const h = 10;
      const gap = 20;
      const topMargin = this.parent.state.positionInFacet.row.first ? 50 : 10;
      const H = this.parent.yScale.range()[0] - h - gap - topMargin;

      let DOT_STEP = H * this.parent.ui.billyYScale / (d3.max(this.bins)||100);
      if (DOT_STEP > DOT_R * 2) DOT_STEP = DOT_R * 2;
      const PACK_HARDER = DOT_STEP < 4;
     
      const showZoombox = (DOT_STEP < 8 || d3.max(this.bins) > 7) && data.length > 0;

      return {showZoombox, DOT_STEP, DOT_R, PACK_HARDER, h, gap, H};
    }



    redrawZoombox({showZoombox, h, gap, H}) {
      const appearing = this.DOM.upperbox.classed("vzb-hidden") && showZoombox;

      this.DOM.zoombox.classed("vzb-hidden", !showZoombox);

      if (!showZoombox) return;

      const xmin = 4000; //this.mesh[this.bins.findIndex(f => f > 0)][0];
      const xmax = 20e7; //this.mesh.concat().reverse()[this.bins.concat().reverse().findIndex(f => f > 0) - 1][1];
      const W = this.parent.xScale(xmax) - this.parent.xScale(xmin);

      
      const X = this.parent.xScale(xmin);
      const Y = this.parent.yScale.range()[0] - gap - h - H;
      const y = this.parent.yScale.range()[0] - h;
      
      const upperboxT = this.parent.duration && !appearing
        ? this.DOM.upperbox.transition().duration(this.parent.duration).ease(d3.easeLinear) 
        : this.DOM.upperbox.interrupt();

      const lowerboxT = this.parent.duration && !appearing
        ? this.DOM.lowerbox.transition().duration(this.parent.duration).ease(d3.easeLinear) 
        : this.DOM.lowerbox.interrupt();

      const arcT = this.parent.duration && !appearing
        ? this.DOM.arc.transition().duration(this.parent.duration).ease(d3.easeLinear) 
        : this.DOM.arc.interrupt();      

      upperboxT.attr("x", X).attr("y", Y).attr("width", W).attr("height", H);
      lowerboxT.attr("x", X).attr("y", y).attr("width", W).attr("height", h);
      arcT.attr("d", `M ${X} ${y + h / 2} A ${h} ${2 * h}, 0, 0 1, ${X} ${y - 5 * h}`);

      const infoElHeight = this.parent.profileConstants.infoElHeight;
      this.DOM.info
        .classed("vzb-hidden", false)
        .attr("transform", `translate(${ X + W - infoElHeight * 1.5 }, ${ Y + infoElHeight * 0.5 })`)
        .select("svg")
        .attr("width", infoElHeight + "px")
        .attr("height", infoElHeight + "px");


      return ({xmin, xmax, W,X,Y,y});      
    }

    redrawDeselectClickRect({showZoombox, H}, params = {}) {
      const X = showZoombox ? params.X : this.parent.xScale(1000);
      const W = showZoombox ? params.W : (this.parent.xScale(this.parent.xScale.domain()[1]) - X);
      const Y = showZoombox ? params.Y :  this.parent.yScale.range()[0] - H;
      this.DOM.deselectClickRect.attr("x", X).attr("y", Y).attr("width", W).attr("height", H);
    }

    redrawBridgeShape({showZoombox, DOT_STEP, DOT_R, X,Y,W,H,h, xmax,xmin, gap}) {
      const _this = this;
      this.DOM.bridgeShape.classed("vzb-hidden", !showZoombox);
      this.DOM.bridgeShapeBlur.classed("vzb-hidden", !showZoombox);

      if (!showZoombox) return;

      // define path generator
      const xScale = this.parent.xScale;
      const height = this.parent.yScale(0);
      const range0 = height - h - gap;
      this.yBridgeShapeScale = d3.scaleLinear().domain([0, d3.max(this.bins)]).range([range0, range0 - d3.max(this.bins) * DOT_STEP - DOT_R * 2]);
      const area = d3.area()
        .curve(d3.curveBasis)
        .x(d => xScale(d.x))
        .y0(d => this.yBridgeShapeScale(d.y0 ))
        .y1(d => this.yBridgeShapeScale((d.y + d.y0) ));
        
      this.bridgeShapes = [];
      let stackBins = this.mesh.map(() => 0);
      Object.keys(this.binsByColor).forEach((color)=> {
        const bins = this.binsByColor[color];
        const shape = this.mesh.map((m,i) => ({x: m[1], y0: stackBins[i], y: bins[i]}));
        const startIndex = bins.indexOf(d3.max(bins));
        for(let i=startIndex; i>0; i--)  shape[i-1].y = shape[i].y * 1.1;
        stackBins = stackBins.map((m,i) => m + shape[i].y);
        this.bridgeShapes.push({color,shape});
      });
      //.filter(f => 1000 < f.x && f.x < 100e6);

      const getColor = (d) => this.parent.MDL.color.scale.d3Scale(d.color);

      this.DOM.defs.selectAll("mask rect")
        .attr("x", X).attr("y", Y).attr("width", W).attr("height", H);

      this.DOM.bridgeShapeBlur.selectAll("path")
        .data(this.bridgeShapes, d => d.color)
        .join("path")
        .attr("d", d => area(d.shape.filter(f => xmin < f.x && f.x < xmax)))
        .style("fill", d => getColor(d) || "#ccc")
        .on("mousemove", function(event, d){
          _this.updateUnknownHint(event, d, {showZoombox, X,Y,W,H});
        })
        .on("mouseout", function(){
          _this.updateUnknownHint(null, null, {showZoombox, X,Y,W,H});
        })
        .attr("mask", `url(#clipMask-${this.parent.id})`)
        .style("opacity", this.parent.ui.opacityRegular); //opacitySelectDim

      this.DOM.bridgeShape.selectAll("path")
        .data(this.bridgeShapes, d => d.color)
        .join("path")
        .style("pointer-events", "none")
        .attr("d", d => area(d.shape.filter(f => xmin < f.x && f.x < xmax)))
        .style("fill", `url(#vzb-pattern-billy-bridgeshape-${this.parent.id})`)
        .attr("mask", `url(#progFadeMask-${this.parent.id})`)
        .style("opacity", 1);  
    }


    redrawCircles(data, {showZoombox, DOT_STEP, DOT_R}) {
      const _this = this;
      const FACE_R = 10;

      const billyIncomeFormatter = this.services.locale.longNumberF;

      const getColor = (d) => this.parent.MDL.color.scale.d3Scale(this.colorMap[this.relevantBilly.get(d.person)]);
      const hasFace = (d) => this.isShowFaces && this.DOM.defs.select(`#vzb-billy-image-${d.person}-${this.id}`).node();
      const getTooltip = (d) => (d.name || d.person).split(";")[0] + ": " + billyIncomeFormatter(d.x) + " $/day";

      const bridgeShapeByColor = {};
      if(showZoombox){
        this.bridgeShapes.forEach(d => {bridgeShapeByColor[d.color] = d.shape;});
      }

      const shiftAllCircles = (showZoombox? -30 : 0) + _this.parent.yScale(0) - 1 - (_this.isShowFaces ? FACE_R : DOT_R);

      const getY = (d) => {
        if (!showZoombox) return shiftAllCircles - d.yInBinByColor * (_this.isShowFaces ? FACE_R * 2 : DOT_STEP);
        const bin = bridgeShapeByColor[d.color];
        return shiftAllCircles
          - bin[d.binNumber].y0 * DOT_STEP
          - bin[d.binNumber].y * DOT_STEP * d.yInBinByColor / this.binsByColor[d.color][d.binNumber];
      };

      const needShuffle = !this.DOM.circlebox.selectAll("circle").size() && data.length;

      const circles = this.DOM.circlebox.selectAll("circle")
        .data(needShuffle ? d3.shuffle(data) : data, d => d.person);

      circles.exit().remove();
      this.DOM.circles = circles.enter().append("circle")
        .style("opacity", d => this._getOpacity(d))
        .on("mouseenter", function(event, d){
          _this.parent._setTooltip(event, getTooltip(d));

          const face = _this.DOM.defs.select(`#vzb-billy-image-${d.person}-${_this.id}`).node();
          if (face) 
            _this.highlightFace(event, d);
          else {
            const promise = _this.fetchOneImage(d.person);
            if(promise) promise.then((success) => {
              if(success) _this.highlightFace(event, d);
            });

          }
          _this.MDL.billyHighlightedF.set(d);
        })
        .on("mouseout", function(event, d) {
          _this.parent._setTooltip();
          _this.highlightFace();
          _this.MDL.billyHighlightedF.delete(d);
        })
        .on("click", function(event, d) {
          _this.MDL.billySelectedF.toggle(d);
        })
        .onTap(function(event, d) {
          _this.MDL.billySelectedF.toggle(d);
          event.stopPropagation();
        })
        .merge(circles)
        .style("stroke-width", d => hasFace(d) ? 2 : 0.25 )
        .style("stroke", d => hasFace(d) ? getColor(d) : "black")
        .attr("r", d => hasFace(d) ? FACE_R : DOT_R)
        .style("fill", d => hasFace(d) ? `url(#vzb-billy-image-${d.person}-${this.id})` : getColor(d) )
        .each(function(){
          const view = d3.select(this);

          const transition = _this.parent.duration && view.attr("cy")
            ? view.transition().duration(_this.parent.duration).ease(d3.easeLinear) 
            : view.interrupt();

          transition
            .attr("cy", d => getY(d))
            .attr("cx", d => _this.parent.xScale(d.x));
        });

      return;
    }

    highlightFace(event, d){

      this.DOM.hlLine.classed("vzb-hidden", !d);
      this.DOM.hlFace.classed("vzb-hidden", !d);
      if(!d) return;

      const target = d3.select(event.target);
      const cy = +target.attr("cy");
      const cx = +target.attr("cx");
      const r = +target.attr("r");
      const stroke = target.style("stroke");

      const position = cy > 150 ? "top" : "right";

      this.DOM.hlLine
        .attr("x1", cx)
        .attr("y1", cy)
        .attr("x2", position === "top" ? cx : this.parent.xScale.range()[1] - 50)
        .attr("y2", position === "top" ? cy - 100 : 50)
        .style("stroke", stroke);

      const length = this.DOM.hlLine.node().getTotalLength();
      this.DOM.hlLine.style("stroke-dasharray", `0 ${r} ${length - 50 - r} ${50}`);

      this.DOM.hlFace
        .attr("r", 50)
        .attr("cx", position === "top" ? cx : this.parent.xScale.range()[1] - 50)
        .attr("cy", position === "top" ? cy - 100 : 50)
        .style("stroke", stroke)
        .style("fill", `url(#vzb-billy-image-${d.person}-${this.id})` );
        
    }

    updateUnknownHint(event, d, params){
      const roundN = (x,n) => Math.ceil(x/n)*n;
      
      if(!event) {
        this.parent._setTooltip();
        this.DOM.unknownCircle.classed("vzb-hidden", true);
        this.updateBoxTopText(null, params);
        return;
      }
      
      const mouse = d3.pointer(event);
      
      const minIndex = this.bins.findIndex(f => f>0);
      const minPx = this.parent.xScale(this.mesh[minIndex][0]);
      
      if(mouse[1] < params.Y || mouse[0] > minPx) {
        this.updateUnknownHint(null, null, params); 
        return;
      }

      this.parent._setTooltip(event, "Unknown rich person");
      this.DOM.unknownCircle
        .classed("vzb-hidden", false)
        .style("stroke-width", 0.5 )
        .style("stroke", "black")
        .style("pointer-events", "none")
        .style("fill", d3.select(event.target).style("fill"))
        .attr("cx", roundN(mouse[0] - 4, 5))
        .attr("cy", roundN(mouse[1] - 4, 5))
        .attr("r", 4);
        
      this.updateBoxTopText("Why many unknown? →", params);
    }


    updateBoxTopText(text, {showZoombox, X,Y,W}={}){
      const infoElHeight = this.parent.profileConstants.infoElHeight;
      this.DOM.boxTopText.classed("vzb-hidden", !showZoombox);

      if(!showZoombox) return;

      this.DOM.boxTopText
        .text(text || d3.format(".2r")(d3.sum(this.bins)) + " richest people")
        .style("text-anchor", text ? "end" : "start")
        .attr("x", text ?  X + W - infoElHeight * 2 : X + infoElHeight )
        .attr("y", Y + infoElHeight)
        .attr("dy", "0.3em");
    }



    redrawText(show){
      this.DOM.text
        .classed("vzb-hidden", !show)
        .attr("transform", `translate(${this.parent.xScale.range()[1] - 100}, ${this.parent.yScale.range()[0]}) `)
        .select("text")
        .attr("y", "-3.5em")
        .html(`
        <tspan x="0" dy=".6em">Billionaire data is</tspan>
        <tspan x="0" dy="1.2em">available between</tspan>
        <tspan x="0" dy="1.2em">${this.localise(this.MDL.billyFrame.scale.domain[0])} and ${this.localise(this.MDL.billyFrame.scale.domain[1])}</tspan>
        `);
    }

    updateSelected() {
      this.MDL.billySelectedF.markers; //watch
      this.someSelected = this.MDL.billySelectedF.any();

      this.nonSelectedOpacityZero = false;
    }

    _getOpacity(d) {
      const OPACITY_SELECT = this.ui.opacitySelect ?? 1.0;
      const OPACITY_REGULAR = this.ui.opacityRegular ?? 1.0;
      const OPACITY_SELECT_DIM = this.ui.opacitySelectDim ?? 0.3;

      if (this.someSelected) {
        //selected or non-selected
        return this.MDL.billySelectedF.has(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
      }
      return OPACITY_REGULAR;
    }

    updateOpacity() {
      if(this.MDL.billyMarker.state !== sharedComponents.Utils.STATUS.READY || !this.drilldownsReady || !this.relevantBillyReady || !this.colorMapReady) return;

      this.MDL.billySelectedF.markers; //watch
      this.MDL.billyHighlightedF.markers; //watch

      const OPACITY_HIGHLT = this.ui.opacityHighlight ?? 1.0;
      const OPACITY_HIGHLT_DIM = this.ui.opacityHighlightDim ?? 0.3;
      const OPACITY_SELECT = this.ui.opacitySelect ?? 1.0;
      const OPACITY_REGULAR = this.ui.opacityRegular ?? 1.0;
      const OPACITY_SELECT_DIM = this.ui.opacitySelectDim ?? 0.3;

      this.someHighlighted = this.MDL.billyHighlightedF.any();
      this.someSelected = this.MDL.billySelectedF.any();

      this.DOM.circles.style("opacity", d => {

        if (this.someHighlighted) {
          //highlight or non-highlight
          if (this.MDL.billyHighlightedF.has(d)) return OPACITY_HIGHLT;
        }

        if (this.someSelected) {
          //selected or non-selected
          return this.MDL.billySelectedF.has(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
        }

        if (this.someHighlighted) return OPACITY_HIGHLT_DIM;

        return OPACITY_REGULAR;
      });

      const nonSelectedOpacityZero = this.ui.opacitySelectDim < 0.01;

      // when pointer events need update...
      if (nonSelectedOpacityZero !== this.nonSelectedOpacityZero) {
        this.DOM.circles.style("pointer-events", d => {
          if (!this.someSelected || !nonSelectedOpacityZero || this.MDL.billySelectedF.has(d)) 
            return "visible";
          else
            return "none";
        });
      }

      this.nonSelectedOpacityZero = nonSelectedOpacityZero;
    }
  }

  const decorated$6 = mobx.decorate(MCUltraRich, {
    "MDL": mobx.computed,
    "drilldownsReady": mobx.observable,
    "relevantBillyReady": mobx.observable,
    "billyReady": mobx.observable,
    "colorMapReady": mobx.observable,
    "imagesReady": mobx.observable,
    "isShowFaces": mobx.computed,
    "principalDimension": mobx.computed,
  });

  const AUTH_TOKEN = "";
  const ENDPOINT = "https://api.dollarstreet.org/v1/";



  const COUNTRY_MAPPING = {
    abw: "aw", afg: "af", ago: "ao", aia: "ai", ala: "ax", alb: "al", and: "ad", are: "ae", arg: "ar", arm: "am", asm: "as", ata: "aq", 
    atg: "ag", aus: "au", aut: "at", aze: "az", bdi: "bi", bel: "be", ben: "bj", bfa: "bf", bgd: "bd", bgr: "bg", bhr: "bh", bhs: "bs", 
    bih: "ba", blr: "by", blz: "bz", bmu: "bm", bol: "bo", bouisl: "bv", bra: "br", brb: "bb", brn: "bn", btn: "bt", bwa: "bw", caf: "cf", 
    can: "ca", cck: "cc", che: "ch", chl: "cl", chn: "cn", civ: "ci", cmr: "cm", cod: "cd", cog: "cg", cok: "ck", col: "co", com: "km", 
    cpv: "cv", cri: "cr", cub: "cu", cxr: "cx", cym: "ky", cyp: "cy", cze: "cz", deu: "de", dji: "dj", dma: "dm", dnk: "dk", dom: "do", 
    dza: "dz", ecu: "ec", egy: "eg", eri: "er", esh: "eh", esp: "es", est: "ee", eth: "et", fin: "fi", fji: "fj", flk: "fk", fra: "fr", 
    fra_clipperton: "cp", fro: "fo", fsm: "fm", gab: "ga", gbg: "gg", gbm: "im", gbr: "gb", geo: "ge", gha: "gh", gib: "gi", gin: "gn", 
    glp: "gp", gmb: "gm", gnb: "gw", gnq: "gq", grc: "gr", grd: "gd", grl: "gl", gtm: "gt", guf: "gf", gum: "gu", guy: "gy", heard_a_mcd: "hm", 
    hkg: "hk", hnd: "hn", hos: "va", hrv: "hr", hti: "ht", hun: "hu", idn: "id", ind: "in", iot: "io", irl: "ie", irn: "ir", irq: "iq", 
    isl: "is", isr: "il", ita: "it", jam: "jm", jey: "je", jor: "jo", jpn: "jp", kaz: "kz", ken: "ke", kgz: "kg", khm: "kh", kir: "ki", 
    kna: "kn", kor: "kr", kos: "xk", kwt: "kw", lao: "la", lbn: "lb", lbr: "lr", lby: "ly", lca: "lc", lie: "li", lka: "lk", lso: "ls", 
    ltu: "lt", lux: "lu", lva: "lv", mac: "mo", maf: "mf", mar: "ma", mco: "mc", mda: "md", mdg: "mg", mdv: "mv", mex: "mx", mhl: "mh", 
    mkd: "mk", mli: "ml", mlt: "mt", mmr: "mm", mne: "me", mng: "mn", mnp: "mp", moz: "mz", mrt: "mr", msr: "ms", mtq: "mq", mus: "mu", 
    mwi: "mw", mys: "my", myt: "yt", nam: "na", ncl: "nc", ner: "ne", nfk: "nf", nga: "ng", nic: "ni", niu: "nu", nld: "nl", nld_curacao: "cw", 
    nor: "no", npl: "np", nru: "nr", nzl: "nz", omn: "om", pak: "pk", pan: "pa", pcn: "pn", per: "pe", phl: "ph", plw: "pw", png: "pg", 
    pol: "pl", pri: "pr", prk: "kp", prt: "pt", pry: "py", pse: "ps", pyf: "pf", qat: "qa", reu: "re", rou: "ro", rus: "ru", rwa: "rw", 
    sau: "sa", sdn: "sd", sen: "sn", sgero_a_ssandw: "gs", sgp: "sg", shn: "sh", sjm: "sj", slb: "sb", sle: "sl", slv: "sv", smr: "sm", 
    som: "so", spm: "pm", srb: "rs", ssd: "ss", stbar: "bl", stp: "st", sur: "sr", svk: "sk", svn: "si", swe: "se", swz: "sz", sxm: "sx", 
    syc: "sc", syr: "sy", tca: "tc", tcd: "td", tgo: "tg", tha: "th", tjk: "tj", tkl: "tk", tkm: "tm", tls: "tl", ton: "to", tto: "tt", 
    tun: "tn", tur: "tr", tuv: "tv", twn: "tw", tza: "tz", uga: "ug", ukr: "ua", ury: "uy", usa: "us", usa_minor_out_isl: "um", uzb: "uz", 
    vct: "vc", ven: "ve", vgb: "vg", vir: "vi", vnm: "vn", vut: "vu", wlf: "wf", wsm: "ws", yem: "ye", zaf: "za", zmb: "zm", zwe: "zw"
  };

  const country3to2 = d3.scaleOrdinal().domain(Object.keys(COUNTRY_MAPPING)).range(Object.values(COUNTRY_MAPPING)).unknown([null]) ;
  const country2to3 = d3.scaleOrdinal().domain(Object.values(COUNTRY_MAPPING)).range(Object.keys(COUNTRY_MAPPING)).unknown([null]) ;

  class MCDollarStreet extends sharedComponents.BaseComponent {
    
    constructor(config) {
      config.template = `
        <defs>
          <pattern class="vzb-noexport" id="vzb-mc-ds-pattern-lines-loading-${config.id}" x="0" y="0" patternUnits="userSpaceOnUse" width="50" height="50" viewBox="0 0 10 10"> 
            <path d='M-1,1 l2,-2M0,10 l10,-10M9,11 l2,-2' stroke='black' stroke-width='3' opacity='0.08'/>
          </pattern> 
        </defs>
      `;
    
      super(config);
    }
    
    setup() {
      this.DOM = {
        container: this.element,
        pattern: this.element.select("defs").select("pattern")
      };
    
      this.families = [];
      this.familiesReady = false;

      this.drilldowns = null;
      this.drilldownsReady = false;
      this.wholeWorld = false;

      this.colorMap = {};
      this.nameMap = {};
      this.colorMapReady = false;
      this.nameMapReady = false;
        
    }
    
    
    get MDL() {
      return {
        frame: this.model.encoding.frame,
        color: this.model.encoding.color,
        label: this.model.encoding.label,
      };
    }
    
    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);
      if(!this.parent.ui.dsShow) return;
      this.addReaction(this.getFamilies);
      this.addReaction(this.getDrillDowns);
      this.addReaction(this.getColorMapping);
      this.addReaction(this.getNameMapping);
      this.addReaction(this.redraw);
    
      this.addReaction(this.disableReactions);
    }
    
    disableReactions(){
      if(this.parent.ui.dsShow) return;
      this.removeReaction(this.getFamilies);
      this.removeReaction(this.getDrillDowns);
      this.removeReaction(this.getColorMapping);
      this.removeReaction(this.getNameMapping);
      this.removeReaction(this.redraw);
      this.DOM.container.selectAll("g").remove();
    }
    
    
    get principalDimension() {
      const frameConcept = this.MDL.frame.data.concept;
      return this.model.data.space.filter(f => f !== frameConcept)[0];
    }

    getDrillDowns() {
      const dim = this.principalDimension;
      const entity = this.parent.atomicSliceData.map(m => m[dim]);
        
      //prevent recalcualaion if list of entities didn't change
      if(this.drilldownsReady == entity.join("")) return;

      this.drilldownsReady = false;
      const drilldownPromise = this.model.data.source.drilldown({dim, entity})
        .then( catalog => {
          if (catalog) {
            const drilldownEntitySet = Object.keys(catalog)[0]; //"country"
            this.drilldowns = catalog[drilldownEntitySet];
          }
        });

      this.wholeWorld = this.getHardcodedWholeWorldShortcuts();
      const isFullEntitySetPromise = this.wholeWorld ? Promise.resolve()
        : this.model.data.isFullEntitySet(dim, entity)
          .then(fullset => {
            this.wholeWorld = fullset;
          });
          
      Promise.all([drilldownPromise, isFullEntitySetPromise]).then(() => {
        this.drilldownsReady = entity.join("");
      });
    }

    getHardcodedWholeWorldShortcuts(){
      const dim = this.principalDimension;
      const filter = this.model.data.filter.config.dimensions[dim] || false;
      const notFacet = this.model.encoding.facet_row.data.constant === "none";
    
      return filter["un_state"] && notFacet
          //showing world as one shape
          || filter["is--global"] && notFacet;
    }

    getColorMapping(){
      const dim = this.principalDimension;
    
      this.colorMapReady = false;
      this.model.data.source.drillupCatalog.then(catalog => {
        const drilldownEntitySet = Object.keys(catalog[dim])[0]; //"country"
        const entities = catalog[dim][drilldownEntitySet].get(Symbol.for("drill_up"));
        for(let [key, entity] of entities) {
          this.colorMap[key] = entity[this.MDL.color.data.concept];
        }
        this.colorMapReady = true;
      });
        
    }

    getNameMapping(){
      const dim = this.principalDimension;

      this.nameMapReady = true;
      this.model.data.spaceCatalog.then(catalog => {
        const entities = catalog[dim].entities;
        for(let [key, entity] of entities) {
          this.nameMap[key] = entity[this.MDL.label.data.concept];
        }
        this.nameMapReady = true;
      });
    }


    getFamilies() {
      if(!this.drilldownsReady) return;

      this.familiesReady = false;
      const topic = this.parent.ui.dsTopic || "homes";
      const pageSize = Math.round(+this.parent.ui.dsHowManyHomes);
      const countries = this.wholeWorld ? "" : this.drilldowns.map(m => country3to2(m)).filter(f => !!f);
      
      const params = {lng: "en", cols: 6, p: 0, pageSize, topic, media: "photo", featuredOnly: false, countries};
      const u = new URLSearchParams(params).toString().replaceAll("%2C", ",");
      fetch(ENDPOINT + "search/families?" + u, {
        headers: {Authorization: AUTH_TOKEN}
      })
        .then(resp => resp.json())
        .then(json => {
          this.families = json.hits[6].map(m => ({
            x: +m.place.income/30, 
            id: m.place.slug, 
            name: m.place.name || m.place.slug.replaceAll("-", " "),
            year: m.place?.visitDate?.split("-")[0] || m.place?.date_created?.split("-")[0],
            geo: country2to3(m.place.country.id), 
            image360: m.images.cropped360,
            image180: m.images.cropped180,
            image80: m.images.cropped80,
            imageOriginal: m.images.original
          })).sort((a,b) => a.x - b.x);

          this.familiesReady = true;
        });
    }

    redraw() {
      const _this = this;
      this.services.layout.size; //watch
      this.parent.ui.inpercent;
        
      this._removeImage();
        
      if(!this.familiesReady || !this.colorMapReady || !this.nameMapReady) return;

      const icon = `<path d="m25 9.0937l-17.719 16.281h5.563v15.531h24.312v-15.531h5.563l-17.719-16.281z"/>`;
      const iconHeight = 20.5;
      const iconWidth = 25;
      const parentHeight = _this.parent.yScale(0);
    
      const getColor = (d) => this.parent.MDL.color.scale.d3Scale(this.colorMap[d.geo]);
      const outsideTimeRange = (d) => +d.year > this.MDL.frame.value.getUTCFullYear();
    
      const data = this.families;
      this.DOM.container.selectAll("g")
        .data(data, d => d.id)
        .join("g")
        .on("click", function(_, d){
          if (!sharedComponents.LegacyUtils.isTouchDevice()) _this._goToDollarStreet(d);
        })
        .on("mouseenter", function(_, d){
          _this._removeImage();
          _this._addImage(d);
        })
        .on("mouseout", function(event) {
          if (!sharedComponents.LegacyUtils.isTouchDevice() || !d3.select(event.relatedTarget).classed("vzb-mc-ds-image"))
            _this._removeImage();
        })
        .html(icon)
        .style("fill", d => outsideTimeRange(d) ? "#999" : getColor(d))
        .style("opacity", d =>  outsideTimeRange(d) ? 0.2 : null) 
        .style("cursor", "pointer")
        .style("stroke", "black")
        .style("stroke-width", "2px")
        .attr("transform", d => `translate(${_this.parent.xScale(d.x) - iconWidth/2} ${parentHeight - iconHeight}) scale(0.5)`);
    }

    _goToDollarStreet(d) {
      window.open("https://www.gapminder.org/dollar-street/families/" + d.id, "_blank");
    }

    _removeImage() {
      this.DOM.pattern.selectAll("animateTransform").remove();
      this.DOM.container.selectAll("image").remove();
      this.DOM.container.selectAll(".vzb-mc-ds-text-group").remove();
      this.DOM.container.selectAll(".vzb-mc-ds-image-placeholder").remove();
    }

    _addImage(d){
      const _this = this;
      const height = this.parent.yScale(0);
      const width = d3.max(this.parent.xScale.range());

      const imageSize = height < 360 - 25 ? height - 30 : 360;
      const imageY = (height - imageSize - 25);
      let imageX = this.parent.xScale(d.x) - imageSize/2;
      if (imageX + imageSize > width) imageX = width - imageSize;
      if (imageX < 0) imageX = 0;

      const placeholder = this.DOM.container
        .append("g")
        .attr("class", "vzb-mc-ds-image-placeholder")
        .attr("transform", "translate("+ imageX +"," + imageY + ")");            
      placeholder.append("rect")
        .style("stroke", "black")
        .style("fill", `url(#vzb-mc-ds-pattern-lines-loading-${this.id})`)
        .attr("width", imageSize)
        .attr("height", imageSize);
      placeholder.append("text")
        .text("loading...")
        .style("text-anchor", "middle")
        .attr("x", imageSize/2)
        .attr("y", imageSize/2);

      this.DOM.pattern.append("animateTransform")
        .attr("attributeType", "xml")
        .attr("attributeName", "patternTransform")
        .attr("type", "rotate")
        .attr("from", "35")
        .attr("to", "395")
        .attr("begin", "0")
        .attr("dur", "60s")
        .attr("repeatCount", "indefinite");

      const imageChoices = imageSize > 180 
        ? ["image360", "image180", "image80", "imageOriginal"] 
        : imageSize > 80 
          ? ["image180", "image80", "image360", "imageOriginal"] 
          : ["image80", "image180", "image360", "imageOriginal"];
          
      const tryDownloadImage = (imageChoices) => {
        this.DOM.container.selectAll("image").remove();
        if (!imageChoices[0]) return;

        const img = this.DOM.container
          .append("image")
          .attr("class", "vzb-mc-ds-image")
          .attr("xlink:href", d[imageChoices[0]])
          .attr("transform", "translate("+ imageX +"," + imageY + ")")
          .attr("width", imageSize)
          .attr("height", imageSize)
          .on("click", function() {     
            _this._goToDollarStreet(d);
          })
          .on("mouseout", function() {
            _this._removeImage();
          });

        img.node().addEventListener("load", () => { placeholder.remove(); });
        img.node().addEventListener("error", () => { tryDownloadImage(imageChoices.slice(1)); });
      };

      tryDownloadImage(imageChoices);
        
      _this._addTextElements(_this.DOM.container, d, {imageX, imageY, imageSize});
    }

    _addTextElements(container, d, size = {}) {
      const _this = this;

      const group = container.append("g")
        .attr("transform", `translate(${size.imageX}, ${size.imageY})`)
        .attr("class", "vzb-mc-ds-text-group")
        .style("font-size", size.imageSize > 180 ? "1.8em" : size.imageSize > 80 ? "1.24em" : "0.8em");

      group.append("text")
        .text(this.nameMap[d.geo])
        .attr("class", "vzb-mc-ds-name vzb-mc-ds-text")
        .attr("dx", "0.5em").attr("dy", "1.5em");

      group.append("text")
        .text(this.localise(d.x) + " " + this.localise("unit/mountainchart_hardcoded_income_per_day"))
        .attr("class", "vzb-mc-ds-income vzb-mc-ds-text")
        .attr("dx", "0.5em").attr("dy", "2.7em");
        
      group.append("text")
        .text(this.localise("mount/ds/visitThisHome"))
        .attr("class", "vzb-mc-ds-hint vzb-mc-ds-text")
        .attr("x", size.imageSize / 2).attr("y", size.imageSize)
        .attr("dy", "-0.8em");

      if(!sharedComponents.LegacyUtils.isTouchDevice()) { 
        group.transition().duration(2000).style("opacity", 0);
      }

      if(sharedComponents.LegacyUtils.isTouchDevice()) {          
        group.append("text")
          .text("×")
          .attr("class", "vzb-mc-ds-closecross vzb-mc-ds-text")
          .attr("dx", "-1.5em").attr("dy", "1.5em")
          .attr("x", size.imageSize)
          .on("click",  function() {
            _this._removeImage();
          });
      }
    }
  }

  const decorated$5 = mobx.decorate(MCDollarStreet, {
    "MDL": mobx.computed,
    "familiesReady": mobx.observable,
    "drilldownsReady": mobx.observable,
    "colorMapReady": mobx.observable,
    "nameMapReady": mobx.observable,
    "principalDimension": mobx.computed,
  });

  const {ICON_QUESTION} = sharedComponents.Icons;
  //const COLOR_BLACKISH = "rgb(51, 51, 51)";
  //const COLOR_WHITEISH = "rgb(253, 253, 253)";

  const THICKNESS_THRESHOLD = 0.0001;

  // MOUNTAIN CHART COMPONENT
  class _VizabiMountainChart extends sharedComponents.BaseComponent {

    constructor(config) {
      config.subcomponents = [{
        name: "selectlist",
        type: MCSelectList,
        placeholder: ".vzb-mc-mountains-labels"
      },{
        name: "probe",
        type: decorated$7,
        placeholder: ".vzb-mc-probe",
        options: {
          povertylineMarkerName: config.root.options?.markerNames?.povertyline || "povertyline",
          povertylineEncName: "povertyline"
        }
      },{
        name: "ultrarich",
        type: decorated$6,
        placeholder: ".vzb-mc-ultrarich",
        options: {
          ultrarichMarkerName: config.root.options?.markerNames?.billy || "billy",
          ultrarichEncName: "slices"
        }
      },{
        name: "dollarstreet",
        type: decorated$5,
        placeholder: ".vzb-mc-dollarstreet"
      }];

      //config.name = "mountainchart";

      config.template = `
      <!-- MountainChart Component -->
      <svg class="vzb-mountainchart-svg vzb-export">
        <g class="vzb-mc-graph">
          <rect class="vzb-mc-eventarea"></rect>
          <g class="vzb-mc-ultrarich"></g>

          <g class="vzb-mc-mountains-mergestacked"></g>
          <g class="vzb-mc-mountains-mergegrouped"></g>
          <g class="vzb-mc-mountains"></g>

          <g class="vzb-mc-decorations">
            <g class="vzb-mc-x-axis-groups"></g>
          </g>
  
          <g class="vzb-mc-mountains-labels"></g>

          <g class="vzb-mc-title">
            <text></text>
          </g>

          <g class="vzb-mc-subtitle">
            <text></text>
          </g>

          <g class="vzb-mc-closecross vzb-noexport">
            <text>×</text>
          </g>

          <g class="vzb-mc-axis-x-title">
            <text></text>
          </g>

          <g class="vzb-mc-axis-info vzb-noexport"></g>

          
          <g class="vzb-mc-axis-x"></g>
          
          <g class="vzb-mc-axis-labels"></g>
          <g class="vzb-mc-probe"></g>
          <g class="vzb-mc-dollarstreet"></g>
          
          <g class="vzb-mc-tooltip vzb-hidden">
            <rect class="vzb-tooltip-border"></rect>
            <text class="vzb-tooltip-text"></text>
          </g>
          </g>
        <rect class="vzb-mc-forecastoverlay vzb-hidden" x="0" y="0" width="100%" height="100%" fill="url(#vzb-mc-pattern-lines-${config.id})" pointer-events='none'></rect>
      </svg>
      <svg>
        <defs>
          <pattern class="vzb-noexport" id="vzb-mc-pattern-lines-${config.id}" x="0" y="0" patternUnits="userSpaceOnUse" width="50" height="50" viewBox="0 0 10 10"> 
            <path d='M-1,1 l2,-2M0,10 l10,-10M9,11 l2,-2' stroke='black' stroke-width='3' opacity='0.08'/>
          </pattern> 
        </defs>
      </svg>
    `;

      super(config);
    }


    setup() {

      this.DOM = {
        graph: this.element.select(".vzb-mc-graph"),
        xAxis: this.element.select(".vzb-mc-axis-x"),
        xTitle: this.element.select(".vzb-mc-axis-x-title"),
        yTitle: this.element.select(".vzb-mc-title"),
        ySubtitle: this.element.select(".vzb-mc-subtitle"),
        closeCross: this.element.select(".vzb-mc-closecross"),
        info: this.element.select(".vzb-mc-axis-info"),
        mountainMergeStackedContainer: this.element.select(".vzb-mc-mountains-mergestacked"),
        mountainMergeGroupedContainer: this.element.select(".vzb-mc-mountains-mergegrouped"),
        mountainAtomicContainer: this.element.select(".vzb-mc-mountains"),
        tooltip: this.element.select(".vzb-mc-tooltip"),
        eventArea: this.element.select(".vzb-mc-eventarea"),
        forecastOverlay: this.element.select(".vzb-mc-forecastoverlay"),
        decorations: this.element.select(".vzb-mc-decorations"),
        xAxisGroups: this.element.select(".vzb-mc-x-axis-groups")
      };

      this._selectlist = this.findChild({name: "selectlist"});
      this._probe = this.findChild({name: "probe"});
      
      // this.element.onTap((event, d) => {
      //   this._interact()._mouseout(event, d);
      // });
        
      this.decorations = new MCDecorations(this);
      this._math = new MCMath(this);
      //this._export = new Exporter(this);
      //this._export
      //  .prefix("vzb-mc-")
      //  .deleteClasses(["vzb-mc-mountains-mergestacked", "vzb-mc-mountains-mergegrouped", "vzb-mc-mountains", "vzb-mc-date", "vzb-mc-mountains-labels", "vzb-mc-axis-labels"]);
      //this._robinhood = new RobinHood(this);

      // define path generator
      this.area = d3.area()
        .x(d => this.xScale(d.x))
        .y0(d => this.yScale(d.y0))
        .y1(d => this.yScale(d.y0 + d.y));

      //define d3 stack layout
      this.stackLayout = d3.stack()
        .order(d3.stackOrderReverse)
        .value((i, slice) => slice.shape[i].y);

      this.xAxis = sharedComponents.axisSmart("bottom");

      this.rangeRatio = 1;
      this.rangeShift = 0;
      this.stickySortValues = {};
      this.yMaxGlobal = 0;
    }

    get MDL(){
      return {
        frame: this.model.encoding.frame,
        selectedF: this.model.encoding.selected.data.filter,
        highlightedF: this.model.encoding.highlighted.data.filter,
        //superHighlightedF: this.model.encoding.superhighlighted.data.filter,
        mu: this.model.encoding[this.state.alias.mu || "mu"],
        shapedata: this.model.encoding[this.state.alias.shapedata || "shapedata"],
        color: this.model.encoding[this.state.alias.color || "color"],
        label: this.model.encoding.label,
        stack: this.model.encoding.stack,
        group: this.model.encoding.group,
        facet_row: this.model.encoding.facet_row,
        maxheight: this.model.encoding.maxheight
      };
    }

    get isInFacet(){
      return this.parent.constructor.name === "_Facet";
    }

    get isManyFacets(){
      return this.isInFacet && this.parent.howManyFacets() > 1;
    }

    get isAreaSmall(){
      this.services.layout.size; //watch

      return !this.ui.inpercent && this.parent.getScaleDomainForSubcomponent(this.name) < this.parent.getScaleDomainForSubcomponent() * 0.01;
    }

    get duration(){
      //smooth animation is needed when playing, except for the case when time jumps from end to start
      if(!this.MDL.frame || !this.MDL.frame.playing) return 0;
      this.frameValue_1 = this.frameValue;
      this.frameValue = this.MDL.frame.value;
      return this.frameValue > this.frameValue_1 ? this.MDL.frame.speed : 0;
    }

    draw() {

      this.localise = this.services.locale.auto(this.MDL.frame.interval);
      this._dataNotes = this.root.findChild({name: "datanotes"});
      this.yMaxGlobal = 0;

      if (this.updateLayoutProfile()) return; //return if exists with error
      this.addReaction(this.updateCurveMethod);
      this.addReaction(this.updateHeaderAndFooter);
      this.addReaction(this.drawForecastOverlay);
      this.addReaction(this.updateMathSettings);
      this.addReaction(this.updateMaxValues);
      this.addReaction(this.updateSize);
      //this.addReaction(this.updateMesh);
      this.addReaction(this.zoom);
      this.addReaction(this.resetYMaxGlobal);
      //this.addReaction(this.updateMasks);
      this.addReaction(this.drawData);
      this.addReaction(this.updateSelected);
      this.addReaction(this.updateAllSlicesOpacity);
      this.addReaction(this.updateDecorations);
      this.addReaction(this.updateProbe);
      this.addReaction(this.updateShowYear);
    }

    drawData() {
      this.services.layout.size; //watch
      this.ui.inpercent;
      if (this.isInFacet) {this.parent.scaleRange; this.parent.rangePartsHash;}

      this.processFrameData();
      this.computeAllShapes();
      this.createAndDeleteSlices();
      this.renderAllShapes();
    }

    updateProbe(){
      this._probe.redraw();
    }

    updateCurveMethod(){
      this.area.curve(d3[this.ui.curve]);
    }

    updateLayoutProfile(){
      this.services.layout.size; //watch
      this.ui.inpercent;

      this.profileConstants = this.services.layout.getProfileConstants(PROFILE_CONSTANTS, PROFILE_CONSTANTS_FOR_PROJECTOR, this.state.positionInFacet);

      if (!this.height || !this.width) return sharedComponents.LegacyUtils.warn("Chart _updateProfile() abort: container is too little or has display:none");
    }

    get height(){
      this.services.layout.size; //watch
      this.ui.inpercent;
      if (this.isInFacet) {this.parent.scaleRange; this.parent.rangePartsHash;}

      return this.element.node().clientHeight || 0;
    }

    get width(){
      this.services.layout.size; //watch
      this.ui.inpercent;
      if (this.isInFacet) {this.parent.scaleRange; this.parent.rangePartsHash;}

      return this.element.node().clientWidth || 0;
    }

    updateHeaderAndFooter() {
      const _this = this;

      this.DOM.xTitle.select("text")
        .text(this.localise("unit/mountainchart_hardcoded_income_per_day"));

      this.DOM.yTitle.select("text")
        .text(this.localise(this.ui.inpercent ? "mount/percentofpeople" : "mount/numberofpeople"));

      //if a mountain is in facets: spell out its name
      this.DOM.ySubtitle
        .classed("vzb-hidden", !this.isManyFacets)
        .select("text")
        .text(this._getSubtitleText())
        .style("pointer-events", this.isAreaSmall ? "all" : "none")
        .on("mouseenter", function(){
          if (_this.isAreaSmall) d3.select(this).text(_this.localise("mount/smallpopulation"));
        })
        .on("mouseleave", function(){
          if (_this.isAreaSmall) d3.select(this).text(_this._getSubtitleText());
        })
        .on("click", () => {
          _this.root.ui.chart.inpercent = !_this.root.ui.chart.inpercent;
        });

      this.DOM.closeCross
        .classed("vzb-hidden", 
          !this.isManyFacets 
          || this.MDL.facet_row.data.concept === this.MDL.color.data.concept
        )
        .on("mouseover", () => {
          this.element.classed("vzb-chart-removepreview", true);
        })
        .on("mouseout", () => {
          this.element.classed("vzb-chart-removepreview", false);
        })
        .on("click", () => {
          this.model.data.filter.delete(this.atomicSliceData);
        });

      sharedComponents.LegacyUtils.setIcon(this.DOM.info, ICON_QUESTION).select("svg").attr("width", "0px").attr("height", "0px");

      this.DOM.info.on("click", () => {
        this._dataNotes.pin();
      });
      this.DOM.info.on("mouseover", function() {
        const rect = this.getBBox();
        const coord = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
        const toolRect = _this.root.element.node().getBoundingClientRect();
        const chartRect = _this.element.node().getBoundingClientRect();
        _this._dataNotes.setEncoding(_this.MDL.shapedata).show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
      });
      this.DOM.info.on("mouseout", () => {
        _this._dataNotes.hide();
      });

      this.DOM.eventArea
        .on("mousemove", function(event) {
          if (_this._isDragging()) return;
          if (!_this.ui.showProbeX) return;

          _this.runHereOrPossiblyInAllFacets(function(context){
            context._probe.redraw({
              level: _this.xScale.invert(d3.pointer(event)[0]),
              full: true
            });
          });
        })
        .on("mouseout", () => {
          if (this._isDragging()) return;
          if (!this.ui.showProbeX) return;

          _this.runHereOrPossiblyInAllFacets(function(context){
            context._probe.redraw();
          });
        });
    }

    updateShowYear() {
      this.root.element.select(".vzb-datetime-background").classed("vzb-hidden", !this.ui.timeInBackground);
    }

    runHereOrPossiblyInAllFacets(func){
      if (this.isManyFacets)
        this.parent.propagateInteractivity(func);
      else
        func(this);
    }

    get xScale() {
      this.services.layout.size; //watch
      this.ui.inpercent;

      const {margin} = this.profileConstants;
      const width = this.width - margin.left - margin.right;
      return this.MDL.mu.scale.d3Scale.range([this.rangeShift, width * this.rangeRatio + this.rangeShift]);
    }
    get yScale() {
      this.services.layout.size; //watch
      this.ui.inpercent;

      const {margin} = this.profileConstants;
      const height = this.height - margin.top - margin.bottom;
      return d3.scaleLinear().domain(this.yDomain).range([height, this.isManyFacets ? height - this.parent.scaleRange : 0]);
    }

    drawForecastOverlay() {
      this.DOM.forecastOverlay.classed("vzb-hidden", 
        !this.ui.showForecast || 
        !this.ui.showForecastOverlay || 
        !this.ui.endBeforeForecast || 
        (this.MDL.frame.value <= this.MDL.frame.parseValue(this.ui.endBeforeForecast))
      );
    }

    updateMathSettings(){
      this._math.xScaleFactor = this.MDL.mu.config.xScaleFactor;
      this._math.xScaleShift = this.MDL.mu.config.xScaleShift;
    }

    updateSize() {
      this.services.layout.size; //watch
      this.ui.inpercent;

      const {
        margin,
        infoElHeight,
      } = this.profileConstants;

      const width = this.width - margin.left - margin.right;
      const height = this.height - margin.top - margin.bottom;

      //graph group is shifted according to margins (while svg element is at 100 by 100%)
      this.DOM.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const isRTL = this.services.locale.isRTL();

      //axis is updated
      this.xAxis.scale(this.xScale)
        .tickSizeOuter(0)
        .tickPadding(9)
        .tickSizeMinor(3, 0)
        .labelerOptions({
          scaleType: this.MDL.mu.scale.type || "log",
          toolMargin: margin,
          pivotingLimit: margin.bottom * 1.5,
          method: this.xAxis.METHOD_REPEATING,
          stops: this.ui.xLogStops,
          formatter: this.localise
        });

      this.DOM.xAxis
        .attr("transform", "translate(0," + height + ")")
        .call(this.xAxis);

      this.DOM.xTitle.select("text")
        .attr("transform", "translate(" + (width - (this.DOM.closeCross.classed("vzb-hidden") ? 0 : 20)) + "," + height + ")")
        .attr("dy", "-0.36em");

      this.DOM.yTitle
        .style("font-size", infoElHeight + "px")
        .attr("transform", "translate(" + (isRTL ? width : 0) + "," + margin.top + ")");

      this.DOM.ySubtitle
        .style("font-size", infoElHeight + "px")
        .attr("transform", "translate(" + (isRTL ? width : 0) + "," + height + ")")
        .select("text")
        .attr("dy", "-0.36em");

      this.DOM.closeCross
        .style("font-size", infoElHeight + "px")
        .attr("transform", "translate(" + (isRTL ? 0 : width) + "," + height + ")")
        .select("text")
        .attr("dy", "-0.36em");

      this.DOM.xAxisGroups
        .style("font-size", infoElHeight * 0.8 + "px");

      const titleBBox = this.DOM.yTitle.node().getBBox();
      const t = sharedComponents.LegacyUtils.transform(this.DOM.yTitle.node());

      if (this.DOM.info.select("svg").node()) {
        const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);
        const cpForInfoEl = this.MDL.shapedata.data.conceptProps;

        this.DOM.info.select("svg")
          .attr("width", infoElHeight + "px")
          .attr("height", infoElHeight + "px");
        this.DOM.info
          .classed("vzb-hidden", !cpForInfoEl.description && !cpForInfoEl.sourceLink || this.services.layout.projector)
          .attr("transform", "translate("
          + hTranslate + ","
          + (t.translateY - infoElHeight * 0.1) + ")");
      }

      this.DOM.eventArea
        .attr("y", height)
        .attr("width", width)
        .attr("height", titleBBox.height);
    }

    get mesh(){
      // this.mesh = this._math.generateMesh(
      //   this.ui.xPoints, 
      //   this.MDL.mu.scale.type || "log", 
      //   this.xScale.domain()
      // );
      const start = this.ui.xStart;
      const end = this.ui.xEnd;
      const nbrackets = this.ui.xPoints;
      const step = Math.pow(end/start, 1/nbrackets);

      return d3.range(nbrackets).map(m => start * Math.pow(step, m + 0.5) );
      
      //rbh
      //this._robinhood.findMeshIndexes(this.mesh);
    }

    updateDecorations(){
      this.services.layout.size;
      this.ui.inpercent;
      
      this.MDL.mu.config;
      this.decorations.update.bind(this)(this.duration);
    }

    zoom() {
      const mdlcfg = this.MDL.mu.config;
      const {
        margin,
      } = this.profileConstants;
      const width = this.width - margin.left - margin.right;

      if (mdlcfg.zoomedMin == null && this.MDL.mu.scale.domain[0] == null || mdlcfg.zoomedMax == null && this.MDL.mu.scale.domain[1] == null) return;

      const x1 = this.xScale(mdlcfg.zoomedMin || this.MDL.mu.scale.domain[0]);
      const x2 = this.xScale(mdlcfg.zoomedMax || this.MDL.mu.scale.domain[1]);
      // if we have same x1 and x2 then divider will be 0 and rangeRation will become -Infinity
      if (!isFinite(x1) || !isFinite(x2) || x1 === x2) return;

      this.rangeRatio = width / (x2 - x1) * this.rangeRatio;
      this.rangeShift = (this.rangeShift - x1) / (x2 - x1) * width;

      this.xScale.range([this.rangeShift, width * this.rangeRatio + this.rangeShift]);

      this.DOM.xAxis.call(this.xAxis);
    }

    updateMasks() {
      const tailFatX = this._math.unscale(this.MDL.mu.config.tailFatX);
      const tailCutX = this._math.unscale(this.MDL.mu.config.tailCutX);
      const tailFade = this.MDL.mu.config.tailFade;
      const k = 2 * Math.PI / (Math.log(tailFatX) - Math.log(tailCutX));
      const m = Math.PI - Math.log(tailFatX) * k;

      this.spawnMask = [];
      this.cosineShape = [];
      this.cosineArea = 0;

      this.mesh.forEach((dX, i) => {
        this.spawnMask[i] = dX < tailCutX ? 1 : (dX > tailFade * 7 ? 0 : Math.exp((tailCutX - dX) / tailFade));
        this.cosineShape[i] = (dX > tailCutX && dX < tailFatX ? (1 + Math.cos(Math.log(dX) * k + m)) : 0);
        this.cosineArea += this.cosineShape[i];
      });
    }

    //TODO rewrite old understandings
    _isProperty(mdl){
      return mdl.data.space && mdl.data.space.length == 1 && !mdl.data.constant && mdl.data.concept != this.MDL.frame.data.concept;
    }

    _getDataArrayForFacet(){
      if(this.isManyFacets)
        return this.parent.getDataForSubcomponent(this.name);
      else
        return this.model.dataArray;
    }

    get atomicSliceData(){
      return this._getDataArrayForFacet()
        .concat() //copy array in order to avoid sorting in place
        .filter(d => d[this._alias("shapedata")] || d[this._alias("mu")] && d[this._alias("norm")] && d[this._alias("sigma")])
        .map(d => {
          d.KEY = () => d[Symbol.for("key")];
          if(typeof d.shapedata === "string"){
            d.distribution = d.shapedata.split(",").map(m => +m);
            d.norm = d3.sum(d.distribution);
          }
          if (this.stickySortValues[d.KEY()] == null) this.stickySortValues[d.KEY()] = d[this._alias("norm")];
          d.sortValue = [this.stickySortValues[d.KEY()] || 0, 0];
          d.aggrLevel = 0;
          return d;
        })
        //1-st level sort: pre-sort atomic slices, this sort will be retained in grouping and stacking
        .sort((a, b) => b.sortValue[0] - a.sortValue[0]);
    }

    get groupedSliceData() {
      const groupManualSort = this.MDL.group.config.manualSorting;
      const isManualSortCorrect = sharedComponents.LegacyUtils.isArray(groupManualSort) && groupManualSort.length > 1;
      this.sortValuesForGroups = {};

      return d3.groups(this.atomicSliceData, d => this._isProperty(this.MDL.stack)? d.stack: d.group)
        //no point doing a grouping when there is only one item in a group (i.e. when atomic slices are regions already)
        .filter(([,v]) => v.length > 1)
        //the output comes in a form of [[key, values[]],[],[]], convert each array to object
        .map(([key, values]) => ({key, values}))
        .map(group => {
          let groupSortValue = 0;

          if (isManualSortCorrect)
            groupSortValue = groupManualSort.includes(group.key) ? groupManualSort.length - 1 - groupManualSort.indexOf(group.key) : -1;
          else
            groupSortValue = d3.sum(group.values.map(m => m.sortValue[0]));

          group.values.forEach(d => {
            d.sortValue[1] = groupSortValue;
          });

          this.sortValuesForGroups[group.key] = groupSortValue;
          group[Symbol.for("key")] = group.key;
          group.KEY = () => group.key;
          group.aggrLevel = 1;

          return group;
        });
    }

    get stackedSliceData() {

      if (this.MDL.stack.data.constant === "none") {
        return [];

      } else {
        return d3.groups(this.atomicSliceData, d => d.stack, d => d.group)
          //the output comes in a form of [[key, values[]],[],[]], convert each array to object, do that for both layers
          .map(([key, values])=>({key, values: values.map(([key, values])=>({key, values}))}))
          .map(stack => {
            //groups are sorted inside a stack
            stack.values.sort((a, b) => this.sortValuesForGroups[b.key] - this.sortValuesForGroups[a.key]);
            stack[Symbol.for("key")] = stack.key;
            stack.KEY = () => stack.key;
            stack.aggrLevel = 2;

            return stack;
          });
      }
    }

    updateMaxValues() {
      if (this.isInFacet) {
        this.parent.maxValues.set(this.name, this.ui.inpercent ? 1 : this.maxValue);
      }
    }

    get maxValue() {
      if (this.isInFacet) {
        const data = this._getDataArrayForFacet();
        const sum = d3.sum(data.map(m => m[this.MDL.maxheight.name]));
        const limit = this.MDL.maxheight.config.limit;
        return (!this._isFrameLastValuesIsEqual() && (!sum || sum > limit)) ? limit : sum;
      }
      return null;
    }

    _isFrameLastValuesIsEqual() {
      const frameLastValue = this.MDL.frame.domainValues[this.MDL.frame.domainValues.length - 1];
      const frameDataLastValue = this.MDL.frame.data.domain[this.MDL.frame.data.domain.length - 1];
      return !(frameDataLastValue - frameLastValue);
    }

    resetYMaxGlobal() {
      this.MDL.frame.domainValues;

      this.yMaxGlobal = 0;
    }

    processFrameData() {
      this.atomicSliceData;
      this.groupedSliceData;
      this.stackedSliceData;

      //2-nd level sort: atomic slices are sorted by groups
      this.atomicSliceData.sort((a, b) => b.sortValue[1] - a.sortValue[1]);
    }

    createAndDeleteSlices() {    

      //bind the data to DOM elements
      this.mountainsMergeStacked = this.DOM.mountainAtomicContainer
        .selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel2")
        .data(this.stackedSliceData, d => d.KEY());
      this.mountainsMergeGrouped = this.DOM.mountainAtomicContainer
        .selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel1")
        .data(this.groupedSliceData, d => d.KEY());
      this.mountainsAtomic = this.DOM.mountainAtomicContainer
        .selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel0")
        .data(this.atomicSliceData, d => d.KEY());

      this.mountainsMergeStacked = this.mountainsMergeStacked.join(
        enter => enter.append("path")
          .attr("class", "vzb-mc-mountain vzb-mc-aggrlevel2")
          .attr("id", d => `vzb-mc-slice-${d.KEY()}-${this.id}`)
          .call(this._interact.bind(this))
      );
      this.mountainsMergeGrouped = this.mountainsMergeGrouped.join(
        enter => enter.append("path")
          .attr("class", "vzb-mc-mountain vzb-mc-aggrlevel1")
          .attr("id", d => `vzb-mc-slice-${d.KEY()}-${this.id}`)
          .call(this._interact.bind(this))
      );
      this.mountainsAtomic = this.mountainsAtomic.join(
        enter => enter.append("path")
          .attr("class", "vzb-mc-mountain vzb-mc-aggrlevel0")
          .attr("id", d => `vzb-mc-slice-${d.KEY()}-${this.id}`)
          .call(this._interact.bind(this))
      );

      this.mountains = this.DOM.mountainAtomicContainer.selectAll(".vzb-mc-mountain")
        .order();
    }

    computeAllShapes() {
      const stackMode = this.MDL.stack.data.constant;

      //spawn the original mountains
      this.atomicSliceData.forEach((d) => {
        d.shape = this._spawnShape(d);
        d.hidden = d.shape.length === 0;
      });

      //rbh
      //this._robinhood.adjustCached();

      //recalculate shapes depending on stacking: shift baseline y0 of each shape
      if (stackMode !== "none") {
        this.stackedSliceData.forEach(stack => {
          let slicesToStack = [];
          stack.values.forEach(group => {
            slicesToStack = slicesToStack.concat(group.values.filter(f => !f.hidden));
          });
          this.stackLayout
            .keys(slicesToStack)(d3.range(this.mesh.length))
            .forEach((vertices, sliceIndex) => {
              const slice = slicesToStack[sliceIndex];
              vertices.forEach((d, i) => {
                slice.shape[i].y0 = d[0];
              });
            });
        });
      }

      //save yMax of each slice, stacked or not
      this.atomicSliceData.forEach(d => {
        d.yMax = d3.max(d.shape.map(m => m.y0 + m.y));
      });

      //recalcuate the merge-stacking slice shape
      if (stackMode == "all") {
        this.stackedSliceData.forEach(d => {
          const firstLast = this._getFirstAndLastSlicesInGroup(d);
          d.shape = this._getMergedShape(firstLast);
          d[this._alias("norm")] = this._sumLeafSlicesByEncoding(d, this._alias("norm"));
          d[this._alias("color")] = "_default";
          d.yMax = firstLast.first.yMax;
        });
      }

      //recalculate the merge-grouping slice shapes
      if (stackMode !== "none") {
        this.groupedSliceData.forEach(d => {
          const firstLast = this._getFirstAndLastSlicesInGroup(d);
          d.shape = this._getMergedShape(firstLast);
          d[this._alias("norm")] = this._sumLeafSlicesByEncoding(d, this._alias("norm"));
          d[this._alias("color")] = firstLast.first[this._alias("color")];
          d.yMax = firstLast.first.yMax;
          d.values.forEach(v => v.yMaxGroup = d.yMax);
        });
      }

      //push yMaxGlobal up so shapes can fit
      let yMaxGlobal = this.yMaxGlobal;
      this.atomicSliceData.forEach(d => {
        if (yMaxGlobal < d.yMax) yMaxGlobal = d.yMax;
        if (yMaxGlobal < this.ui.yMaxMethod) this.yMaxGlobal = this.ui.yMaxMethod;
      });
      this.yMaxGlobal = yMaxGlobal;

      //sort slices again: this time to order DOM-elements correctly
      if (stackMode === "none") {
        //reorder slices to put the tallest in the back (only now we know yMax, couldn't do this earlier)
        this.atomicSliceData.sort((a, b) => b.yMax - a.yMax);
      } else if (stackMode === "all") ; else {
        //reorder merged group slices or atomic shapes to put the tallest in the back
        if (this._isMergingGroups())
          this.groupedSliceData.sort((a, b) => b.yMax - a.yMax);
        else
          this.atomicSliceData.sort((a, b) => b.yMaxGroup - a.yMaxGroup);
      }
    }
    
    renderAllShapes() {
      const _this = this;
      const mergeStacked = this.MDL.stack.config.merge;
      const mergeGrouped = this._isMergingGroups();

      this.mountainsMergeStacked.each(function(d) {
        const view = d3.select(this);
        const hidden = !mergeStacked;
        const selected = false;
        _this._renderShape(view, d, hidden, selected);
      });

      this.mountainsMergeGrouped.each(function(d) {
        const view = d3.select(this);
        const selected = _this.MDL.selectedF.has(d);
        const hidden = !mergeGrouped || (mergeStacked && !selected);
        _this._renderShape(view, d, hidden, selected);
      });

      this.mountainsAtomic.each(function(d) {
        const view = d3.select(this);
        const selected = _this.MDL.selectedF.has(d);
        const hidden = d.hidden || (mergeGrouped || mergeStacked) && !selected;
        _this._renderShape(view, d, hidden, selected);
      });

      // exporting shapes for shape preloader. is needed once in a while
      // if (!this.shapes) this.shapes = {}
      // this.shapes[this.model.time.value.getUTCFullYear()] = {
      //     yMax: d3.format(".2e")(this.yMax),
      //     shape: this.cached["all"].map(function (d) {return d3.format(".2e")(d[this._alias("norm")]);})
      // }
    }

    _renderShape(view, d, hidden, selected) {
      view.classed("vzb-hidden", hidden);

      if (hidden) return;

      const transition = this.duration 
        ? view.transition().duration(this.duration).ease(d3.easeLinear) 
        : view.interrupt();

      if (selected)
        //filter by thickness to avoid stroke of any selected shape cover the entire axis
        transition.attr("d", this.area(d.shape.filter(f => f.y > d[this._alias("norm")] * THICKNESS_THRESHOLD)));
      else        
        transition.attr("d", this.area(d.shape));

      const color = d[this._alias("color")];
      transition.style("fill", this.MDL.color.scale.d3Scale(color || d[Symbol.for("key")] ));
      //transition.style("fill", COLOR_WHITEISH);

      //fancy appear of the slices that were hidden
      if (!this._isDragging() && !this.MDL.frame.playing && this.MDL.stack.data.constant !== "none" && !selected) {
        view
          .style("stroke-opacity", 0)
          .transition().duration(Math.random() * 900 + 100).ease(d3.easeCircle)
          .style("stroke-opacity", 0.5);
      }

      // if (this.model.time.record) this._export.write({
      //   type: "path",
      //   id: key,
      //   time: this.model.time.value.getUTCFullYear(),
      //   fill: this.MDL.color.scale.d3Scale(valuesPointer.color[key]),
      //   d: this.area(this.cached[key])
      // });
    }

    _getSubtitleText() {
      const prefix = this.isAreaSmall ? "🤏 " : "";
      
      if (this.atomicSliceData.length == 1) {
        const slice = this.atomicSliceData[0];
        const population = this.MDL.selectedF.has(slice)
          ? ": " + this.localise(slice.norm) + " " + this.localise("mount/people")
          : "";
        return prefix + this._getLabelText(slice) + population; 
      } else if (this.name.includes("is--"))
        return prefix + this.model.data.source.getConcept(this.name.replace("is--",""))?.name;
      else
        return this.name;
    }

    _getLabelText(d) {
      if(d.aggrLevel == 2)
        return this.localise("mount/stacking/world") || d.key;
      if(d.aggrLevel == 1) {
        //TODO: is there a better way?
        const legend = this.root.model.markers[this.root.options?.markerNames?.legend || "legend"];
        if (!legend) return d.key;
        const legendItem = legend.dataArray.find(f => f[this.MDL.group.data.concept] == d.key) || {};      
        return legendItem.name || d.key;
      }
      if (typeof d.label == "object") 
        return Object.entries(d.label)
          .filter(entry => entry[0] != this.MDL.frame.data.concept)
          .map(entry => sharedComponents.LegacyUtils.isNumber(entry[1]) ? (entry[0] + ": " + entry[1]) : entry[1])
          .join(", ");
      if (d.label != null) return "" + d.label;
      return d[Symbol.for("key")];
    }

    _interact(selection){
      selection
        .on("mousemove", (event, d) => {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          if (this._isDragging() || this.MDL.frame.playing) return;
          this.MDL.highlightedF.set(d);
          this._setTooltip(event, this._getLabelText(d));
        })
        .on("mouseout", (event, d) => {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          if (this._isDragging() || this.MDL.frame.playing) return;
          this._setTooltip();
          this.MDL.highlightedF.delete(d);
        })
        .on("click", (event, d) => {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          if (this._isDragging() || this.MDL.frame.playing) return;
          this.MDL.selectedF.toggle(d);
        })
        .onTap((event, d) => {
          if (this._isDragging() || this.MDL.frame.playing) return;
          this.MDL.selectedF.toggle(d);
          event.stopPropagation();
        });
    }

    updateSelected() {
      this.MDL.selectedF.markers; //watch
      this.someSelected = this.MDL.selectedF.any();

      this.nonSelectedOpacityZero = false;
      this.mountains.classed("vzb-selected", d => this.MDL.selectedF.has(d));
    }

    _sumLeafSlicesByEncoding(branch, enc) {
      if (branch.values)
        return d3.sum(branch.values.map(m => this._sumLeafSlicesByEncoding(m, enc)));
      else
        return branch[enc];    
    }

    updateAllSlicesOpacity() {
      this.MDL.selectedF.markers; //watch
      this.MDL.highlightedF.markers; //watch

      const OPACITY_HIGHLT = 1.0;
      const OPACITY_HIGHLT_DIM = 0.3;
      const OPACITY_SELECT = 1.0;
      const OPACITY_REGULAR = this.ui.opacityRegular;
      const OPACITY_SELECT_DIM = this.ui.opacitySelectDim;

      this.someHighlighted = this.MDL.highlightedF.any();

      this.mountains.style("opacity", d => {

        if (this.someHighlighted) {
          //highlight or non-highlight
          if (this.MDL.highlightedF.has(d)) return OPACITY_HIGHLT;
        }

        if (this.someSelected) {
          //selected or non-selected
          return this.MDL.selectedF.has(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
        }

        if (this.someHighlighted) return OPACITY_HIGHLT_DIM;

        return OPACITY_REGULAR;
      });

      const nonSelectedOpacityZero = this.ui.opacitySelectDim < 0.01;

      // when pointer events need update...
      if (nonSelectedOpacityZero !== this.nonSelectedOpacityZero) {
        this.mountainsAtomic.style("pointer-events", d => {
          if (!this.someSelected || !nonSelectedOpacityZero || this.MDL.selectedF.has(d)) 
            return "visible";
          else
            return "none";
        });
      }

      this.nonSelectedOpacityZero = nonSelectedOpacityZero;
    }



    _getFirstAndLastSlicesInGroup(group) {
      let visible = [], visible2 = [];
      let first, last;

      if (group.aggrLevel == 2) {
        visible = group.values[0].values.filter(f => !f.hidden);
        visible2 = group.values[group.values.length - 1].values.filter(f => !f.hidden);
        first = visible[0];
        last = visible2[visible2.length - 1];
      }
      if (group.aggrLevel == 1) {
        visible = group.values.filter(f => !f.hidden);
        first = visible[0];
        last = visible[visible.length - 1];
      }

      if (!first || !last) sharedComponents.LegacyUtils.warn("mountain chart failed to generate shapes. check the incoming data");

      return {first, last};
    }

    _getMergedShape({first, last}) {
      return this.mesh.map((m, i) => {
        return {
          x: m,
          y0: last.shape[i].y0,
          y: first.shape[i].y0 + first.shape[i].y - last.shape[i].y0
        };
      });
    }

    _spawnShape(d) {
      //in case of the direct shapes the distribution is already known
      if(d.distribution) return this.mesh.map((dX, i) => ({
        x: dX,
        y0: 0,
        y: d.distribution[i]
      }));

      const norm = d[this._alias("norm")];
      const sigma = this.ui.directSigma ?
        d[this._alias("sigma")] :
        this._math.giniToSigma(d[this._alias("sigma")]);
      
      const mu = this.ui.directMu ?
        d[this._alias("mu")] :
        this._math.gdpToMu(d[this._alias("mu")], sigma);

      if (!norm || !mu || !sigma) return [];

      const distribution = [];
      let acc = 0;

      this.mesh.forEach((dX, i) => {
        distribution[i] = this._math.pdfLognormal(dX, mu, sigma);
        acc += this.spawnMask[i] * distribution[i];
      });

      const result = this.mesh.map((dX, i) => ({
        x: dX,
        y0: 0,
        y: norm * (distribution[i] * (1 - this.spawnMask[i]) + this.cosineShape[i] / this.cosineArea * acc)
      }));

      return result;
    }

    get yDomain() {
      return [0, this.isManyFacets ? this.ui.inpercent ? this.maxValue : this.parent.getScaleDomainForSubcomponent(null) : Math.round(this.yMaxGlobal)];
    }

    _isMergingGroups() {
      return this.groupedSliceData.length && (
        this.MDL.group.config.merge
        //merge the grouped entities to save performance during dragging or playing      
        //except when stacking is off
        || (this._isDragging() || this.MDL.frame.playing) && this.MDL.stack.data.constant !== "none"
      );
    }

    _isDragging(){
      const timeslider = this.root.findChild({type: "TimeSlider"});
      return timeslider && timeslider.ui.dragging;
    }

    _setTooltip(event, tooltipText) {
      if (tooltipText) {
        const mouse = d3.pointer(event);

        //position tooltip
        this.DOM.tooltip.classed("vzb-hidden", false)
          .attr("transform", "translate(" + (mouse[0]) + "," + (mouse[1]) + ")")
          .selectAll("text")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .text(tooltipText);

        const contentBBox = this.DOM.tooltip.select("text").node().getBBox();

        this.DOM.tooltip.select("rect")
          .attr("width", contentBBox.width + 8)
          .attr("height", contentBBox.height + 8)
          .attr("x", -contentBBox.width - 25)
          .attr("y", -contentBBox.height - 25)
          .attr("rx", contentBBox.height * 0.2)
          .attr("ry", contentBBox.height * 0.2);

        this.DOM.tooltip.selectAll("text")
          .attr("x", -contentBBox.width - 25 + ((contentBBox.width + 8) / 2))
          .attr("y", -contentBBox.height - 25 + ((contentBBox.height + 11) / 2)); // 11 is 8 for margin + 3 for strokes
        const translateX = (mouse[0] - contentBBox.width - 25) > 0 ? mouse[0] : (contentBBox.width + 25);
        const translateY = (mouse[1] - contentBBox.height - 25) > 0 ? mouse[1] : (contentBBox.height + 25);
        this.DOM.tooltip
          .attr("transform", "translate(" + translateX + "," + translateY + ")");

      } else {

        this.DOM.tooltip.classed("vzb-hidden", true);
      }
    }

    _alias(enc) {
      return this.state.alias[enc] || enc;
    }

  }

  const PROFILE_CONSTANTS = _VizabiMountainChart.PROFILE_CONSTANTS = {
    SMALL: {
      margin: { top: 2, right: 10, left: 10, bottom: 18, betweenRow: 2},
      infoElHeight: 16,
      minHeight: 43
    },
    MEDIUM: {
      margin: { top: 5, right: 20, left: 20, bottom: 60, betweenRow: 2},
      infoElHeight: 20,
      minHeight: 55
    },
    LARGE: {
      margin: { top: 10, right: 30, left: 30, bottom: 65, betweenRow: 2},
      infoElHeight: 22,
      minHeight: 70
    }
  };

  const PROFILE_CONSTANTS_FOR_PROJECTOR = _VizabiMountainChart.PROFILE_CONSTANTS_FOR_PROJECTOR = {
    MEDIUM: {
      margin: { top: 10, right: 20, left: 20, bottom: 70, betweenRow: 2},
      infoElHeight: 26,
      minHeight: 70
    },
    LARGE: {
      margin: { top: 15, right: 30, left: 30, bottom: 85, betweenRow: 2},
      infoElHeight: 32,
      minHeight: 110
    }
  };

  _VizabiMountainChart.DEFAULT_UI = {
    //TODO: why must forecast options be in page config for speed dialog to work
    opacitySelectDim: 0.3,
    opacityRegular: 0.7,
    robinhood: {
      enabled: false,
      xTax: [100],
      yTax: [100]
    },
    decorations: {
      enabled: true,
      xAxisGroups: null
    },
    curve: "curveNatural", //curveBasis curveLinear curveMonotoneX curveCatmullRom curveNatural
    manualSortingEnabled: true,
    yMaxMethod: 0,
    showProbeX: true,
    probeX: 2.15,
    probeXCustom: 4,
    probeXType: "extreme",
    probeXDetails: {
      belowProc: true,
      belowCount: false,
      aboveProc: false,
      aboveCount: false
    },
    xLogStops: [1, 2, 5],
    xPoints: 50,
    xStart: 0.0078125,
    xEnd: 8192.0,
    directSigma: false, //false = input is gini, true = input is standatd deviation of the distribution
    directMu: false, //false = input is GDP/capita, true = input is mean of the distribution
    preload: "income_mountains",
    preloadKey: "world"
  };


  const VizabiMountainChart = mobx.decorate(_VizabiMountainChart, {
    "MDL": mobx.computed,
    "isInFacet": mobx.computed,
    "isManyFacets": mobx.computed,
    "isAreaSmall": mobx.computed,
    "duration": mobx.computed,
    "atomicSliceData": mobx.computed,
    "groupedSliceData": mobx.computed,
    "stackedSliceData": mobx.computed,
    "xScale": mobx.computed,
    "yScale": mobx.computed,
    "height": mobx.computed,
    "width": mobx.computed,
    "mesh": mobx.computed,
    "incomeBrackets": mobx.observable,
    "maxValue": mobx.computed,
    "yDomain": mobx.computed,
    "yMaxGlobal": mobx.observable
  });

  /*
   * stack dialog
   */
  class Stack extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title">
          <span data-localise="buttons/stack"></span>
        </div>
        
        <div class="vzb-dialog-content">
          <form class="vzb-howtostack vzb-dialog-paragraph">
            <!--p class="vzb-dialog-sublabel" data-localise="hints/mount/howtostack"></p-->
            <label> <input type="radio" name="stack" value="none"> <span data-localise="mount/stacking/none"></span> </label>
            <label> <input type="radio" name="stack" value="bycolor"> <span data-localise="mount/stacking/color"></span> </label>
            <label> <input type="radio" name="stack" value="all" data-localise="mount/stacking/world"> <span data-localise="mount/stacking/world"></span> </label>
          </form>
          
          <form class="vzb-howtomerge vzb-dialog-paragraph">
            <p class="vzb-dialog-sublabel"> <span data-localise="hints/mount/howtomerge"></span></p>
            <label> <input type="radio" name="merge" value="none"> <span data-localise="mount/merging/none"></span> </label>
            <label> <input type="radio" name="merge" value="grouped"> <span data-localise="mount/merging/color"></span> </label>
            <label> <input type="radio" name="merge" value="stacked"> <span data-localise="mount/merging/world"></span> </label>
          </form>
          
          <form class="vzb-manual-sorting">
            <p class="vzb-dialog-sublabel" data-localise="mount/manualSorting"></p>
            <div class="vzb-dialog-draggablelist vzb-dialog-control"></div>
          </form>
        </div>
      </div>
    `;
      config.subcomponents = [
      //   type: DraggableList,
      //   name: "draggablelist",
      //   placeholder: ".vzb-dialog-draggablelist"
      // model: ["state.marker.group", "state.marker.color", "locale", "ui.chart"],
      // groupID: "manualSorting",
      // isEnabled: "manualSortingEnabled",
      // dataArrFn: _this.manualSorting.bind(_this),
      // lang: ""
      ];
     
      super(config);
    }

    setup(options) {
      super.setup(options);
      const _this = this;

      this.DOM.howToStack = this.element.select(".vzb-howtostack").selectAll("input")
        .on("change", function() {
          _this.setModel("stack", d3.select(this).node().value);
        });

      this.DOM.howToMerge = this.element.select(".vzb-howtomerge").selectAll("input")
        .on("change", function() {
          _this.setModel("merge", d3.select(this).node().value);
        });
    }

    get MDL() {
      return {
        color: this.model.encoding.color,
        group: this.model.encoding.group,
        stack: this.model.encoding.stack
      };
    }  

    draw(){
      super.draw();
      this.addReaction(this.updateView);
    }

    updateView() {
      const _this = this;

      this.DOM.howToStack
        .property("checked", function() {
          if (d3.select(this).node().value === "none") 
            return _this.MDL.stack.data.constant === "none";
          if (d3.select(this).node().value === "bycolor") 
            return _this.MDL.stack.data.concept === _this.MDL.color.data.concept;
          if (d3.select(this).node().value === "all") 
            return _this.MDL.stack.data.constant === "all";
        })
        .attr("disabled", function() {
          if (d3.select(this).node().value === "none") 
            return null; // always enabled
          if (d3.select(this).node().value === "all") 
            return null; // always enabled
          if (d3.select(this).node().value === "bycolor")
            return _this.MDL.color.data.isConstant || _this.MDL.color.data.space.length !== 1 ? true : null;
        });

      //_this.ui.chart.manualSortingEnabled = _this.MDL.stack.data.constant == "all";

      this.DOM.howToMerge
        .property("checked", function() {
          if (d3.select(this).node().value === "none") 
            return !_this.MDL.group.config.merge && !_this.MDL.stack.config.merge;
          if (d3.select(this).node().value === "grouped") 
            return _this.MDL.group.config.merge;
          if (d3.select(this).node().value === "stacked") 
            return _this.MDL.stack.config.merge;
        })
        .attr("disabled", function() {
          if (d3.select(this).node().value === "none") 
            return null; // always enabled
          if (d3.select(this).node().value === "grouped") 
            return _this.MDL.stack.data.constant === "none" || _this.MDL.color.data.isConstant || _this.MDL.color.data.space.length !== 1 ? true : null;
          if (d3.select(this).node().value === "stacked") 
            return _this.MDL.stack.data.constant === "all" ? null : true;
        });


    }

    manualSorting(value, persistent = false) {
      if (arguments.length === 0) return this.model.state.marker.group.manualSorting;
      this.model.state.marker.group.set({ manualSorting: value }, false, persistent);
    }

    setModel(what, value) {
      mobx.runInAction(() => {

        if (what === "merge") {
          switch (value) {
          case "none":
            this.MDL.group.config.merge = false;
            this.MDL.stack.config.merge = false;
            break;
          case "grouped":
            this.MDL.group.config.merge = true;
            this.MDL.stack.config.merge = false;
            break;
          case "stacked":
            this.MDL.group.config.merge = false;
            this.MDL.stack.config.merge = true;
            break;
          }
        }

        if (what === "stack") {
          switch (value) {
          case "all":
            this.MDL.stack.config.data.constant = "all";
            this.MDL.stack.config.data.concept = null;
            this.MDL.stack.config.data.space = [];
            break;
          case "none":
            this.MDL.stack.config.data.constant = "none";
            this.MDL.stack.config.data.concept = null;
            this.MDL.stack.config.data.space = [];
            
            this.MDL.group.config.merge = false;
            this.MDL.stack.config.merge = false;
            break;
          case "bycolor":
            this.MDL.stack.config.data.space = this.MDL.color.config.data.space;
            this.MDL.stack.config.data.concept = this.MDL.color.config.data.concept;          
            this.MDL.stack.config.merge = false;
            this.MDL.stack.config.data.constant = null;
            break;
          }
        }

      });
    }
  }
   
  const decorated$4 = mobx.decorate(Stack, {
    "MDL": mobx.computed
  });
  sharedComponents.Dialog.add("stack", decorated$4);

  /*
   * poverty dialog
   */
  class PovertyLine extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title">
          <span data-localise="buttons/povertyline"></span>
        </div>
    
        <div class="vzb-dialog-content">

          <form class="vzb-dialog-paragraph">
            <div class="vzb-povertyline-show"></div>
          </form>

          <p class="vzb-dialog-sublabel">
            <span data-localise="hints/povertylinetype"></span>
          </p>
        
          <form class="vzb-povertylinetype vzb-dialog-paragraph">
            <!--p class="vzb-dialog-sublabel" data-localise="hints/mount/povertylinetype"></p-->
            <label>
              <input type="radio" name="povertyline" value="extreme">
              <span data-localise="mount/povertyline/extreme"></span>
            </label>
            <label>
              <input type="radio" name="povertyline" value="national">
              <span data-localise="mount/povertyline/national"></span>
            </label>
            <label>
              <input type="radio" name="povertyline" value="custom">
              <span data-localise="mount/povertyline/custom"></span>
            </label>
            <div>
              <input type="text" class="vzb-povertylinecustomvalue-field" name="povertylinecustomvalue"/>
              <span data-localise="hints/povertylinecustomvaluedescr"></span>
            </div>
          </form>

          <p class="vzb-dialog-sublabel">
            <span data-localise="hints/povertylinedetails"></span>
          </p>

          <form class="vzb-dialog-paragraph">
            <div class="vzb-povertyline-below-perc"></div>
            <div class="vzb-povertyline-below"></div>
            <div class="vzb-povertyline-above-perc"></div>
            <div class="vzb-povertyline-above"></div>
          </form>


        </div>
      </div>
    `;
      config.subcomponents = [
        {
          type: sharedComponents.SimpleCheckbox,
          placeholder: ".vzb-povertyline-show",
          options: {
            checkbox: "showProbeX",
            submodel: "root.ui.chart"
          }
        },
        {
          type: sharedComponents.SimpleCheckbox,
          placeholder: ".vzb-povertyline-below-perc",
          options: {
            checkbox: "belowProc",
            submodel: "root.ui.chart.probeXDetails"
          }
        },
        {
          type: sharedComponents.SimpleCheckbox,
          placeholder: ".vzb-povertyline-below",
          options: {
            checkbox: "belowCount",
            submodel: "root.ui.chart.probeXDetails"
          }
        },
        {
          type: sharedComponents.SimpleCheckbox,
          placeholder: ".vzb-povertyline-above-perc",
          options: {
            checkbox: "aboveProc",
            submodel: "root.ui.chart.probeXDetails"
          }
        },
        {
          type: sharedComponents.SimpleCheckbox,
          placeholder: ".vzb-povertyline-above",
          options: {
            checkbox: "aboveCount",
            submodel: "root.ui.chart.probeXDetails"
          }
        }
      ];

      super(config);
    }

    setup(options) {
      super.setup(options);
      const _this = this;

      this.DOM.customPovertyLineValue = this.element.select(".vzb-povertylinecustomvalue-field");
      this.DOM.povertyLineType = this.element.select(".vzb-povertylinetype").selectAll("input")
        .on("change", function() {
          _this.setPovetryLineType(d3.select(this).node().value);
        });
    
      this.DOM.customPovertyLineValue
        .on("keypress", function(event) {
          if (event.charCode == 13 || event.keyCode == 13) {
            //this prevents form submission action with subsequent page reload
            event.preventDefault();
            this.blur();
          }
        })
        .on("change", function() {
          if (/^\d+\.*\d*$/.test(this.value)) {
            _this.root.ui.chart.probeXCustom = this.value;
          } else {
            this.value = _this.root.ui.chart.probeXCustom;
          }
        });
    
    }

    get MDL() {
      return {

      };
    }  

    draw(){
      this.localise = this.services.locale.auto();
      super.draw();

      this.addReaction(this.updateCustomPovertyLineValue);
      this.addReaction(this.updateView);
    }

    updateCustomPovertyLineValue() {
      this.DOM.customPovertyLineValue.property("value",
        this.localise(this.root.ui.chart.probeXCustom));
    }

    updateView() {
      const _this = this;
      this.DOM.povertyLineType.property("checked", function() {
        return this.value === _this.root.ui.chart.probeXType;
      });
    }

    setPovetryLineType(value) {
      this.root.ui.chart.probeXType = value;
    }
  }

  const decorated$3 = mobx.decorate(PovertyLine, {
    "MDL": mobx.computed
  });
  sharedComponents.Dialog.add("povertyline", decorated$3);

  /*
   * billionaire dialog
   */
  class BillyDialog extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title">
          <span data-localise="buttons/billy"></span>
        </div>
    
        <div class="vzb-dialog-content">

            <div class="vzb-billy-show"></div>
            <div class="vzb-billy-howmany"></div>
            <div class="vzb-billy-count"></div>

        </div>
      </div>
    `;
      config.subcomponents = [
        {
          type: sharedComponents.SimpleCheckbox,
          placeholder: ".vzb-billy-show",
          options: {
            checkbox: "showBilly",
            submodel: "root.ui.chart"
          }
        },
        {
          type: sharedComponents.SingleHandleSlider,
          placeholder: ".vzb-billy-howmany",
          options: {
            domain: [1, 5, 10, 50, 100, 500, 1000, 2000, 4000],
            //snapValue: true,
            value: "howManyBilly",
            submodel: "root.ui.chart"
          }
        }
      ];

      super(config);
    }

    setup(options) {
      super.setup(options);
      this.DOM.slider = this.element.select(".vzb-billy-howmany");
      this.DOM.count = this.element.select(".vzb-billy-count")
        .on("click", () => {this.root.ui.chart.billyFaces = !this.root.ui.chart.billyFaces;});

      this.defaultHowManyBilly = this.root.ui.chart.howManyBilly;
      this.defaultBillyFaces = this.root.ui.chart.billyFaces;
    }

    get MDL() {
      return {

      };
    }  

    draw(){
      this.localise = this.services.locale.auto();
      super.draw();

      this.addReaction(this.updateVisibility);
      this.addReaction(this.updateCount);
      this.addReaction(this.setModel);
    }

    setModel(){
      const showBilly = this.root.ui.chart.showBilly;  
      mobx.runInAction(() => {
        this.model.encoding.mu.config.scale.domain[1] = showBilly ? 2000000000 : 500;

        //take the bily config out of stash and apply it, so that the data starts loading
        //resetting back to null then for cleaning URL state
        const marker = this.root.model.markers[this.root.options?.markerNames?.billy || "billy"];
        const encs = ["x", "name", "slices"];
        if (showBilly)
          for (let enc of encs)
            marker.encoding[enc].data.config.concept = marker.encoding[enc].data.config.stash;
        else
          for (let enc of encs)
            marker.encoding[enc].data.config.concept = null;

        //for cleaning URL state
        if (!showBilly){
          this.root.ui.chart.howManyBilly = this.defaultHowManyBilly;
          this.root.ui.chart.billyFaces = this.defaultBillyFaces; 
        }
      });
    }

    updateVisibility() {
      const showBilly = this.root.ui.chart.showBilly;  
      this.DOM.slider.classed("vzb-hidden", !showBilly);
      this.DOM.count.classed("vzb-hidden", !showBilly);
      this.findChild({type: "SingleHandleSlider"})._updateSize();
      this.findChild({type: "SingleHandleSlider"})._updateView();
    }

    updateCount(){
      const showBilly = this.root.ui.chart.showBilly; 
      const howMany = this.root.ui.chart.howManyBilly;
      if(showBilly) this.DOM.count.text(Math.round(howMany));
    }

  }

  const decorated$2 = mobx.decorate(BillyDialog, {
    "MDL": mobx.computed
  });
  sharedComponents.Dialog.add("billy", decorated$2);

  /*
   * Dollar Street dialog
   */
  class DollarStreetDialog extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title">
          <span data-localise="buttons/dollarstreet"></span>
        </div>
    
        <div class="vzb-dialog-content">
          <div class="vzb-dialog-flex-container">
            <div class="vzb-ds-show"></div>
            <select class="vzb-ds-topic" name="vzb-ds-topic" id="vzb-ds-topic">
                <option value="families">families</option>
                <option value="homes">homes</option>
                <option value="pets">pets</option>
                <option value="beds">beds</option>
                <option value="toilets">toilets</option>
            </select>
            <div class="vzb-ds-howmany"></div>
            <div class="vzb-ds-count"></div>

          </div>
          <div class="vzb-ds-availability">Data available from 2015</div>
        </div>
      </div>
    `;
      config.subcomponents = [
        {
          type: sharedComponents.SimpleCheckbox,
          placeholder: ".vzb-ds-show",
          options: {
            checkbox: "dsShow",
            submodel: "root.ui.chart"
          }
        },
        {
          type: sharedComponents.SingleHandleSlider,
          placeholder: ".vzb-ds-howmany",
          options: {
            domain: [4, 6, 8, 10, 12, 25, 50, 100, 150, 200, 250],
            snapValue: true,
            value: "dsHowManyHomes",
            submodel: "root.ui.chart"
          }
        }
      ];

      super(config);
    }

    setup(options) {    
      super.setup(options);
      const _this = this;
      this.DOM.checkbox = this.element.select(".vzb-ds-show");
      this.DOM.slider = this.element.select(".vzb-ds-howmany");
      this.DOM.topic = this.element.select(".vzb-ds-topic")
        .on("change", function(){ _this.root.ui.chart.dsTopic = d3.select(this).property("value"); });
      this.DOM.count = this.element.select(".vzb-ds-count");

      this.defaultHowManyHomes = this.root.ui.chart.dsHowManyHomes;
    }

    get MDL() {
      return {

      };
    }  

    draw(){
      this.localise = this.services.locale.auto();
      super.draw();

      this.addReaction(this.updateVisibility);
      this.addReaction(this.updateCount);
      this.addReaction(this.setModel);
    }

    setModel(){
      const show = this.root.ui.chart.dsShow;  
      mobx.runInAction(() => {

        //for cleaning URL state
        if (!show){
          this.root.ui.chart.dsHowManyHomes = this.defaultHowManyHomes;
        }
      });
    }

    updateVisibility() {
      const show = this.root.ui.chart.dsShow;  
      this.DOM.slider.classed("vzb-hidden", !show);
      this.DOM.count.classed("vzb-hidden", !show);
      this.DOM.topic.classed("vzb-hidden", !show);
      this.DOM.checkbox.style("flex-basis", !show ? "240px" : "90px");
      this.findChild({type: "SingleHandleSlider"})._updateSize();
      this.findChild({type: "SingleHandleSlider"})._updateView();
    }

    updateCount(){
      const show = this.root.ui.chart.dsShow; 
      const howMany = this.root.ui.chart.dsHowManyHomes;
      if(show) this.DOM.count.text(Math.round(howMany));

      this.children[0].options.labelText = show ? "ds/show" : null;
      this.children[0]._updateView();

      this.DOM.topic.property("value", this.root.ui.chart.dsTopic);
    }

  }

  const decorated$1 = mobx.decorate(DollarStreetDialog, {
    "MDL": mobx.computed
  });
  sharedComponents.Dialog.add("dollarstreet", decorated$1);

  const ICONS = {
    "show_countries--stack_none--facet_none":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Loose countries</title>
      <path stroke-width="3" d="M -270.984 459.336 C -264.363 459.336 -257.742 459.335 -251.121 459.335 C -227.286 459.334 -203.451 459.333 -179.616 459.33 C -100.167 459.32 -20.715 459.432 58.734 459.16 C 82.506 459.079 106.504 459.589 130.239 458.012 C 144.186 457.085 165.112 455.443 177.908 448.881 C 223.313 425.596 237.277 363.508 249.413 320.126 C 267.659 254.902 278.549 187.756 297.083 122.613 C 303.712 99.314 309.364 75.252 320.918 53.962 C 325.783 44.997 335.001 31.785 344.753 34.774 C 357.934 38.814 363.16 55.9 368.588 68.572 C 379.229 93.412 385.24 120.007 392.423 146.058 C 411.794 216.307 416.897 255.572 440.093 323.151 C 454.206 364.268 473.761 413.628 511.598 439.542 C 538.524 457.983 575.826 457.356 606.938 458.264 C 670.444 460.117 734.092 459.308 797.618 459.329 C 821.453 459.337 845.288 459.335 869.123 459.336 C 875.744 459.336 882.364 459.337 888.985 459.337 C 890.309 459.337 892.958 459.337 892.958 459.337 C 892.958 459.337 890.309 459.337 888.985 459.337 C 882.364 459.337 875.744 459.337 869.123 459.337 C 861.178 459.337 853.233 459.337 845.288 459.337 C 781.728 459.337 718.168 459.337 654.608 459.337 C 416.258 459.337 177.909 459.337 -60.441 459.337 C -116.056 459.337 -171.671 459.337 -227.286 459.337 C -235.231 459.337 -243.176 459.337 -251.121 459.337 C -257.742 459.337 -264.363 459.337 -270.984 459.337 C -272.309 459.337 -272.309 459.336 -270.984 459.336 Z" />
      <path stroke-width="3" d="M -289.192 459.337 C -289.192 459.337 -286.883 459.337 -285.729 459.337 C -279.957 459.337 -274.184 459.338 -268.412 459.337 C -261.485 459.336 -254.559 459.334 -247.632 459.333 C -226.852 459.331 -206.071 459.336 -185.291 459.333 C -150.669 459.327 -116.004 459.721 -81.39 458.86 C -41.572 457.869 -1.616 456.161 22.511 418.96 C 53.266 371.539 63.039 313.493 84.852 262.146 C 90.728 248.315 95.629 233.354 105.631 222.139 C 110.468 216.716 120.205 211.769 126.411 215.549 C 143.813 226.146 164.921 294.751 167.971 303.147 C 189.087 361.283 203.126 435.137 271.873 452.813 C 311.478 462.996 356.035 459.161 396.554 459.259 C 472.748 459.444 548.943 459.33 625.137 459.337 C 652.844 459.34 680.55 459.337 708.257 459.337 C 714.029 459.337 719.802 459.337 725.574 459.337 C 726.729 459.337 729.038 459.337 729.038 459.337 C 729.038 459.337 726.729 459.337 725.574 459.337 C 719.802 459.337 714.029 459.337 708.257 459.337 C 694.404 459.337 680.55 459.337 666.697 459.337 C 611.283 459.337 555.869 459.337 500.455 459.337 C 237.239 459.337 -289.192 459.337 -289.192 459.337 Z" />
    </svg>
  `,

    "show_regions--stack_none--facet_none":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Loose Regions</title>
      <path stroke-width="3" id="asia" d="M -274.956 459.251 C -274.956 459.251 -272.506 459.251 -271.28 459.251 C -265.155 459.251 -259.029 459.251 -252.902 459.251 C -245.551 459.248 -238.2 459.248 -230.847 459.245 C -208.793 459.242 -186.74 459.239 -164.686 459.233 C -113.228 459.214 -61.764 459.6 -10.307 458.784 C 18.561 458.329 49.51 461.961 77.91 448.917 C 85.425 445.467 93.106 441.952 99.964 434.559 C 138.642 392.868 151.063 298.559 166.125 220.071 C 172.854 185.01 187.79 72.222 210.234 42.951 C 216.508 34.768 225.362 39.828 232.288 45.122 C 240.625 51.493 247.281 65.285 254.342 76.665 C 268.023 98.711 286.439 135.234 298.45 160.788 C 320.959 208.674 340.773 262.704 364.613 307.744 C 401.773 377.952 447.315 435.222 496.937 449.944 C 526.067 458.585 555.811 458.19 585.154 458.679 C 621.909 459.293 658.668 459.191 695.425 459.225 C 717.479 459.245 739.533 459.245 761.587 459.248 C 768.939 459.248 776.29 459.251 783.641 459.251 C 789.768 459.251 795.893 459.251 802.02 459.251 C 802.02 459.251 805.696 459.251 805.695 459.251 C 445.478 459.444 -274.956 459.251 -274.956 459.251 Z" />
      <path stroke-width="3" id="africa" d="M -271.279 459.134 C -265.154 459.134 -259.028 459.131 -252.901 459.128 C -230.846 459.122 -208.792 459.117 -186.739 459.088 C -135.312 459.026 -83.759 460.627 -32.361 456.42 C 5.656 453.306 42.81 445.453 77.91 411.808 C 112.763 378.398 147.514 317.826 188.181 327.537 C 212.879 333.439 232.67 366.825 254.343 389.181 C 275.396 410.9 297.621 428.12 320.505 438.621 C 356.54 455.157 394.084 455.866 430.777 457.353 C 489.572 459.737 548.406 459.043 607.209 459.097 C 658.668 459.148 710.128 459.139 761.588 459.142 C 768.94 459.142 776.291 459.142 783.642 459.142 C 789.769 459.142 795.894 459.142 802.021 459.142 C 803.245 459.142 805.696 459.142 805.696 459.142 C 805.696 459.142 803.245 459.142 802.021 459.142 C 795.894 459.142 789.769 459.142 783.642 459.142 C 776.291 459.142 768.94 459.142 761.588 459.142 C 702.777 459.142 643.966 459.142 585.155 459.142 C 364.614 459.142 144.072 459.142 -76.469 459.142 C -127.928 459.142 -179.387 459.142 -230.846 459.142 C -238.199 459.142 -245.55 459.142 -252.901 459.142 C -259.028 459.142 -265.154 459.142 -271.279 459.142 C -272.505 459.142 -272.507 459.134 -271.279 459.134 Z" />
      <!--path stroke-width="3" id="europe" d="M -271.278 457.281 C -265.153 457.281 -259.028 457.278 -252.901 457.278 C -245.55 457.278 -238.199 457.276 -230.846 457.276 C -179.387 457.273 -127.927 457.267 -76.468 457.259 C -17.658 457.25 41.155 457.48 99.965 456.983 C 136.631 456.673 173.736 458.132 210.236 449.533 C 243.708 441.652 267.163 419.381 298.452 398.208 C 325.879 379.652 357.908 372.624 386.669 377.374 C 411.054 381.401 430.537 403.581 452.831 422.032 C 474.51 439.974 495.837 449.161 518.994 453.043 C 584.682 464.054 651.632 457.267 717.48 457.278 C 739.534 457.281 761.588 457.281 783.642 457.281 C 789.769 457.281 795.895 457.281 802.021 457.281 C 802.021 457.281 805.697 457.284 805.696 457.284 C 563.101 457.412 320.506 457.284 77.911 457.284 C -10.306 457.284 -98.522 457.284 -186.739 457.284 C -208.792 457.284 -230.846 457.284 -252.901 457.284 C -259.028 457.284 -265.153 457.284 -271.278 457.284 C -272.506 457.284 -272.506 457.281 -271.278 457.281 Z" /-->
      <path stroke-width="3" id="americas" d="M -271.279 459.2 C -265.154 459.197 -259.029 459.197 -252.902 459.197 C -242.297 459.194 -219.399 459.189 -208.793 459.183 C -157.334 459.157 -105.874 459.149 -54.414 458.975 C 18.835 458.725 93.369 462.653 166.126 442.075 C 210.63 429.489 253.138 397.109 298.451 397.408 C 320.511 397.553 342.573 402.536 364.614 404.146 C 386.647 405.759 408.827 404.26 430.776 409.408 C 460.684 416.425 489.334 436.38 518.993 446.233 C 548.122 455.912 577.777 457.28 607.209 458.227 C 658.657 459.886 710.136 459.192 761.587 459.2 C 768.94 459.203 776.291 459.203 783.642 459.203 C 789.769 459.203 795.894 459.203 802.02 459.203 C 803.245 459.203 805.696 459.203 805.696 459.203 C 805.696 459.203 803.245 459.203 802.02 459.203 C 795.894 459.203 789.769 459.203 783.642 459.203 C 776.291 459.203 768.94 459.203 761.587 459.203 C 702.777 459.203 643.966 459.203 585.155 459.203 C 364.614 459.203 144.072 459.203 -76.469 459.203 C -127.928 459.203 -179.388 459.203 -230.847 459.203 C -238.2 459.203 -245.551 459.203 -252.902 459.203 C -259.029 459.203 -265.154 459.203 -271.279 459.203 C -272.507 459.203 -272.507 459.2 -271.279 459.2 Z" />
    </svg>
  `,

    "show_countries--stack_region--facet_none":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Countries stacked in regions</title>
      <path stroke-width="6" id="asia" d="M -274.956 459.251 C -274.956 459.251 -272.506 459.251 -271.28 459.251 C -265.155 459.251 -259.029 459.251 -252.902 459.251 C -245.551 459.248 -238.2 459.248 -230.847 459.245 C -208.793 459.242 -186.74 459.239 -164.686 459.233 C -113.228 459.214 -61.764 459.6 -10.307 458.784 C 18.561 458.329 49.51 461.961 77.91 448.917 C 85.425 445.467 93.106 441.952 99.964 434.559 C 138.642 392.868 151.063 298.559 166.125 220.071 C 172.854 185.01 187.79 72.222 210.234 42.951 C 216.508 34.768 225.362 39.828 232.288 45.122 C 240.625 51.493 247.281 65.285 254.342 76.665 C 268.023 98.711 286.439 135.234 298.45 160.788 C 320.959 208.674 340.773 262.704 364.613 307.744 C 401.773 377.952 447.315 435.222 496.937 449.944 C 526.067 458.585 555.811 458.19 585.154 458.679 C 621.909 459.293 658.668 459.191 695.425 459.225 C 717.479 459.245 739.533 459.245 761.587 459.248 C 768.939 459.248 776.29 459.251 783.641 459.251 C 789.768 459.251 795.893 459.251 802.02 459.251 C 802.02 459.251 805.696 459.251 805.695 459.251 C 445.478 459.444 -274.956 459.251 -274.956 459.251 Z" />
      <path stroke-width="3" id="chn" d="M -274.956 459.166 C -274.956 459.166 -272.507 459.166 -271.281 459.166 C -265.155 459.166 -259.028 459.166 -252.902 459.166 C -245.549 459.164 -238.2 459.164 -230.848 459.161 C -208.794 459.158 -186.74 459.158 -164.685 459.147 C -113.228 459.128 -61.764 459.513 -10.306 458.703 C 18.561 458.245 49.509 461.874 77.909 448.839 C 85.424 445.39 93.106 441.877 99.964 434.488 C 138.642 392.812 151.063 298.545 166.124 220.093 C 172.855 185.047 187.789 72.309 210.233 43.051 C 216.507 34.873 225.362 39.929 232.286 45.221 C 242.165 52.77 269.444 103.019 276.397 116.272 C 307.761 176.066 333.174 248.357 364.613 307.729 C 388.718 353.254 422.703 402.133 452.83 427.216 C 487.508 456.082 526.421 456.736 563.099 458.097 C 614.544 460.011 666.029 459.131 717.478 459.158 C 739.533 459.166 761.587 459.164 783.641 459.166 C 789.767 459.166 795.892 459.166 802.019 459.166 C 803.244 459.166 805.695 459.166 805.695 459.166 C 805.695 459.166 803.244 459.166 802.019 459.166 C 795.892 459.166 789.767 459.166 783.641 459.166 C 761.587 459.164 739.533 459.164 717.478 459.158 C 673.372 459.144 629.26 459.334 585.155 458.754 C 548.412 458.273 511.225 458.457 474.883 445.342 C 452.18 437.145 431.057 419.764 408.721 408.953 C 386.959 398.42 363.824 403.414 342.559 388.345 C 324.811 375.776 311.797 356.219 298.451 328.26 C 279.962 289.534 268.864 251.532 254.342 205.68 C 246.89 182.151 240.887 156.36 232.286 134.671 C 226.043 118.92 219.89 96.06 210.233 94.43 C 186.17 90.358 167.12 225.476 166.124 230.194 C 150.081 306.212 138.015 394.935 99.964 434.963 C 87.481 448.096 69.444 452.315 55.856 454.839 C 26.628 460.279 -3.054 458.739 -32.362 458.947 C -113.225 459.525 -274.956 459.166 -274.956 459.166 Z" />
      <path stroke-width="2" id="idn" d="M -274.956 458.147 C -274.956 458.147 -272.507 458.147 -271.281 458.147 C -265.155 458.147 -259.028 458.147 -252.902 458.147 C -230.848 458.147 -208.794 458.142 -186.74 458.139 C -120.589 458.125 -54.4 459.305 11.748 457.328 C 55.647 456.017 106.349 459.865 144.071 403.904 C 165.912 371.507 182.451 311.405 210.233 299.319 C 225.162 292.823 241.358 307.915 254.342 319.935 C 283.865 347.271 310.151 388.422 342.559 400.149 C 364.606 408.131 386.659 401.242 408.721 410.483 C 439.056 423.191 465.456 443.98 496.937 450.92 C 555.252 463.776 614.831 458.062 673.371 458.125 C 710.127 458.165 746.883 458.147 783.641 458.147 C 789.767 458.147 795.892 458.147 802.019 458.147 C 803.244 458.147 805.695 458.147 805.695 458.147 C 805.695 458.147 803.244 458.147 802.019 458.147 C 795.892 458.147 789.767 458.147 783.641 458.147 C 768.939 458.147 754.235 458.147 739.533 458.147 C 673.418 458.142 607.136 460.761 541.046 456.526 C 511.395 454.626 481.812 449.996 452.83 435.791 C 447.498 433.18 414.131 413.415 408.721 411.285 C 379.333 399.723 349.899 412.15 320.505 398.013 C 297.751 387.069 276.339 366.647 254.342 350.755 C 240.894 341.042 224.981 328.143 210.233 332.04 C 183.69 339.054 166.206 386.184 144.071 412.272 C 129.684 429.232 115.947 437.504 99.964 444.182 C 49.84 465.127 -3.605 457.886 -54.415 458.039 C -127.929 458.261 -274.956 458.147 -274.956 458.147 Z" />
      <path stroke-width="1" id="bgd" d="M -274.956 458.539 C -274.956 458.539 -272.507 458.539 -271.281 458.539 C -265.155 458.539 -259.028 458.539 -252.902 458.539 C -230.848 458.539 -208.794 458.534 -186.74 458.531 C -120.588 458.517 -54.4 459.677 11.748 457.726 C 55.894 456.42 101.94 454.822 144.071 423.242 C 174.133 400.706 199.159 363.566 232.286 364.496 C 262.599 365.343 291.069 389.816 320.505 401.341 C 349.956 412.871 379.413 400.573 408.721 411.902 C 431.07 420.54 452.36 437.651 474.883 445.387 C 518.479 460.365 563.195 458.101 607.208 458.349 C 658.667 458.633 710.127 458.539 761.587 458.539 C 768.939 458.539 776.29 458.539 783.641 458.539 C 789.767 458.539 795.892 458.539 802.019 458.539 C 803.244 458.539 805.695 458.539 805.695 458.539 C 805.695 458.539 803.244 458.539 802.019 458.539 C 795.892 458.539 789.767 458.539 783.641 458.539 C 768.939 458.539 754.235 458.539 739.533 458.539 C 673.418 458.534 607.137 461.151 541.046 456.935 C 511.395 455.041 481.819 450.419 452.83 436.306 C 446.88 433.41 414.765 414.379 408.721 412.075 C 386.472 403.591 364.892 411.378 342.559 408.941 C 312.763 405.69 284.265 384.767 254.342 383.791 C 223.521 382.785 195.481 402.191 166.124 418.967 C 137.223 435.484 107.717 446.192 77.909 451.858 C 26.716 461.591 -25.128 458.403 -76.47 458.474 C -142.632 458.574 -274.956 458.539 -274.956 458.539 Z" />
      <path stroke-width="6" id="africa" d="M -271.279 459.134 C -265.154 459.134 -259.028 459.131 -252.901 459.128 C -230.846 459.122 -208.792 459.117 -186.739 459.088 C -135.312 459.026 -83.759 460.627 -32.361 456.42 C 5.656 453.306 42.81 445.453 77.91 411.808 C 112.763 378.398 147.514 317.826 188.181 327.537 C 212.879 333.439 232.67 366.825 254.343 389.181 C 275.396 410.9 297.621 428.12 320.505 438.621 C 356.54 455.157 394.084 455.866 430.777 457.353 C 489.572 459.737 548.406 459.043 607.209 459.097 C 658.668 459.148 710.128 459.139 761.588 459.142 C 768.94 459.142 776.291 459.142 783.642 459.142 C 789.769 459.142 795.894 459.142 802.021 459.142 C 803.245 459.142 805.696 459.142 805.696 459.142 C 805.696 459.142 803.245 459.142 802.021 459.142 C 795.894 459.142 789.769 459.142 783.642 459.142 C 776.291 459.142 768.94 459.142 761.588 459.142 C 702.777 459.142 643.966 459.142 585.155 459.142 C 364.614 459.142 144.072 459.142 -76.469 459.142 C -127.928 459.142 -179.387 459.142 -230.846 459.142 C -238.199 459.142 -245.55 459.142 -252.901 459.142 C -259.028 459.142 -265.154 459.142 -271.279 459.142 C -272.505 459.142 -272.507 459.134 -271.279 459.134 Z" />
      <path stroke-width="3" id="nga" d="M -274.956 457.604 C -274.956 457.604 -272.507 457.604 -271.281 457.604 C -265.155 457.601 -259.028 457.598 -252.902 457.598 C -230.848 457.589 -208.794 457.584 -186.74 457.555 C -121.08 457.479 -53.554 465.423 11.746 448.365 C 43.839 439.983 71.399 418.162 99.962 386.673 C 127.14 356.717 156.046 318.731 188.179 326.382 C 212.878 332.267 232.67 365.557 254.342 387.85 C 275.394 409.507 297.62 426.675 320.505 437.148 C 356.539 453.633 394.084 454.344 430.775 455.826 C 489.571 458.204 548.406 457.51 607.208 457.567 C 658.667 457.612 710.127 457.607 761.587 457.609 C 768.939 457.609 776.29 457.612 783.641 457.612 C 789.767 457.612 795.892 457.612 802.019 457.612 C 803.244 457.612 805.695 457.612 805.695 457.612 C 805.695 457.612 803.244 457.612 802.019 457.612 C 795.892 457.612 789.767 457.612 783.641 457.612 C 771.586 457.612 751.586 457.609 739.533 457.609 C 673.371 457.604 607.208 457.683 541.046 457.439 C 496.946 457.277 452.806 457.587 408.721 454.757 C 379.26 452.865 349.48 450.359 320.505 437.907 C 297.814 428.162 275.801 412.195 254.342 393.971 C 232.48 375.409 212.4 350.547 188.179 349.637 C 157.479 348.488 127.893 378.02 99.962 400.994 C 78.262 418.844 56.802 434.335 33.8 442.802 C -9.629 458.787 -54.608 456.679 -98.523 457.194 C -157.333 457.888 -274.956 457.604 -274.956 457.604 Z" />
      <path stroke-width="2" id="tza" d="M -274.956 458.327 C -274.956 458.327 -272.507 458.327 -271.281 458.327 C -265.155 458.324 -259.028 458.324 -252.902 458.321 C -230.848 458.318 -208.794 458.307 -186.74 458.284 C -120.776 458.219 -54.072 463.142 11.746 452.243 C 34.143 448.537 56.178 441.722 77.908 429.383 C 107.323 412.679 135.152 385.083 166.124 383.906 C 222.416 381.761 285.449 434.688 342.559 447.828 C 379.104 456.242 416.112 456.489 452.83 457.314 C 504.285 458.469 555.75 458.244 607.208 458.29 C 658.667 458.335 710.127 458.33 761.587 458.332 C 768.939 458.332 776.29 458.335 783.641 458.335 C 789.767 458.335 795.892 458.335 802.019 458.335 C 803.244 458.335 805.695 458.335 805.695 458.335 C 805.695 458.335 803.244 458.335 802.019 458.335 C 795.892 458.335 789.767 458.335 783.641 458.335 C 771.586 458.335 751.586 458.332 739.533 458.332 C 673.371 458.33 607.208 458.392 541.046 458.173 C 468.123 457.923 392.776 466.086 320.505 441.992 C 269.532 424.994 218.32 386.38 166.124 391.062 C 143.234 393.116 121.896 407.832 99.962 420.205 C 78.118 432.529 56.271 442.518 33.8 448.107 C -10.002 459.001 -54.497 457.624 -98.523 458 C -157.334 458.503 -274.956 458.327 -274.956 458.327 Z" />
      <path stroke-width="1" id="mar" d="M -274.956 457.12 C -274.956 457.12 -272.507 457.12 -271.281 457.12 C -265.155 457.12 -259.028 457.117 -252.902 457.114 C -230.848 457.108 -208.794 457.1 -186.74 457.08 C -120.699 457.014 -54.192 460.809 11.746 451.644 C 63.152 444.502 115.811 409.939 166.124 412.035 C 225.139 414.498 283.699 442.216 342.559 450.723 C 437.704 464.481 533.952 457.1 629.262 457.12 C 673.371 457.128 717.478 457.128 761.587 457.128 C 768.939 457.128 776.29 457.128 783.641 457.128 C 789.767 457.128 795.892 457.128 802.019 457.128 C 803.244 457.128 805.695 457.128 805.695 457.128 C 805.695 457.128 803.244 457.128 802.019 457.128 C 795.892 457.128 789.767 457.128 783.641 457.128 C 768.939 457.128 754.235 457.128 739.533 457.128 C 673.371 457.128 607.208 457.142 541.046 457.086 C 467.623 457.02 393.793 460.59 320.505 449.469 C 290.99 444.992 261.599 437.662 232.286 429.129 C 210.329 422.738 188.329 414.364 166.124 412.814 C 136.118 410.724 107.304 424.555 77.908 434.965 C 55.944 442.75 33.972 448.558 11.746 451.644 C -82.753 464.771 -274.956 457.12 -274.956 457.12 Z" />
      <path stroke-width="1" id="sen" d="M -274.956 458.465 C -274.956 458.465 -272.507 458.465 -271.281 458.465 C -265.155 458.463 -259.028 458.463 -252.902 458.46 C -230.848 458.457 -208.794 458.454 -186.74 458.445 C -120.596 458.417 -54.38 459.922 11.746 456.09 C 63.224 453.107 114.627 439.525 166.124 440.487 C 224.941 441.582 283.744 452.819 342.559 456.022 C 438.067 461.224 533.73 458.46 629.262 458.465 C 673.371 458.468 717.478 458.468 761.587 458.468 C 768.939 458.468 776.29 458.468 783.641 458.468 C 789.767 458.468 795.892 458.468 802.019 458.468 C 803.244 458.468 805.695 458.468 805.695 458.468 C 805.695 458.468 803.244 458.468 802.019 458.468 C 795.892 458.468 789.767 458.468 783.641 458.468 C 768.939 458.468 754.235 458.468 739.533 458.468 C 680.721 458.468 621.911 458.474 563.099 458.457 C 489.6 458.44 416.044 459.865 342.559 456.164 C 283.74 453.198 224.945 444.056 166.124 442.367 C 114.617 440.885 63.217 453.226 11.746 456.142 C -83.751 461.54 -274.956 458.465 -274.956 458.465 Z" />
      <path stroke-width="6" id="europe" d="M -271.278 457.281 C -265.153 457.281 -259.028 457.278 -252.901 457.278 C -245.55 457.278 -238.199 457.276 -230.846 457.276 C -179.387 457.273 -127.927 457.267 -76.468 457.259 C -17.658 457.25 41.155 457.48 99.965 456.983 C 136.631 456.673 173.736 458.132 210.236 449.533 C 243.708 441.652 267.163 419.381 298.452 398.208 C 325.879 379.652 357.908 372.624 386.669 377.374 C 411.054 381.401 430.537 403.581 452.831 422.032 C 474.51 439.974 495.837 449.161 518.994 453.043 C 584.682 464.054 651.632 457.267 717.48 457.278 C 739.534 457.281 761.588 457.281 783.642 457.281 C 789.769 457.281 795.895 457.281 802.021 457.281 C 802.021 457.281 805.697 457.284 805.696 457.284 C 563.101 457.412 320.506 457.284 77.911 457.284 C -10.306 457.284 -98.522 457.284 -186.739 457.284 C -208.792 457.284 -230.846 457.284 -252.901 457.284 C -259.028 457.284 -265.153 457.284 -271.278 457.284 C -272.506 457.284 -272.506 457.281 -271.278 457.281 Z" />
      <path stroke-width="3" id="rus" d="M -274.956 458.336 C -274.956 458.336 -272.506 458.336 -271.279 458.336 C -265.154 458.336 -259.028 458.332 -252.902 458.332 C -230.848 458.329 -208.794 458.327 -186.74 458.327 C -120.578 458.318 -54.415 458.332 11.748 458.281 C 55.85 458.246 99.971 458.771 144.072 457.278 C 173.441 456.284 203.326 455.504 232.287 443.615 C 255.543 434.068 276.1 413.344 298.452 397.862 C 325.878 378.865 357.907 371.666 386.668 376.529 C 418.603 381.93 444.657 420.593 474.884 438.828 C 517.196 464.363 563.74 457.872 607.208 458.144 C 658.667 458.46 710.127 458.336 761.587 458.336 C 768.939 458.336 776.29 458.336 783.641 458.336 C 789.767 458.336 795.893 458.336 802.02 458.336 C 803.244 458.336 805.695 458.336 805.695 458.336 C 805.695 458.336 803.244 458.336 802.02 458.336 C 795.893 458.336 789.767 458.336 783.641 458.336 C 768.939 458.336 754.235 458.336 739.533 458.336 C 673.437 458.327 607.11 461.514 541.046 456.56 C 518.844 454.893 496.47 452.23 474.884 439.776 C 444.825 422.428 418.69 384.937 386.668 385.187 C 341.192 385.547 298.319 422.138 254.342 440.376 C 239.88 446.374 224.901 449.718 210.234 452.152 C 144.389 463.076 77.733 458.232 11.748 458.281 C -83.821 458.359 -274.956 458.336 -274.956 458.336 Z" />
      <path stroke-width="6" id="americas" d="M -271.279 459.2 C -265.154 459.197 -259.029 459.197 -252.902 459.197 C -242.297 459.194 -219.399 459.189 -208.793 459.183 C -157.334 459.157 -105.874 459.149 -54.414 458.975 C 18.835 458.725 93.369 462.653 166.126 442.075 C 210.63 429.489 253.138 397.109 298.451 397.408 C 320.511 397.553 342.573 402.536 364.614 404.146 C 386.647 405.759 408.827 404.26 430.776 409.408 C 460.684 416.425 489.334 436.38 518.993 446.233 C 548.122 455.912 577.777 457.28 607.209 458.227 C 658.657 459.886 710.136 459.192 761.587 459.2 C 768.94 459.203 776.291 459.203 783.642 459.203 C 789.769 459.203 795.894 459.203 802.02 459.203 C 803.245 459.203 805.696 459.203 805.696 459.203 C 805.696 459.203 803.245 459.203 802.02 459.203 C 795.894 459.203 789.769 459.203 783.642 459.203 C 776.291 459.203 768.94 459.203 761.587 459.203 C 702.777 459.203 643.966 459.203 585.155 459.203 C 364.614 459.203 144.072 459.203 -76.469 459.203 C -127.928 459.203 -179.388 459.203 -230.847 459.203 C -238.2 459.203 -245.551 459.203 -252.902 459.203 C -259.029 459.203 -265.154 459.203 -271.279 459.203 C -272.507 459.203 -272.507 459.2 -271.279 459.2 Z" />
      <path stroke-width="3" id="usa" d="M -271.279 459.009 C -265.154 459.009 -259.028 459.009 -252.902 459.006 C -242.296 459.006 -219.4 459 -208.794 458.992 C -157.334 458.967 -105.874 458.961 -54.415 458.788 C 18.836 458.538 93.371 462.444 166.125 441.988 C 210.631 429.475 253.138 397.284 298.452 397.583 C 320.512 397.727 342.572 402.681 364.613 404.284 C 386.647 405.885 408.828 404.395 430.776 409.513 C 460.682 416.488 489.333 436.325 518.993 446.119 C 548.12 455.742 577.777 457.101 607.209 458.044 C 658.656 459.69 710.135 459.003 761.588 459.009 C 768.94 459.012 776.291 459.012 783.641 459.012 C 789.768 459.012 795.893 459.014 802.02 459.014 C 803.244 459.014 805.696 459.014 805.696 459.014 C 805.696 459.014 803.244 459.014 802.02 459.014 C 795.893 459.014 789.768 459.012 783.641 459.012 C 776.291 459.012 768.94 459.012 761.588 459.012 C 717.48 459.009 673.372 459.049 629.264 458.928 C 555.608 458.729 481.928 459.5 408.722 440.217 C 364.773 428.637 321.05 396.923 276.397 401.446 C 239.055 405.23 203.082 431.998 166.125 442.244 C 122.387 454.374 77.871 456.457 33.802 457.808 C -47.046 460.29 -127.94 459.003 -208.794 459.009 C -223.497 459.009 -238.2 459.012 -252.902 459.012 C -259.028 459.012 -265.154 459.012 -271.279 459.012 C -272.507 459.012 -272.507 459.009 -271.279 459.009 Z" />
      <path stroke-width="2" id="mex" d="M -274.956 457.782 C -274.956 457.782 -272.506 457.782 -271.279 457.782 C -265.154 457.782 -259.028 457.782 -252.902 457.782 C -230.848 457.779 -208.794 457.779 -186.74 457.776 C -120.579 457.764 -54.414 458.129 11.748 457.27 C 63.188 456.598 114.896 455.739 166.125 444.769 C 202.895 436.899 239.331 416.218 276.397 415.786 C 320.556 415.274 364.708 438.008 408.722 444.985 C 482.228 456.635 555.593 457.651 629.264 457.747 C 673.372 457.801 717.48 457.779 761.588 457.782 C 768.94 457.782 776.291 457.784 783.641 457.784 C 789.768 457.784 795.893 457.784 802.02 457.784 C 803.244 457.784 805.696 457.784 805.696 457.784 C 805.696 457.784 803.244 457.784 802.02 457.784 C 795.893 457.784 789.768 457.784 783.641 457.784 C 783.641 457.784 739.533 457.784 739.533 457.784 C 673.374 457.779 607.206 458.419 541.046 457.312 C 489.54 456.448 438.068 451.157 386.668 444.189 C 349.917 439.205 313.286 429.148 276.397 430.684 C 217.549 433.136 158.85 449.954 99.964 454.155 C -24.861 463.066 -274.956 457.782 -274.956 457.782 Z" />
      <path stroke-width="1" id="chl" d="M -274.956 458.551 C -274.956 458.551 -272.506 458.551 -271.279 458.551 C -265.154 458.551 -259.028 458.551 -252.902 458.551 C -230.848 458.551 -208.794 458.549 -186.74 458.549 C -120.578 458.549 -54.415 458.651 11.748 458.438 C 63.21 458.273 114.689 458.039 166.125 454.143 C 202.88 451.361 239.613 445.297 276.397 444.634 C 320.561 443.841 364.605 452.627 408.722 455.542 C 482.183 460.397 555.777 458.52 629.264 458.543 C 673.372 458.557 717.48 458.551 761.588 458.551 C 768.94 458.551 776.291 458.551 783.641 458.551 C 789.768 458.551 795.893 458.551 802.02 458.551 C 803.244 458.551 805.696 458.551 805.696 458.551 C 805.696 458.551 803.244 458.551 802.02 458.551 C 795.893 458.551 789.768 458.551 783.641 458.551 C 768.94 458.551 754.236 458.551 739.533 458.551 C 680.723 458.551 621.912 458.583 563.1 458.512 C 504.296 458.438 445.446 459.149 386.668 454.948 C 349.913 452.322 313.183 446.486 276.397 446.216 C 217.589 445.792 158.781 455.764 99.964 457.417 C -24.981 460.926 -274.956 458.551 -274.956 458.551 Z" />
      <path stroke-width="1" id="hnd" d="M -274.956 459.332 C -274.956 459.332 -272.506 459.332 -271.279 459.332 C -265.154 459.332 -259.028 459.332 -252.902 459.332 C -230.848 459.332 -208.794 459.332 -186.74 459.332 C -120.578 459.327 -54.415 459.364 11.748 459.29 C 99.976 459.19 188.179 455.126 276.397 454.691 C 394 454.107 511.643 459.321 629.264 459.327 C 673.372 459.332 717.48 459.332 761.588 459.332 C 768.94 459.332 776.291 459.332 783.641 459.332 C 789.768 459.332 795.893 459.332 802.02 459.332 C 803.244 459.332 805.696 459.332 805.696 459.332 C 805.696 459.332 803.244 459.332 802.02 459.332 C 795.893 459.332 789.768 459.332 783.641 459.332 C 768.94 459.332 754.236 459.332 739.533 459.332 C 680.723 459.332 621.912 459.349 563.1 459.31 C 467.537 459.247 371.949 454.591 276.397 455.467 C 92.61 457.157 -274.956 459.332 -274.956 459.332 Z" />
    </svg>
  `,

    "show_countries--stack_all--facet_none":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Countries in one stack</title>
      <path stroke-width="4" id="asia" d="M -89.945 459.085 C -89.945 458.307 -88.389 459.084 -87.611 459.083 C -83.72 459.08 -79.83 459.078 -75.939 459.074 C -71.271 459.069 -66.602 459.064 -61.934 459.058 C -47.929 459.039 -33.925 459.019 -19.92 458.964 C 7.959 458.855 36.376 459.767 64.112 456.483 C 78.61 454.766 93.803 451.824 106.129 443.405 C 118.295 435.095 126.924 424.433 134.139 411.548 C 173.541 341.184 178.801 245.539 190.16 168.194 C 194.72 137.147 197.624 105.791 204.165 75.1 C 207.001 61.791 208.458 46.286 218.171 36.755 C 222.387 32.618 228.644 42.879 232.176 47.614 C 232.823 48.481 259.802 100.533 260.186 101.332 C 277.43 137.214 288.799 174.721 302.201 212.089 C 314.196 245.535 330.805 275.843 344.218 308.61 C 351.46 326.3 364.657 364.833 372.228 382.521 C 376.431 392.341 380.94 402.066 386.233 411.345 C 393.66 424.364 401.989 435.669 414.244 444.394 C 437.416 460.891 471.329 458.385 498.276 458.786 C 521.616 459.133 544.961 459.082 568.302 459.089 C 572.97 459.091 577.639 459.091 582.307 459.092 C 586.197 459.093 590.087 459.093 593.977 459.094 C 594.755 459.094 596.312 458.317 596.312 459.095 C 596.312 459.873 594.755 459.095 593.977 459.095 C 590.087 459.095 586.197 459.094 582.307 459.094 C 577.639 459.093 572.97 459.093 568.302 459.092 C 540.295 459.086 512.274 459.229 484.271 458.655 C 461.267 458.184 435.11 458.789 414.244 447.491 C 380.847 429.408 371.421 390.81 344.218 366.926 C 333.344 357.378 329.19 358.641 316.207 355.759 C 306.754 353.66 297.634 350.221 288.196 348.056 C 272.811 344.527 261.292 349.51 246.182 349.446 C 231.483 349.384 218.925 337.815 204.165 341.337 C 199.043 342.56 194.383 345.503 190.16 348.649 C 155.453 374.501 144.342 422.707 106.129 445.008 C 85.395 457.108 59.381 457.595 36.102 458.337 C -5.873 459.675 -89.945 459.863 -89.945 459.085 Z" />
      <path stroke-width="2" id="chn" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.677 -103.781 459.673 C -98.705 459.668 -93.628 459.663 -88.552 459.657 C -73.323 459.639 -58.094 459.619 -42.865 459.563 C -12.53 459.452 18.305 460.373 48.508 457.074 C 71.072 454.609 93.159 448.858 109.423 431.797 C 133.683 406.348 146.423 369.039 155.11 336.018 C 170.936 275.86 175.503 231.146 185.567 167.943 C 190.526 136.802 193.697 105.3 200.796 74.576 C 203.9 61.143 205.803 45.372 216.025 36.12 C 220.652 31.932 227.33 42.157 231.254 47.01 C 237.71 54.994 241.43 64.846 246.483 73.784 C 259.206 96.289 266.375 108.072 276.94 132.236 C 293.682 170.529 305.011 210.948 322.627 248.877 C 332.061 269.191 343.999 288.298 353.085 308.77 C 368.306 343.065 378.9 379.677 398.771 411.804 C 407.026 425.15 416.094 436.325 429.229 444.95 C 446.978 456.605 469.664 457.727 490.144 458.655 C 515.489 459.803 540.924 459.62 566.289 459.667 C 581.518 459.696 596.746 459.69 611.975 459.692 C 616.205 459.693 620.436 459.692 624.666 459.693 C 625.512 459.693 627.204 459.694 627.204 459.694 C 627.204 459.694 625.512 459.693 624.666 459.693 C 620.436 459.692 616.205 459.693 611.975 459.692 C 596.746 459.69 581.518 459.695 566.289 459.669 C 540.923 459.626 515.492 459.815 490.144 458.724 C 462.229 457.522 434.645 454.431 414 433.324 C 385.528 404.215 376.655 363.556 353.085 331.426 C 348.894 325.713 343.772 320.496 337.856 316.598 C 333.373 313.644 327.456 313.703 322.627 311.357 C 317.236 308.738 311.756 305.914 307.398 301.799 C 284.829 280.488 271.958 245.263 261.712 217.126 C 249.58 183.809 242.152 148.949 231.254 115.208 C 226.948 101.877 227.505 84.066 216.025 76.038 C 209.611 71.553 203.077 86.423 200.796 93.91 C 192.684 120.538 190.341 148.594 185.567 176.017 C 174.465 239.782 171.299 276.937 155.11 337.082 C 146.302 369.806 133.529 406.675 109.423 431.878 C 89.365 452.849 60.694 456.647 33.279 458.255 C -17.301 461.223 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="2" id="idn" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.62 -42.865 459.566 C -17.507 459.476 7.953 459.741 33.279 458.264 C 53.827 457.066 76.161 455.206 94.194 444.169 C 115.088 431.381 128.45 410.172 139.881 389.189 C 159.389 353.382 171.379 315.488 185.567 277.474 C 186.918 273.854 199.058 228.216 216.025 225.645 C 221.908 224.753 226.675 231.158 231.254 234.958 C 245.496 246.776 263.956 268.107 276.94 281.937 C 286.029 291.618 295.679 303.744 307.398 310.748 C 316.477 316.175 328.576 314.572 337.856 319.647 C 343.819 322.908 348.936 327.821 353.085 333.204 C 380.671 368.992 388.454 420.232 429.229 445.659 C 447.179 456.852 469.683 457.879 490.144 458.747 C 520.56 460.037 551.081 459.667 581.517 459.686 C 589.263 459.691 604.229 459.692 611.975 459.693 C 616.205 459.693 620.436 459.693 624.666 459.694 C 625.512 459.694 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.694 624.666 459.694 C 620.436 459.693 616.205 459.693 611.975 459.693 C 603.703 459.692 589.789 459.691 581.517 459.686 C 551.081 459.668 520.56 460.037 490.144 458.749 C 469.683 457.882 447.185 456.863 429.229 445.685 C 388.48 420.318 380.989 369.242 353.085 333.773 C 348.954 328.522 343.839 323.716 337.856 320.744 C 328.584 316.138 316.898 318.781 307.398 314.666 C 291.057 307.588 276.345 293.725 261.712 283.745 C 250.993 276.434 241.502 267.465 231.254 259.507 C 226.467 255.789 222.085 249.686 216.025 249.57 C 198.856 249.241 188.23 283.912 185.567 289.904 C 164.776 336.68 147.063 395.682 109.423 432.472 C 88.72 452.707 60.844 456.658 33.279 458.264 C -17.304 461.212 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="bgd" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.62 -42.865 459.566 C -17.507 459.476 7.953 459.74 33.279 458.264 C 60.877 456.656 88.645 452.679 109.423 432.506 C 144.3 398.645 161.151 348.341 185.567 307.347 C 191.73 296.999 200.94 277.92 216.025 275.325 C 222.184 274.265 241.601 283.883 246.483 285.729 C 256.695 289.59 267.368 292.522 276.94 297.772 C 287.257 303.43 296.272 311.448 307.398 315.734 C 317.015 319.438 328.578 316.55 337.856 321.036 C 343.844 323.931 348.959 328.711 353.085 333.927 C 381.071 369.31 388.487 420.346 429.229 445.696 C 447.186 456.869 469.685 457.887 490.144 458.752 C 520.56 460.038 551.081 459.668 581.517 459.686 C 589.789 459.691 603.703 459.692 611.975 459.693 C 616.205 459.693 620.436 459.693 624.666 459.694 C 625.512 459.694 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.694 624.666 459.694 C 620.436 459.693 616.205 459.693 611.975 459.693 C 603.703 459.692 589.789 459.691 581.517 459.686 C 556.138 459.671 530.747 459.739 505.373 459.182 C 485.368 458.743 463.646 459.123 444.458 452.559 C 391.709 434.515 383.94 372.897 353.085 334.046 C 337.206 314.052 327.736 323.558 307.398 316.644 C 294.136 312.135 289.863 306.481 276.94 301.195 C 262.631 295.343 246.441 295.49 231.254 294.476 C 226.185 294.137 220.968 292.698 216.025 293.871 C 194.559 298.967 181.046 324.685 170.338 341.264 C 150.816 371.49 135.676 407.263 109.423 432.566 C 88.577 452.658 60.894 456.655 33.279 458.264 C -17.304 461.212 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="jpn" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.62 -42.865 459.566 C -17.507 459.476 7.953 459.74 33.279 458.264 C 60.894 456.655 88.577 452.658 109.423 432.566 C 135.676 407.263 150.816 371.49 170.338 341.264 C 181.046 324.685 194.559 298.967 216.025 293.871 C 220.968 292.698 226.185 294.137 231.254 294.476 C 246.441 295.49 262.631 295.343 276.94 301.195 C 289.863 306.481 294.136 312.135 307.398 316.644 C 327.735 323.558 337.206 314.052 353.085 334.046 C 381.134 369.364 388.492 420.367 429.229 445.703 C 447.188 456.872 469.685 457.888 490.144 458.753 C 520.56 460.038 551.081 459.668 581.517 459.686 C 589.789 459.691 603.703 459.692 611.975 459.693 C 616.205 459.693 620.436 459.693 624.666 459.694 C 625.512 459.694 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.694 624.666 459.694 C 620.436 459.693 616.205 459.693 611.975 459.693 C 603.703 459.692 589.789 459.691 581.517 459.686 C 551.081 459.668 520.562 460.042 490.144 458.813 C 469.774 457.99 447.381 457.037 429.229 446.523 C 390.949 424.352 381.336 378.406 353.085 347.441 C 340.036 333.138 323.301 332.074 307.398 322.877 C 298.423 317.687 286.356 307.155 276.94 302.558 C 263.021 295.763 246.365 295.838 231.254 294.699 C 226.187 294.317 220.973 292.845 216.025 294.002 C 194.558 299.02 181.021 324.864 170.338 341.401 C 150.831 371.597 135.667 407.329 109.423 432.593 C 88.572 452.665 60.885 456.656 33.279 458.264 C -17.304 461.21 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="vnm" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.62 -42.865 459.566 C -17.507 459.476 7.953 459.739 33.279 458.265 C 60.893 456.658 88.519 452.652 109.423 432.65 C 135.169 408.015 149.781 373.501 170.338 344.871 C 177.448 334.968 190.192 318.062 200.796 310.677 C 215.14 300.687 230.34 304.826 246.483 304.263 C 251.566 304.086 256.637 302.949 261.712 303.296 C 280.237 304.562 291.781 315.928 307.398 324.161 C 323.517 332.659 340.028 333.446 353.085 347.639 C 381.449 378.472 390.963 424.379 429.229 446.53 C 447.383 457.039 469.773 457.991 490.144 458.813 C 520.562 460.04 551.081 459.668 581.517 459.686 C 589.789 459.691 603.703 459.692 611.975 459.693 C 616.205 459.693 620.436 459.693 624.666 459.694 C 625.512 459.694 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.694 624.666 459.694 C 620.436 459.693 616.205 459.693 611.975 459.693 C 603.703 459.692 589.789 459.691 581.517 459.686 C 541.55 459.662 499.252 462.858 459.687 456.284 C 449.095 454.524 438.651 451.991 429.229 446.545 C 391.029 424.466 381.894 378.692 353.085 348.395 C 339.809 334.434 324.092 335.154 307.398 328.697 C 295.971 324.278 288.755 318.775 276.94 315.297 C 263.106 311.225 260.557 313.302 246.483 311.991 C 236.263 311.039 226.244 306.51 216.025 307.468 C 195.429 309.399 181.236 330.59 170.338 345.485 C 146.522 378.034 130.088 422.518 94.194 444.231 C 71.863 457.74 43.289 458.097 18.05 458.883 C -27.593 460.305 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="mmr" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.62 -42.865 459.566 C -17.507 459.477 7.953 459.739 33.279 458.265 C 60.894 456.658 88.497 452.654 109.423 432.683 C 135.05 408.226 149.381 374.046 170.338 345.941 C 180.668 332.088 195.546 309.978 216.025 311.728 C 217.709 311.872 244.966 322.802 246.483 323.237 C 253.964 325.382 269.376 326.879 276.94 328.605 C 287.257 330.959 297.041 335.388 307.398 337.557 C 324.447 341.128 339.172 337.041 353.085 350.506 C 382.896 379.356 391.259 424.822 429.229 446.62 C 447.412 457.059 469.775 458.002 490.144 458.819 C 520.562 460.039 551.081 459.669 581.517 459.686 C 591.158 459.691 602.334 459.692 611.975 459.693 C 616.205 459.694 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.694 616.205 459.694 611.975 459.693 C 602.334 459.692 591.158 459.691 581.517 459.686 C 541.544 459.664 499.262 462.844 459.687 456.303 C 422.816 450.209 402.837 426.118 383.542 395.796 C 375.47 383.111 364.475 361.549 353.085 350.558 C 339.183 337.143 324.463 341.212 307.398 338.059 C 297.11 336.158 287.284 332.045 276.94 330.479 C 266.881 328.956 256.485 330.366 246.483 328.505 C 235.855 326.528 226.677 319.209 216.025 317.369 C 195.505 313.824 181.229 332.692 170.338 346.719 C 145.609 378.568 130.072 422.555 94.194 444.238 C 71.857 457.738 43.291 458.098 18.05 458.884 C -27.593 460.306 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="kor" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.62 -42.865 459.566 C -17.507 459.477 7.953 459.739 33.279 458.265 C 53.855 457.067 76.091 455.179 94.194 444.238 C 130.072 422.555 145.609 378.568 170.338 346.719 C 181.229 332.692 195.505 313.824 216.025 317.369 C 226.677 319.209 235.855 326.528 246.483 328.505 C 256.485 330.366 266.881 328.956 276.94 330.479 C 287.284 332.045 297.11 336.158 307.398 338.059 C 324.463 341.212 339.183 337.143 353.085 350.558 C 364.475 361.549 375.47 383.111 383.542 395.796 C 402.837 426.118 422.816 450.209 459.687 456.303 C 499.262 462.844 541.544 459.664 581.517 459.686 C 591.158 459.691 602.334 459.692 611.975 459.693 C 616.205 459.694 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.694 616.205 459.694 611.975 459.693 C 602.334 459.692 591.158 459.691 581.517 459.686 C 541.522 459.664 499.296 462.784 459.687 456.344 C 423.39 450.443 403.355 427.371 383.542 397.994 C 374.846 385.1 364.991 366.728 353.085 355.851 C 339.468 343.411 323.89 345.369 307.398 340.836 C 293.148 336.92 291.48 334.061 276.94 331.324 C 266.927 329.439 256.48 330.713 246.483 328.748 C 235.857 326.66 226.691 319.316 216.025 317.442 C 195.51 313.838 181.222 332.726 170.338 346.74 C 145.607 378.582 130.068 422.56 94.194 444.239 C 71.857 457.738 43.291 458.098 18.05 458.884 C -27.593 460.306 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="uzb" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.621 -42.865 459.568 C -17.506 459.48 7.951 459.737 33.279 458.283 C 53.832 457.103 76.004 455.266 94.194 444.569 C 129.44 423.843 145.458 381.69 170.338 351.15 C 181.826 337.049 195.566 320.388 216.025 323.889 C 226.499 325.681 235.916 332.182 246.483 333.305 C 256.579 334.378 266.905 332.073 276.94 333.618 C 289.759 335.592 295.072 339.524 307.398 343.259 C 323.588 348.165 339.596 347.073 353.085 359.025 C 365.04 369.618 374.683 386.913 383.542 399.592 C 403.656 428.378 423.757 450.706 459.687 456.419 C 499.336 462.723 541.498 459.664 581.517 459.686 C 591.158 459.691 602.334 459.692 611.975 459.693 C 616.205 459.694 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.694 616.205 459.694 611.975 459.693 C 602.334 459.692 591.158 459.691 581.517 459.686 C 541.498 459.664 499.336 462.722 459.687 456.419 C 423.757 450.707 403.659 428.382 383.542 399.6 C 374.695 386.942 365.035 369.626 353.085 359.057 C 339.599 347.129 323.605 348.249 307.398 343.501 C 295.366 339.976 289.493 335.972 276.94 334.379 C 266.864 333.101 256.628 335.821 246.483 335.322 C 236.014 334.807 226.37 329.193 216.025 327.509 C 195.801 324.218 182.356 338.132 170.338 352.304 C 144.93 382.267 129.361 423.985 94.194 444.592 C 71.719 457.762 43.289 458.118 18.05 458.894 C -27.595 460.298 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="prk" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.678 -103.781 459.674 C -98.705 459.669 -93.628 459.664 -88.552 459.658 C -73.323 459.64 -58.094 459.621 -42.865 459.568 C -17.505 459.48 7.949 459.726 33.279 458.292 C 53.82 457.129 75.855 455.318 94.194 444.993 C 129.051 425.369 144.979 385.277 170.338 356.271 C 182.541 342.313 196.039 329.136 216.025 331.753 C 226.31 333.1 236.111 337.997 246.483 338.136 C 256.642 338.272 266.871 335.575 276.94 336.933 C 289.354 338.608 295.485 342.853 307.398 346.323 C 323.413 350.987 339.531 349.354 353.085 360.838 C 365.13 371.043 374.69 387.891 383.542 400.329 C 403.819 428.82 423.921 450.813 459.687 456.448 C 499.352 462.698 541.488 459.664 581.517 459.686 C 591.158 459.691 602.334 459.692 611.975 459.693 C 616.205 459.694 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.694 616.205 459.694 611.975 459.693 C 602.334 459.692 591.158 459.691 581.517 459.686 C 541.488 459.664 499.353 462.697 459.687 456.449 C 423.922 450.815 403.82 428.823 383.542 400.335 C 374.695 387.906 365.126 371.049 353.085 360.853 C 339.532 349.377 323.415 351.017 307.398 346.388 C 295.554 342.965 289.291 338.703 276.94 337.111 C 266.859 335.812 256.647 338.595 246.483 338.597 C 236.148 338.599 226.302 333.893 216.025 332.792 C 195.966 330.643 182.498 344.314 170.338 358.29 C 145.32 387.044 128.949 426.411 94.194 445.417 C 71.432 457.864 43.276 458.184 18.05 458.93 C -27.598 460.28 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="jor" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.677 -103.781 459.674 C -98.705 459.67 -93.628 459.666 -88.552 459.661 C -73.323 459.646 -58.094 459.629 -42.865 459.579 C -17.504 459.496 7.946 459.737 33.279 458.348 C 53.794 457.223 75.74 455.492 94.194 445.496 C 128.423 426.955 144.92 388.697 170.338 361.054 C 182.77 347.534 196.327 334.962 216.025 337.428 C 226.303 338.715 236.125 343.578 246.483 343.592 C 256.668 343.606 266.778 340.445 276.94 341.137 C 289.571 341.998 295.322 345.554 307.398 348.861 C 323.287 353.212 339.697 352.619 353.085 363.749 C 377.743 384.248 389.215 416.531 414 437.346 C 431.57 452.102 452.707 456.376 474.916 458.095 C 515.286 461.219 556.287 459.683 596.746 459.691 C 601.822 459.692 606.899 459.692 611.975 459.693 C 616.205 459.694 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.694 616.205 459.694 611.975 459.693 C 604.995 459.692 588.497 459.691 581.517 459.687 C 556.138 459.674 530.749 459.735 505.373 459.246 C 485.286 458.859 463.924 459.134 444.458 453.408 C 416.84 445.283 399.982 424.434 383.542 402.084 C 374.581 389.901 365.092 373.757 353.085 363.805 C 339.697 352.708 323.3 353.352 307.398 349.176 C 295.247 345.985 289.631 342.578 276.94 341.938 C 266.759 341.424 256.676 344.777 246.483 344.689 C 230.82 344.554 216.524 333.784 200.796 338.303 C 181.37 343.885 166.632 364.844 155.11 379.709 C 136.851 403.265 121.307 430.811 94.194 445.497 C 71.384 457.852 43.288 458.189 18.05 458.933 C -27.598 460.279 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="4" id="africa" d="M -87.611 459.084 C -83.72 459.082 -79.83 459.079 -75.939 459.076 C -61.934 459.064 -47.929 459.053 -33.924 459.02 C 2.797 458.935 41.902 461.828 78.118 454.705 C 122.184 446.038 137.623 413.633 162.15 380.17 C 172.255 366.384 185.927 345.69 204.165 341.337 C 218.925 337.815 231.483 349.384 246.182 349.446 C 255.59 349.486 264.785 345.782 274.191 345.967 C 285.897 346.197 291.072 349.331 302.201 352.392 C 316.9 356.434 332.09 356.277 344.218 366.926 C 371.421 390.81 380.847 429.408 414.244 447.491 C 431.145 456.642 451.534 457.54 470.265 458.286 C 493.58 459.215 516.962 459.04 540.29 459.076 C 554.296 459.098 568.301 459.092 582.307 459.094 C 586.197 459.094 590.087 459.095 593.977 459.095 C 593.978 459.095 596.313 459.096 596.312 459.096 C 558.972 459.096 521.606 459.417 484.271 458.677 C 461.277 458.221 435.144 458.862 414.244 447.675 C 380.415 429.569 372.012 391.343 344.218 368.895 C 332.158 359.154 302.846 358.114 288.196 361.999 C 269.464 366.967 258.32 383.836 246.182 397.42 C 233.423 411.699 220.46 426.024 204.165 436.417 C 187.251 447.204 167.723 451.552 148.144 454.394 C 111.168 459.761 73.364 458.83 36.102 458.943 C 3.423 459.042 -29.255 459.064 -61.934 459.08 C -66.602 459.082 -71.271 459.084 -75.939 459.086 C -79.83 459.088 -83.72 459.089 -87.611 459.09 C -89.758 459.091 -88.395 459.085 -87.611 459.084 Z" />
      <path stroke-width="1" id="nga" d="M -119.01 459.742 C -119.01 459.742 -117.317 459.742 -116.471 459.741 C -112.241 459.738 -108.011 459.735 -103.781 459.732 C -98.705 459.728 -93.628 459.724 -88.552 459.719 C -73.323 459.704 -58.094 459.687 -42.865 459.637 C -17.504 459.554 7.946 459.793 33.279 458.409 C 53.788 457.289 75.724 455.567 94.194 445.625 C 121.212 431.081 136.655 403.821 155.11 380.597 C 166.484 366.284 181.412 345.918 200.796 341.651 C 216.756 338.138 230.586 349.721 246.483 349.783 C 256.702 349.823 266.723 346.108 276.94 346.293 C 289.675 346.524 295.2 349.643 307.398 352.737 C 323.205 356.747 339.742 356.509 353.085 367.315 C 371.926 382.573 382.743 405.98 398.771 423.814 C 419.857 447.275 444.222 455.889 474.916 458.192 C 515.301 461.222 556.277 459.742 596.746 459.75 C 601.822 459.751 606.899 459.75 611.975 459.751 C 616.205 459.751 620.436 459.752 624.666 459.753 C 625.512 459.753 627.204 459.753 627.204 459.753 C 627.204 459.753 625.512 459.753 624.666 459.753 C 620.436 459.752 616.205 459.751 611.975 459.751 C 599.212 459.75 594.28 459.752 581.517 459.745 C 556.138 459.732 530.749 459.79 505.373 459.312 C 485.257 458.933 464.005 459.161 444.458 453.68 C 417.128 446.016 400.134 426.466 383.542 404.585 C 374.398 392.527 365.184 377.121 353.085 367.337 C 339.765 356.566 323.212 356.771 307.398 352.97 C 295.682 350.154 289.201 346.926 276.94 347.361 C 264.415 347.805 258.678 351.798 246.483 353.944 C 230.955 356.677 215.68 351.596 200.796 358.22 C 191.024 362.569 177.881 374.196 170.338 381.123 C 145.749 403.704 125.396 432.86 94.194 447.017 C 66.192 459.722 32.898 458.843 2.821 459.31 C -37.781 459.941 -119.01 459.742 -119.01 459.742 Z" />
      <path stroke-width="1" id="egy" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.684 -116.471 459.683 C -112.241 459.68 -108.011 459.677 -103.781 459.674 C -98.705 459.67 -93.628 459.666 -88.552 459.661 C -73.323 459.646 -58.094 459.63 -42.865 459.58 C -0.507 459.442 54.847 464.371 94.194 447.198 C 124.391 434.019 144.025 406.974 170.338 388.302 C 196.763 369.55 217.223 367.294 246.483 357.793 C 262.587 352.564 274.801 346.921 292.169 349.578 C 302.451 351.151 312.407 354.43 322.627 356.364 C 336.402 358.97 341.323 357.852 353.085 367.333 C 365.175 377.078 374.418 392.515 383.542 404.541 C 400.137 426.415 417.131 445.961 444.458 453.624 C 464.004 459.105 485.257 458.875 505.373 459.254 C 530.749 459.732 556.138 459.674 581.517 459.687 C 594.28 459.694 599.212 459.692 611.975 459.693 C 616.205 459.693 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.694 616.205 459.693 611.975 459.693 C 599.212 459.692 594.28 459.694 581.517 459.687 C 556.138 459.674 530.749 459.732 505.373 459.254 C 485.257 458.875 464.005 459.104 444.458 453.625 C 417.135 445.967 400.144 426.432 383.542 404.569 C 374.443 392.586 365.167 377.116 353.085 367.426 C 341.381 358.039 336.339 359.098 322.627 356.676 C 312.432 354.875 302.461 351.717 292.169 350.594 C 268.182 347.978 251.76 362.674 231.254 372.15 C 211.708 381.182 189.298 381.359 170.338 391.405 C 142.172 406.328 123.95 434.256 94.194 447.208 C 65.968 459.494 32.99 458.786 2.821 459.253 C -37.781 459.881 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="tza" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.683 -116.471 459.683 C -112.241 459.681 -108.011 459.679 -103.781 459.676 C -98.705 459.672 -93.628 459.668 -88.552 459.663 C -73.323 459.648 -58.094 459.631 -42.865 459.587 C -1.197 459.467 54.895 463.771 94.194 450.295 C 125.042 439.717 143.404 414.035 170.338 397.575 C 189.098 386.11 211.686 383.506 231.254 373.553 C 251.459 363.276 268.057 348.268 292.169 350.75 C 302.461 351.809 312.435 354.946 322.627 356.726 C 336.332 359.12 341.388 358.069 353.085 367.444 C 365.168 377.128 374.444 392.596 383.542 404.575 C 400.145 426.436 417.136 445.969 444.458 453.626 C 464.005 459.104 485.256 458.876 505.373 459.254 C 530.749 459.731 556.138 459.674 581.517 459.687 C 594.28 459.694 599.212 459.692 611.975 459.693 C 616.205 459.693 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.694 616.205 459.693 611.975 459.693 C 599.212 459.692 594.28 459.694 581.517 459.687 C 556.138 459.674 530.749 459.732 505.373 459.255 C 485.257 458.877 464.005 459.105 444.458 453.628 C 417.138 445.973 400.147 426.444 383.542 404.587 C 374.452 392.621 365.165 377.144 353.085 367.476 C 341.398 358.122 336.32 359.164 322.627 356.815 C 312.439 355.067 302.46 351.965 292.169 350.992 C 267.906 348.699 251.1 364.148 231.254 375.296 C 211.652 386.308 189.418 391.43 170.338 403.314 C 149.317 416.407 132.172 434.329 109.423 444.858 C 80.987 458.019 48.773 458.477 18.05 459.101 C -27.62 460.029 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="ken" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.683 -116.471 459.683 C -112.241 459.681 -108.011 459.679 -103.781 459.676 C -98.705 459.672 -93.628 459.668 -88.552 459.663 C -73.323 459.649 -58.094 459.632 -42.865 459.588 C 0.615 459.464 52.357 463.633 94.194 451.014 C 123.731 442.105 144.393 421.258 170.338 406.032 C 189.715 394.66 211.782 389.565 231.254 378.162 C 250.995 366.601 267.731 350.592 292.169 352.49 C 297.319 352.89 302.311 354.462 307.398 355.361 C 323.183 358.152 339.789 357.67 353.085 368.151 C 365.171 377.678 374.47 393.075 383.542 404.94 C 400.185 426.706 417.178 446.109 444.458 453.698 C 464.014 459.138 485.257 458.897 505.373 459.268 C 530.749 459.736 556.138 459.676 581.517 459.688 C 591.905 459.693 601.587 459.692 611.975 459.693 C 616.205 459.693 620.436 459.694 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.694 611.975 459.694 C 605.049 459.693 588.443 459.691 581.517 459.688 C 556.138 459.676 530.749 459.736 505.373 459.268 C 485.257 458.897 464.013 459.139 444.458 453.7 C 417.181 446.113 400.187 426.713 383.542 404.953 C 374.482 393.108 365.168 377.696 353.085 368.194 C 339.795 357.743 323.182 358.25 307.398 355.631 C 302.314 354.788 297.313 353.275 292.169 352.97 C 267.338 351.498 250.69 368.678 231.254 381.199 C 211.925 393.651 190.475 399.377 170.338 409.961 C 149.39 420.971 131.383 436.566 109.423 445.832 C 80.657 457.97 48.767 458.508 18.05 459.113 C -27.621 460.013 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="dza" d="M -119.01 459.684 C -119.01 459.684 -117.317 459.683 -116.471 459.683 C -112.241 459.681 -108.011 459.679 -103.781 459.676 C -98.705 459.672 -93.628 459.668 -88.552 459.663 C -73.323 459.649 -58.094 459.632 -42.865 459.589 C 1.891 459.463 50.6 463.397 94.194 451.453 C 121.588 443.948 144.333 427.28 170.338 416.65 C 185.928 410.277 201.593 406.369 216.025 397.24 C 240.371 381.839 260.646 352.479 292.169 353.587 C 297.305 353.768 302.318 355.208 307.398 355.982 C 323.176 358.385 339.806 357.856 353.085 368.265 C 365.163 377.733 374.496 393.159 383.542 404.978 C 400.192 426.731 417.183 446.119 444.458 453.703 C 464.014 459.141 485.257 458.898 505.373 459.269 C 530.749 459.736 556.138 459.676 581.517 459.688 C 588.443 459.691 605.049 459.693 611.975 459.694 C 616.205 459.694 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.694 611.975 459.694 C 605.049 459.693 588.443 459.691 581.517 459.688 C 556.138 459.676 530.749 459.736 505.373 459.269 C 485.257 458.898 464.014 459.141 444.458 453.703 C 417.184 446.119 400.198 426.732 383.542 404.985 C 374.538 393.228 365.147 377.733 353.085 368.341 C 339.871 358.052 323.134 358.551 307.398 356.813 C 295.554 355.505 288.56 353.565 276.94 358.108 C 254.283 366.966 237.542 388.413 216.025 399.811 C 201.434 407.54 185.558 410.794 170.338 416.813 C 149.276 425.143 130.611 438.338 109.423 446.455 C 75.6 459.412 38.496 458.931 2.821 459.333 C -37.785 459.79 -119.01 459.684 -119.01 459.684 Z" />
      <path stroke-width="1" id="moz" d="M -119.01 459.686 C -119.01 458.84 -117.317 459.684 -116.471 459.684 C -112.241 459.682 -108.011 459.68 -103.781 459.677 C -98.705 459.674 -93.628 459.67 -88.552 459.666 C -73.323 459.653 -58.094 459.637 -42.865 459.598 C 1.946 459.483 50.38 463.332 94.194 452.264 C 121.56 445.351 144.256 429.121 170.338 419.234 C 191.358 411.266 212.127 407.291 231.254 394.627 C 250.827 381.667 267.314 359.593 292.169 357.196 C 297.229 356.708 302.327 357.652 307.398 358.013 C 323.096 359.13 339.866 358.454 353.085 368.621 C 365.136 377.889 374.583 393.413 383.542 405.077 C 400.218 426.787 417.199 446.141 444.458 453.712 C 464.016 459.144 485.256 458.899 505.373 459.27 C 530.749 459.737 556.138 459.677 581.517 459.689 C 585.303 459.691 608.189 459.694 611.975 459.694 C 616.205 459.694 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.694 611.975 459.694 C 608.189 459.694 585.303 459.691 581.517 459.689 C 551.077 459.675 520.57 460.006 490.144 458.91 C 469.844 458.179 447.835 457.415 429.229 448.206 C 409.684 438.532 396.53 421.999 383.542 405.095 C 370.67 388.342 359.601 367.664 337.856 361.079 C 332.969 359.599 327.709 359.927 322.627 359.432 C 307.646 357.973 291.308 354.624 276.94 361.166 C 254.386 371.435 238.247 392.962 216.025 404.45 C 201.431 411.995 185.503 415.426 170.338 421.441 C 154.621 427.675 140.214 436.606 124.652 443.184 C 90.64 457.561 54.429 458.657 18.05 459.22 C -27.627 459.926 -119.01 460.532 -119.01 459.686 Z" />
      <path stroke-width="1" id="cmr" d="M -119.01 459.687 C -119.01 459.687 -117.317 459.686 -116.471 459.686 C -112.241 459.684 -108.011 459.681 -103.781 459.679 C -98.705 459.676 -93.628 459.674 -88.552 459.67 C -73.323 459.659 -58.094 459.643 -42.865 459.61 C 2.254 459.512 49.655 462.607 94.194 454.145 C 122.015 448.859 144.527 434.627 170.338 424.174 C 191.283 415.692 212.278 411.041 231.254 398.011 C 250.848 384.556 267.167 361.678 292.169 358.427 C 308.191 356.344 340.094 358.854 353.085 368.768 C 365.121 377.953 374.622 393.529 383.542 405.126 C 400.228 426.82 417.205 446.157 444.458 453.72 C 464.016 459.147 485.257 458.903 505.373 459.272 C 530.749 459.737 556.138 459.677 581.517 459.689 C 585.303 459.691 608.189 459.694 611.975 459.694 C 616.205 459.694 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.694 611.975 459.694 C 608.189 459.694 585.303 459.691 581.517 459.689 C 551.077 459.675 520.57 460.007 490.144 458.911 C 469.845 458.18 447.836 457.416 429.229 448.213 C 409.689 438.548 396.538 422.029 383.542 405.142 C 370.732 388.497 359.622 367.702 337.856 361.405 C 332.959 359.988 327.71 360.4 322.627 360.017 C 307.46 358.874 291.164 356.301 276.94 363.53 C 254.335 375.018 238.858 397.145 216.025 408.961 C 201.479 416.488 185.5 419.689 170.338 425.553 C 154.742 431.585 140.355 440.176 124.652 445.979 C 90.602 458.561 53.878 458.815 18.05 459.277 C -27.63 459.866 -119.01 459.687 -119.01 459.687 Z" />
      <path stroke-width="1" id="tcd" d="M -119.01 459.688 C -119.01 459.688 -117.317 459.686 -116.471 459.686 C -112.241 459.684 -108.011 459.683 -103.781 459.681 C -98.705 459.678 -93.628 459.676 -88.552 459.672 C -73.323 459.662 -58.094 459.65 -42.865 459.622 C 7.522 459.531 59.625 462.337 109.423 453.31 C 142.236 447.362 188.469 436.13 216.025 417.469 C 238.105 402.517 253.765 378.009 276.94 365.019 C 288.252 358.679 295.061 359.421 307.398 359.619 C 323.021 359.869 339.851 358.906 353.085 368.924 C 365.111 378.028 374.657 393.642 383.542 405.177 C 400.238 426.852 417.212 446.172 444.458 453.727 C 464.017 459.151 485.256 458.904 505.373 459.272 C 530.749 459.736 556.138 459.677 581.517 459.689 C 585.303 459.691 608.189 459.694 611.975 459.694 C 616.205 459.694 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.694 611.975 459.694 C 607.8 459.694 585.692 459.691 581.517 459.689 C 551.077 459.676 520.57 460.007 490.144 458.913 C 469.844 458.183 447.838 457.422 429.229 448.222 C 409.691 438.563 396.543 422.056 383.542 405.178 C 370.766 388.592 359.629 367.729 337.856 361.581 C 332.954 360.197 327.71 360.65 322.627 360.329 C 307.338 359.365 290.976 357.218 276.94 365.165 C 266.757 370.931 254.598 384.316 246.483 392.108 C 228.191 409.672 209.668 425.225 185.567 434.095 C 91.235 468.814 -119.01 459.688 -119.01 459.688 Z" />
      <path stroke-width="1" id="bdi" d="M -116.471 459.688 C -112.241 459.687 -108.011 459.685 -103.781 459.683 C -88.552 459.676 -73.323 459.668 -58.094 459.651 C -12.473 459.6 33.401 460.614 78.965 457.977 C 116.582 455.8 167.709 451.081 200.796 432.257 C 218.373 422.257 232.395 407.933 246.483 393.709 C 254.505 385.61 266.697 371.809 276.94 365.798 C 288.177 359.203 295.019 359.816 307.398 359.891 C 323.003 359.985 339.853 358.993 353.085 368.984 C 365.109 378.063 374.666 393.683 383.542 405.2 C 400.242 426.867 417.215 446.182 444.458 453.732 C 464.017 459.152 485.257 458.907 505.373 459.274 C 530.749 459.737 556.138 459.678 581.517 459.689 C 585.692 459.691 607.8 459.694 611.975 459.694 C 616.205 459.694 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.694 611.975 459.694 C 607.8 459.694 585.692 459.691 581.517 459.689 C 556.138 459.678 530.749 459.737 505.373 459.274 C 485.257 458.907 464.017 459.152 444.458 453.732 C 417.215 446.183 400.241 426.868 383.542 405.201 C 374.667 393.686 365.108 378.062 353.085 368.985 C 339.995 359.102 308.04 357.211 292.169 360.298 C 272.278 364.167 259.901 380.199 246.483 393.782 C 232.372 408.067 218.34 422.424 200.796 432.58 C 182.293 443.291 160.68 447.883 139.881 451.708 C 99.734 459.091 58.729 459.159 18.05 459.433 C -17.483 459.672 -53.018 459.654 -88.552 459.675 C -93.628 459.678 -98.705 459.681 -103.781 459.683 C -108.011 459.685 -112.241 459.686 -116.471 459.688 C -117.318 459.688 -117.318 459.688 -116.471 459.688 Z" />
      <path stroke-width="4" id="americas" d="M -87.611 459.09 C -83.72 459.089 -79.83 459.088 -75.939 459.086 C -71.271 459.084 -66.602 459.082 -61.934 459.08 C -47.929 459.073 -33.925 459.063 -19.92 459.047 C 31.202 458.99 83.213 461.287 134.139 456.093 C 164.958 452.949 193.927 446.47 218.171 425.995 C 245.842 402.625 262.557 362.391 302.201 360.888 C 316.658 360.34 332.144 359.144 344.218 368.895 C 355.264 377.817 364.327 393.746 372.228 404.833 C 387.218 425.87 402.55 445.443 428.249 453.157 C 461.556 463.155 505.544 459.03 540.29 459.08 C 554.296 459.1 568.301 459.094 582.307 459.095 C 586.197 459.095 590.087 459.095 593.977 459.095 C 594.755 459.095 596.312 458.318 596.312 459.096 C 596.312 459.874 594.755 459.096 593.977 459.096 C 590.087 459.096 586.197 459.096 582.307 459.096 C 577.639 459.096 572.97 459.095 568.302 459.095 C 544.96 459.093 521.618 459.106 498.276 459.064 C 468.315 459.009 428.598 463.011 400.239 453.008 C 388.309 448.8 381.652 444.003 372.228 435.354 C 359.153 423.353 348.817 406.034 330.213 401.745 C 324.828 400.504 307.474 402.12 302.201 402.974 C 267.736 408.559 251.249 442.858 218.171 452.761 C 191.549 460.731 161.604 458.808 134.139 458.957 C 92.125 459.185 50.107 459.077 8.092 459.083 C -15.25 459.086 -38.592 459.088 -61.934 459.091 C -66.602 459.091 -71.271 459.092 -75.939 459.093 C -79.83 459.093 -83.72 459.094 -87.611 459.094 C -89.864 459.094 -88.392 459.09 -87.611 459.09 Z" />
      <path stroke-width="1" id="usa" d="M -116.471 459.69 C -112.241 459.689 -108.011 459.687 -103.781 459.685 C -88.552 459.679 -73.323 459.674 -58.094 459.661 C -12.421 459.624 33.3 460.059 78.965 459.027 C 118.94 458.124 165.31 457.827 200.796 436.951 C 218.282 426.664 232.489 412.283 246.483 397.839 C 254.413 389.653 266.954 375.033 276.94 368.649 C 290.76 359.814 307.018 360.781 322.627 361.249 C 327.709 361.401 332.938 360.824 337.856 362.113 C 359.649 367.824 370.859 388.857 383.542 405.274 C 400.26 426.914 417.224 446.198 444.458 453.739 C 464.019 459.156 485.256 458.908 505.373 459.275 C 530.749 459.738 556.138 459.677 581.517 459.689 C 591.825 459.694 601.667 459.693 611.975 459.694 C 616.205 459.694 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.694 611.975 459.694 C 601.339 459.693 592.153 459.693 581.517 459.691 C 551.06 459.685 520.599 459.782 490.144 459.461 C 470.039 459.249 449.003 459.862 429.229 455.609 C 390.677 447.317 379.927 419.144 353.085 395.167 C 341.259 384.603 336.72 383.595 322.627 378.111 C 308.163 372.482 292.45 364.723 276.94 372.26 C 266.885 377.146 253.927 391.575 246.483 398.941 C 228.214 417.019 209.849 434.88 185.567 444.62 C 157.208 455.996 124.358 457.5 94.194 458.643 C 53.628 460.18 12.95 459.639 -27.637 459.667 C -53.018 459.684 -78.4 459.686 -103.781 459.69 C -108.011 459.691 -112.241 459.691 -116.471 459.692 C -118.769 459.692 -117.319 459.69 -116.471 459.69 Z" />
      <path stroke-width="1" id="mex" d="M -116.471 459.692 C -112.241 459.691 -108.011 459.691 -103.781 459.69 C -88.552 459.688 -73.323 459.686 -58.094 459.682 C -17.485 459.671 23.129 459.798 63.737 459.422 C 108.228 459.01 159.511 461.359 200.796 442.111 C 217.935 434.121 232.286 422.37 246.483 410.108 C 260.129 398.323 272.829 383.574 292.169 382.221 C 309.224 381.028 339.756 389.112 353.085 399.545 C 370.025 412.805 380.835 431.971 398.771 444.235 C 412.481 453.61 428.289 456.602 444.458 458.105 C 489.678 462.308 536.144 459.688 581.517 459.692 C 591.67 459.693 601.822 459.694 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 611.975 459.695 581.517 459.693 581.517 459.693 C 536.135 459.689 489.693 462.283 444.458 458.157 C 428.311 456.684 412.513 453.752 398.771 444.478 C 380.959 432.457 370.195 413.432 353.085 400.749 C 338.097 389.638 310.47 385.199 292.169 389.061 C 273.03 393.1 260.858 409.177 246.483 420.826 C 232.597 432.079 217.807 440.535 200.796 446.079 C 171.735 455.55 139.749 457.289 109.423 458.513 C 63.795 460.354 18.019 459.648 -27.637 459.672 C -53.018 459.685 -78.4 459.686 -103.781 459.69 C -108.011 459.691 -112.241 459.691 -116.471 459.692 C -117.318 459.692 -117.318 459.692 -116.471 459.692 Z" />
      <path stroke-width="1" id="can" d="M -119.01 459.693 C -119.01 459.693 -117.317 459.692 -116.471 459.692 C -112.241 459.691 -108.011 459.692 -103.781 459.691 C -98.705 459.69 -93.628 459.689 -88.552 459.688 C -73.323 459.686 -58.094 459.684 -42.865 459.679 C 2.811 459.666 48.526 460.071 94.194 459.072 C 133.747 458.207 178.641 458.65 216.025 444.104 C 249.867 430.936 269.355 394.814 307.398 393.46 C 312.275 393.286 333.083 393.761 337.856 395.115 C 364.132 402.57 376.998 430.373 398.771 444.786 C 416.844 456.75 438.725 458.229 459.687 459.047 C 500.225 460.628 540.956 459.69 581.517 459.693 C 581.517 459.693 611.975 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 601.822 459.695 591.67 459.694 581.517 459.693 C 551.06 459.69 520.601 459.748 490.144 459.558 C 469.985 459.432 449.188 460.093 429.229 456.754 C 411.313 453.757 397.255 447.053 383.542 435.012 C 373.447 426.148 364.189 413.888 353.085 406.045 C 339.523 396.466 323.492 395.061 307.398 394.84 C 277.805 394.433 268.165 410.264 246.483 426.778 C 228.188 440.712 208.048 448.098 185.567 452.018 C 140.567 459.865 94.025 459.349 48.508 459.554 C -7.33 459.805 -119.01 459.693 -119.01 459.693 Z" />
      <path stroke-width="1" id="gtm" d="M -119.01 459.693 C -119.01 459.693 -117.317 459.693 -116.471 459.693 C -112.241 459.693 -108.011 459.692 -103.781 459.692 C -98.705 459.691 -93.628 459.691 -88.552 459.69 C -73.323 459.688 -58.094 459.687 -42.865 459.684 C 2.82 459.677 48.51 459.844 94.194 459.475 C 134.012 459.153 178.114 461.258 216.025 447.119 C 249.689 434.564 270.009 399.879 307.398 398.138 C 312.811 397.886 332.555 398.19 337.856 399.701 C 363.469 406.999 376.671 433.583 398.771 446.698 C 425.256 462.416 460.592 459.384 490.144 459.562 C 525.677 459.776 561.213 459.693 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 601.822 459.695 591.67 459.694 581.517 459.693 C 551.06 459.69 520.601 459.745 490.144 459.564 C 469.982 459.444 449.199 460.11 429.229 456.829 C 411.352 453.891 397.304 447.292 383.542 435.382 C 368.889 422.7 357.602 405.387 337.856 399.886 C 332.947 398.518 327.718 398.773 322.627 398.56 C 315.474 398.261 299.167 398.398 292.169 400.372 C 268.16 407.145 252.787 430.025 231.254 441.616 C 217.104 449.232 201.351 453.09 185.567 455.371 C 145.541 461.155 104.068 459.528 63.737 459.619 C 2.822 459.757 -119.01 459.693 -119.01 459.693 Z" />
      <path stroke-width="4" id="europe" d="M -87.611 459.094 C -83.72 459.094 -79.83 459.093 -75.939 459.093 C -61.934 459.091 -47.929 459.091 -33.924 459.089 C 3.423 459.085 40.771 459.087 78.118 459.064 C 106.123 459.047 134.149 459.253 162.15 458.653 C 180.742 458.255 200.188 458.145 218.171 452.761 C 242.125 445.589 254.85 428.126 274.191 414.022 C 286.869 404.777 300.875 402.244 316.207 401.571 C 320.872 401.366 325.663 400.696 330.213 401.745 C 354.297 407.297 366.331 433.9 386.233 446.443 C 406.705 459.346 433.02 458.535 456.26 458.859 C 493.599 459.379 530.96 459.092 568.302 459.095 C 572.97 459.095 577.639 459.096 582.307 459.096 C 586.197 459.096 590.087 459.096 593.977 459.096 C 594.755 459.096 596.312 459.096 596.312 459.096 C 596.312 459.096 594.755 459.096 593.977 459.096 C 590.087 459.096 586.197 459.096 582.307 459.096 C 577.639 459.096 572.97 459.096 568.302 459.096 C 530.955 459.096 493.607 459.096 456.26 459.096 C 316.207 459.096 176.155 459.096 36.102 459.096 C 3.423 459.096 -29.255 459.096 -61.934 459.096 C -66.602 459.096 -71.271 459.096 -75.939 459.096 C -79.83 459.096 -83.72 459.096 -87.611 459.096 C -88.389 459.096 -88.391 459.094 -87.611 459.094 Z" />
      <path stroke-width="1" id="rus" d="M -119.01 459.693 C -119.01 459.693 -117.317 459.693 -116.471 459.693 C -112.241 459.693 -108.011 459.692 -103.781 459.692 C -98.705 459.692 -93.628 459.691 -88.552 459.691 C -73.323 459.69 -58.094 459.688 -42.865 459.686 C 2.821 459.68 48.508 459.706 94.194 459.638 C 119.561 459.601 144.985 459.857 170.338 458.853 C 190.811 458.042 212.339 456.735 231.254 447.995 C 249.104 439.747 260.96 425.237 276.94 414.489 C 290.883 405.111 306.182 402.668 322.627 402.002 C 327.7 401.796 332.89 401.12 337.856 402.176 C 363.477 407.624 377.147 434.434 398.771 447.004 C 425.357 462.458 460.598 459.403 490.144 459.571 C 525.677 459.773 561.212 459.693 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 598.439 459.695 595.053 459.695 581.517 459.694 C 551.06 459.691 520.601 459.74 490.144 459.577 C 469.97 459.469 449.238 460.131 429.229 457.082 C 411.526 454.384 397.553 448.211 383.542 436.951 C 369.588 425.737 357.646 408.546 337.856 407.783 C 331.547 407.54 313.102 413.382 307.398 415.174 C 283.239 422.764 268.534 435.761 246.483 445.791 C 232.102 452.332 216.381 455.241 200.796 457 C 160.604 461.537 119.344 459.621 78.965 459.654 C 12.973 459.708 -119.01 459.693 -119.01 459.693 Z" />
      <path stroke-width="1" id="deu" d="M -119.01 459.693 C -119.01 459.693 -117.317 459.693 -116.471 459.693 C -112.241 459.693 -108.011 459.692 -103.781 459.692 C -88.552 459.691 -73.323 459.69 -58.094 459.688 C -12.408 459.682 33.279 459.69 78.965 459.654 C 109.419 459.63 139.889 459.775 170.338 459.181 C 190.557 458.787 211.405 458.631 231.254 454.276 C 258.545 448.288 281.553 431.035 307.398 420.964 C 313.049 418.762 331.418 411.253 337.856 410.986 C 362.908 409.946 378.778 437.167 398.771 447.981 C 425.686 462.538 460.614 459.427 490.144 459.58 C 525.677 459.764 561.212 459.694 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 598.439 459.695 595.053 459.695 581.517 459.694 C 535.92 459.69 490.012 461.11 444.458 458.859 C 422.569 457.777 402.545 454.778 383.542 443.073 C 368.713 433.939 356.379 420.176 337.856 418.837 C 311.271 416.915 284.46 432.544 261.712 443.605 C 246.923 450.796 232.312 454.767 216.025 456.751 C 175.905 461.639 134.531 459.587 94.194 459.639 C 23.126 459.73 -119.01 459.693 -119.01 459.693 Z" />
      <path stroke-width="1" id="fra" d="M -119.01 459.693 C -119.01 459.693 -117.317 459.693 -116.471 459.693 C -112.241 459.693 -108.011 459.692 -103.781 459.692 C -88.552 459.691 -73.323 459.69 -58.094 459.688 C -12.408 459.682 33.279 459.693 78.965 459.661 C 126.062 459.629 185.707 463.933 231.254 454.545 C 268.031 446.965 296.921 421.542 337.856 425.203 C 360.823 427.257 377.507 445.646 398.771 452.765 C 427.289 462.313 460.519 459.538 490.144 459.636 C 525.678 459.754 561.212 459.694 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 601.822 459.695 591.67 459.696 581.517 459.695 C 535.86 459.692 490.101 460.513 444.458 459.257 C 423.603 458.683 403.255 457.202 383.542 449.776 C 362.695 441.923 345.516 431.542 322.627 430.607 C 306.883 429.964 291.682 431.809 276.94 437.532 C 266.633 441.533 256.988 447.219 246.483 450.666 C 231.731 455.506 216.199 457.14 200.796 458.155 C 160.341 460.822 119.484 459.634 78.965 459.661 C 12.973 459.704 -119.01 459.693 -119.01 459.693 Z" />
      <path stroke-width="1" id="esp" d="M -119.01 459.695 C -119.01 459.695 -117.317 459.695 -116.471 459.695 C -112.241 459.695 -108.011 459.694 -103.781 459.694 C -88.552 459.693 -73.323 459.693 -58.094 459.692 C -12.408 459.691 33.279 459.7 78.965 459.674 C 126.436 459.648 185.178 463.827 231.254 454.906 C 257.786 449.769 279.7 434.487 307.398 434.823 C 341.96 435.243 366.43 449.261 398.771 455.645 C 428.498 461.513 460.009 459.618 490.144 459.665 C 525.678 459.721 561.212 459.695 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 601.822 459.695 591.67 459.695 581.517 459.695 C 535.845 459.694 490.124 460.262 444.458 459.412 C 423.865 459.029 403.651 457.886 383.542 453.102 C 354.147 446.109 322.902 435.474 292.169 437.909 C 275.817 439.204 261.957 447.248 246.483 451.73 C 236.096 454.738 226.747 456.157 216.025 457.281 C 175.788 461.499 134.592 459.645 94.194 459.673 C 23.126 459.722 -119.01 459.695 -119.01 459.695 Z" />
      <path stroke-width="1" id="pol" d="M -119.01 459.695 C -119.01 459.695 -117.317 459.695 -116.471 459.695 C -112.241 459.695 -108.011 459.695 -103.781 459.695 C -88.552 459.695 -73.323 459.695 -58.094 459.694 C -12.408 459.693 33.279 459.701 78.965 459.681 C 129.388 459.659 181.103 462.395 231.254 456.257 C 257.04 453.101 281.358 442.442 307.398 441.461 C 339.365 440.256 367.806 451.238 398.771 456.272 C 428.741 461.145 459.893 459.629 490.144 459.669 C 525.678 459.716 561.212 459.695 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 601.822 459.695 591.67 459.695 581.517 459.695 C 535.844 459.694 490.125 460.248 444.458 459.419 C 429.2 459.142 413.875 458.735 398.771 456.333 C 372.894 452.218 349.225 443.495 322.627 444.16 C 301.798 444.68 282.113 449.609 261.712 453.114 C 241.6 456.569 221.161 457.832 200.796 458.63 C 94.429 462.8 -119.01 459.695 -119.01 459.695 Z" />
      <path stroke-width="1" id="bel" d="M -119.01 459.695 C -119.01 459.695 -117.317 459.695 -116.471 459.695 C -112.241 459.695 -108.011 459.695 -103.781 459.695 C -88.552 459.695 -73.323 459.695 -58.094 459.694 C -12.408 459.693 33.279 459.696 78.965 459.687 C 129.665 459.677 180.648 460.94 231.254 457.283 C 261.877 455.07 291.885 446.892 322.627 446.643 C 348.675 446.432 373.158 453.591 398.771 456.885 C 433.907 461.404 470.029 459.665 505.373 459.684 C 535.831 459.7 566.288 459.695 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.695 624.666 459.695 C 625.512 459.695 627.204 459.695 627.204 459.695 C 627.204 459.695 625.512 459.695 624.666 459.695 C 620.436 459.695 616.205 459.695 611.975 459.695 C 601.822 459.695 591.67 459.695 581.517 459.695 C 535.839 459.694 490.133 460.122 444.458 459.48 C 423.995 459.192 403.798 458.143 383.542 455.091 C 363.298 452.041 343.178 447.806 322.627 447.41 C 301.896 447.01 282.097 451.33 261.712 454.218 C 241.555 457.074 221.126 458.151 200.796 458.849 C 94.383 462.503 -119.01 459.695 -119.01 459.695 Z" />
      <path stroke-width="1" id="blr" d="M -119.01 459.695 C -119.01 459.695 -117.317 459.695 -116.471 459.695 C -112.241 459.695 -108.011 459.695 -103.781 459.695 C -88.552 459.695 -73.323 459.695 -58.094 459.694 C -12.408 459.693 33.279 459.697 78.965 459.691 C 124.636 459.685 170.381 460.282 216.025 458.415 C 256.654 456.753 297.159 452.688 337.856 453.071 C 363.39 453.312 388.535 457.438 414 458.726 C 444.4 460.263 474.945 459.674 505.373 459.686 C 535.831 459.698 566.288 459.695 596.746 459.695 C 601.822 459.695 606.899 459.695 611.975 459.695 C 616.205 459.695 620.436 459.696 624.666 459.696 C 625.512 459.696 627.204 459.696 627.204 459.696 C 627.204 459.696 625.512 459.696 624.666 459.696 C 620.436 459.696 616.205 459.695 611.975 459.695 C 601.822 459.695 591.67 459.695 581.517 459.695 C 540.908 459.695 500.296 459.814 459.687 459.619 C 439.368 459.522 419.037 459.377 398.771 457.738 C 378.396 456.09 358.355 453.29 337.856 453.519 C 287.065 454.086 236.353 458.398 185.567 459.305 C 84.092 461.117 -119.01 459.695 -119.01 459.695 Z" />
      <path stroke-width="1" id="arm" d="M -119.01 459.696 C -119.01 459.696 -117.317 459.696 -116.471 459.696 C -112.241 459.696 -108.011 459.696 -103.781 459.696 C -88.552 459.696 -73.323 459.697 -58.094 459.696 C -12.408 459.695 33.279 459.697 78.965 459.694 C 221.11 459.685 363.231 459.69 505.373 459.695 C 535.831 459.696 566.288 459.696 596.746 459.696 C 601.822 459.696 606.899 459.696 611.975 459.696 C 616.205 459.696 620.436 459.696 624.666 459.696 C 625.512 459.696 627.204 459.696 627.204 459.696 C 627.204 459.696 625.512 459.696 624.666 459.696 C 620.436 459.696 616.205 459.696 611.975 459.696 C 601.822 459.696 591.67 459.696 581.517 459.696 C 540.907 459.696 500.297 459.708 459.687 459.688 C 266.796 459.593 -119.01 459.696 -119.01 459.696 Z" />
    </svg>
  `,

    "show_regions--stack_all--facet_none":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Regions in one stack</title>
      <path stroke-width="3" id="asia" d="M -89.945 459.085 C -89.945 458.307 -88.389 459.084 -87.611 459.083 C -83.72 459.08 -79.83 459.078 -75.939 459.074 C -71.271 459.069 -66.602 459.064 -61.934 459.058 C -47.929 459.039 -33.925 459.019 -19.92 458.964 C 7.959 458.855 36.376 459.767 64.112 456.483 C 78.61 454.766 93.803 451.824 106.129 443.405 C 118.295 435.095 126.924 424.433 134.139 411.548 C 173.541 341.184 178.801 245.539 190.16 168.194 C 194.72 137.147 197.624 105.791 204.165 75.1 C 207.001 61.791 208.458 46.286 218.171 36.755 C 222.387 32.618 228.644 42.879 232.176 47.614 C 232.823 48.481 259.802 100.533 260.186 101.332 C 277.43 137.214 288.799 174.721 302.201 212.089 C 314.196 245.535 330.805 275.843 344.218 308.61 C 351.46 326.3 364.657 364.833 372.228 382.521 C 376.431 392.341 380.94 402.066 386.233 411.345 C 393.66 424.364 401.989 435.669 414.244 444.394 C 437.416 460.891 471.329 458.385 498.276 458.786 C 521.616 459.133 544.961 459.082 568.302 459.089 C 572.97 459.091 577.639 459.091 582.307 459.092 C 586.197 459.093 590.087 459.093 593.977 459.094 C 594.755 459.094 596.312 458.317 596.312 459.095 C 596.312 459.873 594.755 459.095 593.977 459.095 C 590.087 459.095 586.197 459.094 582.307 459.094 C 577.639 459.093 572.97 459.093 568.302 459.092 C 540.295 459.086 512.274 459.229 484.271 458.655 C 461.267 458.184 435.11 458.789 414.244 447.491 C 380.847 429.408 371.421 390.81 344.218 366.926 C 333.344 357.378 329.19 358.641 316.207 355.759 C 306.754 353.66 297.634 350.221 288.196 348.056 C 272.811 344.527 261.292 349.51 246.182 349.446 C 231.483 349.384 218.925 337.815 204.165 341.337 C 199.043 342.56 194.383 345.503 190.16 348.649 C 155.453 374.501 144.342 422.707 106.129 445.008 C 85.395 457.108 59.381 457.595 36.102 458.337 C -5.873 459.675 -89.945 459.863 -89.945 459.085 Z" />
      <path stroke-width="3" id="africa" d="M -87.611 459.084 C -83.72 459.082 -79.83 459.079 -75.939 459.076 C -61.934 459.064 -47.929 459.053 -33.924 459.02 C 2.797 458.935 41.902 461.828 78.118 454.705 C 122.184 446.038 137.623 413.633 162.15 380.17 C 172.255 366.384 185.927 345.69 204.165 341.337 C 218.925 337.815 231.483 349.384 246.182 349.446 C 255.59 349.486 264.785 345.782 274.191 345.967 C 285.897 346.197 291.072 349.331 302.201 352.392 C 316.9 356.434 332.09 356.277 344.218 366.926 C 371.421 390.81 380.847 429.408 414.244 447.491 C 431.145 456.642 451.534 457.54 470.265 458.286 C 493.58 459.215 516.962 459.04 540.29 459.076 C 554.296 459.098 568.301 459.092 582.307 459.094 C 586.197 459.094 590.087 459.095 593.977 459.095 C 593.978 459.095 596.313 459.096 596.312 459.096 C 558.972 459.096 521.606 459.417 484.271 458.677 C 461.277 458.221 435.144 458.862 414.244 447.675 C 380.415 429.569 372.012 391.343 344.218 368.895 C 332.158 359.154 302.846 358.114 288.196 361.999 C 269.464 366.967 258.32 383.836 246.182 397.42 C 233.423 411.699 220.46 426.024 204.165 436.417 C 187.251 447.204 167.723 451.552 148.144 454.394 C 111.168 459.761 73.364 458.83 36.102 458.943 C 3.423 459.042 -29.255 459.064 -61.934 459.08 C -66.602 459.082 -71.271 459.084 -75.939 459.086 C -79.83 459.088 -83.72 459.089 -87.611 459.09 C -89.758 459.091 -88.395 459.085 -87.611 459.084 Z" />
      <path stroke-width="3" id="europe" d="M -87.611 459.094 C -83.72 459.094 -79.83 459.093 -75.939 459.093 C -61.934 459.091 -47.929 459.091 -33.924 459.089 C 3.423 459.085 40.771 459.087 78.118 459.064 C 106.123 459.047 134.149 459.253 162.15 458.653 C 180.742 458.255 200.188 458.145 218.171 452.761 C 242.125 445.589 254.85 428.126 274.191 414.022 C 286.869 404.777 300.875 402.244 316.207 401.571 C 320.872 401.366 325.663 400.696 330.213 401.745 C 354.297 407.297 366.331 433.9 386.233 446.443 C 406.705 459.346 433.02 458.535 456.26 458.859 C 493.599 459.379 530.96 459.092 568.302 459.095 C 572.97 459.095 577.639 459.096 582.307 459.096 C 586.197 459.096 590.087 459.096 593.977 459.096 C 594.755 459.096 596.312 459.096 596.312 459.096 C 596.312 459.096 594.755 459.096 593.977 459.096 C 590.087 459.096 586.197 459.096 582.307 459.096 C 577.639 459.096 572.97 459.096 568.302 459.096 C 530.955 459.096 493.607 459.096 456.26 459.096 C 316.207 459.096 176.155 459.096 36.102 459.096 C 3.423 459.096 -29.255 459.096 -61.934 459.096 C -66.602 459.096 -71.271 459.096 -75.939 459.096 C -79.83 459.096 -83.72 459.096 -87.611 459.096 C -88.389 459.096 -88.391 459.094 -87.611 459.094 Z" />
      <path stroke-width="3" id="americas" d="M -87.611 459.09 C -83.72 459.089 -79.83 459.088 -75.939 459.086 C -71.271 459.084 -66.602 459.082 -61.934 459.08 C -47.929 459.073 -33.925 459.063 -19.92 459.047 C 31.202 458.99 83.213 461.287 134.139 456.093 C 164.958 452.949 193.927 446.47 218.171 425.995 C 245.842 402.625 262.557 362.391 302.201 360.888 C 316.658 360.34 332.144 359.144 344.218 368.895 C 355.264 377.817 364.327 393.746 372.228 404.833 C 387.218 425.87 402.55 445.443 428.249 453.157 C 461.556 463.155 505.544 459.03 540.29 459.08 C 554.296 459.1 568.301 459.094 582.307 459.095 C 586.197 459.095 590.087 459.095 593.977 459.095 C 594.755 459.095 596.312 458.318 596.312 459.096 C 596.312 459.874 594.755 459.096 593.977 459.096 C 590.087 459.096 586.197 459.096 582.307 459.096 C 577.639 459.096 572.97 459.095 568.302 459.095 C 544.96 459.093 521.618 459.106 498.276 459.064 C 468.315 459.009 428.598 463.011 400.239 453.008 C 388.309 448.8 381.652 444.003 372.228 435.354 C 359.153 423.353 348.817 406.034 330.213 401.745 C 324.828 400.504 307.474 402.12 302.201 402.974 C 267.736 408.559 251.249 442.858 218.171 452.761 C 191.549 460.731 161.604 458.808 134.139 458.957 C 92.125 459.185 50.107 459.077 8.092 459.083 C -15.25 459.086 -38.592 459.088 -61.934 459.091 C -66.602 459.091 -71.271 459.092 -75.939 459.093 C -79.83 459.093 -83.72 459.094 -87.611 459.094 C -89.864 459.094 -88.392 459.09 -87.611 459.09 Z" />
    </svg>
  `,

    "show_world--stack_all--facet_none":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>World total</title>
      <path stroke-width="4" id="world" d="M -64.105 463.26 C -50.056 463.233 -35.846 465.285 -21.958 463.166 C 25.231 455.966 90.573 474.087 118.528 435.394 C 171.838 361.608 167.87 260.091 188.773 171.494 C 196.001 140.858 196.26 108.898 202.821 78.112 C 205.666 64.762 207.127 49.208 216.87 39.647 C 221.099 35.497 227.375 45.79 230.918 50.54 C 236.945 58.62 240.5 68.283 244.968 77.319 C 254.551 96.701 265.016 115.715 273.065 135.782 C 288.457 174.157 299.927 214.025 315.211 252.443 C 323.364 272.936 334.578 292.093 343.308 312.346 C 357.999 346.427 368.444 382.414 385.455 415.399 C 415.425 473.512 458.013 456.749 525.941 463.228 C 539.926 464.562 554.038 463.274 568.087 463.291 C 572.77 463.297 577.453 463.294 582.136 463.295 C 586.038 463.296 589.941 463.296 593.843 463.297 C 594.623 463.297 596.964 463.298 596.184 463.298 C 418.234 463.298 240.283 463.298 62.333 463.298 C 24.87 463.298 -12.592 463.298 -50.055 463.298 C -59.421 463.298 -68.81 463.269 -64.105 463.26 Z" />
    </svg>
  `,

    "show_geo--stack_all--facet_isness":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Groupings in facets, countries each in a facet on it's own</title>
      <path stroke-width="3" id="nga" d="M -274.956 157.508 C -274.956 157.508 -272.506 157.508 -271.281 157.508 C -265.155 157.508 -259.028 157.508 -252.902 157.508 C -245.551 157.508 -238.199 157.506 -230.848 157.506 C -208.794 157.505 -186.739 157.508 -164.685 157.506 C -120.6 157.503 -76.431 158.172 -32.36 156.902 C -10.715 156.278 13.183 156.309 33.802 148.636 C 76.253 132.839 93.545 90.716 122.019 59.245 C 132.323 47.857 147.217 30.619 166.125 36.025 C 183.38 40.958 201.301 68.13 210.233 79.676 C 225.487 99.395 234.765 115.493 254.342 130.993 C 279.28 150.737 312.038 154.229 342.559 156.025 C 379.216 158.182 416.127 157.427 452.829 157.469 C 541.046 157.569 629.262 157.508 717.479 157.508 C 739.533 157.508 761.587 157.508 783.641 157.508 C 789.767 157.508 795.894 157.508 802.02 157.508 C 803.245 157.508 805.696 157.508 805.696 157.508 C 805.696 157.508 803.245 157.508 802.02 157.508 C 795.894 157.508 789.767 157.508 783.641 157.508 C 768.938 157.508 754.236 157.508 739.533 157.508 C 680.722 157.508 621.911 157.508 563.1 157.508 C 283.748 157.508 -274.956 157.508 -274.956 157.508 Z" />
      <path stroke-width="3" id="asia" d="M -274.956 459.331 C -274.956 459.331 -272.506 459.33 -271.281 459.33 C -265.155 459.328 -259.028 459.327 -252.902 459.325 C -245.551 459.323 -238.199 459.32 -230.848 459.317 C -208.794 459.308 -186.739 459.296 -164.685 459.267 C -120.601 459.209 -76.419 459.705 -32.36 457.964 C 5.054 456.486 44.87 454.043 77.909 434.366 C 126.263 405.568 144.534 355.595 166.126 306.565 C 172.462 292.178 186.009 245.465 210.234 237.538 C 217.451 235.176 225.356 240.141 232.288 243.241 C 240.24 246.797 247.003 252.568 254.342 257.261 C 271.287 268.098 282.823 274.945 298.451 287.869 C 321.634 307.04 340.843 330.44 364.613 348.946 C 378.848 360.028 394.735 368.913 408.721 380.307 C 445.343 410.141 470.859 440.186 518.992 451.616 C 547.639 458.419 577.951 458.313 607.209 458.792 C 643.959 459.394 680.725 459.298 717.479 459.322 C 739.533 459.337 761.588 459.334 783.642 459.335 C 789.768 459.335 795.894 459.335 802.02 459.335 C 802.022 459.335 805.698 459.337 805.696 459.337 C 746.887 459.369 688.071 459.505 629.263 459.106 C 592.702 458.858 555.118 459.766 518.992 453.242 C 495.49 448.998 474.292 440.681 452.83 430.445 C 436.452 422.634 426.199 416.051 408.721 410.933 C 391.281 405.826 382.501 406.392 364.613 405.068 C 342.592 403.438 320.56 400.069 298.451 399.924 C 283.736 399.828 269.058 401.774 254.342 401.753 C 232.132 401.722 210.408 395.725 188.18 397.494 C 132.855 401.897 87.809 441.43 33.802 451.939 C -9.38 460.342 -54.74 458.849 -98.523 459.102 C -157.332 459.442 -274.956 459.331 -274.956 459.331 Z" />
      <path stroke-width="3" id="americas" d="M -271.281 459.334 C -265.155 459.333 -259.028 459.332 -252.902 459.331 C -230.848 459.328 -208.793 459.326 -186.739 459.319 C -135.279 459.303 -83.819 459.322 -32.36 459.189 C 39.507 459.003 117.681 462.422 188.18 447.427 C 226.294 439.32 260.746 420.377 298.451 411.661 C 315.054 407.823 325.66 407.976 342.559 407.762 C 364.421 407.485 387.368 406.215 408.721 411.966 C 439.567 420.273 466.089 439.548 496.938 448.345 C 532.573 458.507 570.47 458.453 607.209 458.929 C 658.661 459.596 710.133 459.334 761.588 459.335 C 768.939 459.335 776.291 459.335 783.642 459.335 C 789.768 459.335 795.894 459.336 802.02 459.337 C 803.245 459.337 805.696 459.337 805.696 459.337 C 805.696 459.337 803.245 459.337 802.02 459.337 C 795.894 459.337 789.768 459.337 783.642 459.337 C 776.291 459.337 768.939 459.337 761.588 459.337 C 717.48 459.335 673.371 459.352 629.263 459.302 C 578.542 459.245 524.827 463.187 474.884 452.691 C 452.154 447.914 431.303 437.624 408.721 432.518 C 391.043 428.521 382.582 428.862 364.613 429.126 C 342.369 429.452 320.163 430.385 298.451 435.665 C 276.128 441.093 255.074 449.404 232.288 453.21 C 169.213 463.746 97.907 459.271 33.802 459.307 C -47.063 459.353 -127.929 459.33 -208.794 459.334 C -223.497 459.335 -238.199 459.335 -252.902 459.335 C -259.028 459.335 -265.155 459.335 -271.281 459.335 C -272.507 459.335 -272.507 459.334 -271.281 459.334 Z" />
      <path stroke-width="3" id="africa" d="M -271.281 459.33 C -265.155 459.329 -259.028 459.328 -252.902 459.326 C -230.848 459.32 -208.793 459.313 -186.739 459.296 C -135.308 459.256 -83.766 459.932 -32.36 458.066 C 5.519 456.691 42.503 453.138 77.909 438.632 C 114.152 423.783 148.056 400.687 188.18 397.494 C 210.408 395.725 232.132 401.722 254.342 401.753 C 269.058 401.774 283.736 399.828 298.451 399.924 C 320.56 400.069 342.592 403.438 364.613 405.068 C 382.501 406.392 391.281 405.826 408.721 410.933 C 439.513 419.95 465.949 439.251 496.938 448.191 C 532.548 458.463 570.47 458.425 607.209 458.913 C 658.661 459.597 710.133 459.331 761.588 459.334 C 768.939 459.334 776.291 459.334 783.642 459.335 C 789.768 459.335 795.894 459.336 802.02 459.337 C 803.245 459.337 805.696 459.337 805.696 459.337 C 805.696 459.337 803.245 459.337 802.02 459.337 C 795.894 459.336 789.768 459.335 783.642 459.335 C 776.291 459.335 768.939 459.335 761.588 459.335 C 710.133 459.334 658.661 459.596 607.209 458.929 C 570.47 458.453 532.573 458.507 496.938 448.345 C 466.089 439.548 439.567 420.273 408.721 411.966 C 391.924 407.442 381.786 407.972 364.613 407.786 C 342.619 407.548 320.06 406.666 298.451 411.661 C 260.746 420.377 226.294 439.32 188.18 447.427 C 137.89 458.124 84.996 458.039 33.802 458.757 C -47.047 459.892 -127.939 459.308 -208.794 459.325 C -208.794 459.325 -252.902 459.331 -252.902 459.331 C -259.028 459.332 -265.155 459.333 -271.281 459.334 C -274.607 459.334 -272.509 459.33 -271.281 459.33 Z" />
      <path stroke-width="3" id="europe" d="M -271.281 459.335 C -265.155 459.335 -259.028 459.335 -252.902 459.335 C -238.199 459.335 -223.497 459.335 -208.794 459.334 C -149.983 459.331 -91.171 459.328 -32.36 459.323 C 11.747 459.319 55.856 459.371 99.963 459.211 C 136.652 459.078 173.679 459.66 210.234 456.01 C 241.089 452.929 268.612 442.921 298.451 435.665 C 320.163 430.385 342.369 429.452 364.613 429.126 C 382.582 428.862 391.043 428.521 408.721 432.518 C 431.303 437.624 452.154 447.914 474.884 452.691 C 517.867 461.725 563.554 459.182 607.209 459.271 C 658.669 459.376 710.128 459.335 761.588 459.337 C 768.939 459.337 776.291 459.337 783.642 459.337 C 789.768 459.337 795.894 459.337 802.02 459.337 C 803.245 459.337 805.696 459.337 805.696 459.337 C 805.696 459.337 803.245 459.337 802.02 459.337 C 795.894 459.337 789.768 459.337 783.642 459.337 C 776.291 459.337 768.939 459.337 761.588 459.337 C 702.777 459.337 643.965 459.337 585.154 459.337 C 364.613 459.337 144.072 459.337 -76.469 459.337 C -127.929 459.337 -179.388 459.337 -230.848 459.337 C -238.199 459.337 -245.551 459.337 -252.902 459.337 C -259.028 459.337 -265.155 459.337 -271.281 459.337 C -272.508 459.337 -272.508 459.335 -271.281 459.335 Z" />
    </svg>
  `,

    "show_regions--stack_all--facet_regions":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Regions in facets</title>
      <path stroke-width="3" id="asia" d="M -274.956 183.252 C -274.956 183.252 -272.506 183.252 -271.28 183.252 C -265.155 183.252 -259.029 183.252 -252.902 183.252 C -245.551 183.251 -238.2 183.251 -230.847 183.25 C -208.793 183.249 -186.74 183.248 -164.686 183.246 C -113.228 183.239 -61.764 183.375 -10.307 183.088 C 18.561 182.928 49.51 184.205 77.91 179.619 C 85.425 178.406 93.106 177.17 99.964 174.571 C 138.642 159.913 151.063 126.756 166.125 99.161 C 172.854 86.834 187.79 47.18 210.234 36.889 C 216.508 34.012 225.362 35.791 232.288 37.652 C 240.625 39.892 247.281 44.741 254.342 48.742 C 268.023 56.493 286.439 69.334 298.45 78.318 C 320.959 95.154 340.773 114.15 364.613 129.985 C 401.773 154.669 447.315 174.804 496.937 179.98 C 526.067 183.018 555.811 182.879 585.154 183.051 C 621.909 183.267 658.668 183.231 695.425 183.243 C 717.479 183.25 739.533 183.25 761.587 183.251 C 768.939 183.251 776.29 183.252 783.641 183.252 C 789.768 183.252 795.893 183.252 802.02 183.252 C 802.02 183.252 805.696 183.252 805.695 183.252 C 445.478 183.32 -274.956 183.252 -274.956 183.252 Z" />
      <path stroke-width="3" id="africa" d="M -271.279 460.502 C -265.154 460.502 -259.028 460.501 -252.901 460.5 C -230.846 460.498 -208.792 460.496 -186.739 460.486 C -135.312 460.464 -83.759 461.027 -32.361 459.548 C 5.656 458.453 42.81 455.692 77.91 443.863 C 112.763 432.117 147.514 410.821 188.181 414.235 C 212.879 416.31 232.67 428.048 254.343 435.908 C 275.396 443.544 297.621 449.598 320.505 453.29 C 356.54 459.104 394.084 459.353 430.777 459.876 C 489.572 460.714 548.406 460.47 607.209 460.489 C 658.668 460.507 710.128 460.504 761.588 460.505 C 768.94 460.505 776.291 460.505 783.642 460.505 C 789.769 460.505 795.894 460.505 802.021 460.505 C 803.245 460.505 805.696 460.505 805.696 460.505 C 805.696 460.505 803.245 460.505 802.021 460.505 C 795.894 460.505 789.769 460.505 783.642 460.505 C 776.291 460.505 768.94 460.505 761.588 460.505 C 702.777 460.505 643.966 460.505 585.155 460.505 C 364.614 460.505 144.072 460.505 -76.469 460.505 C -127.928 460.505 -179.387 460.505 -230.846 460.505 C -238.199 460.505 -245.55 460.505 -252.901 460.505 C -259.028 460.505 -265.154 460.505 -271.279 460.505 C -272.505 460.505 -272.507 460.502 -271.279 460.502 Z" />
      <path stroke-width="3" id="europe" d="M -271.279 265.634 C -265.154 265.634 -259.029 265.633 -252.902 265.633 C -245.551 265.633 -238.2 265.632 -230.847 265.632 C -179.388 265.631 -127.928 265.629 -76.469 265.626 C -17.659 265.623 41.154 265.704 99.964 265.529 C 136.63 265.42 173.735 265.933 210.235 262.91 C 243.707 260.139 267.162 252.309 298.451 244.865 C 325.878 238.341 357.907 235.87 386.668 237.54 C 411.053 238.956 430.536 246.754 452.83 253.241 C 474.509 259.549 495.836 262.779 518.993 264.144 C 584.681 268.015 651.631 265.629 717.479 265.633 C 739.533 265.634 761.587 265.634 783.641 265.634 C 789.768 265.634 795.894 265.634 802.02 265.634 C 802.02 265.634 805.696 265.635 805.695 265.635 C 563.1 265.68 320.505 265.635 77.91 265.635 C -10.307 265.635 -98.523 265.635 -186.74 265.635 C -208.793 265.635 -230.847 265.635 -252.902 265.635 C -259.029 265.635 -265.154 265.635 -271.279 265.635 C -272.507 265.635 -272.507 265.634 -271.279 265.634 Z" />
      <path stroke-width="3" id="americas" d="M -271.279 350.768 C -265.154 350.767 -259.029 350.767 -252.902 350.767 C -242.297 350.766 -219.399 350.764 -208.793 350.762 C -157.334 350.753 -105.874 350.75 -54.414 350.689 C 18.835 350.601 93.369 351.982 166.126 344.747 C 210.63 340.322 253.138 328.938 298.451 329.043 C 320.511 329.094 342.573 330.846 364.614 331.412 C 386.647 331.979 408.827 331.452 430.776 333.262 C 460.684 335.729 489.334 342.745 518.993 346.209 C 548.122 349.612 577.777 350.093 607.209 350.426 C 658.657 351.009 710.136 350.765 761.587 350.768 C 768.94 350.769 776.291 350.769 783.642 350.769 C 789.769 350.769 795.894 350.769 802.02 350.769 C 803.245 350.769 805.696 350.769 805.696 350.769 C 805.696 350.769 803.245 350.769 802.02 350.769 C 795.894 350.769 789.769 350.769 783.642 350.769 C 776.291 350.769 768.94 350.769 761.587 350.769 C 702.777 350.769 643.966 350.769 585.155 350.769 C 364.614 350.769 144.072 350.769 -76.469 350.769 C -127.928 350.769 -179.388 350.769 -230.847 350.769 C -238.2 350.769 -245.551 350.769 -252.902 350.769 C -259.029 350.769 -265.154 350.769 -271.279 350.769 C -272.507 350.769 -272.507 350.768 -271.279 350.768 Z" />
    </svg>
  `,

    "show_countries--stack_all--facet_regions":`
    <svg viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
      <title>Countries in facets by region</title>
      <path stroke-width="3" id="asia" d="M -274.956 183.252 C -274.956 183.252 -272.506 183.252 -271.28 183.252 C -265.155 183.252 -259.029 183.252 -252.902 183.252 C -245.551 183.251 -238.2 183.251 -230.847 183.25 C -208.793 183.249 -186.74 183.248 -164.686 183.246 C -113.228 183.239 -61.764 183.375 -10.307 183.088 C 18.561 182.928 49.51 184.205 77.91 179.619 C 85.425 178.406 93.106 177.17 99.964 174.571 C 138.642 159.913 151.063 126.756 166.125 99.161 C 172.854 86.834 187.79 47.18 210.234 36.889 C 216.508 34.012 225.362 35.791 232.288 37.652 C 240.625 39.892 247.281 44.741 254.342 48.742 C 268.023 56.493 286.439 69.334 298.45 78.318 C 320.959 95.154 340.773 114.15 364.613 129.985 C 401.773 154.669 447.315 174.804 496.937 179.98 C 526.067 183.018 555.811 182.879 585.154 183.051 C 621.909 183.267 658.668 183.231 695.425 183.243 C 717.479 183.25 739.533 183.25 761.587 183.251 C 768.939 183.251 776.29 183.252 783.641 183.252 C 789.768 183.252 795.893 183.252 802.02 183.252 C 802.02 183.252 805.696 183.252 805.695 183.252 C 445.478 183.32 -274.956 183.252 -274.956 183.252 Z" />
      <path stroke-width="3" id="chn" d="M -275.984 184.085 C -275.984 184.085 -273.53 184.085 -272.302 184.085 C -266.162 184.085 -260.022 184.085 -253.883 184.085 C -246.515 184.084 -239.15 184.084 -231.782 184.083 C -209.681 184.082 -187.581 184.082 -165.479 184.078 C -113.912 184.072 -62.339 184.207 -10.772 183.922 C 18.156 183.761 49.17 185.037 77.631 180.455 C 85.162 179.243 92.86 178.008 99.733 175.411 C 138.492 160.763 150.94 127.63 166.033 100.056 C 172.778 87.738 187.744 48.113 210.236 37.829 C 216.523 34.955 225.397 36.732 232.336 38.592 C 242.235 41.245 269.572 58.907 276.539 63.565 C 307.97 84.581 333.438 109.99 364.943 130.858 C 389.099 146.859 423.157 164.039 453.347 172.855 C 488.099 183.001 527.095 183.231 563.851 183.709 C 615.405 184.382 666.999 184.073 718.558 184.082 C 740.659 184.085 762.76 184.084 784.861 184.085 C 791 184.085 797.139 184.085 803.279 184.085 C 804.506 184.085 806.962 184.085 806.962 184.085 C 806.962 184.085 804.506 184.085 803.279 184.085 C 797.139 184.085 791 184.085 784.861 184.085 C 762.76 184.084 740.659 184.084 718.558 184.082 C 674.358 184.077 630.152 184.144 585.953 183.94 C 549.132 183.771 511.867 183.836 475.447 179.226 C 452.697 176.345 431.529 170.236 409.145 166.436 C 387.337 162.734 364.153 164.489 342.842 159.193 C 325.057 154.775 312.015 147.901 298.64 138.074 C 280.113 124.463 268.991 111.106 254.439 94.99 C 246.97 86.72 240.955 77.655 232.336 70.032 C 226.079 64.496 219.913 56.461 210.236 55.888 C 186.122 54.457 167.031 101.948 166.033 103.606 C 149.955 130.325 137.864 161.509 99.733 175.578 C 87.223 180.194 69.148 181.677 55.531 182.564 C 26.241 184.476 -3.504 183.935 -32.875 184.008 C -113.909 184.211 -275.984 184.085 -275.984 184.085 Z" />
      <path stroke-width="2" id="idn" d="M -275.984 184.085 C -275.984 184.085 -273.53 184.085 -272.302 184.085 C -266.162 184.085 -260.022 184.085 -253.883 184.085 C -231.782 184.085 -209.681 184.083 -187.581 184.082 C -121.289 184.077 -54.959 184.492 11.329 183.797 C 55.321 183.336 106.131 184.689 143.933 165.014 C 165.82 153.624 182.394 132.493 210.236 128.244 C 225.196 125.96 241.426 131.266 254.439 135.492 C 284.024 145.103 310.366 159.571 342.842 163.694 C 364.936 166.5 387.036 164.078 409.145 167.327 C 439.544 171.795 466 179.104 497.548 181.544 C 555.987 186.064 615.692 184.055 674.357 184.077 C 711.191 184.091 748.025 184.085 784.861 184.085 C 791 184.085 797.139 184.085 803.279 184.085 C 804.506 184.085 806.962 184.085 806.962 184.085 C 806.962 184.085 804.506 184.085 803.279 184.085 C 797.139 184.085 791 184.085 784.861 184.085 C 770.128 184.085 755.393 184.085 740.659 184.085 C 674.404 184.083 607.981 185.004 541.751 183.515 C 512.037 182.847 482.391 181.219 453.347 176.225 C 448.004 175.307 414.567 168.358 409.145 167.609 C 379.694 163.544 350.198 167.913 320.741 162.943 C 297.939 159.095 276.481 151.915 254.439 146.328 C 240.962 142.913 225.015 138.378 210.236 139.748 C 183.636 142.214 166.115 158.784 143.933 167.956 C 129.515 173.919 115.749 176.827 99.733 179.175 C 49.502 186.539 -4.057 183.993 -54.974 184.047 C -128.645 184.125 -275.984 184.085 -275.984 184.085 Z" />
      <path stroke-width="1" id="bgd" d="M -275.984 184.085 C -275.984 184.085 -273.53 184.085 -272.302 184.085 C -266.162 184.085 -260.022 184.085 -253.883 184.085 C -231.782 184.085 -209.681 184.083 -187.581 184.082 C -121.288 184.077 -54.959 184.485 11.329 183.799 C 55.569 183.34 101.713 182.778 143.933 171.675 C 174.059 163.752 199.138 150.694 232.336 151.021 C 262.712 151.319 291.243 159.923 320.741 163.975 C 350.255 168.029 379.774 163.705 409.145 167.688 C 431.542 170.725 452.877 176.741 475.447 179.461 C 519.136 184.727 563.947 183.931 608.053 184.018 C 659.622 184.118 711.191 184.085 762.76 184.085 C 770.128 184.085 777.495 184.085 784.861 184.085 C 791 184.085 797.139 184.085 803.279 184.085 C 804.506 184.085 806.962 184.085 806.962 184.085 C 806.962 184.085 804.506 184.085 803.279 184.085 C 797.139 184.085 791 184.085 784.861 184.085 C 770.128 184.085 755.393 184.085 740.659 184.085 C 674.404 184.083 607.982 185.003 541.751 183.521 C 512.037 182.855 482.398 181.23 453.347 176.268 C 447.385 175.25 415.202 168.559 409.145 167.749 C 386.849 164.766 365.223 167.504 342.842 166.647 C 312.983 165.504 284.425 158.148 254.439 157.805 C 223.551 157.451 195.453 164.274 166.033 170.172 C 137.07 175.979 107.502 179.744 77.631 181.736 C 26.329 185.158 -25.625 184.037 -77.076 184.062 C -143.379 184.097 -275.984 184.085 -275.984 184.085 Z" />
      <path stroke-width="1" id="vnm" d="M -275.984 184.085 C -275.984 184.085 -273.53 184.085 -272.302 184.085 C -266.162 184.085 -260.022 184.085 -253.883 184.085 C -231.782 184.085 -209.681 184.083 -187.581 184.082 C -121.287 184.077 -54.961 184.467 11.329 183.804 C 55.863 183.359 99.896 180.933 143.933 175.849 C 180.783 171.596 216.979 162.887 254.439 161.978 C 291.725 161.074 327.963 169.433 364.943 171.773 C 386.912 173.163 387.216 172.524 409.145 174.417 C 438.707 176.971 467.794 181 497.548 182.456 C 534.308 184.254 571.236 184 608.053 184.049 C 659.622 184.117 711.191 184.085 762.76 184.085 C 770.128 184.085 777.495 184.085 784.861 184.085 C 791 184.085 797.139 184.085 803.279 184.085 C 804.506 184.085 806.962 184.085 806.962 184.085 C 806.962 184.085 804.506 184.085 803.279 184.085 C 797.139 184.085 791 184.085 784.861 184.085 C 770.128 184.085 755.393 184.085 740.659 184.085 C 674.374 184.084 608.025 184.661 541.751 183.716 C 519.612 183.401 497.494 182.751 475.447 181.16 C 453.249 179.557 431.329 176.45 409.145 174.813 C 379.727 172.643 350.155 173.341 320.741 170.931 C 298.622 169.118 276.743 166.035 254.439 165.593 C 224.259 164.993 195.56 169.784 166.033 173.559 C 136.823 177.295 107.175 180.091 77.631 181.862 C 26.258 184.943 -25.583 184.035 -77.076 184.062 C -143.379 184.098 -275.984 184.085 -275.984 184.085 Z" />
      <path stroke-width="1" id="kor" d="M -275.984 184.085 C -275.984 184.085 -273.53 184.085 -272.302 184.085 C -266.162 184.085 -260.022 184.085 -253.883 184.085 C -231.782 184.085 -209.681 184.083 -187.581 184.082 C -121.287 184.077 -54.961 184.46 11.329 183.806 C 40.898 183.514 70.304 182.598 99.733 180.344 C 136.42 177.534 173.311 172.657 210.236 172.157 C 247.181 171.655 283.844 176.451 320.741 177.096 C 350.251 177.612 379.648 174.614 409.145 175.906 C 438.709 177.199 467.95 181.212 497.548 182.555 C 541.659 184.557 585.984 184.045 630.154 184.068 C 674.357 184.092 718.558 184.085 762.76 184.085 C 770.128 184.085 777.495 184.085 784.861 184.085 C 791 184.085 797.139 184.085 803.279 184.085 C 804.506 184.085 806.962 184.085 806.962 184.085 C 806.962 184.085 804.506 184.085 803.279 184.085 C 797.139 184.085 791 184.085 784.861 184.085 C 770.128 184.085 755.393 184.085 740.659 184.085 C 674.367 184.083 608.037 184.53 541.751 183.792 C 497.389 183.298 453.419 179.91 409.145 178.495 C 379.676 177.555 350.209 178.87 320.741 177.785 C 283.904 176.428 247.179 171.72 210.236 172.189 C 158.503 172.844 107.224 181.031 55.531 182.931 C 11.404 184.552 -32.909 184.039 -77.076 184.062 C -143.379 184.097 -275.984 184.085 -275.984 184.085 Z" />
      <path stroke-width="1" id="syr" d="M -275.984 184.085 C -275.984 184.085 -273.53 184.085 -272.302 184.085 C -266.162 184.085 -260.022 184.085 -253.883 184.085 C -231.782 184.085 -209.681 184.085 -187.581 184.085 C -121.278 184.085 -54.974 184.133 11.329 184.055 C 85.061 183.971 158.638 180.586 232.336 180.368 C 269.192 180.26 305.997 181.711 342.842 182.095 C 438.601 183.095 534.383 184.066 630.154 184.082 C 674.357 184.088 718.558 184.085 762.76 184.085 C 770.128 184.085 777.495 184.085 784.861 184.085 C 791 184.085 797.139 184.085 803.279 184.085 C 804.506 184.085 806.962 184.085 806.962 184.085 C 806.962 184.085 804.506 184.085 803.279 184.085 C 797.139 184.085 791 184.085 784.861 184.085 C 770.128 184.085 755.393 184.085 740.659 184.085 C 681.723 184.085 622.786 184.162 563.851 184.037 C 460.707 183.818 357.57 181.041 254.439 180.737 C 202.848 180.586 151.314 183.193 99.733 183.73 C -25.474 185.03 -275.984 184.085 -275.984 184.085 Z" />
      <path stroke-width="1" id="omn" d="M -275.984 184.085 C -275.984 184.085 -273.53 184.085 -272.302 184.085 C -266.162 184.085 -260.022 184.085 -253.883 184.085 C -231.782 184.085 -209.681 184.085 -187.581 184.085 C -121.278 184.085 -54.974 184.088 11.329 184.085 C 217.608 184.076 423.876 184.068 630.154 184.083 C 674.357 184.086 718.558 184.085 762.76 184.085 C 770.128 184.085 777.495 184.085 784.861 184.085 C 791 184.085 797.139 184.085 803.279 184.085 C 804.506 184.085 806.962 184.085 806.962 184.085 C 806.962 184.085 804.506 184.085 803.279 184.085 C 797.139 184.085 791 184.085 784.861 184.085 C 770.128 184.085 755.393 184.085 740.659 184.085 C 681.723 184.085 622.788 184.102 563.851 184.069 C 283.908 183.912 -275.984 184.085 -275.984 184.085 Z" />
      <path stroke-width="3" id="africa" d="M -271.279 460.502 C -265.154 460.502 -259.028 460.501 -252.901 460.5 C -230.846 460.498 -208.792 460.496 -186.739 460.486 C -135.312 460.464 -83.759 461.027 -32.361 459.548 C 5.656 458.453 42.81 455.692 77.91 443.863 C 112.763 432.117 147.514 410.821 188.181 414.235 C 212.879 416.31 232.67 428.048 254.343 435.908 C 275.396 443.544 297.621 449.598 320.505 453.29 C 356.54 459.104 394.084 459.353 430.777 459.876 C 489.572 460.714 548.406 460.47 607.209 460.489 C 658.668 460.507 710.128 460.504 761.588 460.505 C 768.94 460.505 776.291 460.505 783.642 460.505 C 789.769 460.505 795.894 460.505 802.021 460.505 C 803.245 460.505 805.696 460.505 805.696 460.505 C 805.696 460.505 803.245 460.505 802.021 460.505 C 795.894 460.505 789.769 460.505 783.642 460.505 C 776.291 460.505 768.94 460.505 761.588 460.505 C 702.777 460.505 643.966 460.505 585.155 460.505 C 364.614 460.505 144.072 460.505 -76.469 460.505 C -127.928 460.505 -179.387 460.505 -230.846 460.505 C -238.199 460.505 -245.55 460.505 -252.901 460.505 C -259.028 460.505 -265.154 460.505 -271.279 460.505 C -272.505 460.505 -272.507 460.502 -271.279 460.502 Z" />
      <path stroke-width="3" id="nga" d="M -275.984 460.853 C -275.984 460.853 -273.53 460.853 -272.302 460.853 C -266.162 460.852 -260.022 460.851 -253.883 460.851 C -231.782 460.848 -209.681 460.846 -187.581 460.836 C -121.782 460.809 -54.111 463.602 11.327 457.605 C 43.488 454.658 71.106 446.986 99.731 435.915 C 126.966 425.383 155.933 412.028 188.135 414.718 C 212.886 416.787 232.72 428.491 254.439 436.329 C 275.535 443.943 297.808 449.979 320.741 453.661 C 356.852 459.457 394.476 459.707 431.245 460.228 C 490.166 461.064 549.126 460.82 608.053 460.84 C 659.622 460.856 711.191 460.854 762.76 460.855 C 770.128 460.855 777.495 460.856 784.861 460.856 C 791 460.856 797.139 460.856 803.279 460.856 C 804.506 460.856 806.962 460.856 806.962 460.856 C 806.962 460.856 804.506 460.856 803.279 460.856 C 797.139 460.856 791 460.856 784.861 460.856 C 772.781 460.856 752.739 460.855 740.659 460.855 C 674.357 460.853 608.053 460.881 541.751 460.795 C 497.557 460.738 453.323 460.847 409.145 459.852 C 379.621 459.187 349.778 458.306 320.741 453.928 C 298.003 450.502 275.943 444.888 254.439 438.481 C 232.53 431.955 212.407 423.214 188.135 422.894 C 157.369 422.49 127.72 432.873 99.731 440.95 C 77.984 447.226 56.479 452.672 33.428 455.649 C -10.094 461.269 -55.168 460.528 -99.176 460.709 C -158.111 460.953 -275.984 460.853 -275.984 460.853 Z" />
      <path stroke-width="1" id="tza" d="M -275.984 460.853 C -275.984 460.853 -273.53 460.853 -272.302 460.853 C -266.162 460.852 -260.022 460.852 -253.883 460.851 C -231.782 460.85 -209.681 460.846 -187.581 460.838 C -121.476 460.815 -54.631 462.546 11.327 458.714 C 33.771 457.411 55.853 455.015 77.63 450.677 C 107.107 444.804 134.995 435.102 166.033 434.688 C 222.444 433.934 285.611 452.542 342.842 457.162 C 379.465 460.12 416.551 460.207 453.347 460.497 C 504.912 460.903 556.486 460.824 608.053 460.84 C 659.622 460.856 711.191 460.854 762.76 460.855 C 770.128 460.855 777.495 460.856 784.861 460.856 C 791 460.856 797.139 460.856 803.279 460.856 C 804.506 460.856 806.962 460.856 806.962 460.856 C 806.962 460.856 804.506 460.856 803.279 460.856 C 797.139 460.856 791 460.856 784.861 460.856 C 772.781 460.856 752.739 460.855 740.659 460.855 C 674.357 460.854 608.053 460.876 541.751 460.799 C 468.673 460.711 393.166 463.581 320.741 455.11 C 269.66 449.134 218.339 435.558 166.033 437.204 C 143.094 437.926 121.711 443.1 99.731 447.45 C 77.84 451.783 55.946 455.295 33.428 457.26 C -10.467 461.09 -55.057 460.606 -99.176 460.738 C -158.112 460.915 -275.984 460.853 -275.984 460.853 Z" />
      <path stroke-width="1" id="mar" d="M -275.984 460.853 C -275.984 460.853 -273.53 460.853 -272.302 460.853 C -266.162 460.853 -260.022 460.852 -253.883 460.851 C -231.782 460.849 -209.681 460.846 -187.581 460.839 C -121.399 460.816 -54.751 462.15 11.327 458.928 C 62.842 456.417 115.613 444.265 166.033 445.002 C 225.173 445.868 283.857 455.613 342.842 458.604 C 438.19 463.441 534.642 460.846 630.154 460.853 C 674.357 460.856 718.558 460.856 762.76 460.856 C 770.128 460.856 777.495 460.856 784.861 460.856 C 791 460.856 797.139 460.856 803.279 460.856 C 804.506 460.856 806.962 460.856 806.962 460.856 C 806.962 460.856 804.506 460.856 803.279 460.856 C 797.139 460.856 791 460.856 784.861 460.856 C 770.128 460.856 755.393 460.856 740.659 460.856 C 674.357 460.856 608.053 460.861 541.751 460.841 C 468.172 460.818 394.185 462.073 320.741 458.163 C 291.164 456.589 261.71 454.012 232.336 451.012 C 210.332 448.765 188.285 445.821 166.033 445.276 C 135.963 444.541 107.088 449.404 77.63 453.064 C 55.619 455.801 33.6 457.843 11.327 458.928 C -83.373 463.543 -275.984 460.853 -275.984 460.853 Z" />
      <path stroke-width="1" id="sen" d="M -275.984 460.855 C -275.984 460.855 -273.53 460.855 -272.302 460.855 C -266.162 460.854 -260.022 460.854 -253.883 460.853 C -231.782 460.852 -209.681 460.851 -187.581 460.848 C -121.296 460.838 -54.939 461.367 11.327 460.02 C 62.915 458.971 114.427 454.196 166.033 454.534 C 224.975 454.919 283.902 458.87 342.842 459.996 C 438.553 461.825 534.419 460.853 630.154 460.855 C 674.357 460.856 718.558 460.856 762.76 460.856 C 770.128 460.856 777.495 460.856 784.861 460.856 C 791 460.856 797.139 460.856 803.279 460.856 C 804.506 460.856 806.962 460.856 806.962 460.856 C 806.962 460.856 804.506 460.856 803.279 460.856 C 797.139 460.856 791 460.856 784.861 460.856 C 770.128 460.856 755.393 460.856 740.659 460.856 C 681.723 460.856 622.788 460.858 563.851 460.852 C 490.195 460.846 416.483 461.347 342.842 460.046 C 283.898 459.003 224.979 455.789 166.033 455.195 C 114.417 454.674 62.908 459.013 11.327 460.038 C -84.373 461.936 -275.984 460.855 -275.984 460.855 Z" />
      <path stroke-width="1" id="bdi" d="M -275.984 460.855 C -275.984 460.855 -273.53 460.855 -272.302 460.855 C -266.162 460.855 -260.022 460.855 -253.883 460.855 C -231.782 460.854 -209.681 460.853 -187.581 460.851 C -121.282 460.845 -54.965 461.117 11.327 460.365 C 55.534 459.863 99.716 458.387 143.933 458.346 C 217.627 458.276 291.266 459.725 364.943 460.454 C 453.332 461.327 541.761 460.854 630.154 460.856 C 674.357 460.856 718.558 460.856 762.76 460.856 C 770.128 460.856 777.495 460.856 784.861 460.856 C 791 460.856 797.139 460.856 803.279 460.856 C 804.506 460.856 806.962 460.856 806.962 460.856 C 806.962 460.856 804.506 460.856 803.279 460.856 C 797.139 460.856 791 460.856 784.861 460.856 C 770.128 460.856 755.393 460.856 740.659 460.856 C 681.723 460.856 622.788 460.857 563.851 460.853 C 431.223 460.846 298.65 458.709 166.033 458.672 C 114.459 458.657 62.899 460.075 11.327 460.477 C -84.434 461.222 -275.984 460.855 -275.984 460.855 Z" />
      <path stroke-width="1" id="tun" d="M -275.984 460.855 C -275.984 460.855 -273.53 460.855 -272.302 460.855 C -266.162 460.855 -260.022 460.855 -253.883 460.855 C -231.782 460.854 -209.681 460.853 -187.581 460.851 C -121.28 460.846 -54.97 460.993 11.327 460.477 C 62.899 460.075 114.459 458.657 166.033 458.672 C 239.73 458.692 313.361 460.172 387.044 460.626 C 468.075 461.125 549.121 460.854 630.154 460.856 C 674.357 460.856 718.558 460.856 762.76 460.856 C 770.128 460.856 777.495 460.856 784.861 460.856 C 791 460.856 797.139 460.856 803.279 460.856 C 804.506 460.856 806.962 460.856 806.962 460.856 C 806.962 460.856 804.506 460.856 803.279 460.856 C 797.139 460.856 791 460.856 784.861 460.856 C 770.128 460.856 755.393 460.856 740.659 460.856 C 681.723 460.856 622.788 460.856 563.851 460.853 C 431.225 460.847 298.648 459.061 166.033 458.728 C 114.461 458.599 62.896 460.076 11.327 460.477 C -84.434 461.222 -275.984 460.855 -275.984 460.855 Z" />
      <path stroke-width="1" id="mrt" d="M -275.984 460.856 C -275.984 460.856 -273.53 460.856 -272.302 460.856 C -266.162 460.856 -260.022 460.856 -253.883 460.856 C -231.782 460.856 -209.681 460.856 -187.581 460.855 C -121.278 460.854 -54.975 460.888 11.327 460.819 C 217.608 460.607 423.871 460.856 630.154 460.856 C 674.357 460.856 718.558 460.856 762.76 460.856 C 770.128 460.856 777.495 460.856 784.861 460.856 C 791 460.856 797.139 460.856 803.279 460.856 C 804.506 460.856 806.962 460.856 806.962 460.856 C 806.962 460.856 804.506 460.856 803.279 460.856 C 797.139 460.856 791 460.856 784.861 460.856 C 770.128 460.856 755.393 460.856 740.659 460.856 C 681.723 460.856 622.788 460.856 563.851 460.854 C 283.904 460.846 -275.984 460.856 -275.984 460.856 Z" />
      <path stroke-width="3" id="europe" d="M -271.279 265.634 C -265.154 265.634 -259.029 265.633 -252.902 265.633 C -245.551 265.633 -238.2 265.632 -230.847 265.632 C -179.388 265.631 -127.928 265.629 -76.469 265.626 C -17.659 265.623 41.154 265.704 99.964 265.529 C 136.63 265.42 173.735 265.933 210.235 262.91 C 243.707 260.139 267.162 252.309 298.451 244.865 C 325.878 238.341 357.907 235.87 386.668 237.54 C 411.053 238.956 430.536 246.754 452.83 253.241 C 474.509 259.549 495.836 262.779 518.993 264.144 C 584.681 268.015 651.631 265.629 717.479 265.633 C 739.533 265.634 761.587 265.634 783.641 265.634 C 789.768 265.634 795.894 265.634 802.02 265.634 C 802.02 265.634 805.696 265.635 805.695 265.635 C 563.1 265.68 320.505 265.635 77.91 265.635 C -10.307 265.635 -98.523 265.635 -186.74 265.635 C -208.793 265.635 -230.847 265.635 -252.902 265.635 C -259.029 265.635 -265.154 265.635 -271.279 265.635 C -272.507 265.635 -272.507 265.634 -271.279 265.634 Z" />
      <path stroke-width="3" id="rus" d="M -275.984 266.409 C -275.984 266.409 -273.529 266.409 -272.3 266.409 C -266.161 266.409 -260.022 266.408 -253.883 266.408 C -231.782 266.407 -209.681 266.406 -187.581 266.406 C -121.278 266.403 -54.974 266.408 11.329 266.39 C 55.525 266.378 99.74 266.559 143.934 266.044 C 173.366 265.701 203.314 265.432 232.337 261.329 C 255.642 258.034 276.242 250.882 298.641 245.539 C 326.126 238.983 358.223 236.499 387.045 238.177 C 419.048 240.041 445.158 253.384 475.448 259.677 C 517.851 268.489 564.493 266.249 608.053 266.343 C 659.622 266.452 711.191 266.409 762.76 266.409 C 770.128 266.409 777.495 266.409 784.861 266.409 C 791 266.409 797.14 266.409 803.28 266.409 C 804.506 266.409 806.962 266.409 806.962 266.409 C 806.962 266.409 804.506 266.409 803.28 266.409 C 797.14 266.409 791 266.409 784.861 266.409 C 770.128 266.409 755.393 266.409 740.659 266.409 C 674.423 266.406 607.955 267.506 541.751 265.796 C 519.502 265.221 497.08 264.302 475.448 260.004 C 445.326 254.017 419.135 241.079 387.045 241.165 C 341.472 241.289 298.508 253.917 254.439 260.211 C 239.946 262.281 224.935 263.435 210.237 264.275 C 144.252 268.045 77.454 266.373 11.329 266.39 C -84.443 266.417 -275.984 266.409 -275.984 266.409 Z" />
      <path stroke-width="1" id="esp" d="M -275.984 266.409 C -275.984 266.409 -273.529 266.409 -272.3 266.409 C -266.161 266.409 -260.022 266.409 -253.883 266.409 C -231.782 266.409 -209.681 266.409 -187.581 266.408 C -121.278 266.406 -54.974 266.41 11.329 266.4 C 84.725 266.386 159.116 268.655 232.337 264.29 C 269.519 262.072 305.4 254.591 342.843 254.41 C 387.835 254.193 430.929 261.058 475.448 264.223 C 526.677 267.867 578.759 266.386 630.154 266.401 C 674.357 266.412 718.558 266.409 762.76 266.409 C 770.128 266.409 777.495 266.409 784.861 266.409 C 791 266.409 797.14 266.409 803.28 266.409 C 804.506 266.409 806.962 266.409 806.962 266.409 C 806.962 266.409 804.506 266.409 803.28 266.409 C 797.14 266.409 791 266.409 784.861 266.409 C 784.861 266.409 740.659 266.409 740.659 266.409 C 674.361 266.409 608.046 266.714 541.751 266.256 C 519.639 266.103 497.506 265.864 475.448 264.577 C 431.136 261.992 387.392 256.673 342.843 255.972 C 312.585 255.495 284.265 260.125 254.439 262.85 C 232.444 264.859 210.269 265.453 188.136 265.842 C 33.565 268.56 -275.984 266.409 -275.984 266.409 Z" />
      <path stroke-width="1" id="rou" d="M -275.984 266.409 C -275.984 266.409 -273.529 266.409 -272.3 266.409 C -266.161 266.409 -260.022 266.409 -253.883 266.409 C -231.782 266.409 -209.681 266.409 -187.581 266.409 C -121.278 266.409 -54.974 266.412 11.329 266.402 C 84.971 266.393 158.727 267.063 232.337 265.128 C 276.63 263.964 320.63 259.432 364.943 258.893 C 402.173 258.439 438.448 262.54 475.448 264.623 C 526.814 267.516 578.685 266.39 630.154 266.402 C 674.357 266.41 718.558 266.409 762.76 266.409 C 770.128 266.409 777.495 266.409 784.861 266.409 C 791 266.409 797.14 266.409 803.28 266.409 C 804.506 266.409 806.962 266.409 806.962 266.409 C 806.962 266.409 804.506 266.409 803.28 266.409 C 797.14 266.409 791 266.409 784.861 266.409 C 784.861 266.409 740.659 266.409 740.659 266.409 C 681.725 266.409 622.786 266.508 563.851 266.347 C 534.382 266.265 504.855 266.268 475.448 264.642 C 445.919 263.008 416.712 259.615 387.045 259.375 C 350.064 259.076 313.382 262.131 276.539 263.885 C 247.12 265.286 217.607 265.711 188.136 266.025 C 33.478 267.678 -275.984 266.409 -275.984 266.409 Z" />
      <path stroke-width="1" id="swe" d="M -275.984 266.409 C -275.984 266.409 -273.529 266.409 -272.3 266.409 C -266.161 266.409 -260.022 266.409 -253.883 266.409 C -231.782 266.409 -209.681 266.409 -187.581 266.409 C -121.278 266.408 -54.974 266.409 11.329 266.406 C 84.995 266.402 158.686 266.722 232.337 265.469 C 283.905 264.592 335.453 262.117 387.045 262.3 C 416.584 262.405 445.962 264.152 475.448 265.189 C 512.252 266.484 549.117 266.361 585.953 266.389 C 637.522 266.428 689.091 266.409 740.659 266.409 C 740.659 266.409 784.861 266.409 784.861 266.409 C 791 266.409 797.14 266.409 803.28 266.409 C 803.28 266.409 806.963 266.409 806.962 266.409 C 711.209 266.427 615.397 267.08 519.651 266.18 C 468.04 265.695 416.573 262.575 364.943 262.689 C 298.637 262.837 232.363 265.842 166.034 266.226 C 18.709 267.078 -275.984 266.409 -275.984 266.409 Z" />
      <path stroke-width="1" id="che" d="M -275.984 266.409 C -275.984 266.409 -273.529 266.409 -272.3 266.409 C -266.161 266.409 -260.022 266.409 -253.883 266.409 C -231.782 266.409 -209.681 266.409 -187.581 266.409 C -121.278 266.409 -54.974 266.41 11.329 266.408 C 70.261 266.405 129.207 266.599 188.136 266.076 C 254.439 265.488 320.734 263.768 387.045 263.792 C 423.906 263.806 460.701 265.445 497.549 265.986 C 541.739 266.635 585.959 266.401 630.154 266.405 C 674.357 266.409 718.558 266.409 762.76 266.409 C 770.128 266.409 777.495 266.409 784.861 266.409 C 791 266.409 797.14 266.409 803.28 266.409 C 804.506 266.409 806.962 266.409 806.962 266.409 C 806.962 266.409 804.506 266.409 803.28 266.409 C 797.14 266.409 791 266.409 784.861 266.409 C 770.128 266.409 755.393 266.409 740.659 266.409 C 681.723 266.409 622.788 266.445 563.851 266.387 C 504.879 266.33 445.996 264.401 387.045 264.106 C 313.363 263.735 239.707 265.827 166.034 266.233 C 18.707 267.047 -275.984 266.409 -275.984 266.409 Z" />
      <path stroke-width="1" id="irl" d="M -275.984 266.409 C -275.984 266.409 -273.529 266.409 -272.3 266.409 C -266.161 266.409 -260.022 266.409 -253.883 266.409 C -231.782 266.409 -209.681 266.409 -187.581 266.409 C -121.278 266.409 -54.974 266.41 11.329 266.409 C 129.206 266.405 247.071 265.187 364.943 265.305 C 453.347 265.394 541.744 266.406 630.154 266.409 C 674.357 266.409 718.558 266.409 762.76 266.409 C 770.128 266.409 777.495 266.409 784.861 266.409 C 791 266.409 797.14 266.409 803.28 266.409 C 804.506 266.409 806.962 266.409 806.962 266.409 C 806.962 266.409 804.506 266.409 803.28 266.409 C 797.14 266.409 791 266.409 784.861 266.409 C 784.861 266.409 740.659 266.409 740.659 266.409 C 681.723 266.409 622.788 266.417 563.851 266.405 C 490.177 266.39 416.512 265.451 342.843 265.406 C 136.575 265.281 -275.984 266.409 -275.984 266.409 Z" />
      <path stroke-width="1" id="geo" d="M -275.984 266.409 C -275.984 266.409 -273.529 266.409 -272.3 266.409 C -266.161 266.409 -260.022 266.409 -253.883 266.409 C -231.782 266.409 -209.681 266.409 -187.581 266.409 C -121.278 266.409 -54.974 266.41 11.329 266.409 C 217.607 266.402 423.876 266.406 630.154 266.409 C 674.357 266.409 718.558 266.409 762.76 266.409 C 770.128 266.409 777.495 266.409 784.861 266.409 C 791 266.409 797.14 266.409 803.28 266.409 C 804.506 266.409 806.962 266.409 806.962 266.409 C 806.962 266.409 804.506 266.409 803.28 266.409 C 797.14 266.409 791 266.409 784.861 266.409 C 784.861 266.409 740.659 266.409 740.659 266.409 C 681.723 266.409 622.788 266.417 563.851 266.405 C 283.909 266.353 -275.984 266.409 -275.984 266.409 Z" />
      <path stroke-width="3" id="americas" d="M -271.279 350.768 C -265.154 350.767 -259.029 350.767 -252.902 350.767 C -242.297 350.766 -219.399 350.764 -208.793 350.762 C -157.334 350.753 -105.874 350.75 -54.414 350.689 C 18.835 350.601 93.369 351.982 166.126 344.747 C 210.63 340.322 253.138 328.938 298.451 329.043 C 320.511 329.094 342.573 330.846 364.614 331.412 C 386.647 331.979 408.827 331.452 430.776 333.262 C 460.684 335.729 489.334 342.745 518.993 346.209 C 548.122 349.612 577.777 350.093 607.209 350.426 C 658.657 351.009 710.136 350.765 761.587 350.768 C 768.94 350.769 776.291 350.769 783.642 350.769 C 789.769 350.769 795.894 350.769 802.02 350.769 C 803.245 350.769 805.696 350.769 805.696 350.769 C 805.696 350.769 803.245 350.769 802.02 350.769 C 795.894 350.769 789.769 350.769 783.642 350.769 C 776.291 350.769 768.94 350.769 761.587 350.769 C 702.777 350.769 643.966 350.769 585.155 350.769 C 364.614 350.769 144.072 350.769 -76.469 350.769 C -127.928 350.769 -179.388 350.769 -230.847 350.769 C -238.2 350.769 -245.551 350.769 -252.902 350.769 C -259.029 350.769 -265.154 350.769 -271.279 350.769 C -272.507 350.769 -272.507 350.768 -271.279 350.768 Z" />
      <path stroke-width="3" id="usa" d="M -272.3 352.072 C -266.161 352.072 -260.022 352.072 -253.883 352.071 C -243.255 352.071 -220.31 352.069 -209.681 352.066 C -158.112 352.057 -106.543 352.055 -54.974 351.992 C 18.431 351.902 93.125 353.315 166.034 345.913 C 210.634 341.385 253.231 329.737 298.641 329.845 C 320.748 329.897 342.855 331.69 364.943 332.27 C 387.024 332.849 409.252 332.31 431.246 334.162 C 461.217 336.686 489.928 343.864 519.651 347.408 C 548.84 350.89 578.56 351.382 608.054 351.723 C 659.611 352.319 711.199 352.07 762.761 352.072 C 770.129 352.073 777.496 352.073 784.861 352.073 C 791.001 352.073 797.14 352.074 803.28 352.074 C 804.506 352.074 806.963 352.074 806.963 352.074 C 806.963 352.074 804.506 352.074 803.28 352.074 C 797.14 352.074 791.001 352.073 784.861 352.073 C 777.496 352.073 770.129 352.073 762.761 352.073 C 718.56 352.072 674.358 352.087 630.156 352.043 C 556.344 351.971 482.507 352.25 409.146 345.272 C 365.104 341.082 321.288 329.606 276.539 331.243 C 239.119 332.612 203.069 342.298 166.034 346.006 C 122.203 350.395 77.593 351.149 33.43 351.638 C -47.59 352.536 -128.656 352.07 -209.681 352.072 C -224.416 352.072 -239.15 352.073 -253.883 352.073 C -260.022 352.073 -266.161 352.073 -272.3 352.073 C -273.53 352.073 -273.53 352.072 -272.3 352.072 Z" />
      <path stroke-width="1" id="mex" d="M -275.984 352.073 C -275.984 352.073 -273.529 352.073 -272.3 352.073 C -266.161 352.073 -260.022 352.073 -253.883 352.073 C -231.782 352.072 -209.681 352.072 -187.581 352.071 C -121.279 352.067 -54.973 352.195 11.329 351.893 C 62.878 351.657 114.696 351.355 166.034 347.498 C 202.882 344.731 239.395 337.46 276.539 337.308 C 320.792 337.128 365.038 345.121 409.146 347.574 C 482.808 351.67 556.329 352.027 630.156 352.061 C 674.358 352.08 718.56 352.072 762.761 352.073 C 770.129 352.073 777.496 352.074 784.861 352.074 C 791.001 352.074 797.14 352.074 803.28 352.074 C 804.506 352.074 806.963 352.074 806.963 352.074 C 806.963 352.074 804.506 352.074 803.28 352.074 C 797.14 352.074 791.001 352.074 784.861 352.074 C 784.861 352.074 740.659 352.074 740.659 352.074 C 674.36 352.072 608.051 352.297 541.751 351.908 C 490.135 351.604 438.554 349.744 387.045 347.294 C 350.216 345.542 313.508 342.006 276.539 342.546 C 217.567 343.408 158.744 349.321 99.733 350.798 C -25.358 353.931 -275.984 352.073 -275.984 352.073 Z" />
      <path stroke-width="1" id="chl" d="M -275.984 352.074 C -275.984 352.074 -273.529 352.074 -272.3 352.074 C -266.161 352.074 -260.022 352.074 -253.883 352.074 C -231.782 352.074 -209.681 352.073 -187.581 352.073 C -121.278 352.073 -54.974 352.109 11.329 352.034 C 62.901 351.976 114.489 351.894 166.034 350.524 C 202.867 349.546 239.677 347.414 276.539 347.181 C 320.798 346.902 364.935 349.991 409.146 351.016 C 482.763 352.723 556.513 352.063 630.156 352.071 C 674.358 352.076 718.56 352.074 762.761 352.074 C 770.129 352.074 777.496 352.074 784.861 352.074 C 791.001 352.074 797.14 352.074 803.28 352.074 C 804.506 352.074 806.963 352.074 806.963 352.074 C 806.963 352.074 804.506 352.074 803.28 352.074 C 797.14 352.074 791.001 352.074 784.861 352.074 C 770.129 352.074 755.394 352.074 740.659 352.074 C 681.725 352.074 622.789 352.085 563.852 352.06 C 504.923 352.034 445.948 352.284 387.045 350.807 C 350.212 349.884 313.404 347.832 276.539 347.737 C 217.608 347.588 158.675 351.094 99.733 351.675 C -25.478 352.909 -275.984 352.074 -275.984 352.074 Z" />
      <path stroke-width="1" id="hnd" d="M -275.984 352.074 C -275.984 352.074 -273.529 352.074 -272.3 352.074 C -266.161 352.074 -260.022 352.074 -253.883 352.074 C -231.782 352.074 -209.681 352.074 -187.581 352.074 C -121.278 352.072 -54.974 352.085 11.329 352.059 C 99.745 352.024 188.135 350.595 276.539 350.442 C 394.392 350.237 512.285 352.07 630.156 352.072 C 674.358 352.074 718.56 352.074 762.761 352.074 C 770.129 352.074 777.496 352.074 784.861 352.074 C 791.001 352.074 797.14 352.074 803.28 352.074 C 804.506 352.074 806.963 352.074 806.963 352.074 C 806.963 352.074 804.506 352.074 803.28 352.074 C 797.14 352.074 791.001 352.074 784.861 352.074 C 770.129 352.074 755.394 352.074 740.659 352.074 C 681.725 352.074 622.789 352.08 563.852 352.066 C 468.086 352.044 372.294 350.407 276.539 350.715 C 92.363 351.309 -275.984 352.074 -275.984 352.074 Z" />
      <path stroke-width="1" id="cri" d="M -275.984 352.074 C -275.984 352.074 -273.529 352.074 -272.3 352.074 C -266.161 352.074 -260.022 352.074 -253.883 352.074 C -231.782 352.074 -209.681 352.074 -187.581 352.074 C -121.278 352.072 -54.974 352.076 11.329 352.071 C 217.607 352.058 423.876 352.067 630.156 352.073 C 674.358 352.075 718.56 352.074 762.761 352.074 C 770.129 352.074 777.496 352.074 784.861 352.074 C 791.001 352.074 797.14 352.074 803.28 352.074 C 804.506 352.074 806.963 352.074 806.963 352.074 C 806.963 352.074 804.506 352.074 803.28 352.074 C 797.14 352.074 791.001 352.074 784.861 352.074 C 770.129 352.074 755.394 352.074 740.659 352.074 C 681.725 352.074 622.789 352.079 563.852 352.071 C 283.906 352.035 -275.984 352.074 -275.984 352.074 Z" />
    </svg>
  `
  };

  const PRESETS_DEFAULT = [
    [{
      icon: "show_countries--stack_none--facet_none",
      mode: "show",
      loosePath: ["geo", "geo", "$in"],
      config: {
        data: {
          filter: {dimensions: {"geo": {"geo": {$in: ["usa", "chn", "rus", "nga"]}}}}
        },
        encoding: {
          stack: {data: {constant:"none", space: null, concept: null}},
          facet_row: {data: {constant: "none", concept: null, exceptions: null}}
        }
      }
    },{
      icon: "show_countries--stack_region--facet_none",
      mode: "select",
      config: {
        data: {
          filter: {dimensions: { "geo": { "un_state": true } }}
        },
        encoding: {
          stack: {data: {constant:null, space: ["geo"], concept: "world_4region"}},
          facet_row: {data: {constant: "none", concept: null, exceptions: null}}
        }
      }
    },{
      icon: "show_regions--stack_none--facet_none",
      mode: "none",
      groupPath: ["geo"],
      config: {
        data: {
          filter: {dimensions: { "geo": { "is--world_4region": true } }}
          //filter: {dimensions: {"geo": {"geo": {$in: ["americas", "europe", "africa", "asia"]}}}}
        },
        encoding: {
          stack: {data: {constant:"none", space: null, concept: null}},
          facet_row: {data: {constant: "none", concept: null, exceptions: null}}
        }
      }
    }],


    [{
      icon: "show_countries--stack_all--facet_none",
      mode: "select",
      config: {
        data: {
          filter: {dimensions: { "geo": { "un_state": true } }}
        },
        encoding: {
          stack: {data: {constant:"all", space: null, concept: null}},
          facet_row: {data: {constant: "none", concept: null, exceptions: null}}
        }
      }
    },{
      icon: "show_regions--stack_all--facet_none",
      mode: "none",
      groupPath: ["geo"],
      config: {
        data: {
          filter: {dimensions: { "geo": { "is--world_4region": true } }}
          //filter: {dimensions: {"geo": {"geo": {$in: ["americas", "europe", "africa", "asia"]}}}}
        },
        encoding: {
          stack: {data: {constant:"all", space: null, concept: null}},
          facet_row: {data: {constant: "none", concept: null, exceptions: null}}
        }
      }
    },{
      icon: "show_world--stack_all--facet_none",
      mode: "none",
      config: {
        data: {
          filter: {dimensions: { "geo": { "is--global": true } }}
          //filter: {dimensions: {"geo": {"geo": {$in: ["world"]}}}}
        },
        encoding: {
          stack: {data: {constant:"all", space: null, concept: null}},
          facet_row: {data: {constant: "none", concept: null, exceptions: null}}
        }
      }
    }],


    [{
      icon: "show_geo--stack_all--facet_isness",
      mode: "show",
      groupPath: ["geo", "$or", 0],
      loosePath: ["geo", "$or", 1, "geo", "$in"],
      config: {
        data: {
          filter: {dimensions: { "geo": { "$or": [{"is--world_4region": true}, {"geo": {"$in": ["chn"]}}] } }}
          //filter: {dimensions: {"geo": {"geo": {$in: ["americas", "europe", "africa", "asia", "chn"]}}}}
        },
        encoding: {
          stack: {data: {constant:"all", space: null, concept: null}},
          facet_row: {data: {constant: null, concept: "is--", exceptions: {"is--country": "geo"}}}
        }
      }
    },{
      icon: "show_regions--stack_all--facet_regions",
      mode: "none",
      groupPath: ["geo"],
      config: {
        data: {
          filter: {dimensions: { "geo": { "is--world_4region": true } }}
          //filter: {dimensions: {"geo": {"geo": {$in: ["americas", "europe", "africa", "asia"]}}}}
        },
        encoding: {
          stack: {data: {constant:"all", space: null, concept: null}},
          facet_row: {data: {constant: null, concept: "world_4region", exceptions: null}}
        }
      }
    },{
      icon: "show_countries--stack_all--facet_regions",
      mode: "select",
      config: {
        data: {
          filter: {dimensions: { "geo": { "un_state": true } }}
        },
        encoding: {
          stack: {data: {constant:"all", space: null, concept: null}},
          facet_row: {data: {constant: null, concept: "world_4region", exceptions: null}}
        }
      }
    }],
  ];

  //import draggablelist from "components/draggablelist/draggablelist";


  function followPath(base, path, createMissingObj = false){
    return path.reduce((a, p)=>{
      if (a == null) return null;

      if (Array.isArray(a) && !createMissingObj && (a.length <= p || a[p] == null))
        return null;    

      if (createMissingObj && a[p] == null) a[p] = {};
      
      return a[p];
    }, base);
  }

  /*
   * Presets dialog
   */
  class Presets extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title"> <span data-localise="buttons/presets"></span> </div>
        <div class="vzb-dialog-content">
          <div class="vzb-dialog-preset-container">
            <div class="vzb-form"></div>
            <div class="vzb-hint"><span data-localise="mount/presets/hint"></span></div>
          </div>
        </div>
      </div>
    `;
      config.subcomponents = [];
     
      super(config);
    }

    setup(options) {
      super.setup(options);
      const _this = this;

      this.DOM.container = this.element.select(".vzb-dialog-preset-container");
      this.DOM.form = this.DOM.container.select(".vzb-form").append("form");

      const PRESETS = mobx.toJS(this.root.model.config.presets) || PRESETS_DEFAULT;

      this.DOM.radioGroups = this.DOM.form.selectAll("fieldset")
        .data(PRESETS).enter().append("fieldset")
        .attr("class", "vzb-radio-svg-group")
        .each(function(d, i){
          d3.select(this)
            .attr("group", i)
            .selectAll("p").data(d)
            .enter().append("p")
            .attr("class", "vzb-radio-svg-item")
            .attr("group", i)
            .each(function(d){
              const id = d.icon;
              const view = d3.select(this);

              view.append("input")
                .attr("type", "radio")
                .attr("name", "presets")
                .attr("id", id)
                .attr("value", id);

              view.append("label")
                .attr("for", id)
                .html(ICONS[d.icon])
                .on("click", function(evt, d){ _this.setModel(d); });
            });
        })
        .on("mouseover", function(evt) {
          if(evt.shiftKey) _this.updateView(d3.select(this).attr("group"));
        })
        .on("mouseout", function(){
          _this.updateView();
        });
    }


    get MDL() {
      return {
        color: this.model.encoding["color"]
      };
    }  

    draw(){
      super.draw();
      this.addReaction(this.updateView);
      this.addReaction(this.setFilterToMatchColorConcept);
    }


    get activePreset(){
      const PRESETS = mobx.toJS(this.root.model.config.presets) || PRESETS_DEFAULT;

      PRESETS.flat().forEach(p => {
        p.score = sharedComponents.Utils.computeObjectsSimilarityScore(p.config, mobx.toJS(this.model.config), "is--"); 
      });      
      const topScore = d3.max(PRESETS.flat(), d => d.score);
      return PRESETS.flat().find(f => f.score === topScore);
    }

    setFilterToMatchColorConcept(){
      const concept = this.MDL.color.data.concept;
      const path = this.activePreset.groupPath;
      if(!path) return;
      const filterConfig = followPath(this.model.config.data.filter.dimensions, path);

      if (!filterConfig["is--" + concept]) {
        mobx.runInAction(() => {
          //clear filter config 
          Object.keys(filterConfig).forEach(k => {if(k.includes("is--")) delete filterConfig[k]; });
          //set new filter config
          filterConfig["is--" + concept] = true;        
        });
      }
    }

    updateView(unfoldedRadioGroup){

      const activeConfig = this.activePreset;

      this.DOM.container.selectAll("fieldset").each(function(d, i){
        const fieldset = d3.select(this);
        const fields = fieldset.selectAll("p");
        const nFields = fields.size();

        fields
          .each(function(d){
            const isActive = d.icon == activeConfig.icon;
            d3.select(this).select("input").property("checked", isActive);
            d.selected = isActive;
          })
          .sort((b,a)=>{
            return a.selected - b.selected;
          })
          .order()
          .each(function(d, j){
            const field = d3.select(this);

            const unfold = field.attr("group") === unfoldedRadioGroup;
            const width = 80;
            const spacingH = 10;
            const spacingV = 4;
            const deckEffect = 2;
            const marginLeft = 22;
            const marginTop = 5;
            field
              .style("width", width + "px")
              .style("z-index", nFields - j)
              .transition().duration(100)
              .style("top", marginTop + j * (unfold ? width + spacingV : deckEffect) + "px")
              .style("left", marginLeft + i * (width + spacingH) + j * (unfold ? 0 : deckEffect) + "px");
          });
      });

    }

    setModel(target){
      const source = this.activePreset;
      mobx.runInAction(() => {
        target = sharedComponents.LegacyUtils.deepClone(target);

        if(source.mode === "show" && target.mode === "select") {
          
          const show = (followPath(this.model.config.data.filter.dimensions, source.loosePath) || []).filter(f => !!f);
          this.model.encoding.selected.data.filter.clear();
          this.model.encoding.selected.data.filter.set(show);

        } else if(source.mode === "select" && target.mode === "show") {
          if(this.model.encoding.selected.data.filter.any()) {
            const $in = target.loosePath.pop();
            const show = followPath(target.config.data.filter.dimensions, target.loosePath, true);
            show[$in] = [...this.model.encoding.selected.data.filter.markers.keys()];
            //clear select
            this.model.encoding.selected.data.filter.clear();
          }
        } else if(source.mode === "show" && target.mode === "show") {
          const $in = target.loosePath.pop();
          const show1 = followPath(this.model.config.data.filter.dimensions, source.loosePath);
          const show2 = followPath(target.config.data.filter.dimensions, target.loosePath, true);

          if(show1) {
            show2[$in] = [...show1];
            this.model.encoding.selected.data.filter.clear();
          }

        } else if(source.mode === "none" || target.mode === "none") {
          //clear select
          this.model.encoding.selected.data.filter.clear();
        }
        this.model.config.data.filter = target.config.data.filter;

        delete this.model.config.encoding.stack.data.constant;
        delete this.model.config.encoding.stack.data.concept;
        delete this.model.config.encoding.stack.data.space;
        delete this.model.config.encoding.stack.data.source;
        this.model.config.encoding.stack.data = target.config.encoding.stack.data;

        delete this.model.config.encoding.order.data.constant;
        delete this.model.config.encoding.order.data.concept;
        delete this.model.config.encoding.order.data.space;
        delete this.model.config.encoding.order.data.source;
        delete this.model.config.encoding.order.direction;
        this.model.config.encoding.order.data = target.config.encoding.order.data;
        this.model.config.encoding.order.direction = target.config.encoding.order.direction;

        target.config.encoding.facet_row.data.modelType = "entityMembershipDataConfig";
        delete this.model.config.encoding.facet_row.data.constant;
        delete this.model.config.encoding.facet_row.data.concept;
        delete this.model.config.encoding.facet_row.data.space;
        delete this.model.config.encoding.facet_row.data.source;
        delete this.model.config.encoding.facet_row.data.exceptions;

        this.model.config.encoding.facet_row.data = target.config.encoding.facet_row.data;
      });
    }
  }
   
  const decorated = mobx.decorate(Presets, {
    "MDL": mobx.computed,
    "activePreset": mobx.computed
  });
  sharedComponents.Dialog.add("presets", decorated);

  /*eslint no-unused-vars: ["warn", { "varsIgnorePattern": "Stack" }]*/

  //import "./dialogs/axesmc/axesmc";
  //import "./dialogs/robinhood/robinhood";

  class MountainChart extends sharedComponents.BaseComponent {

    constructor(config){

      const markerName = config.options?.markerNames?.mountain || "mountain";
      const fullMarker = config.model.markers[markerName];

      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);

      config.model.markers[markerName] = marker;

      config.name = "mountainchart";

      config.subcomponents = [{
        type: sharedComponents.Repeater,
        placeholder: ".vzb-repeater",
        model: marker,
        options: {
          repeatedComponent: sharedComponents.Facet, 
          repeatedComponentCssClass: "vzb-facet",
          repeatedComponentOptions: {
            facetedComponent: VizabiMountainChart,
            facetedComponentCssClass: "vzb-mountainchart",
            direction: "row"
          }
        },
        name: "chart",
      },{
        type: sharedComponents.AddGeo,
        placeholder: ".vzb-addgeo",
        name: "addgeo",
        model: marker,
        options: {
          PROFILE_CONSTANTS: sharedComponents.LegacyUtils.deepExtend({}, VizabiMountainChart.PROFILE_CONSTANTS, {
            LARGE: {dy: 5}, MEDIUM: {dy: 1}, SMALL: {dy: 0}
          }),
          PROFILE_CONSTANTS_FOR_PROJECTOR: sharedComponents.LegacyUtils.deepExtend({}, VizabiMountainChart.PROFILE_CONSTANTS_FOR_PROJECTOR, {
            LARGE: {dy: 16}, MEDIUM: {dy: 10}
          }),
          xAlign: "right",
          yAlign: "top"
        }
      },{
        type: sharedComponents.DateTimeBackground,
        placeholder: ".vzb-datetime",
        name: "datetime",
        model: marker,
        options: {xAlign: "right", yAlign: "top", widthRatio: 0.5, topOffset: 100, leftOffset: 10}
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        name: "time-slider",
        model: marker
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        name: "speed-slider",
        model: marker
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        name: "tree-menu",
        model: marker
      },{
        name: "datanotes",
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        name: "buttons",
        model: marker
      }];

      config.template = `
      <div class="vzb-chart">
        <div class="vzb-datetime"></div>
        <div class="vzb-repeater"></div>
        <div class="vzb-addgeo"></div>
      </div>
      <div class="vzb-animationcontrols">
        <div class="vzb-timeslider"></div>
        <div class="vzb-speedslider"></div>
      </div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datanotes"></div>
    `;

      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);
      
      this.splashMarker = splashMarker;
    }
    draw(){
      this.addReaction(this.updatePercentButton);
    }
    updatePercentButton(){
      const enabled = !!this.model.markers[this.root.options?.markerNames?.mountain || "mountain"].encoding.facet_row.data.concept;
      this.findChild({type: "ButtonList"}).setButtonUnavailable("inpercent", !enabled);
    }
  }
  MountainChart.DEFAULT_UI = {
    chart: {  
    },
  };

  MountainChart.versionInfo = { version: "7.3.12", build: 1706306812826, package: {"homepage":"https://github.com/vizabi/mountainchart#readme","name":"@vizabi/mountainchart","description":"Vizabi mountain chart"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = MountainChart;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/popbyage#readme v5.0.2 build 1719060136758 Copyright 2024 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('d3'), require('mobx')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'd3', 'mobx'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.PopByAge = {}, global.VizabiSharedComponents, global.d3, global.mobx));
})(window, (function (exports, sharedComponents, d3, mobx) {
  const {ICON_QUESTION} = sharedComponents.Icons;

  const SYMBOL_KEY = Symbol.for("key");
  const SYMBOL_KEY2 = Symbol.for("key2");
  const SYMBOL_STACKEDSUM = Symbol.for("stackedSum");
  const OVERHANG = "_ovh";

  //
  // POPBYAGE CHART COMPONENT
  class _VizabiPopByAge extends sharedComponents.BaseComponent {

    constructor(config) {
      config.subcomponents = [{
        type: sharedComponents.DateTimeBackground,
        placeholder: ".vzb-bc-date-now"
      }];

      config.template = `
      <svg class="vzb-popbyage-svg vzb-export">
        <g class="vzb-bc-header">
            <g class="vzb-bc-axis-x-title">
              <text></text>
            </g>
            <g class="vzb-bc-axis-x-info vzb-noexport"></g>
            <g class="vzb-bc-date-now"></g>
            <text class="vzb-bc-date vzb-bc-date-locked"></text>
        </g>
        <g class="vzb-bc-graph">
            <text class="vzb-bc-title"></text>
            <text class="vzb-bc-title vzb-bc-title-right"></text>
            <text class="vzb-bc-title vzb-bc-title-center"></text>
            <g class="vzb-bc-closecross vzb-noexport">
              <text>×</text>
            </g>

            <g class="vzb-bc-axis-y-title"></g>

            <g class="vzb-bc-axis-y"></g>

            <svg class="vzb-bc-bars-crop">
                <g class="vzb-bc-bars"></g>
            </svg>

            <svg class="vzb-bc-locked-crop">
                <g class="vzb-bc-paths"></g>
            </svg>

            <g class="vzb-bc-axis-x"></g>
            <g class="vzb-bc-axis-x vzb-bc-axis-x-left"></g>

            <svg class="vzb-bc-labels-crop">
                <g class="vzb-bc-labels"></g>
            </svg>

            <g class="vzb-bc-axis-labels">
                <!-- <text class="vzb-x_label">Lifespan</text>
                      <text class="vzb-y_label">Lifespan</text> -->
            </g>
        </g>
        <g class="vzb-bc-tooltip vzb-hidden">
            <rect class="vzb-tooltip-border"></rect>
            <text class="vzb-tooltip-text"></text>
        </g>
        <rect class="vzb-bc-forecastoverlay vzb-hidden" x="0" y="0" width="100%" height="100%" fill="url(#vzb-bc-pattern-lines)" pointer-events='none'></rect>
      </svg>
      <svg width="0" height="0">
        <defs>
            <pattern class="vzb-noexport" id="vzb-bc-pattern-lines" x="0" y="0" patternUnits="userSpaceOnUse" width="50" height="50" viewBox="0 0 10 10">
                <path d='M-1,1 l2,-2M0,10 l10,-10M9,11 l2,-2' stroke='black' stroke-width='3' opacity='0.08'/>
            </pattern>
        </defs>
      </svg>
    `;
      super(config);
    }

    setup() {
      this.state = {};

      this.DOM = {
        svg: this.element.select(".vzb-popbyage-svg"),
        xTitleEl: this.element.select(".vzb-bc-axis-x-title"),
        xInfoEl: this.element.select(".vzb-bc-axis-x-info"),
        dateLocked: this.element.select(".vzb-bc-date-locked"),
        forecastOverlay: this.element.select(".vzb-bc-forecastoverlay"),
        graph: this.element.select(".vzb-bc-graph"),
        closeCross: this.element.select(".vzb-bc-closecross"),
      };
      this.__updateGraphDOM(this.DOM.graph);
      
      this._date = this.findChild({type: "DateTimeBackground"});

      this._textEllipsis = new sharedComponents.TextEllipsis(this);
      this._textEllipsis.setTooltip(this.element.select(".vzb-bc-tooltip"));

      this.interaction = this._interaction();

      const _this = this;

      this._attributeUpdaters = {
        _newWidth(d, i) {
          //d["x_"] = 0;
          let width;
          width = _this.frame[d[SYMBOL_KEY2]] && _this.frame[d[SYMBOL_KEY2]].x;
          d["width_"] = width ? _this.xScale(width) : 0;
          if (_this.ui.inpercent && d[_this.STACKDIM] != _this.OVERHANGKEY) {
            d["width_"] /= _this.total[d.i][d[_this.PREFIXEDSIDEDIM]];
          }
          return d.width_;
        },
        _newX(d, i) {
          const prevSbl = this.previousSibling;
          if (prevSbl) {
            const prevSblDatum = d3.select(prevSbl).datum();
            d["x_"] = prevSblDatum.x_ + prevSblDatum.width_ - d.width_;
          }
          // else {
          //   d["x_"] = 0;
          // }
          return d.x_;
        },
        _newColor(d) {
          const color = _this.cScale(_this.frame[d[SYMBOL_KEY2]] && _this.frame[d[SYMBOL_KEY2]].color || d[_this.PREFIXEDSTACKDIM]);
          return d[_this.STACKDIM] == _this.OVERHANGKEY ? d3.color(color).darker(1) : color;
        }
      };

      // this.xScale = null;
      // this.yScale = null;
      // this.cScale = null;

      this.xAxis = sharedComponents.axisSmart("bottom");
      this.xAxisLeft = sharedComponents.axisSmart("bottom");
      this.yAxis = sharedComponents.axisSmart("left");
      this.SHIFTEDAGEDIM = "s_age";
      this.OVERHANGKEY = this.name + OVERHANG;

      this.element.style("overflow", this.isInFacet ? "visible" : null);
      this.DOM.svg.style("overflow", this.isInFacet ? "visible" : null);
      this.DOM.svg.style("width", this.isInFacet ? "100%" : null);
      this.DOM.svg.style("height", this.isInFacet ? "100%" : null);
    }

    get MDL() {
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted,
        y: this.model.encoding.y,
        x: this.model.encoding.x,
        // y: this.model.encoding.get(this.state.alias.y || "y"),
        // x: this.model.encoding.get(this.state.alias.x || "x"),
        side: this.model.encoding.side,
        color: this.model.encoding.color,
        label: this.model.encoding.label,
        facet: this.model.encoding.facet_column,
        aggregate: this.model.encoding.aggregate
      };
    }

    get groupBy() {
      this.DOM.labels.text(""); //TODO: find more clear way
      return this.MDL.aggregate.grouping["age"].grouping;
    }

    draw() {
      this.localise = this.services.locale.auto(this.MDL.frame.interval);

      this.yAxis.tickFormat(this.localise);
      this.xAxis.tickFormat(this.localise);
      this.xAxisLeft.tickFormat(this.localise);

      this.geoDomainDimension = this.MDL.facet.data.concept;
      this.geoDomainDefaultValue = "world";//this.model.entities_geodomain.show[this.geoDomainDimension]["$in"][0];

      //this.groupBy = this.MDL.aggregate.grouping["age"].grouping;
      this.timeSteps = this.MDL.frame.stepScale.domain();

      if (this._updateLayoutProfile()) return; //return if exists with error


      this.addReaction(this.checkDimensions);
      this.addReaction(this._clearLockAndSelectedOnGroupByChange);
      this.addReaction(this._updateIndicators);
      //this.addReaction(this._checkFrameValue);
      this.addReaction(this.updateUIStrings);
      //this.addReaction(this._setupLimits);
      //this.addReaction(this._updateLimits);
      this.addReaction(this._updateSideTitles);
      this.addReaction(this._updateMaxValues);
      this.addReaction(this.updateSize);
      this.addReaction(this._updateForecastOverlay);
      //this.addReaction(this._updateStepSeries);
      this.addReaction(this.drawData);
      this.addReaction(this._redrawLocked);
      this.addReaction(this._highlightBars);


    }

    _updateLayoutProfile() {
      this.services.layout.size;

      if (!this.size.height || !this.size.width) return sharedComponents.LegacyUtils.warn("Chart _updateProfile() abort: container is too little or has display:none");
    }

    get profileConstants() { 
      this.services.layout.size; //watch
      return this.services.layout.getProfileConstants(PROFILE_CONSTANTS, PROFILE_CONSTANTS_FOR_PROJECTOR, this.state.positionInFacet);
    }

    get size() {
      this.services.layout.size; //watch
      this.ui.inpercent;
      if (this.isInFacet) {
        this.parent.scaleRange;
        this.parent.rangePartsHash;
      }

      const {margin} = this.profileConstants;
      const deltaMarginTop = this.sideSkip ? margin.top * 0.23 : 0;    
      const width = this.element.node().clientWidth || 0;
      const height = this.element.node().clientHeight || 0;

      return {
        width,
        height,
        innerWidth: width - margin.left - margin.right,
        innerHeight: height + deltaMarginTop - margin.top - margin.bottom
      }
    }

    get stepSeries() {
      return this._getStepSeries();
    }

    _getStepSeries() {
      let stepSeries;
      if(this.groupBy != 1) {
        if(!this._isDragging()) {
            const currentStep = this.MDL.frame.step ?? 0;
            const pStepSeries = d3.range(currentStep, -1, -this.groupBy).reverse();
            const nStepSeries = d3.range(currentStep, this.MDL.frame.stepCount, this.groupBy);
            stepSeries = this.prevStepSeries = pStepSeries.concat(nStepSeries.slice(1));
        } else {
          stepSeries = this.prevStepSeries;
        }    } else {
          stepSeries = this.MDL.frame.stepScale.range();
      }    return stepSeries;
    }

    _clearLockAndSelectedOnGroupByChange() {
      this.groupBy;
      mobx.runInAction(() => {
        if (this.someSelected) this.MDL.selected.data.filter.clear();
        if (this.lock) this.ui.lockNonSelected = this.lock = 0;
      });
    }

    get _getDataArrayForFacet() {
      if(this.isManyFacets)
        return this.parent.getDataForSubcomponent(this.name);
      else
        return this.model.dataArray;
    }

    get _getFacetEncName() {
      return "facet_" + this.parent.direction;
    }

    drawData() {
      this.size;

      this.MDL;

      this.shiftScale = d3.scaleLinear()
        .domain([this.stepSeries[0], this.stepSeries[this.stepSeries.length - 1]])
        .range([0, this.stepSeries.length - 1])
        .clamp(true);

      const step = this.MDL.frame.step < this.stepSeries[0] ? this.stepSeries[0] 
        : this.MDL.frame.step > this.stepSeries[this.stepSeries.length - 1] ? this.stepSeries[this.stepSeries.length - 1]
          : this.MDL.frame.step;
       
      const stepFraction = this.MDL.frame.stepScale.domain().length == 1 ? 0 : (step - this.stepSeries[0]) % this.groupBy / this.groupBy;

      const frameValue = step == undefined ? this.MDL.frame.stepScale.domain()[0] : this.MDL.frame.stepScale.invert(step);

      if (this.ui.inpercent) {
        this.total = this._updateTotal(frameValue);
      }

      const facetEncName = this._getFacetEncName;

      this.frame = stepFraction == 0 ? this._processData(step == this.MDL.frame.step ? this._getDataArrayForFacet : [...this.model.getDataMapByFrameValue(this.MDL.frame.stepScale.invert(step), "order.order").rows()])
        : 
        this._interpolateDiagonal(...(a=>[this.stepSeries[a],this.stepSeries[a+1]])(~~((this.MDL.frame.step - this.stepSeries[0])/ this.groupBy)).map(this.MDL.frame.stepScale.invert).map(v => this.model.getDataMapByFrameValue(v, "order.order").filter(row => row[facetEncName] === this.name).rows()), stepFraction, this._getFacetEncName, this.name, !this.sideSkip);
      if (this.overhang && !this.sideSkip) this._addOverHangData(this.frame, this.total);

      this._updateEntities(true, 
        step ?? this.stepSeries[0],
        frameValue      
      );
      this.updateBarsOpacity();
    }

    _addOverHangData(frame, total) {
      const keyFn = this.model.dataMap.keyFn;
      const keys = Object.keys(frame);
      const stackDim = this.STACKDIM;
      const sideDim = this.SIDEDIM;
      const inpercent = this.ui.inpercent;
      const overhangKey = this.OVERHANGKEY;

      let data1, data2, x1, x2;
      for(let i = 0; i < keys.length; i = i + 2) {
        data1 = Object.assign({}, frame[keys[i]]);
        data2 = Object.assign({}, frame[keys[i + 1]]);
        data1[stackDim] = data2[stackDim] = overhangKey;
        x1 = data1.x;
        x2 = data2.x;
        if (inpercent) {
          x1 /= total[0][data1[sideDim]];
          x2 /= total[0][data2[sideDim]];
        }
        data1.x = x1 > x2 ? x1 - x2 : 0;
        data2.x = x2 > x1 ? x2 - x1 : 0;
        frame[keyFn(data1)] = data1;
        frame[keyFn(data2)] = data2;
      }
    }

    __updateGraphDOM(graph) {
      this.DOM.yAxisEl = graph.select(".vzb-bc-axis-y");
      this.DOM.xAxisEl = graph.select(".vzb-bc-axis-x");
      this.DOM.xAxisLeftEl = graph.select(".vzb-bc-axis-x-left");
      this.DOM.yTitleEl = graph.select(".vzb-bc-axis-y-title");
      this.DOM.title = graph.select(".vzb-bc-title");
      this.DOM.titleRight = graph.select(".vzb-bc-title-right");
      this.DOM.titleCenter = graph.select(".vzb-bc-title-center");
      this.DOM.barsCrop = graph.select(".vzb-bc-bars-crop");
      this.DOM.lockedCrop = graph.select(".vzb-bc-locked-crop");
      this.DOM.labelsCrop = graph.select(".vzb-bc-labels-crop");
      this.DOM.bars = this.DOM.barsCrop.select(".vzb-bc-bars");
      this.DOM.lockedPaths = this.DOM.lockedCrop.select(".vzb-bc-paths");
      this.DOM.labels = this.DOM.labelsCrop.select(".vzb-bc-labels");
    }

    _processData(dataArray) {
      const data = {};
      for (let index = 0; index < dataArray.length; index++) {
        const element = dataArray[index];
        data[element[SYMBOL_KEY]] = element;
      }
      return data;
    }

    _interpolateDiagonal(pData, nData, fraction, filterKey, filterValue, sided) {
      const data = {};
      let newRow, shiftedRow;
      for (const row of nData) {
        if (row[filterKey] == filterValue) {
          newRow = Object.assign({}, row);
          data[newRow[SYMBOL_KEY]] = newRow;
          if (sided) {
            newRow = Object.assign({}, nData.next().value);
            data[newRow[SYMBOL_KEY]] = newRow;
            pData.drop(2);
          }
          break;
        }
        pData.next();
      }
      for (const row of nData) {
        if (row[filterKey] !== filterValue) {
          break;
        }
        newRow = Object.assign({}, row);
        shiftedRow = pData.next().value;
        newRow.x = shiftedRow.x + (newRow.x - shiftedRow.x) * fraction;
        data[newRow[SYMBOL_KEY]] = newRow;
        if (sided) {
          newRow = Object.assign({}, nData.next().value);
          shiftedRow = pData.next().value;
          newRow.x = shiftedRow.x + (newRow.x - shiftedRow.x) * fraction;
          data[newRow[SYMBOL_KEY]] = newRow;  
        }
      }
      return data;
    }

    checkDimensions() {
      const {
        frame,
        facet,
        y,
        color,
        side
      } = this.MDL;

      const sideDim = this.SIDEDIM = //"side";
        side.data.isConstant ? side.data.constant : side.data.concept;
      this.PREFIXEDSIDEDIM = "side_" + this.SIDEDIM;
      const stackDim = this.STACKDIM = //"facet";
        facet.data.concept;
      this.PREFIXEDSTACKDIM = "stack_" + this.STACKDIM;
      this.AGEDIM = //"y";
        y.data.concept;
      this.TIMEDIM = //"frame";
        frame.data.concept;

      this.colorUseConstant = color.data.isConstant;
      this.stackSkip = this.colorUseConstant || stackDim == sideDim;
      this.geoLess = stackDim !== this.geoDomainDimension && sideDim !== this.geoDomainDimension;
    }

    updateUIStrings() {
      const _this = this;

      this.DOM.xTitleEl.select("text").text(this.localise("popbyage/title"));

      const conceptPropsX = this.MDL.x.data.conceptProps;

      const dataNotes = this.root.findChild({type: "DataNotes"});

      sharedComponents.LegacyUtils.setIcon(this.DOM.xInfoEl, ICON_QUESTION)
        .select("svg").attr("width", "0px").attr("height", "0px")
        .style('opacity', Number(Boolean(conceptPropsX.description || conceptPropsX.sourceLink)));

      this.DOM.xInfoEl.on("click", () => {
        dataNotes.pin();
      });
      this.DOM.xInfoEl.on("mouseover", function() {
        if (_this._isDragging()) return;
        const rect = this.getBBox();
        const coord = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
        const toolRect = _this.root.element.node().getBoundingClientRect();
        const chartRect = _this.element.node().getBoundingClientRect();
        dataNotes
          .setEncoding(_this.MDL.x)
          .show()
          .setPos(coord.x + chartRect.left - toolRect.left, coord.y);
      });
      this.DOM.xInfoEl.on("mouseout", () => {
        if (_this._isDragging()) return;
        dataNotes.hide();
      });

      this.DOM.closeCross
        .classed("vzb-hidden", !this.isManyFacets)
        .on("mouseover", () => {
          this.element.classed("vzb-chart-removepreview", true);
        })
        .on("mouseout", () => {
          this.element.classed("vzb-chart-removepreview", false);
        })
        .on("click", () => {
          this.model.data.filter.delete(this.name);
        });



      // var titleStringY = this.model.marker.axis_y.getConceptprops().name;

      // var yTitle = this.yTitleEl.selectAll("text").data([0]);
      // yTitle.enter().append("text");
      // yTitle
      //   .attr("y", "-6px")
      //   .attr("x", "-9px")
      //   .attr("dx", "-0.72em")
      //   .text(titleStringY);
    }

    get ageKeys() {
      return  this.MDL.y.data.domain.toSorted(d3.ascending);
    }

    get sideKeys() {
      const _sideKeys = this.MDL.side.scale.domain;
      return _sideKeys.length <= 1 ? _sideKeys : _sideKeys.sort(this.root.ui.chart.flipSides ? d3.ascending : d3.descending).slice(0);
    }

    get stackKeys() {
      return this.isInFacet ? [this.name] : this.MDL.facet.scale.domain;
    }

    get xScale() {
      const maxRange = this.twoSided ? Math.abs(this.size.innerWidth - this.profileConstants.centerWidth) * 0.5 : this.size.innerWidth;
      return this.MDL.x.scale.d3Scale.copy().domain(this.domains[0]).range([0, maxRange]);
    }

    get yScale() {
      return this.MDL.y.scale.d3Scale.copy().range([this.size.innerHeight, 0]);  }

    get cScale() {
      return this.MDL.color.scale.d3Scale.copy();
    }

    get isInFacet(){
      return this.parent.constructor.name === "_Facet";
    }

    get isManyFacets(){
      return this.isInFacet && this.parent.howManyFacets() > 1;
    }

    get twoSided() {
      return this.sideKeys.length > 1;
    }

    get oneBarHeight() {
      const domain = d3.extent(this.yScale.domain());
      return this.size.innerHeight / (domain[1] - domain[0]);
    }
    get barHeight() {
      return this.oneBarHeight * this.groupBy; // height per bar is total domain height divided by the number of possible markers in the domain
    }

    get firstBarOffsetY() {
      return this.size.innerHeight - this.barHeight;
    }

    get sideSkip() {
      return this.MDL.side.data.isConstant;
    }

    get overhang() {
      return this.root.ui.chart.overhang;
    }

    /**
     * Changes labels for indicators
     */
    _updateIndicators() {
      const {
        frame,
        x,
        y,
        side,
        color
      } = this.MDL;

      const groupBy = this.groupBy;

      frame.config.playbackSteps = groupBy;
      this.duration = frame.speed;

      if (this.twoSided) {
        this.xScaleLeft = this.xScale.copy();
      }
    }

    _updateForecastOverlay() {
      this.DOM.forecastOverlay.classed("vzb-hidden",
      !this.ui.showForecast ||
      !this.ui.showForecastOverlay ||
      !this.ui.endBeforeForecast ||
        (this.MDL.frame.value <= this.MDL.frame.parseValue(this.ui.endBeforeForecast))
      );
    }

    _updateSideTitles() {
      const label = this.MDL.label.data.concept;

      const sideItems = this.sideItems = this.SIDEDIM === "true" ? {} : this.sideKeys
        .reduce((obj,m) => {
          obj[m] = this.MDL.label.data.response.get({[this.SIDEDIM]: m})[label][this.SIDEDIM];
          return obj;
        }, {});

      const stackItems = this.stackItems = this.stackKeys
        .reduce((obj,m) => {
          obj[m] = this.MDL.label.data.response.get({[this.STACKDIM]: m})[label][this.STACKDIM];
          return obj;
        }, {});

      this.DOM.titleRight.classed("vzb-hidden", !this.twoSided);
      if (this.twoSided) {
        this.DOM.title.text(sideItems[this.sideKeys[1]]).call(this._textEllipsis.clear);
        this.DOM.titleRight.text(sideItems[this.sideKeys[0]]).call(this._textEllipsis.clear);
      } else {
        const title = this.sideKeys.length && sideItems[this.sideKeys[0]] ? sideItems[this.sideKeys[0]] : "";
        this.DOM.title.text(title).call(this._textEllipsis.clear);
      }

      const title = this.stackKeys.length && stackItems[this.stackKeys[0]] && !this.stackSkip ? stackItems[this.stackKeys[0]] : "";
      this.DOM.titleCenter.text(title).call(this._textEllipsis.clear);
    }

    _interaction() {
      const _this = this;
      return {
        mouseover(event, d) {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          if (_this._isDragging()) return;
          _this.MDL.highlighted.data.filter.set(d, JSON.stringify({color: d[_this.STACKDIM]}));
          _this._showLabel(event, d);
        },
        mouseout(event, d) {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          if (_this._isDragging()) return;
          _this.MDL.highlighted.data.filter.delete(d);
        },
        click(event, d) {
          if (sharedComponents.LegacyUtils.isTouchDevice()) return;
          _this.MDL.selected.data.filter.toggle(d);
        },
        tap(event, d) {
          event.stopPropagation();
          _this.MDL.selected.data.filter.set(d);
        }
      };
    }

    /**
     * Updates entities
     */
    _updateEntities(reorder, step, frameValue) {
      const _this = this;
      const groupBy = this.groupBy;
      const frame = this.MDL.frame;
      const sideDim = this.SIDEDIM;
      const prefixedSideDim = this.PREFIXEDSIDEDIM;
      const ageDim = this.AGEDIM;
      const stackDim = this.STACKDIM;
      const prefixedStackDim = this.PREFIXEDSTACKDIM;
      this.TIMEDIM;
      const duration = (frame.playing) ? frame.speed : 0;
      //const frameValue = this.MDL.frame.stepScale.invert(step);
      //var group_offset = this.model.marker.group_offset ? Math.abs(this.model.marker.group_offset % groupBy) : 0;

      const domain = d3.extent(this.yScale.domain());

      const nextStep = d3.bisectLeft(this.stepSeries, step);

      const shiftedAgeDim = this.SHIFTEDAGEDIM;

      const markers = this.ageKeys.map(data => {
        const o = {};
        o[ageDim] = o[shiftedAgeDim] = +data;
        o[ageDim] -= nextStep * groupBy;
        return o;
      });

      const ageData = markers.slice(0);

      const outAge = {};
      outAge[shiftedAgeDim] = markers.length * groupBy;
      outAge[ageDim] = outAge[shiftedAgeDim] - nextStep * groupBy;

      this.ageShift = nextStep * groupBy;

      if (nextStep) ageData.push(outAge);

      const stacks = _this.stackKeys.length ? _this.stackKeys.slice(0) : [_this.geoDomainDefaultValue];
      if (this.overhang) stacks.push(this.OVERHANGKEY);
      const geoDomainDefaultValue = this.geoDomainDefaultValue;
      const geoDomainDimension = this.geoDomainDimension;

      // for(let i = 0, j = ageData.length; i < j; i++) {
      //   const d = ageData[i];
      //   d["side"] = _this.sideKeys.map(m => {
      //     const r = {};
      //     r[ageDim] = d[ageDim];
      //     r[shiftedAgeDim] = d[shiftedAgeDim];
      //     r[prefixedSideDim] = m;
      //     r[sideDim] = m;
      //     r["stack"] = stacks.map(m => {
      //       const s = {};
      //       s[geoDomainDimension] = geoDomainDefaultValue;
      //       s[ageDim] = r[ageDim];
      //       s[shiftedAgeDim] = r[shiftedAgeDim];
      //       s[sideDim] = r[sideDim];
      //       s[stackDim] = m;
      //       s[prefixedSideDim] = r[prefixedSideDim];
      //       s[prefixedStackDim] = m;
      //       s["x_"] = 0;
      //       s["width_"] = 0;
      //       return s;
      //     });
      //     return r;
      //   });
      // }
      const transition = duration ? d3.transition()
        .duration(duration)
        .ease(d3.easeLinear)
        : null;

      const oneBarHeight = this.oneBarHeight;
      const barHeight = this.barHeight;
      const firstBarOffsetY = this.firstBarOffsetY;

      const stepShift = (ageData[0][shiftedAgeDim] - ageData[0][ageDim]) - this.shiftScale(step) * groupBy;

      this.barsData = [];

      this.ageBars = this.DOM.bars.selectAll(".vzb-bc-bar")
        .data((d, i) => (_this.barsData[i] = ageData.map(m => {
          const p = {};
          p[ageDim] = m[ageDim];
          p[shiftedAgeDim] = m[shiftedAgeDim];
          p.i = i;
          return p;
        }), this.barsData[i]), d => d[ageDim])
        .join(
          enter => enter.append("g")
            .attr("class", d => "vzb-bc-bar " + "vzb-bc-bar-" + d[ageDim])
            .attr("transform", (d, i) => "translate(0," + (firstBarOffsetY - (d[shiftedAgeDim] - domain[0] - groupBy) * oneBarHeight) + ")"),
          update => update,
          exit => exit.remove()
        ).call(ageBars => {
          if (duration) {
            ageBars.transition(transition)
              .attr("transform", (d, i) => "translate(0," + (firstBarOffsetY - (d[shiftedAgeDim] - domain[0] - stepShift) * oneBarHeight) + ")");
          } else {
            ageBars.interrupt()
              .attr("transform", (d, i) => "translate(0," + (firstBarOffsetY - (d[shiftedAgeDim] - domain[0] - stepShift) * oneBarHeight) + ")");
          }
        });

      this.sideBars = this.ageBars.selectAll(".vzb-bc-side")
        .data((d, i) => (d.side = _this.sideKeys.map(m => {
          const r = {};
          r[ageDim] = d[ageDim];
          r[shiftedAgeDim] = d[shiftedAgeDim];
          r[prefixedSideDim] = m;
          r[sideDim] = m;
          r.i = d.i;
          return r;
        }), d.side), d => d[prefixedSideDim])
        .join(
          enter => enter.append("g")
            .attr("class", (d, i) => "vzb-bc-side " + "vzb-bc-side-" + (!i != !_this.twoSided ? "right" : "left"))
            .attr("transform", (d, i) => i ? ("scale(-1,1) translate(" + _this.profileConstants.centerWidth + ",0)") : ""),
          update => update,
          exit => exit.remove()
        )
        .call(sideBars => {
          if (reorder) {
            sideBars.attr("class", (d, i) => "vzb-bc-side " + "vzb-bc-side-" + (!i != !_this.twoSided ? "right" : "left"))
              .attr("transform", (d, i) => i ? ("scale(-1,1) translate(" + _this.profileConstants.centerWidth + ",0)") : "");
          }
        });

      const _attributeUpdaters = this._attributeUpdaters;
      const keyFn = this.model.dataMap.keyFn;

      this.stackBars = this.sideBars.selectAll(".vzb-bc-stack")
        .data(d => ( d.stack = stacks.map(m => {
          const s = {};
          s[geoDomainDimension] = geoDomainDefaultValue;
          s[ageDim] = d[ageDim];
          s[shiftedAgeDim] = d[shiftedAgeDim];
          s[sideDim] = d[sideDim];
          s[stackDim] = m;
          s[prefixedSideDim] = d[prefixedSideDim];
          s[prefixedStackDim] = m;
          s["x_"] = 0;
          s["width_"] = 0;
          s[SYMBOL_KEY] = keyFn({
            [ageDim]: d[ageDim],
            [sideDim]: d[prefixedSideDim],
            [stackDim]: m,
          });
          s[SYMBOL_KEY2] = keyFn({
            [ageDim]: d[shiftedAgeDim],
            [sideDim]: d[prefixedSideDim],
            [stackDim]: m,
          });
          s.i = d.i;
          return s;
        }), d.stack), d => d[prefixedStackDim])
        .join(
          enter => enter.append("rect")
            .attr("class", (d, i) => "vzb-bc-stack " + "vzb-bc-stack-" + i + (_this.highlighted ? " vzb-dimmed" : ""))
            .attr("y", 0)
            .attr("height", barHeight - (groupBy > 2 ? 1 : 0))
            .attr("fill", _attributeUpdaters._newColor)
            .attr("width", (d, i) => {
              return duration ? _attributeUpdaters._newWidth(d, i) : null;
            })
            .attr("x", function(d, i) {
              return duration ? _attributeUpdaters._newX.call(this, d, i) : null;
            })
            .on("mouseover", _this.interaction.mouseover)
            .on("mouseout", _this.interaction.mouseout)
            .on("click", _this.interaction.click)
            .onTap(_this.interaction.tap),
          update => update,
          exit => exit.remove()
        )
        .call(stackBars => {
          if (reorder) stackBars
          .attr("class", (d, i) => "vzb-bc-stack " + "vzb-bc-stack-" + i + (_this.highlighted ? " vzb-dimmed" : ""))
          .attr("fill", _attributeUpdaters._newColor)
          .order();

          if (duration) {
            stackBars
              .transition(transition)
              .attr("width", _attributeUpdaters._newWidth)
              .attr("x", _attributeUpdaters._newX);
          } else {
            stackBars.interrupt()
              .attr("width", _attributeUpdaters._newWidth)
              .attr("x", _attributeUpdaters._newX);
          }

        });

      this.entityLabels = this.DOM.labels.selectAll(".vzb-bc-label text")
        .data(markers, d => d[shiftedAgeDim])
        .join(
          enter => enter.append("g")
            .attr("class", d => "vzb-bc-label" + " vzb-bc-label-" + d[shiftedAgeDim])
            .append("text")
            .attr("class", "vzb-bc-age"),
          update => update,
          exit => exit.remove()
        )
        .each((d, i) => {
          const yearOlds = _this.localise("popbyage/yearOlds");

          let age = parseInt(d[shiftedAgeDim], 10);

          if (groupBy > 1) {
            const nextAge = (age + groupBy - 1);
            age = age + "-to-" + (nextAge > domain[1] ? domain[1] : nextAge);
          }

          d["text"] = age + yearOlds;
        })
        .attr("y", (d, i) => firstBarOffsetY - (d[shiftedAgeDim] - domain[0]) * oneBarHeight - 10)
        .attr("dy", (d, i) => (d[shiftedAgeDim] + groupBy) > domain[1] ? (groupBy - domain[1] + d[shiftedAgeDim]) / groupBy * barHeight : 0);
      // .style("fill", function(d) {
      //   var color = _this.cScale(values.color[d[ageDim]]);
      //   return d3.rgb(color).darker(2);
      // });

      this._date.setText(this.MDL.frame.value, this.duration);
    }

    _isDragging(){
      const timeslider = this.root.findChild({type: "TimeSlider"});
      return timeslider && timeslider.ui.dragging;
    }

    get allLimitsAndTotals() {
      this.groupBy;
      const steps = this.MDL.frame.stepScale.domain();
      return this._createTotalsAndLimits(this.model.getTransformedDataMap('filterRequired'), steps);
    }

    _createTotalsAndLimits(data, steps) {
      const limits = {};
      const totals = {};

      this.sideKeys.forEach(sideKey => {
        limits[sideKey] = {};
        steps.forEach(step => {
          limits[sideKey][step] = {};
          this.ageKeys.forEach(ageKey => {
            limits[sideKey][step][ageKey] = {};
          });
        });
      });

      [...this.stackKeys, SYMBOL_STACKEDSUM].forEach(stackKey => {
        totals[stackKey] = {};
        steps.forEach(step => {
          totals[stackKey][step] = {};
        });
      });

      const stackDim = this.STACKDIM;
      const sideDim = this.SIDEDIM;
      const timeDim = this.TIMEDIM;
      const ageDim = this.AGEDIM;

      let _stack, _side, _time, _age;

      for (const row of data.rows()) {
        _stack = row[stackDim] ?? stackDim;
        if (!this.stackKeys.includes(_stack)) continue;

        _time = "" + row[timeDim];
        _side = row[sideDim] ?? sideDim;
        _age = row[ageDim] ?? ageDim;

        totals[_stack][_time][_side] ??= 0;
        totals[_stack][_time][_side] += row.x;
        totals[SYMBOL_STACKEDSUM][_time][_side] ??= 0;
        totals[SYMBOL_STACKEDSUM][_time][_side] += row.x;

        limits[_side][_time][_age][_stack] = row.x;
        limits[_side][_time][_age][SYMBOL_STACKEDSUM] ??= 0;
        limits[_side][_time][_age][SYMBOL_STACKEDSUM] += row.x;
      }

      return {limits, totals};
    }

    get domains() {
      this.groupBy;
      
      return this._createDomains(this._calcLimit(this.allLimitsAndTotals.totals, this.allLimitsAndTotals.limits));
    }

    _updateMaxValues() {
      if (this.isInFacet) {
        const domains = this.domains;
        mobx.runInAction(() => {
          this.parent.maxValues.set(this.name, domains.reduce((result, d) => {
            result += d[0] + d[1];
            return result;
          }, 0));
        });
      }
    }

    _calcLimit(totals, limits, stackKey) {
      this.overhang && !this.sideSkip;
      const inpercent = this.ui.inpercent;
      const steps = this.MDL.frame.stepScale.domain();
      const sideSkip = this.sideSkip;
      const sideKeys = this.sideKeys;

      const limitsArray = [];
      let limitLeft, limitRight;

      steps.map(step => {
        this.ageKeys.map(age => {
          limitLeft = limits[sideKeys[0]][step][age][stackKey ?? SYMBOL_STACKEDSUM];
          if (inpercent) limitLeft /= totals[stackKey ?? SYMBOL_STACKEDSUM][step][sideKeys[0]];
          if (sideSkip) {
            limitsArray.push(limitLeft);
          } else {
            limitRight = limits[sideKeys[1]][step][age][stackKey ?? SYMBOL_STACKEDSUM];
            if (inpercent) limitRight /= totals[stackKey ?? SYMBOL_STACKEDSUM][step][sideKeys[1]];
            limitsArray.push(Math.max(limitLeft, limitRight));
          }
        });
      });

      return d3.max(limitsArray);
    }

    _createDomains(limit) {
      const domains = [];
      const axisX = this.MDL.x;

      if (this.ui.inpercent) {
        domains[0] = [0, limit];
      } else {
        domains[0] = axisX.scale.config.domain ? axisX.scale.domain : [0, limit];
      }

      return domains;
    }

    _updateTotal(frame) {
      const total = {};
      sharedComponents.LegacyUtils.forEach(this.stackKeys, (stackKey, i) => {
        total[i] = this.allLimitsAndTotals.totals[stackKey][frame] ? this.allLimitsAndTotals.totals[stackKey][frame] : this._interpolateBetweenTotals(this.timeSteps, this.allLimitsAndTotals.totals[stackKey], frame);
      });
      return total;
    }

    _calcDomainScalers() {
      const domain = this.domains.map(m => m[1] - m[0]);
      const sumDomains = domain.reduce((a, b) => a + b);
      return domain.map(d => d / sumDomains);
    }

    _interpolateBetweenTotals(timeSteps, totals, frame) {
      const nextStep = d3.bisectLeft(timeSteps, frame);
      const fraction = (frame - timeSteps[nextStep - 1]) / (timeSteps[nextStep] - timeSteps[nextStep - 1]);
      const total = {};
      sharedComponents.LegacyUtils.forEach(this.sideKeys, side => {
        total[side] = totals[timeSteps[nextStep]][side] * fraction + totals[timeSteps[nextStep - 1]][side] * (1 - fraction);
    });
      return total;
    }

    _redrawLocked() {
      this.size;
      if (this.ui.lockNonSelected) {
        this.lock = this.ui.lockNonSelected;
        this.overhang;
        this.sideSkip;

        const filterFn = ((filterKey, filterValue) => row => row[filterKey] == filterValue)(this._getFacetEncName, this.name);
        const lockTime = this.MDL.frame.parseValue(this.ui.lockNonSelected);
        const lockFrame = this._processData([...this.model.getDataMapByFrameValue(lockTime, "order.order").filter(filterFn).rows()]);
        const lockTotal = this._updateTotal(lockTime);
        mobx.runInAction(() => {
          if (this.overhang && !this.sideSkip) this._addOverHangData(lockFrame, lockTotal);      
          this._makeOutlines(lockFrame, lockTotal);
        });

        this.DOM.dateLocked.text("" + this.ui.lockNonSelected);
      } else {
        this.DOM.lockedPaths.text("");
        this.DOM.dateLocked.text("");
      }

    }

    _makeOutlines(frame, total) {
      const _this = this;

      const groupBy = this.groupBy;
      const barHeight = this.barHeight;
      const firstBarOffsetY = this.firstBarOffsetY + barHeight;

      const line = d3.line().curve(d3.curveStepBefore)
        .x(d => d.x)//_ + d.width_)
        .y((d, i) => firstBarOffsetY - barHeight * i  - (groupBy > 2 ? 1 : 0));

      const pathDataOverhang = [];
      const pathsData = this.barsData.map((barsData, _i) => {
        const stackIndex = [0, 0];
        pathDataOverhang.push([]);

        return this.sideKeys.map((s, i) => {
          if (_this.stackSkip) {
            barsData[0].side[i].stack.forEach((d, j) => {
              if (d[_this.PREFIXEDSIDEDIM] === d[_this.PREFIXEDSTACKDIM]) {
                stackIndex[i] = j;
              }
            });
          }
          const data = {};
          data.d = barsData.map(age => {
            const r = {};
            const x = frame[age.side[i].stack[stackIndex[i]][SYMBOL_KEY2]]?.x;
            r.x = x ? _this.xScale(x) : 0;
              if (_this.ui.inpercent) {
                r.x /= total[_i][age.side[i].stack[stackIndex[i]][_this.PREFIXEDSIDEDIM]];
              }
            return r;
          });

          if (this.overhang && !this.sideSkip) {
            const dataOverhang = barsData.map(age => {
              const r = {};
              const x = frame[age.side[i].stack[stackIndex[i]][SYMBOL_KEY2]]?.x;
              const x_overhang = frame[age.side[i].stack[stackIndex[i] + 1][SYMBOL_KEY2]]?.x;
              r.x = x ? this.xScale(x) : 0;
              if (_this.ui.inpercent) {
                r.x /= total[_i][age.side[i].stack[stackIndex[i]][_this.PREFIXEDSIDEDIM]];
              }
              r.x -= x_overhang ? this.xScale(x_overhang) : 0;
              return r;
            });

            pathDataOverhang[_i].push({d: dataOverhang});
          }

          return data;
        });
      });

      pathsData.map((p, i) => p.push(...pathDataOverhang[i]));

      this.DOM.lockedPaths.each(function(d, _i) {
        const paths = d3.select(this).selectAll("path").data(pathsData[_i]);
        paths.exit().remove();
        paths.enter()
          .append("path")
          .merge(paths)
          .attr("d", (d, i) => line(d.d))
          .attr("stroke", "#000")
          .attr("transform", (d, i) => i % 2 ? ("scale(-1,1) translate(" + _this.profileConstants.centerWidth + ",0)") : "");
      });
    }

    updateSize() {
      this.size;

      const _this = this;

      const {
        x,
        y
      } = this.MDL;

      const {
        graph,
        barsCrop,
        lockedCrop,
        labelsCrop,
        yAxisEl,
        xAxisEl,
        xAxisLeftEl,
        bars,
        lockedPaths,
        labels,
        title,
        titleCenter,
        titleRight,
        xTitleEl,
        xInfoEl,
        dateLocked,
      } = this.DOM;

      const margin = this.profileConstants.margin;
      const infoElHeight = this.profileConstants.infoElHeight;

      const deltaMarginTop = this.sideSkip ? margin.top * 0.23 : 0;
      //stage
      const height = this.size.innerHeight;
      const width = this.size.innerWidth;
      this.fullWidth = (this.isInFacet ? this.parent.width : this.size.width) || 0;

      if (height <= 0 || width <= 0) return sharedComponents.LegacyUtils.warn("Pop by age resize() abort: vizabi container is too little or has display:none");

      graph.attr("transform", "translate(" + margin.left + "," + (margin.top - deltaMarginTop) + ")");

      barsCrop
        .attr("width", Math.max(0, width))
        .attr("height", Math.max(0, height));

      lockedCrop
        .attr("width", Math.max(0, width))
        .attr("height", Math.max(0, height));

      labelsCrop
        .attr("width", Math.max(0, width))
        .attr("height", Math.max(0, height));

      const groupBy = this.groupBy;

      const domain = d3.extent(this.yScale.domain());
      const barHeight = this.barHeight;

      if (this.stackBars) this.stackBars.attr("height", barHeight - (groupBy > 2 ? 1 : 0));

      if (this.sideBars) this.sideBars
        .attr("transform", (d, i) => i ? ("scale(-1,1) translate(" + _this.profileConstants.centerWidth + ",0)") : "");

      //update scales to the new range
      //apply scales to axes and redraw

      const yScaleCopy = this.yScale.copy().domain(domain);
      if (groupBy > 2) {
        yScaleCopy.ticks = () => d3.range(domain[0], domain[1] + 1, groupBy);
      }

      _this.yAxis.scale(yScaleCopy.range([height, 0]))
        .tickSizeInner(-width)
        .tickSizeOuter(0)
        .tickPadding(6)
        .tickSizeMinor(-width, 0)
        .labelerOptions({
          scaleType:  y.scale.type,
          toolMargin: margin,
          limitMaxTickNumber: 19,
          fitIntoScale: "optimistic",
          isPivotAuto: false,
          formatter: _this.localise
        });

      yAxisEl.attr("transform", "translate(" + 0 + ",0)")
        .call(_this.yAxis)
        .classed("vzb-bc-axis-text-hidden", false);//!_this.getYAxisVisibility(i));
      yAxisEl.select(".tick line").classed("vzb-hidden", true);


      const format = this.ui.inpercent ? d3.format((groupBy > 3 ? ".1" : ".1") + "%") : this.localise;

      const translateX = _this.twoSided ? ((width + _this.profileConstants.centerWidth) * 0.5) : 0;

      _this.xAxis.scale(_this.xScale.copy())
        .tickFormat(format)
        .tickSizeInner(-height)
        .tickSizeOuter(0)
        .tickPadding(6)
        .tickSizeMinor(0, 0)
        .labelerOptions({
          scaleType: x.scale.type,
          toolMargin: margin,
          limitMaxTickNumber: 6,
          //formatter: _this.localise
        });

      xAxisEl
        .attr("transform", "translate(" + translateX + "," + height + ")")
        .call(_this.xAxis);
      const zeroTickEl = xAxisEl.selectAll(".tick text");
      const tickCount = zeroTickEl.size();
      if (tickCount > 0) {
        const zeroTickBBox = zeroTickEl.node().getBBox();
        if (tickCount > 1) {
          d3.select(zeroTickEl.node()).attr("dx", (_this.twoSided ? -_this.profileConstants.centerWidth * 0.5 : 0) - zeroTickBBox.width * 0.5 - zeroTickBBox.x);
        }
        zeroTickEl.classed("vzb-invisible", (width + margin.betweenColumn) < zeroTickBBox.width);
      }

      xAxisEl.select(".tick line").classed("vzb-hidden", true);
      xAxisLeftEl.classed("vzb-hidden", !this.twoSided);
      if (this.twoSided) {
        this.xScaleLeft.range([(width - this.profileConstants.centerWidth) * 0.5, 0]);

        this.xAxisLeft.scale(this.xScaleLeft.copy())
          .tickFormat(format)
          .tickSizeInner(-height)
          .tickSizeOuter(0)
          .tickPadding(6)
          .tickSizeMinor(0, 0)
          .labelerOptions({
            scaleType: x.scale.type,
            toolMargin: margin,
            limitMaxTickNumber: 6,
            //formatter: this.localise
          });
        xAxisLeftEl
          .attr("transform", "translate(0," + height + ")")
          .call(this.xAxisLeft);
        //hide left axis zero tick
        const tickNodes = xAxisLeftEl.selectAll(".tick").classed("vzb-hidden", false).nodes();
        d3.select(tickNodes[tickNodes.length - 1]).classed("vzb-hidden", true);
      }

      const isRTL = this.services.locale.isRTL();

      bars.attr("transform", "translate(" + translateX + ",0)");
      lockedPaths.attr("transform", "translate(" + translateX + ",0)");
      labels.attr("transform", "translate(" + translateX + ",0)");

      const titleSpace = (translateX - this.profileConstants.titlesSpacing) < 0 ? _this.profileConstants.centerWidth * 0.5 : _this.profileConstants.titlesSpacing;

      title
        .attr("x", (d, i) => this.twoSided ? translateX - _this.profileConstants.centerWidth * 0.5 - titleSpace : 0)
        .style("text-anchor", this.twoSided ? "end" : "")
        .attr("y", -margin.top * 0.275 - deltaMarginTop)
        .each(function(d, i) {
          _this._textEllipsis.wrap(this, _this.twoSided ? (width + margin.betweenColumn - titleSpace) * 0.5 : width +  margin.betweenColumn);
        });
      titleRight
        .attr("x", translateX - _this.profileConstants.centerWidth * 0.5 + titleSpace)
        .attr("y", -margin.top * 0.275 - deltaMarginTop)
        .each(function(d, i) {
          _this._textEllipsis.wrap(this, (width + margin.betweenColumn - titleSpace) * 0.5);
        });
      titleCenter
        .attr("x", this.twoSided ? translateX - _this.profileConstants.centerWidth * 0.5: width * 0.5)
        .style("text-anchor", "middle")
        .attr("y", (-margin.top - deltaMarginTop)* 0.035 )
        .each(function(d, i) {
          _this._textEllipsis.wrap(this, width +  margin.betweenColumn);
        });
      

      const titleWidth = titleCenter.node().getBoundingClientRect().width;
      const xPosCloseCross = titleWidth > width ? (titleWidth - width) * 0.5 : null;

      this.DOM.closeCross
        .style("font-size", infoElHeight + "px")
        .attr("transform", "translate(" + (isRTL ? 0 : width) + "," + (-margin.top - deltaMarginTop)* 0.035 + ")")
        .select("text")
        .attr("dx", isRTL ? "-0.5em": "-0.1em")
        .attr("dy", "-0.05em")
        .attr("x", (isRTL ? -1 : 1) * xPosCloseCross);

      xTitleEl
        .style("font-size", infoElHeight + "px")
        .attr("transform", "translate(" + (isRTL ? margin.left + width + margin.right * 0.6 : margin.left * 0.4) + "," + (margin.top * 0.35) + ")");

      if (xInfoEl.select("svg").node()) {
        const titleBBox = xTitleEl.node().getBBox();
        const t = sharedComponents.LegacyUtils.transform(xTitleEl.node());
        const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);

        xInfoEl.select("svg")
          .attr("width", infoElHeight + "px")
          .attr("height", infoElHeight + "px");
        xInfoEl.attr("transform", "translate("
          + hTranslate + ","
          + (t.translateY - infoElHeight * 0.8) + ")");
      }

      const yearLabelOptions = {
        topOffset: this.services.layout.projector ? 25 : this.services.layout.profile === "small" ? 10 : 15,
        leftOffset: this.services.layout.profile === "small" ? 5 : 10,
        rightOffset: this.services.layout.profile === "small" ? 5 : 10,
        xAlign: isRTL ? "left" : "right",
        yAlign: "top",
        heightRatio: this.services.layout.projector ? 0.5 : 0.5,
        //widthRatio: this.services.layout.profile === "large" ? 3 / 8 : 5 / 10
      };

      //year resized
      this._date
        .setConditions(yearLabelOptions)
        .resizeText(this.fullWidth, margin.top);
      dateLocked.attr("x", width + margin.left + margin.right - 10).attr("y", (margin.top - deltaMarginTop) * (this.services.layout.profile === "large" ? 1.27 : 1.27));

    }

    _showLabel(event, d) {
      const _this = this;
      const formatter = _this.ui.inpercent ? d3.format(".1%") : _this.localise;
      const sideDim = _this.SIDEDIM;
      _this.AGEDIM;
      const stackDim = _this.STACKDIM;
      const shiftedAgeDim = "s_age";
      const left = _this.sideKeys.indexOf(d[sideDim]) > 0;

      let deltaX = 7;
      const hoverBarEl = d3.select(event.target);
      deltaX += +hoverBarEl.attr("x");

      const labelNode = _this.DOM.labels.select(".vzb-bc-label-" + d[shiftedAgeDim]).nodes()[d.i];// + "-" + _this._id);
      const labelEl = d3.select(labelNode);
      labelEl.selectAll(".vzb-bc-age")
        .text(textData => {
          //var total = _this.ui.inpercent ? _this.totalValues[d[sideDim]] : 1;
          let text = _this.stackKeys.length > 1 ? _this.stackItems[d[stackDim]] : textData.text;
          text = _this.twoSided ? text : textData.text + " " + _this.stackItems[d[stackDim]];
          const value = _this.xScale.invert(d["width_"]);
          return text + ": " + formatter(value);
        })
        .attr("x", left ? -this.profileConstants.centerWidth - deltaX : deltaX)
        .attr("dx", 0)
        .classed("vzb-text-left", left);
      labelEl.classed("vzb-prehovered", true);
      const bbox = labelNode.getBBox();
      const transform = _this.DOM.svg.node().getScreenCTM().inverse().multiply(labelNode.getScreenCTM());
      const overDrawLeft = Math.max(-bbox.x - transform.e, 0);
      const overDrawRight = Math.min(_this.fullWidth - bbox.x - bbox.width - transform.e, 0);
      labelEl.selectAll(".vzb-bc-age").attr("dx", overDrawLeft + overDrawRight);
      labelEl.classed("vzb-prehovered", false);
      labelEl.classed("vzb-hovered", true);
    }

    _highlightBars() {
      const _this = this;

      _this.someHighlighted = this.MDL.highlighted.data.filter.any();

      _this.updateBarsOpacity();

      if (!_this.someHighlighted) {
        //hide labels
        _this.DOM.labels.selectAll(".vzb-hovered").classed("vzb-hovered", false);
      }
    }

    updateBarsOpacity(duration) {

      const highlightedFilter = this.MDL.highlighted.data.filter;
      const selectedFilter = this.MDL.selected.data.filter;
      this.someSelected = selectedFilter.any();
      this.nonSelectedOpacityZero = false;

      const OPACITY_HIGHLT = 1.0;
      const OPACITY_HIGHLT_DIM = this.ui.opacityHighlightDim;
      const OPACITY_SELECT = 1.0;
      const OPACITY_REGULAR = this.ui.opacityRegular;
      const OPACITY_SELECT_DIM = this.ui.opacitySelectDim;

      const nonSelectedOpacityZero = this.ui.opacitySelectDim < 0.01;
      const nonSelectedOpacityZeroFlag = nonSelectedOpacityZero != this.nonSelectedOpacityZero;
      const someSelected = this.someSelected;
      const someHighlighted = this.someHighlighted;

      this.stackBars.each(function(d) {
        const isSelected =  someSelected ? selectedFilter.has(d) : false;
        const isHighlighted = someHighlighted ? highlightedFilter.has(d): false;
        const bar = d3.select(this);

        bar.style("opacity", isHighlighted ? OPACITY_HIGHLT
          :
          someSelected ? (isSelected ? OPACITY_SELECT : OPACITY_SELECT_DIM)
            :
            someHighlighted ? OPACITY_HIGHLT_DIM : OPACITY_REGULAR)
          .style("stroke", isSelected ? "#333" : null)
          .style("y", isSelected ? "0.5px" : null);

        if(nonSelectedOpacityZeroFlag) {
          bar.style("pointer-events", !someSelected || !nonSelectedOpacityZero || isSelected ? "visible" : "none");
        }
      });

      this.nonSelectedOpacityZero = OPACITY_SELECT_DIM < 0.01;
    }

    getYAxisVisibility(index) {
      return index == 0 ? true : false;
    }

  }

  const PROFILE_CONSTANTS = _VizabiPopByAge.PROFILE_CONSTANTS = {
    SMALL: {
      margin: {
        top: 50,
        right: 20,
        left: 40,
        bottom: 20,
        betweenColumn: 10
      },
      infoElHeight: 16,
      centerWidth: 2,
      titlesSpacing: 5
    },
    MEDIUM: {
      margin: {
        top: 70,
        right: 40,
        left: 60,
        bottom: 20,
        betweenColumn: 20
      },
      infoElHeight: 20,
      centerWidth: 2,
      titlesSpacing: 10
    },
    LARGE: {
      margin: {
        top: 80,
        right: 60,
        left: 60,
        bottom: 30,
        betweenColumn: 20
      },
      infoElHeight: 22,
      centerWidth: 2,
      titlesSpacing: 20
    }
  };

  const PROFILE_CONSTANTS_FOR_PROJECTOR = _VizabiPopByAge.PROFILE_CONSTANTS_FOR_PROJECTOR = {
    MEDIUM: {
      margin: { top: 120, right: 50, left:80, bottom: 60, betweenColumn: 30 },
      infoElHeight: 32
    },
    LARGE: {
      margin: { top: 120, right: 70, left: 100, bottom: 70, betweenColumn: 30 },
      infoElHeight: 32
    }
  };

  _VizabiPopByAge.DEFAULT_UI = {

    showForecast: true,
    showForecastOverlay: true,
    pauseBeforeForecast: false,
    opacityHighlightDim: 0.1,
    opacitySelectDim: 0.3,
    opacityRegular: 1,
  };

  const VizabiPopByAge = mobx.decorate(_VizabiPopByAge, {
    "xScale": mobx.computed,
    "yScale": mobx.computed,
    "cScale": mobx.computed,
    "stepSeries": mobx.computed,
    "ageKeys": mobx.computed,
    "sideKeys": mobx.computed,
    "stackKeys": mobx.computed,
    "twoSided": mobx.computed,
    "domains": mobx.computed,
    "allLimitsAndTotals": mobx.computed,
    "groupBy": mobx.computed,
    "MDL": mobx.computed,
    "isInFacet": mobx.computed,
    "isManyFacets": mobx.computed,
    "_getDataArrayForFacet": mobx.computed,
    "_getFacetEncName": mobx.computed,
    "size": mobx.computed,
    "profileConstants": mobx.computed,
    "barHeight": mobx.computed,
    "oneBarHeight": mobx.computed,
    "firstBarOffsetY": mobx.computed,
    "sideSkip": mobx.computed,
    "overhang": mobx.computed
  });

  /*
   * grouping dialog
   */

  class Grouping extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <div class="vzb-dialog-title"> 
          <span data-localise="buttons/grouping"><span>
        </div>
            
        <div class="vzb-dialog-content">
          <div class="vzb-dialog-groups"></div>
          <div class="vzb-dialog-placeholder"></div>
        </div>

        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>
      </div>
    `;

      const GROUP_KEY = "age";

      const aggregateModel = function() {
        const _this = this;
        return  {
          get value() {
            return _this.encoding.aggregate.grouping[GROUP_KEY].grouping;
          },
          set value(value) {
            _this.encoding.aggregate.config.grouping[GROUP_KEY].grouping = value;
          }
        };
      };

      const groupStops = [1, 5, 10, 15];
      config.options = Object.assign(config.options || {}, {groupStops});

      config.subcomponents = [{
        type: sharedComponents.SingleHandleSlider,
        placeholder: ".vzb-dialog-placeholder",
        //model: ["state.time", "locale"],
        options: {
          value: "value",
          submodelFunc: aggregateModel,
          snapValue: true,
          suppressInput: true,
          domain: groupStops
        }
      }];

      super(config);

    }

    setup(options) {
      super.setup(options);

      const groups = this.element.select(".vzb-dialog-groups");

      groups.selectAll(".vzb-dialog-groups-title")
        .data(options.groupStops)
        .enter()
        .append("span")
        .attr("class", ".vzb-dialog-groups-title")
        .text(d => d);
    }
  }

  // const decorated = decorate(Grouping, {
  //   "MDL": computed
  // });
  sharedComponents.Dialog.add("grouping", Grouping);

  //import * as utils from "base/utils";
  //import Component from "base/component";
  //import Dialog from "components/dialogs/_dialog";

  //import indicatorpicker from "components/indicatorpicker/indicatorpicker";
  //import simplecheckbox from "components/simplecheckbox/simplecheckbox";
  /*!
   * VIZABI SIDE CONTROL
   * Reusable side dialog
   */

  class Side extends sharedComponents.Dialog {

    constructor(config) {
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="side" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="side" data-click="dragDialog"></span>
        <div class="vzb-dialog-title">
          <span data-localise="buttons/side"></span>
          <span class="vzb-side-selector"></span>
        </div>
        
        <div class="vzb-dialog-content vzb-dialog-scrollable">
          <div class="vzb-side-list vzb-side-list-left">
            <!-- list will be placed here -->
          </div>
          <div class="vzb-side-list vzb-side-list-right">
            <!-- list will be placed here -->
          </div>
        </div>

        <div class="vzb-dialog-buttons">
          <div class="vzb-dialog-button vzb-label-primary vzb-side-switch-sides">
            <span data-localise="buttons/leftright"></span>
          </div>

          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>
      </div>
    `;

      config.subcomponents = [{
        type: sharedComponents.IndicatorPicker,
        placeholder: ".vzb-side-selector",
        options: {
          submodel: "encoding",
          targetProp: "side",
          showHoverValues: false
        }
      }];

      super(config);
    }

    setup(options) {
      super.setup(options);

      this.DOM.switchSides = this.element.select(".vzb-side-switch-sides");
      this.DOM.switchSides.on("click", () => {
        this.root.ui.chart.flipSides = !this.root.ui.chart.flipSides;
      });

    }

  }

  /*
  const _Side = {

    init(config, parent) {
      this.name = "side";
      const _this = this;

      this.model_binds = {
        "change:ui.chart.flipSides": function(evt) {
          if (!_this._readyOnce) return;
          _this.updateState();
          _this.redraw();
        }

      };

      this.components = [
        {
          component: indicatorpicker,
          placeholder: ".vzb-side-selector",
          model: ["state.time", "state.marker.side", "locale"],
          showHoverValues: false
        }
      ];

      this._super(config, parent);
    },

    readyOnce() {
      this._super();
      this.listLeft = this.element.select(".vzb-side-list-left");
      this.listRight = this.element.select(".vzb-side-list-right");
      this.switchSides = this.element.select(".vzb-side-switch-sides");

      this.TIMEDIM = this.model.state.time.getDimension();
      this.state = {};
      const _this = this;

      this.switchSides.on("click", () => {
        _this.model.ui.chart.flipSides = !_this.model.ui.chart.flipSides;
      });

      this.model.state.marker.side.getEntity().on("change:show", () => {
        _this.updateState();
        _this.redraw();
      });

      //make sure it refreshes when all is reloaded
      this.root.on("ready", () => {
        _this.redraw();
      });
    },

    ready() {
      this._super();

      const sideEntities = this.model.state.marker.side.getEntity();
      this.KEY = sideEntities.getDimension();
      this.labelNames = this.model.state.marker.getLabelHookNames();
      if (this.model.state.marker.side.use !== "constant" && !(sideEntities.show[this.KEY] || {})["$in"]) {
        const sideKeys = this.model.state.marker.side.getUnique(this.model.state.marker.side.which).filter(f => f !== null);
        const filterKeys = sideKeys.sort(d3.ascending).slice(0, 2);
        if (filterKeys.length > 0) {
          const show = Object.assign({}, sideEntities.show);
          show[this.KEY] = { "$in": filterKeys };
          sideEntities.set("show", show);
        }
      }

      this.updateState();
      this.redraw();
      utils.preventAncestorScrolling(this.element.select(".vzb-dialog-scrollable"));

    },

    updateState() {
      const _this = this;
      const sideDim = this.model.state.marker.side.getEntity().getDimension();
      const modelSide = this.model.state.marker.side;

      this.state["right"] = {};
      this.state["left"] = {};
      if (modelSide.state["left"][sideDim] && modelSide.state["right"][sideDim]) {
        this.state["left"][sideDim] = modelSide.state["left"][sideDim];
        this.state["right"][sideDim] = modelSide.state["right"][sideDim];
      } else {
        const sides = this.model.state.marker.getKeys(sideDim);
        let sideKeys = [];
        const sideFiltered = !!this.model.state.marker.side.getEntity().show[sideDim];
        sideKeys = sides.filter(f => !sideFiltered || _this.model.state.marker.side.getEntity().isShown(f)).map(m => m[sideDim]);

        if (sideKeys.length > 2) sideKeys.length = 2;
        if (sideKeys.length > 1) {
          const sortFunc = this.ui.chart.flipSides ? d3.ascending : d3.descending;
          sideKeys.sort(sortFunc);
        }

        this.state["right"] = {};
        this.state["right"][sideDim] = sideKeys[0];
        this.state["left"] = {};
        this.state["left"][sideDim] = sideKeys[1] ? sideKeys[1] : sideKeys[0];
      }

      const hidden = this.model.state.marker.side.use == "constant";

      this.listLeft.classed("vzb-hidden", hidden);
      this.listRight.classed("vzb-hidden", hidden);
      this.switchSides.classed("vzb-hidden", hidden || this.state["left"][sideDim] == this.state["right"][sideDim]);
    },

    redraw() {

      const _this = this;
      const labelNames = this.labelNames;
      const KEY = this.KEY;

      this.translator = this.model.locale.getTFunction();

      if (!_this.model.state.marker.side.getEntity().dim) return;

      this.model.state.marker.getFrame(this.model.state.time.value, values => {
        if (!values) return;
        const data = [];
        const sideConcept = _this.model.state.marker.side.getConceptprops();

        if (sideConcept.concept_type == "entity_set") {
          data.push(..._this.model.state.marker.side.getEntity().getEntitySets("data")[sideConcept.concept][0].map(d => {
            const result = {};
            result[KEY] = d[sideConcept.concept];
            result["label"] = d["name"];
            return result;
          }));
        } else {
          utils.forEach(values[labelNames[KEY]], (value, key) => {
            const result = {};
            result[KEY] = key;
            result["label"] = value;
            data.push(result);
          });
        }

        //sort data alphabetically
        data.sort((a, b) => (a.label < b.label) ? -1 : 1);

        _this.listLeft.html("");
        _this.listRight.html("");
        _this.createList(_this.listLeft, "left", data);
        _this.createList(_this.listRight, "right", data);

      });
    },

    createList(listSel, name, data) {
      const _this = this;
      const sideDim = this.model.state.marker.side.getEntity().getDimension();

      const items = listSel.selectAll(".vzb-side-item")
        .data(data)
        .enter()
        .append("div")
        .attr("class", "vzb-side-item vzb-dialog-radio");

      items.append("input")
        .attr("type", "radio")
        .attr("name", name + "-" + _this._id)
        .attr("class", "vzb-side-item")
        .attr("id", d => "-side-" + name + "-" + d[sideDim] + "-" + _this._id)
        .property("checked", d => _this.state[name][sideDim] === d[sideDim])
        .on("change", (d, i) => {
          const sideEntities = _this.model.state.marker.side.getEntity();
          const sideDim = sideEntities.getDimension();
          const otherSide = name == "left" ? "right" : "left";
          const modelSide = _this.model.state.marker.side;

          modelSide.state[name][sideDim] = d[sideDim];
          modelSide.state[otherSide][sideDim] = _this.state[otherSide][sideDim];

          const showArray = [];

          if (!sideEntities.isShown(d)) {
            showArray.push(d);
          }
          if (d[sideDim] !== _this.state[otherSide][sideDim] && !sideEntities.isShown(_this.state[otherSide])) {
            showArray.push(_this.state[otherSide]);
          }
          if (_this.state[name][sideDim] !== _this.state[otherSide][sideDim] && sideEntities.isShown(_this.state[name])) {
            showArray.push(_this.state[name]);
          }

          if (d[sideDim] !== _this.state[otherSide][sideDim]) {
            const sideKeys = [d[sideDim], _this.state[otherSide][sideDim]];
            const sortFunc = _this.ui.chart.flipSides ? d3.ascending : d3.descending;
            sideKeys.sort(sortFunc);
            if (sideKeys[name == "left" ? 0 : 1] == d[sideDim]) {
              _this.model.state.marker.side.switchSideState();
              _this.ui.chart.flipSides = !_this.ui.chart.flipSides;
            }
          }

          if (showArray.length) {
            sideEntities.showEntity(showArray);
          }

        });

      items.append("label")
        .attr("for", d => "-side-" + name + "-" + d[_this.KEY] + "-" + _this._id)
        .text(d => d.label);
    }

  }*/


  sharedComponents.Dialog.add("side", Side);

  class PopByAge extends sharedComponents.BaseComponent {

    constructor(config){
      const fullMarker = config.model.markers.pyramid;
        
      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);
      config.model.markers.pyramid = marker;

      config.name = "popbyage";

      config.subcomponents = [{
        type: sharedComponents.Repeater,
        placeholder: ".vzb-repeater",
        model: marker,
        options: {
          repeatedComponent: sharedComponents.Facet, 
          repeatedComponentCssClass: "vzb-facet",
          repeatedComponentOptions: {
            facetedComponent: VizabiPopByAge,
            facetedComponentCssClass: "vzb-popbyage",
            direction: "column"
          }
        },
        name: "chart",
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        model: marker,
        name: "time-slider"
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        model: marker,
        name: "speed-slider"
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        model: marker,
        name: "tree-menu"
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        model: marker,
        name: "buttons"
      }];

      config.template = `
      <div class="vzb-chart">
        <div class="vzb-repeater"></div>
      </div>
      <div class="vzb-animationcontrols">
        <div class="vzb-timeslider"></div>
        <div class="vzb-speedslider"></div>
      </div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datanotes"></div>
    `;
    
      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService({placeholder: config.placeholder})
      };
      
      super(config);
      this.splashMarker = splashMarker;
    }
  }
  PopByAge.DEFAULT_UI = {
    chart: {
      mode: "smallMultiples",
      opacityHighlightDim: 0.1,
      opacitySelectDim: 0.3,
      opacityRegular: 1,
      stacked: true,
      inpercent: false,
      flipSides: true,
      lockActive: true,
      lockNonSelected: 0
    },
  };

  PopByAge.versionInfo = { version: "5.0.2", build: 1719060136758, package: {"homepage":"https://github.com/vizabi/popbyage#readme","name":"@vizabi/popbyage","description":"Vizabi age pyrmid"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = PopByAge;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/spreadsheet#readme v4.0.0 build 1687773699667 Copyright 2023 Gapminder Foundation and contributors
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('fs'), require('d3'), require('mobx')) :
	typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'fs', 'd3', 'mobx'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Spreadsheet = {}, global.VizabiSharedComponents, global.require$$0, global.d3, global.mobx));
})(window, (function (exports, sharedComponents, require$$0, d3, mobx) {
	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var xlsx_mini_min = createCommonjsModule(function (module, exports) {
	var XLSX={};function make_xlsx_lib(e){e.version="0.17.5";var r=1200,t=1252;var a=[874,932,936,949,950];for(var n=0;n<=8;++n)a.push(1250+n);var i={0:1252,1:65001,2:65001,77:1e4,128:932,129:949,130:1361,134:936,136:950,161:1253,162:1254,163:1258,177:1255,178:1256,186:1257,204:1251,222:874,238:1250,255:1252,69:6969};var s=function(e){if(a.indexOf(e)==-1)return;t=i[0]=e;};function l(){s(1252);}var o=function(e){r=e;s(e);};function c(){o(1200);l();}function f(e){var r=[];for(var t=0,a=e.length;t<a;++t)r[t]=e.charCodeAt(t);return r}function u(e){var r=[];for(var t=0;t<e.length>>1;++t)r[t]=String.fromCharCode(e.charCodeAt(2*t)+(e.charCodeAt(2*t+1)<<8));return r.join("")}function h(e){var r=[];for(var t=0;t<e.length>>1;++t)r[t]=String.fromCharCode(e.charCodeAt(2*t+1)+(e.charCodeAt(2*t)<<8));return r.join("")}var d=function(e){var r=e.charCodeAt(0),t=e.charCodeAt(1);if(r==255&&t==254)return u(e.slice(2));if(r==254&&t==255)return h(e.slice(2));if(r==65279)return e.slice(1);return e};var p=function Hl(e){return String.fromCharCode(e)};var m=function Xl(e){return String.fromCharCode(e)};var b=function Vl(){var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";return {encode:function(r){var t="";var a=0,n=0,i=0,s=0,l=0,o=0,c=0;for(var f=0;f<r.length;){a=r.charCodeAt(f++);s=a>>2;n=r.charCodeAt(f++);l=(a&3)<<4|n>>4;i=r.charCodeAt(f++);o=(n&15)<<2|i>>6;c=i&63;if(isNaN(n)){o=c=64;}else if(isNaN(i)){c=64;}t+=e.charAt(s)+e.charAt(l)+e.charAt(o)+e.charAt(c);}return t},decode:function r(t){var a="";var n=0,i=0,s=0,l=0,o=0,c=0,f=0;t=t.replace(/[^\w\+\/\=]/g,"");for(var u=0;u<t.length;){l=e.indexOf(t.charAt(u++));o=e.indexOf(t.charAt(u++));n=l<<2|o>>4;a+=String.fromCharCode(n);c=e.indexOf(t.charAt(u++));i=(o&15)<<4|c>>2;if(c!==64){a+=String.fromCharCode(i);}f=e.indexOf(t.charAt(u++));s=(c&3)<<6|f;if(f!==64){a+=String.fromCharCode(s);}}return a}}}();var w=typeof Buffer!=="undefined"&&typeof process!=="undefined"&&typeof process.versions!=="undefined"&&!!process.versions.node;var k=function(){};if(typeof Buffer!=="undefined"){var y=!Buffer.from;if(!y)try{Buffer.from("foo","utf8");}catch(x){y=true;}k=y?function(e,r){return r?new Buffer(e,r):new Buffer(e)}:Buffer.from.bind(Buffer);if(!Buffer.alloc)Buffer.alloc=function(e){return new Buffer(e)};if(!Buffer.allocUnsafe)Buffer.allocUnsafe=function(e){return new Buffer(e)};}function S(e){return w?Buffer.alloc(e):new Array(e)}function _(e){return w?Buffer.allocUnsafe(e):new Array(e)}var C=function Gl(e){if(w)return k(e,"binary");return e.split("").map(function(e){return e.charCodeAt(0)&255})};function A(e){if(typeof ArrayBuffer==="undefined")return C(e);var r=new ArrayBuffer(e.length),t=new Uint8Array(r);for(var a=0;a!=e.length;++a)t[a]=e.charCodeAt(a)&255;return r}function E(e){if(Array.isArray(e))return e.map(function(e){return String.fromCharCode(e)}).join("");var r=[];for(var t=0;t<e.length;++t)r[t]=String.fromCharCode(e[t]);return r.join("")}function F(e){if(typeof Uint8Array==="undefined")throw new Error("Unsupported");return new Uint8Array(e)}function T(e){if(typeof ArrayBuffer=="undefined")throw new Error("Unsupported");if(e instanceof ArrayBuffer)return T(new Uint8Array(e));var r=new Array(e.length);for(var t=0;t<e.length;++t)r[t]=e[t];return r}var O=function(e){return [].concat.apply([],e)};var D=/\u0000/g,M=/[\u0001-\u0006]/g;var N={};var R=function Yl(e){e.version="0.11.2";function r(e){var r="",t=e.length-1;while(t>=0)r+=e.charAt(t--);return r}function t(e,r){var t="";while(t.length<r)t+=e;return t}function a(e,r){var a=""+e;return a.length>=r?a:t("0",r-a.length)+a}function n(e,r){var a=""+e;return a.length>=r?a:t(" ",r-a.length)+a}function i(e,r){var a=""+e;return a.length>=r?a:a+t(" ",r-a.length)}function s(e,r){var a=""+Math.round(e);return a.length>=r?a:t("0",r-a.length)+a}function l(e,r){var a=""+e;return a.length>=r?a:t("0",r-a.length)+a}var o=Math.pow(2,32);function c(e,r){if(e>o||e<-o)return s(e,r);var t=Math.round(e);return l(t,r)}function f(e,r){r=r||0;return e.length>=7+r&&(e.charCodeAt(r)|32)===103&&(e.charCodeAt(r+1)|32)===101&&(e.charCodeAt(r+2)|32)===110&&(e.charCodeAt(r+3)|32)===101&&(e.charCodeAt(r+4)|32)===114&&(e.charCodeAt(r+5)|32)===97&&(e.charCodeAt(r+6)|32)===108}var u=[["Sun","Sunday"],["Mon","Monday"],["Tue","Tuesday"],["Wed","Wednesday"],["Thu","Thursday"],["Fri","Friday"],["Sat","Saturday"]];var h=[["J","Jan","January"],["F","Feb","February"],["M","Mar","March"],["A","Apr","April"],["M","May","May"],["J","Jun","June"],["J","Jul","July"],["A","Aug","August"],["S","Sep","September"],["O","Oct","October"],["N","Nov","November"],["D","Dec","December"]];function d(e){e[0]="General";e[1]="0";e[2]="0.00";e[3]="#,##0";e[4]="#,##0.00";e[9]="0%";e[10]="0.00%";e[11]="0.00E+00";e[12]="# ?/?";e[13]="# ??/??";e[14]="m/d/yy";e[15]="d-mmm-yy";e[16]="d-mmm";e[17]="mmm-yy";e[18]="h:mm AM/PM";e[19]="h:mm:ss AM/PM";e[20]="h:mm";e[21]="h:mm:ss";e[22]="m/d/yy h:mm";e[37]="#,##0 ;(#,##0)";e[38]="#,##0 ;[Red](#,##0)";e[39]="#,##0.00;(#,##0.00)";e[40]="#,##0.00;[Red](#,##0.00)";e[45]="mm:ss";e[46]="[h]:mm:ss";e[47]="mmss.0";e[48]="##0.0E+0";e[49]="@";e[56]='"上午/下午 "hh"時"mm"分"ss"秒 "';}var p={};d(p);var m=[];var v=0;for(v=5;v<=8;++v)m[v]=32+v;for(v=23;v<=26;++v)m[v]=0;for(v=27;v<=31;++v)m[v]=14;for(v=50;v<=58;++v)m[v]=14;for(v=59;v<=62;++v)m[v]=v-58;for(v=67;v<=68;++v)m[v]=v-58;for(v=72;v<=75;++v)m[v]=v-58;for(v=67;v<=68;++v)m[v]=v-57;for(v=76;v<=78;++v)m[v]=v-56;for(v=79;v<=81;++v)m[v]=v-34;var g=[];g[5]=g[63]='"$"#,##0_);\\("$"#,##0\\)';g[6]=g[64]='"$"#,##0_);[Red]\\("$"#,##0\\)';g[7]=g[65]='"$"#,##0.00_);\\("$"#,##0.00\\)';g[8]=g[66]='"$"#,##0.00_);[Red]\\("$"#,##0.00\\)';g[41]='_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)';g[42]='_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)';g[43]='_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)';g[44]='_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)';function b(e,r,t){var a=e<0?-1:1;var n=e*a;var i=0,s=1,l=0;var o=1,c=0,f=0;var u=Math.floor(n);while(c<r){u=Math.floor(n);l=u*s+i;f=u*c+o;if(n-u<5e-8)break;n=1/(n-u);i=s;s=l;o=c;c=f;}if(f>r){if(c>r){f=o;l=i;}else {f=c;l=s;}}if(!t)return [0,a*l,f];var h=Math.floor(a*l/f);return [h,a*l-h*f,f]}function w(e,r,t){if(e>2958465||e<0)return null;var a=e|0,n=Math.floor(86400*(e-a)),i=0;var s=[];var l={D:a,T:n,u:86400*(e-a)-n,y:0,m:0,d:0,H:0,M:0,S:0,q:0};if(Math.abs(l.u)<1e-6)l.u=0;if(r&&r.date1904)a+=1462;if(l.u>.9999){l.u=0;if(++n==86400){l.T=n=0;++a;++l.D;}}if(a===60){s=t?[1317,10,29]:[1900,2,29];i=3;}else if(a===0){s=t?[1317,8,29]:[1900,1,0];i=6;}else {if(a>60)--a;var o=new Date(1900,0,1);o.setDate(o.getDate()+a-1);s=[o.getFullYear(),o.getMonth()+1,o.getDate()];i=o.getDay();if(a<60)i=(i+6)%7;if(t)i=E(o,s);}l.y=s[0];l.m=s[1];l.d=s[2];l.S=n%60;n=Math.floor(n/60);l.M=n%60;n=Math.floor(n/60);l.H=n;l.q=i;return l}e.parse_date_code=w;var k=new Date(1899,11,31,0,0,0);var y=k.getTime();var x=new Date(1900,2,1,0,0,0);function S(e,r){var t=e.getTime();if(r)t-=1461*24*60*60*1e3;else if(e>=x)t+=24*60*60*1e3;return (t-(y+(e.getTimezoneOffset()-k.getTimezoneOffset())*6e4))/(24*60*60*1e3)}function _(e){return e.toString(10)}e._general_int=_;var C=function $(){var e=/(?:\.0*|(\.\d*[1-9])0+)$/;function r(r){return r.indexOf(".")==-1?r:r.replace(e,"$1")}var t=/(?:\.0*|(\.\d*[1-9])0+)[Ee]/;var a=/(E[+-])(\d)$/;function n(e){if(e.indexOf("E")==-1)return e;return e.replace(t,"$1E").replace(a,"$10$2")}function i(e){var t=e<0?12:11;var a=r(e.toFixed(12));if(a.length<=t)return a;a=e.toPrecision(10);if(a.length<=t)return a;return e.toExponential(5)}function s(e){var t=r(e.toFixed(11));return t.length>(e<0?12:11)||t==="0"||t==="-0"?e.toPrecision(6):t}function l(e){var t=Math.floor(Math.log(Math.abs(e))*Math.LOG10E),a;if(t>=-4&&t<=-1)a=e.toPrecision(10+t);else if(Math.abs(t)<=9)a=i(e);else if(t===10)a=e.toFixed(10).substr(0,12);else a=s(e);return r(n(a.toUpperCase()))}return l}();e._general_num=C;function A(e,r){switch(typeof e){case"string":return e;case"boolean":return e?"TRUE":"FALSE";case"number":return (e|0)===e?e.toString(10):C(e);case"undefined":return "";case"object":if(e==null)return "";if(e instanceof Date)return z(14,S(e,r&&r.date1904),r);}throw new Error("unsupported value in General format: "+e)}e._general=A;function E(e,r){r[0]-=581;var t=e.getDay();if(e<60)t=(t+6)%7;return t}function F(e,r,t,n){var i="",s=0,l=0,o=t.y,c,f=0;switch(e){case 98:o=t.y+543;case 121:switch(r.length){case 1:case 2:c=o%100;f=2;break;default:c=o%1e4;f=4;break;}break;case 109:switch(r.length){case 1:case 2:c=t.m;f=r.length;break;case 3:return h[t.m-1][1];case 5:return h[t.m-1][0];default:return h[t.m-1][2];}break;case 100:switch(r.length){case 1:case 2:c=t.d;f=r.length;break;case 3:return u[t.q][0];default:return u[t.q][1];}break;case 104:switch(r.length){case 1:case 2:c=1+(t.H+11)%12;f=r.length;break;default:throw "bad hour format: "+r;}break;case 72:switch(r.length){case 1:case 2:c=t.H;f=r.length;break;default:throw "bad hour format: "+r;}break;case 77:switch(r.length){case 1:case 2:c=t.M;f=r.length;break;default:throw "bad minute format: "+r;}break;case 115:if(r!="s"&&r!="ss"&&r!=".0"&&r!=".00"&&r!=".000")throw "bad second format: "+r;if(t.u===0&&(r=="s"||r=="ss"))return a(t.S,r.length);if(n>=2)l=n===3?1e3:100;else l=n===1?10:1;s=Math.round(l*(t.S+t.u));if(s>=60*l)s=0;if(r==="s")return s===0?"0":""+s/l;i=a(s,2+n);if(r==="ss")return i.substr(0,2);return "."+i.substr(2,r.length-1);case 90:switch(r){case"[h]":case"[hh]":c=t.D*24+t.H;break;case"[m]":case"[mm]":c=(t.D*24+t.H)*60+t.M;break;case"[s]":case"[ss]":c=((t.D*24+t.H)*60+t.M)*60+Math.round(t.S+t.u);break;default:throw "bad abstime format: "+r;}f=r.length===3?1:2;break;case 101:c=o;f=1;break;}var d=f>0?a(c,f):"";return d}function T(e){var r=3;if(e.length<=r)return e;var t=e.length%r,a=e.substr(0,t);for(;t!=e.length;t+=r)a+=(a.length>0?",":"")+e.substr(t,r);return a}var O=function U(){var e=/%/g;function s(r,a,n){var i=a.replace(e,""),s=a.length-i.length;return O(r,i,n*Math.pow(10,2*s))+t("%",s)}function l(e,r,t){var a=r.length-1;while(r.charCodeAt(a-1)===44)--a;return O(e,r.substr(0,a),t/Math.pow(10,3*(r.length-a)))}function o(e,r){var t;var a=e.indexOf("E")-e.indexOf(".")-1;if(e.match(/^#+0.0E\+0$/)){if(r==0)return "0.0E+0";else if(r<0)return "-"+o(e,-r);var n=e.indexOf(".");if(n===-1)n=e.indexOf("E");var i=Math.floor(Math.log(r)*Math.LOG10E)%n;if(i<0)i+=n;t=(r/Math.pow(10,i)).toPrecision(a+1+(n+i)%n);if(t.indexOf("e")===-1){var s=Math.floor(Math.log(r)*Math.LOG10E);if(t.indexOf(".")===-1)t=t.charAt(0)+"."+t.substr(1)+"E+"+(s-t.length+i);else t+="E+"+(s-i);while(t.substr(0,2)==="0."){t=t.charAt(0)+t.substr(2,n)+"."+t.substr(2+n);t=t.replace(/^0+([1-9])/,"$1").replace(/^0+\./,"0.");}t=t.replace(/\+-/,"-");}t=t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function(e,r,t,a){return r+t+a.substr(0,(n+i)%n)+"."+a.substr(i)+"E"});}else t=r.toExponential(a);if(e.match(/E\+00$/)&&t.match(/e[+-]\d$/))t=t.substr(0,t.length-1)+"0"+t.charAt(t.length-1);if(e.match(/E\-/)&&t.match(/e\+/))t=t.replace(/e\+/,"e");return t.replace("e","E")}var f=/# (\?+)( ?)\/( ?)(\d+)/;function u(e,r,i){var s=parseInt(e[4],10),l=Math.round(r*s),o=Math.floor(l/s);var c=l-o*s,f=s;return i+(o===0?"":""+o)+" "+(c===0?t(" ",e[1].length+1+e[4].length):n(c,e[1].length)+e[2]+"/"+e[3]+a(f,e[4].length))}function h(e,r,a){return a+(r===0?"":""+r)+t(" ",e[1].length+2+e[4].length)}var d=/^#*0*\.([0#]+)/;var p=/\).*[0#]/;var m=/\(###\) ###\\?-####/;function v(e){var r="",t;for(var a=0;a!=e.length;++a)switch(t=e.charCodeAt(a)){case 35:break;case 63:r+=" ";break;case 48:r+="0";break;default:r+=String.fromCharCode(t);}return r}function g(e,r){var t=Math.pow(10,r);return ""+Math.round(e*t)/t}function w(e,r){var t=e-Math.floor(e),a=Math.pow(10,r);if(r<(""+Math.round(t*a)).length)return 0;return Math.round(t*a)}function k(e,r){if(r<(""+Math.round((e-Math.floor(e))*Math.pow(10,r))).length){return 1}return 0}function y(e){if(e<2147483647&&e>-2147483648)return ""+(e>=0?e|0:e-1|0);return ""+Math.floor(e)}function x(e,h,S){if(e.charCodeAt(0)===40&&!h.match(p)){var _=h.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");if(S>=0)return x("n",_,S);return "("+x("n",_,-S)+")"}if(h.charCodeAt(h.length-1)===44)return l(e,h,S);if(h.indexOf("%")!==-1)return s(e,h,S);if(h.indexOf("E")!==-1)return o(h,S);if(h.charCodeAt(0)===36)return "$"+x(e,h.substr(h.charAt(1)==" "?2:1),S);var C;var A,E,F,D=Math.abs(S),M=S<0?"-":"";if(h.match(/^00+$/))return M+c(D,h.length);if(h.match(/^[#?]+$/)){C=c(S,0);if(C==="0")C="";return C.length>h.length?C:v(h.substr(0,h.length-C.length))+C}if(A=h.match(f))return u(A,D,M);if(h.match(/^#+0+$/))return M+c(D,h.length-h.indexOf("0"));if(A=h.match(d)){C=g(S,A[1].length).replace(/^([^\.]+)$/,"$1."+v(A[1])).replace(/\.$/,"."+v(A[1])).replace(/\.(\d*)$/,function(e,r){return "."+r+t("0",v(A[1]).length-r.length)});return h.indexOf("0.")!==-1?C:C.replace(/^0\./,".")}h=h.replace(/^#+([0.])/,"$1");if(A=h.match(/^(0*)\.(#*)$/)){return M+g(D,A[2].length).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,A[1].length?"0.":".")}if(A=h.match(/^#{1,3},##0(\.?)$/))return M+T(c(D,0));if(A=h.match(/^#,##0\.([#0]*0)$/)){return S<0?"-"+x(e,h,-S):T(""+(Math.floor(S)+k(S,A[1].length)))+"."+a(w(S,A[1].length),A[1].length)}if(A=h.match(/^#,#*,#0/))return x(e,h.replace(/^#,#*,/,""),S);if(A=h.match(/^([0#]+)(\\?-([0#]+))+$/)){C=r(x(e,h.replace(/[\\-]/g,""),S));E=0;return r(r(h.replace(/\\/g,"")).replace(/[0#]/g,function(e){return E<C.length?C.charAt(E++):e==="0"?"0":""}))}if(h.match(m)){C=x(e,"##########",S);return "("+C.substr(0,3)+") "+C.substr(3,3)+"-"+C.substr(6)}var N="";if(A=h.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)){E=Math.min(A[4].length,7);F=b(D,Math.pow(10,E)-1,false);C=""+M;N=O("n",A[1],F[1]);if(N.charAt(N.length-1)==" ")N=N.substr(0,N.length-1)+"0";C+=N+A[2]+"/"+A[3];N=i(F[2],E);if(N.length<A[4].length)N=v(A[4].substr(A[4].length-N.length))+N;C+=N;return C}if(A=h.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)){E=Math.min(Math.max(A[1].length,A[4].length),7);F=b(D,Math.pow(10,E)-1,true);return M+(F[0]||(F[1]?"":"0"))+" "+(F[1]?n(F[1],E)+A[2]+"/"+A[3]+i(F[2],E):t(" ",2*E+1+A[2].length+A[3].length))}if(A=h.match(/^[#0?]+$/)){C=c(S,0);if(h.length<=C.length)return C;return v(h.substr(0,h.length-C.length))+C}if(A=h.match(/^([#0?]+)\.([#0]+)$/)){C=""+S.toFixed(Math.min(A[2].length,10)).replace(/([^0])0+$/,"$1");E=C.indexOf(".");var R=h.indexOf(".")-E,P=h.length-C.length-R;return v(h.substr(0,R)+C+h.substr(h.length-P))}if(A=h.match(/^00,000\.([#0]*0)$/)){E=w(S,A[1].length);return S<0?"-"+x(e,h,-S):T(y(S)).replace(/^\d,\d{3}$/,"0$&").replace(/^\d*$/,function(e){return "00,"+(e.length<3?a(0,3-e.length):"")+e})+"."+a(E,A[1].length)}switch(h){case"###,##0.00":return x(e,"#,##0.00",S);case"###,###":case"##,###":case"#,###":var I=T(c(D,0));return I!=="0"?M+I:"";case"###,###.00":return x(e,"###,##0.00",S).replace(/^0\./,".");case"#,###.00":return x(e,"#,##0.00",S).replace(/^0\./,".");}throw new Error("unsupported format |"+h+"|")}function S(e,r,t){var a=r.length-1;while(r.charCodeAt(a-1)===44)--a;return O(e,r.substr(0,a),t/Math.pow(10,3*(r.length-a)))}function _(r,a,n){var i=a.replace(e,""),s=a.length-i.length;return O(r,i,n*Math.pow(10,2*s))+t("%",s)}function C(e,r){var t;var a=e.indexOf("E")-e.indexOf(".")-1;if(e.match(/^#+0.0E\+0$/)){if(r==0)return "0.0E+0";else if(r<0)return "-"+C(e,-r);var n=e.indexOf(".");if(n===-1)n=e.indexOf("E");var i=Math.floor(Math.log(r)*Math.LOG10E)%n;if(i<0)i+=n;t=(r/Math.pow(10,i)).toPrecision(a+1+(n+i)%n);if(!t.match(/[Ee]/)){var s=Math.floor(Math.log(r)*Math.LOG10E);if(t.indexOf(".")===-1)t=t.charAt(0)+"."+t.substr(1)+"E+"+(s-t.length+i);else t+="E+"+(s-i);t=t.replace(/\+-/,"-");}t=t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function(e,r,t,a){return r+t+a.substr(0,(n+i)%n)+"."+a.substr(i)+"E"});}else t=r.toExponential(a);if(e.match(/E\+00$/)&&t.match(/e[+-]\d$/))t=t.substr(0,t.length-1)+"0"+t.charAt(t.length-1);if(e.match(/E\-/)&&t.match(/e\+/))t=t.replace(/e\+/,"e");return t.replace("e","E")}function A(e,s,l){if(e.charCodeAt(0)===40&&!s.match(p)){var o=s.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");if(l>=0)return A("n",o,l);return "("+A("n",o,-l)+")"}if(s.charCodeAt(s.length-1)===44)return S(e,s,l);if(s.indexOf("%")!==-1)return _(e,s,l);if(s.indexOf("E")!==-1)return C(s,l);if(s.charCodeAt(0)===36)return "$"+A(e,s.substr(s.charAt(1)==" "?2:1),l);var c;var u,g,w,k=Math.abs(l),y=l<0?"-":"";if(s.match(/^00+$/))return y+a(k,s.length);if(s.match(/^[#?]+$/)){c=""+l;if(l===0)c="";return c.length>s.length?c:v(s.substr(0,s.length-c.length))+c}if(u=s.match(f))return h(u,k,y);if(s.match(/^#+0+$/))return y+a(k,s.length-s.indexOf("0"));if(u=s.match(d)){c=(""+l).replace(/^([^\.]+)$/,"$1."+v(u[1])).replace(/\.$/,"."+v(u[1]));c=c.replace(/\.(\d*)$/,function(e,r){return "."+r+t("0",v(u[1]).length-r.length)});return s.indexOf("0.")!==-1?c:c.replace(/^0\./,".")}s=s.replace(/^#+([0.])/,"$1");if(u=s.match(/^(0*)\.(#*)$/)){return y+(""+k).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,u[1].length?"0.":".")}if(u=s.match(/^#{1,3},##0(\.?)$/))return y+T(""+k);if(u=s.match(/^#,##0\.([#0]*0)$/)){return l<0?"-"+A(e,s,-l):T(""+l)+"."+t("0",u[1].length)}if(u=s.match(/^#,#*,#0/))return A(e,s.replace(/^#,#*,/,""),l);if(u=s.match(/^([0#]+)(\\?-([0#]+))+$/)){c=r(A(e,s.replace(/[\\-]/g,""),l));g=0;return r(r(s.replace(/\\/g,"")).replace(/[0#]/g,function(e){return g<c.length?c.charAt(g++):e==="0"?"0":""}))}if(s.match(m)){c=A(e,"##########",l);return "("+c.substr(0,3)+") "+c.substr(3,3)+"-"+c.substr(6)}var x="";if(u=s.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)){g=Math.min(u[4].length,7);w=b(k,Math.pow(10,g)-1,false);c=""+y;x=O("n",u[1],w[1]);if(x.charAt(x.length-1)==" ")x=x.substr(0,x.length-1)+"0";c+=x+u[2]+"/"+u[3];x=i(w[2],g);if(x.length<u[4].length)x=v(u[4].substr(u[4].length-x.length))+x;c+=x;return c}if(u=s.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)){g=Math.min(Math.max(u[1].length,u[4].length),7);w=b(k,Math.pow(10,g)-1,true);return y+(w[0]||(w[1]?"":"0"))+" "+(w[1]?n(w[1],g)+u[2]+"/"+u[3]+i(w[2],g):t(" ",2*g+1+u[2].length+u[3].length))}if(u=s.match(/^[#0?]+$/)){c=""+l;if(s.length<=c.length)return c;return v(s.substr(0,s.length-c.length))+c}if(u=s.match(/^([#0]+)\.([#0]+)$/)){c=""+l.toFixed(Math.min(u[2].length,10)).replace(/([^0])0+$/,"$1");g=c.indexOf(".");var E=s.indexOf(".")-g,F=s.length-c.length-E;return v(s.substr(0,E)+c+s.substr(s.length-F))}if(u=s.match(/^00,000\.([#0]*0)$/)){return l<0?"-"+A(e,s,-l):T(""+l).replace(/^\d,\d{3}$/,"0$&").replace(/^\d*$/,function(e){return "00,"+(e.length<3?a(0,3-e.length):"")+e})+"."+a(0,u[1].length)}switch(s){case"###,###":case"##,###":case"#,###":var D=T(""+k);return D!=="0"?y+D:"";default:if(s.match(/\.[0#?]*$/))return A(e,s.slice(0,s.lastIndexOf(".")),l)+v(s.slice(s.lastIndexOf(".")));}throw new Error("unsupported format |"+s+"|")}return function E(e,r,t){return (t|0)===t?A(e,r,t):x(e,r,t)}}();function D(e){var r=[];var t=false;for(var a=0,n=0;a<e.length;++a)switch(e.charCodeAt(a)){case 34:t=!t;break;case 95:case 42:case 92:++a;break;case 59:r[r.length]=e.substr(n,a-n);n=a+1;}r[r.length]=e.substr(n);if(t===true)throw new Error("Format |"+e+"| unterminated string ");return r}e._split=D;var M=/\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;function N(e){var r=0,t="",a="";while(r<e.length){switch(t=e.charAt(r)){case"G":if(f(e,r))r+=6;r++;break;case'"':for(;e.charCodeAt(++r)!==34&&r<e.length;){}++r;break;case"\\":r+=2;break;case"_":r+=2;break;case"@":++r;break;case"B":case"b":if(e.charAt(r+1)==="1"||e.charAt(r+1)==="2")return true;case"M":case"D":case"Y":case"H":case"S":case"E":case"m":case"d":case"y":case"h":case"s":case"e":case"g":return true;case"A":case"a":case"上":if(e.substr(r,3).toUpperCase()==="A/P")return true;if(e.substr(r,5).toUpperCase()==="AM/PM")return true;if(e.substr(r,5).toUpperCase()==="上午/下午")return true;++r;break;case"[":a=t;while(e.charAt(r++)!=="]"&&r<e.length)a+=e.charAt(r);if(a.match(M))return true;break;case".":case"0":case"#":while(r<e.length&&("0#?.,E+-%".indexOf(t=e.charAt(++r))>-1||t=="\\"&&e.charAt(r+1)=="-"&&"0#".indexOf(e.charAt(r+2))>-1)){}break;case"?":while(e.charAt(++r)===t){}break;case"*":++r;if(e.charAt(r)==" "||e.charAt(r)=="*")++r;break;case"(":case")":++r;break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":while(r<e.length&&"0123456789".indexOf(e.charAt(++r))>-1){}break;case" ":++r;break;default:++r;break;}}return false}e.is_date=N;function R(e,r,t,a){var n=[],i="",s=0,l="",o="t",c,u,h;var d="H";while(s<e.length){switch(l=e.charAt(s)){case"G":if(!f(e,s))throw new Error("unrecognized character "+l+" in "+e);n[n.length]={t:"G",v:"General"};s+=7;break;case'"':for(i="";(h=e.charCodeAt(++s))!==34&&s<e.length;)i+=String.fromCharCode(h);n[n.length]={t:"t",v:i};++s;break;case"\\":var p=e.charAt(++s),m=p==="("||p===")"?p:"t";n[n.length]={t:m,v:p};++s;break;case"_":n[n.length]={t:"t",v:" "};s+=2;break;case"@":n[n.length]={t:"T",v:r};++s;break;case"B":case"b":if(e.charAt(s+1)==="1"||e.charAt(s+1)==="2"){if(c==null){c=w(r,t,e.charAt(s+1)==="2");if(c==null)return ""}n[n.length]={t:"X",v:e.substr(s,2)};o=l;s+=2;break}case"M":case"D":case"Y":case"H":case"S":case"E":l=l.toLowerCase();case"m":case"d":case"y":case"h":case"s":case"e":case"g":if(r<0)return "";if(c==null){c=w(r,t);if(c==null)return ""}i=l;while(++s<e.length&&e.charAt(s).toLowerCase()===l)i+=l;if(l==="m"&&o.toLowerCase()==="h")l="M";if(l==="h")l=d;n[n.length]={t:l,v:i};o=l;break;case"A":case"a":case"上":var v={t:l,v:l};if(c==null)c=w(r,t);if(e.substr(s,3).toUpperCase()==="A/P"){if(c!=null)v.v=c.H>=12?"P":"A";v.t="T";d="h";s+=3;}else if(e.substr(s,5).toUpperCase()==="AM/PM"){if(c!=null)v.v=c.H>=12?"PM":"AM";v.t="T";s+=5;d="h";}else if(e.substr(s,5).toUpperCase()==="上午/下午"){if(c!=null)v.v=c.H>=12?"下午":"上午";v.t="T";s+=5;d="h";}else {v.t="t";++s;}if(c==null&&v.t==="T")return "";n[n.length]=v;o=l;break;case"[":i=l;while(e.charAt(s++)!=="]"&&s<e.length)i+=e.charAt(s);if(i.slice(-1)!=="]")throw 'unterminated "[" block: |'+i+"|";if(i.match(M)){if(c==null){c=w(r,t);if(c==null)return ""}n[n.length]={t:"Z",v:i.toLowerCase()};o=i.charAt(1);}else if(i.indexOf("$")>-1){i=(i.match(/\$([^-\[\]]*)/)||[])[1]||"$";if(!N(e))n[n.length]={t:"t",v:i};}break;case".":if(c!=null){i=l;while(++s<e.length&&(l=e.charAt(s))==="0")i+=l;n[n.length]={t:"s",v:i};break}case"0":case"#":i=l;while(++s<e.length&&"0#?.,E+-%".indexOf(l=e.charAt(s))>-1)i+=l;n[n.length]={t:"n",v:i};break;case"?":i=l;while(e.charAt(++s)===l)i+=l;n[n.length]={t:l,v:i};o=l;break;case"*":++s;if(e.charAt(s)==" "||e.charAt(s)=="*")++s;break;case"(":case")":n[n.length]={t:a===1?"t":l,v:l};++s;break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":i=l;while(s<e.length&&"0123456789".indexOf(e.charAt(++s))>-1)i+=e.charAt(s);n[n.length]={t:"D",v:i};break;case" ":n[n.length]={t:l,v:l};++s;break;case"$":n[n.length]={t:"t",v:"$"};++s;break;default:if(",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(l)===-1)throw new Error("unrecognized character "+l+" in "+e);n[n.length]={t:"t",v:l};++s;break;}}var g=0,b=0,k;for(s=n.length-1,o="t";s>=0;--s){switch(n[s].t){case"h":case"H":n[s].t=d;o="h";if(g<1)g=1;break;case"s":if(k=n[s].v.match(/\.0+$/))b=Math.max(b,k[0].length-1);if(g<3)g=3;case"d":case"y":case"M":case"e":o=n[s].t;break;case"m":if(o==="s"){n[s].t="M";if(g<2)g=2;}break;case"X":break;case"Z":if(g<1&&n[s].v.match(/[Hh]/))g=1;if(g<2&&n[s].v.match(/[Mm]/))g=2;if(g<3&&n[s].v.match(/[Ss]/))g=3;}}switch(g){case 0:break;case 1:if(c.u>=.5){c.u=0;++c.S;}if(c.S>=60){c.S=0;++c.M;}if(c.M>=60){c.M=0;++c.H;}break;case 2:if(c.u>=.5){c.u=0;++c.S;}if(c.S>=60){c.S=0;++c.M;}break;}var y="",x;for(s=0;s<n.length;++s){switch(n[s].t){case"t":case"T":case" ":case"D":break;case"X":n[s].v="";n[s].t=";";break;case"d":case"m":case"y":case"h":case"H":case"M":case"s":case"e":case"b":case"Z":n[s].v=F(n[s].t.charCodeAt(0),n[s].v,c,b);n[s].t="t";break;case"n":case"?":x=s+1;while(n[x]!=null&&((l=n[x].t)==="?"||l==="D"||(l===" "||l==="t")&&n[x+1]!=null&&(n[x+1].t==="?"||n[x+1].t==="t"&&n[x+1].v==="/")||n[s].t==="("&&(l===" "||l==="n"||l===")")||l==="t"&&(n[x].v==="/"||n[x].v===" "&&n[x+1]!=null&&n[x+1].t=="?"))){n[s].v+=n[x].v;n[x]={v:"",t:";"};++x;}y+=n[s].v;s=x-1;break;case"G":n[s].t="t";n[s].v=A(r,t);break;}}var S="",_,C;if(y.length>0){if(y.charCodeAt(0)==40){_=r<0&&y.charCodeAt(0)===45?-r:r;C=O("n",y,_);}else {_=r<0&&a>1?-r:r;C=O("n",y,_);if(_<0&&n[0]&&n[0].t=="t"){C=C.substr(1);n[0].v="-"+n[0].v;}}x=C.length-1;var E=n.length;for(s=0;s<n.length;++s)if(n[s]!=null&&n[s].t!="t"&&n[s].v.indexOf(".")>-1){E=s;break}var T=n.length;if(E===n.length&&C.indexOf("E")===-1){for(s=n.length-1;s>=0;--s){if(n[s]==null||"n?".indexOf(n[s].t)===-1)continue;if(x>=n[s].v.length-1){x-=n[s].v.length;n[s].v=C.substr(x+1,n[s].v.length);}else if(x<0)n[s].v="";else {n[s].v=C.substr(0,x+1);x=-1;}n[s].t="t";T=s;}if(x>=0&&T<n.length)n[T].v=C.substr(0,x+1)+n[T].v;}else if(E!==n.length&&C.indexOf("E")===-1){x=C.indexOf(".")-1;for(s=E;s>=0;--s){if(n[s]==null||"n?".indexOf(n[s].t)===-1)continue;u=n[s].v.indexOf(".")>-1&&s===E?n[s].v.indexOf(".")-1:n[s].v.length-1;S=n[s].v.substr(u+1);for(;u>=0;--u){if(x>=0&&(n[s].v.charAt(u)==="0"||n[s].v.charAt(u)==="#"))S=C.charAt(x--)+S;}n[s].v=S;n[s].t="t";T=s;}if(x>=0&&T<n.length)n[T].v=C.substr(0,x+1)+n[T].v;x=C.indexOf(".")+1;for(s=E;s<n.length;++s){if(n[s]==null||"n?(".indexOf(n[s].t)===-1&&s!==E)continue;u=n[s].v.indexOf(".")>-1&&s===E?n[s].v.indexOf(".")+1:0;S=n[s].v.substr(0,u);for(;u<n[s].v.length;++u){if(x<C.length)S+=C.charAt(x++);}n[s].v=S;n[s].t="t";T=s;}}}for(s=0;s<n.length;++s)if(n[s]!=null&&"n?".indexOf(n[s].t)>-1){_=a>1&&r<0&&s>0&&n[s-1].v==="-"?-r:r;n[s].v=O(n[s].t,n[s].v,_);n[s].t="t";}var D="";for(s=0;s!==n.length;++s)if(n[s]!=null)D+=n[s].v;return D}e._eval=R;var P=/\[[=<>]/;var I=/\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;function L(e,r){if(r==null)return false;var t=parseFloat(r[2]);switch(r[1]){case"=":if(e==t)return true;break;case">":if(e>t)return true;break;case"<":if(e<t)return true;break;case"<>":if(e!=t)return true;break;case">=":if(e>=t)return true;break;case"<=":if(e<=t)return true;break;}return false}function B(e,r){var t=D(e);var a=t.length,n=t[a-1].indexOf("@");if(a<4&&n>-1)--a;if(t.length>4)throw new Error("cannot find right format for |"+t.join("|")+"|");if(typeof r!=="number")return [4,t.length===4||n>-1?t[t.length-1]:"@"];switch(t.length){case 1:t=n>-1?["General","General","General",t[0]]:[t[0],t[0],t[0],"@"];break;case 2:t=n>-1?[t[0],t[0],t[0],t[1]]:[t[0],t[1],t[0],"@"];break;case 3:t=n>-1?[t[0],t[1],t[0],t[2]]:[t[0],t[1],t[2],"@"];break;}var i=r>0?t[0]:r<0?t[1]:t[2];if(t[0].indexOf("[")===-1&&t[1].indexOf("[")===-1)return [a,i];if(t[0].match(P)!=null||t[1].match(P)!=null){var s=t[0].match(I);var l=t[1].match(I);return L(r,s)?[a,t[0]]:L(r,l)?[a,t[1]]:[a,t[s!=null&&l!=null?2:1]]}return [a,i]}function z(e,r,t){if(t==null)t={};var a="";switch(typeof e){case"string":if(e=="m/d/yy"&&t.dateNF)a=t.dateNF;else a=e;break;case"number":if(e==14&&t.dateNF)a=t.dateNF;else a=(t.table!=null?t.table:p)[e];if(a==null)a=t.table&&t.table[m[e]]||p[m[e]];if(a==null)a=g[e]||"General";break;}if(f(a,0))return A(r,t);if(r instanceof Date)r=S(r,t.date1904);var n=B(a,r);if(f(n[1]))return A(r,t);if(r===true)r="TRUE";else if(r===false)r="FALSE";else if(r===""||r==null)return "";return R(n[1],r,t,n[0])}function W(e,r){if(typeof r!="number"){r=+r||-1;for(var t=0;t<392;++t){if(p[t]==undefined){if(r<0)r=t;continue}if(p[t]==e){r=t;break}}if(r<0)r=391;}p[r]=e;return r}e.load=W;e._table=p;e.get_table=function j(){return p};e.load_table=function H(e){for(var r=0;r!=392;++r)if(e[r]!==undefined)W(e[r],r);};e.init_table=d;e.format=z;};R(N);({"General Number":"General","General Date":N._table[22],"Long Date":"dddd, mmmm dd, yyyy","Medium Date":N._table[15],"Short Date":N._table[14],"Long Time":N._table[19],"Medium Time":N._table[18],"Short Time":N._table[20],Currency:'"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',Fixed:N._table[2],Standard:N._table[4],Percent:N._table[10],Scientific:N._table[11],"Yes/No":'"Yes";"Yes";"No";@',"True/False":'"True";"True";"False";@',"On/Off":'"Yes";"Yes";"No";@'});var I={5:'"$"#,##0_);\\("$"#,##0\\)',6:'"$"#,##0_);[Red]\\("$"#,##0\\)',7:'"$"#,##0.00_);\\("$"#,##0.00\\)',8:'"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',23:"General",24:"General",25:"General",26:"General",27:"m/d/yy",28:"m/d/yy",29:"m/d/yy",30:"m/d/yy",31:"m/d/yy",32:"h:mm:ss",33:"h:mm:ss",34:"h:mm:ss",35:"h:mm:ss",36:"m/d/yy",41:'_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',42:'_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',43:'_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',44:'_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',50:"m/d/yy",51:"m/d/yy",52:"m/d/yy",53:"m/d/yy",54:"m/d/yy",55:"m/d/yy",56:"m/d/yy",57:"m/d/yy",58:"m/d/yy",59:"0",60:"0.00",61:"#,##0",62:"#,##0.00",63:'"$"#,##0_);\\("$"#,##0\\)',64:'"$"#,##0_);[Red]\\("$"#,##0\\)',65:'"$"#,##0.00_);\\("$"#,##0.00\\)',66:'"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',67:"0%",68:"0.00%",69:"# ?/?",70:"# ??/??",71:"m/d/yy",72:"m/d/yy",73:"d-mmm-yy",74:"d-mmm",75:"mmm-yy",76:"h:mm",77:"h:mm:ss",78:"m/d/yy h:mm",79:"mm:ss",80:"[h]:mm:ss",81:"mmss.0"};var L=/[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;function B(e){var r=typeof e=="number"?N._table[e]:e;r=r.replace(L,"(\\d+)");return new RegExp("^"+r+"$")}function z(e,r,t){var a=-1,n=-1,i=-1,s=-1,l=-1,o=-1;(r.match(L)||[]).forEach(function(e,r){var c=parseInt(t[r+1],10);switch(e.toLowerCase().charAt(0)){case"y":a=c;break;case"d":i=c;break;case"h":s=c;break;case"s":o=c;break;case"m":if(s>=0)l=c;else n=c;break;}});if(o>=0&&l==-1&&n>=0){l=n;n=-1;}var c=(""+(a>=0?a:(new Date).getFullYear())).slice(-4)+"-"+("00"+(n>=1?n:1)).slice(-2)+"-"+("00"+(i>=1?i:1)).slice(-2);if(c.length==7)c="0"+c;if(c.length==8)c="20"+c;var f=("00"+(s>=0?s:0)).slice(-2)+":"+("00"+(l>=0?l:0)).slice(-2)+":"+("00"+(o>=0?o:0)).slice(-2);if(s==-1&&l==-1&&o==-1)return c;if(a==-1&&n==-1&&i==-1)return f;return c+"T"+f}var W=true;var U;(function(e){e(U={});})(function(e){e.version="1.2.0";function r(){var e=0,r=new Array(256);for(var t=0;t!=256;++t){e=t;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;r[t]=e;}return typeof Int32Array!=="undefined"?new Int32Array(r):r}var t=r();function a(e,r){var a=r^-1,n=e.length-1;for(var i=0;i<n;){a=a>>>8^t[(a^e.charCodeAt(i++))&255];a=a>>>8^t[(a^e.charCodeAt(i++))&255];}if(i===n)a=a>>>8^t[(a^e.charCodeAt(i))&255];return a^-1}function n(e,r){if(e.length>1e4)return i(e,r);var a=r^-1,n=e.length-3;for(var s=0;s<n;){a=a>>>8^t[(a^e[s++])&255];a=a>>>8^t[(a^e[s++])&255];a=a>>>8^t[(a^e[s++])&255];a=a>>>8^t[(a^e[s++])&255];}while(s<n+3)a=a>>>8^t[(a^e[s++])&255];return a^-1}function i(e,r){var a=r^-1,n=e.length-7;for(var i=0;i<n;){a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];}while(i<n+7)a=a>>>8^t[(a^e[i++])&255];return a^-1}function s(e,r){var a=r^-1;for(var n=0,i=e.length,s,l;n<i;){s=e.charCodeAt(n++);if(s<128){a=a>>>8^t[(a^s)&255];}else if(s<2048){a=a>>>8^t[(a^(192|s>>6&31))&255];a=a>>>8^t[(a^(128|s&63))&255];}else if(s>=55296&&s<57344){s=(s&1023)+64;l=e.charCodeAt(n++)&1023;a=a>>>8^t[(a^(240|s>>8&7))&255];a=a>>>8^t[(a^(128|s>>2&63))&255];a=a>>>8^t[(a^(128|l>>6&15|(s&3)<<4))&255];a=a>>>8^t[(a^(128|l&63))&255];}else {a=a>>>8^t[(a^(224|s>>12&15))&255];a=a>>>8^t[(a^(128|s>>6&63))&255];a=a>>>8^t[(a^(128|s&63))&255];}}return a^-1}e.table=t;e.bstr=a;e.buf=n;e.str=s;});var j=function Kl(){var e={};e.version="1.1.4";function r(e,r){var t=e.split("/"),a=r.split("/");for(var n=0,i=0,s=Math.min(t.length,a.length);n<s;++n){if(i=t[n].length-a[n].length)return i;if(t[n]!=a[n])return t[n]<a[n]?-1:1}return t.length-a.length}function t(e){if(e.charAt(e.length-1)=="/")return e.slice(0,-1).indexOf("/")===-1?e:t(e.slice(0,-1));var r=e.lastIndexOf("/");
	return r===-1?e:e.slice(0,r+1)}function a(e){if(e.charAt(e.length-1)=="/")return a(e.slice(0,-1));var r=e.lastIndexOf("/");return r===-1?e:e.slice(r+1)}function n(e,r){if(typeof r==="string")r=new Date(r);var t=r.getHours();t=t<<6|r.getMinutes();t=t<<5|r.getSeconds()>>>1;e._W(2,t);var a=r.getFullYear()-1980;a=a<<4|r.getMonth()+1;a=a<<5|r.getDate();e._W(2,a);}function i(e){var r=e._R(2)&65535;var t=e._R(2)&65535;var a=new Date;var n=t&31;t>>>=5;var i=t&15;t>>>=4;a.setMilliseconds(0);a.setFullYear(t+1980);a.setMonth(i-1);a.setDate(n);var s=r&31;r>>>=5;var l=r&63;r>>>=6;a.setHours(r);a.setMinutes(l);a.setSeconds(s<<1);return a}function s(e){Kr(e,0);var r={};var t=0;while(e.l<=e.length-4){var a=e._R(2);var n=e._R(2),i=e.l+n;var s={};switch(a){case 21589:{t=e._R(1);if(t&1)s.mtime=e._R(4);if(n>5){if(t&2)s.atime=e._R(4);if(t&4)s.ctime=e._R(4);}if(s.mtime)s.mt=new Date(s.mtime*1e3);}break;}e.l=i;r[a]=s;}return r}var l;function o(){return l||(l=require$$0["default"])}function c(e,r){if(e[0]==80&&e[1]==75)return Ae(e,r);if(e.length<512)throw new Error("CFB file size "+e.length+" < 512");var t=3;var a=512;var n=0;var i=0;var s=0;var l=0;var o=0;var c=[];var p=e.slice(0,512);Kr(p,0);var v=f(p);t=v[0];switch(t){case 3:a=512;break;case 4:a=4096;break;case 0:if(v[1]==0)return Ae(e,r);default:throw new Error("Major Version: Expected 3 or 4 saw "+t);}if(a!==512){p=e.slice(0,a);Kr(p,28);}var b=e.slice(0,a);u(p,t);var w=p._R(4,"i");if(t===3&&w!==0)throw new Error("# Directory Sectors: Expected 0 saw "+w);p.l+=4;s=p._R(4,"i");p.l+=4;p.chk("00100000","Mini Stream Cutoff Size: ");l=p._R(4,"i");n=p._R(4,"i");o=p._R(4,"i");i=p._R(4,"i");for(var y=-1,x=0;x<109;++x){y=p._R(4,"i");if(y<0)break;c[x]=y;}var S=h(e,a);m(o,i,S,a,c);var _=g(S,s,c,a);_[s].name="!Directory";if(n>0&&l!==I)_[l].name="!MiniFAT";_[c[0]].name="!FAT";_.fat_addrs=c;_.ssz=a;var C={},A=[],E=[],F=[];k(s,_,S,A,n,C,E,l);d(E,F,A);A.shift();var T={FileIndex:E,FullPaths:F};if(r&&r.raw)T.raw={header:b,sectors:S};return T}function f(e){if(e[e.l]==80&&e[e.l+1]==75)return [0,0];e.chk(L,"Header Signature: ");e.l+=16;var r=e._R(2,"u");return [e._R(2,"u"),r]}function u(e,r){var t=9;e.l+=2;switch(t=e._R(2)){case 9:if(r!=3)throw new Error("Sector Shift: Expected 9 saw "+t);break;case 12:if(r!=4)throw new Error("Sector Shift: Expected 12 saw "+t);break;default:throw new Error("Sector Shift: Expected 9 or 12 saw "+t);}e.chk("0600","Mini Sector Shift: ");e.chk("000000000000","Reserved: ");}function h(e,r){var t=Math.ceil(e.length/r)-1;var a=[];for(var n=1;n<t;++n)a[n-1]=e.slice(n*r,(n+1)*r);a[t-1]=e.slice(t*r);return a}function d(e,r,t){var a=0,n=0,i=0,s=0,l=0,o=t.length;var c=[],f=[];for(;a<o;++a){c[a]=f[a]=a;r[a]=t[a];}for(;l<f.length;++l){a=f[l];n=e[a].L;i=e[a].R;s=e[a].C;if(c[a]===a){if(n!==-1&&c[n]!==n)c[a]=c[n];if(i!==-1&&c[i]!==i)c[a]=c[i];}if(s!==-1)c[s]=a;if(n!==-1&&a!=c[a]){c[n]=c[a];if(f.lastIndexOf(n)<l)f.push(n);}if(i!==-1&&a!=c[a]){c[i]=c[a];if(f.lastIndexOf(i)<l)f.push(i);}}for(a=1;a<o;++a)if(c[a]===a){if(i!==-1&&c[i]!==i)c[a]=c[i];else if(n!==-1&&c[n]!==n)c[a]=c[n];}for(a=1;a<o;++a){if(e[a].type===0)continue;l=a;if(l!=c[l])do{l=c[l];r[a]=r[l]+"/"+r[a];}while(l!==0&&-1!==c[l]&&l!=c[l]);c[a]=-1;}r[0]+="/";for(a=1;a<o;++a){if(e[a].type!==2)r[a]+="/";}}function p(e,r,t){var a=e.start,n=e.size;var i=[];var s=a;while(t&&n>0&&s>=0){i.push(r.slice(s*P,s*P+P));n-=P;s=$r(t,s*4);}if(i.length===0)return qr(0);return O(i).slice(0,e.size)}function m(e,r,t,a,n){var i=I;if(e===I){if(r!==0)throw new Error("DIFAT chain shorter than expected")}else if(e!==-1){var s=t[e],l=(a>>>2)-1;if(!s)return;for(var o=0;o<l;++o){if((i=$r(s,o*4))===I)break;n.push(i);}if(r>=1)m($r(s,a-4),r-1,t,a,n);}}function v(e,r,t,a,n){var i=[],s=[];if(!n)n=[];var l=a-1,o=0,c=0;for(o=r;o>=0;){n[o]=true;i[i.length]=o;s.push(e[o]);var f=t[Math.floor(o*4/a)];c=o*4&l;if(a<4+c)throw new Error("FAT boundary crossed: "+o+" 4 "+a);if(!e[f])break;o=$r(e[f],c);}return {nodes:i,data:vr([s])}}function g(e,r,t,a){var n=e.length,i=[];var s=[],l=[],o=[];var c=a-1,f=0,u=0,h=0,d=0;for(f=0;f<n;++f){l=[];h=f+r;if(h>=n)h-=n;if(s[h])continue;o=[];var p=[];for(u=h;u>=0;){p[u]=true;s[u]=true;l[l.length]=u;o.push(e[u]);var m=t[Math.floor(u*4/a)];d=u*4&c;if(a<4+d)throw new Error("FAT boundary crossed: "+u+" 4 "+a);if(!e[m])break;u=$r(e[m],d);if(p[u])break}i[h]={nodes:l,data:vr([o])};}return i}function k(e,r,t,a,n,i,s,l){var o=0,c=a.length?2:0;var f=r[e].data;var u=0,h=0,d;for(;u<f.length;u+=128){var m=f.slice(u,u+128);Kr(m,64);h=m._R(2);d=br(m,0,h-c);a.push(d);var g={name:d,type:m._R(1),color:m._R(1),L:m._R(4,"i"),R:m._R(4,"i"),C:m._R(4,"i"),clsid:m._R(16),state:m._R(4,"i"),start:0,size:0};var b=m._R(2)+m._R(2)+m._R(2)+m._R(2);if(b!==0)g.ct=y(m,m.l-8);var w=m._R(2)+m._R(2)+m._R(2)+m._R(2);if(w!==0)g.mt=y(m,m.l-8);g.start=m._R(4,"i");g.size=m._R(4,"i");if(g.size<0&&g.start<0){g.size=g.type=0;g.start=I;g.name="";}if(g.type===5){o=g.start;if(n>0&&o!==I)r[o].name="!StreamData";}else if(g.size>=4096){g.storage="fat";if(r[g.start]===undefined)r[g.start]=v(t,g.start,r.fat_addrs,r.ssz);r[g.start].name=g.name;g.content=r[g.start].data.slice(0,g.size);}else {g.storage="minifat";if(g.size<0)g.size=0;else if(o!==I&&g.start!==I&&r[o]){g.content=p(g,r[o].data,(r[l]||{}).data);}}if(g.content)Kr(g.content,0);i[d]=g;s.push(g);}}function y(e,r){return new Date((Wr(e,r+4)/1e7*Math.pow(2,32)+Wr(e,r)/1e7-11644473600)*1e3)}function x(e,r){o();return c(l.readFileSync(e),r)}function A(e,r){switch(r&&r.type||"base64"){case"file":return x(e,r);case"base64":return c(C(b.decode(e)),r);case"binary":return c(C(e),r);}return c(e,r)}function E(e,r){var t=r||{},a=t.root||"Root Entry";if(!e.FullPaths)e.FullPaths=[];if(!e.FileIndex)e.FileIndex=[];if(e.FullPaths.length!==e.FileIndex.length)throw new Error("inconsistent CFB structure");if(e.FullPaths.length===0){e.FullPaths[0]=a+"/";e.FileIndex[0]={name:a,type:5};}if(t.CLSID)e.FileIndex[0].clsid=t.CLSID;F(e);}function F(e){var r="Sh33tJ5";if(j.find(e,"/"+r))return;var t=qr(4);t[0]=55;t[1]=t[3]=50;t[2]=54;e.FileIndex.push({name:r,type:2,content:t,size:4,L:69,R:69,C:69});e.FullPaths.push(e.FullPaths[0]+r);T(e);}function T(e,n){E(e);var i=false,s=false;for(var l=e.FullPaths.length-1;l>=0;--l){var o=e.FileIndex[l];switch(o.type){case 0:if(s)i=true;else {e.FileIndex.pop();e.FullPaths.pop();}break;case 1:case 2:case 5:s=true;if(isNaN(o.R*o.L*o.C))i=true;if(o.R>-1&&o.L>-1&&o.R==o.L)i=true;break;default:i=true;break;}}if(!i&&!n)return;var c=new Date(1987,1,19),f=0;var u=[];for(l=0;l<e.FullPaths.length;++l){if(e.FileIndex[l].type===0)continue;u.push([e.FullPaths[l],e.FileIndex[l]]);}for(l=0;l<u.length;++l){var h=t(u[l][0]);s=false;for(f=0;f<u.length;++f)if(u[f][0]===h)s=true;if(!s)u.push([h,{name:a(h).replace("/",""),type:1,clsid:z,ct:c,mt:c,content:null}]);}u.sort(function(e,t){return r(e[0],t[0])});e.FullPaths=[];e.FileIndex=[];for(l=0;l<u.length;++l){e.FullPaths[l]=u[l][0];e.FileIndex[l]=u[l][1];}for(l=0;l<u.length;++l){var d=e.FileIndex[l];var p=e.FullPaths[l];d.name=a(p).replace("/","");d.L=d.R=d.C=-(d.color=1);d.size=d.content?d.content.length:0;d.start=0;d.clsid=d.clsid||z;if(l===0){d.C=u.length>1?1:-1;d.size=0;d.type=5;}else if(p.slice(-1)=="/"){for(f=l+1;f<u.length;++f)if(t(e.FullPaths[f])==p)break;d.C=f>=u.length?-1:f;for(f=l+1;f<u.length;++f)if(t(e.FullPaths[f])==t(p))break;d.R=f>=u.length?-1:f;d.type=1;}else {if(t(e.FullPaths[l+1]||"")==t(p))d.R=l+1;d.type=2;}}}function N(e,r){var t=r||{};T(e);if(t.fileType=="zip")return Fe(e,t);var a=function(e){var r=0,t=0;for(var a=0;a<e.FileIndex.length;++a){var n=e.FileIndex[a];if(!n.content)continue;var i=n.content.length;if(i>0){if(i<4096)r+=i+63>>6;else t+=i+511>>9;}}var s=e.FullPaths.length+3>>2;var l=r+7>>3;var o=r+127>>7;var c=l+t+s+o;var f=c+127>>7;var u=f<=109?0:Math.ceil((f-109)/127);while(c+f+u+127>>7>f)u=++f<=109?0:Math.ceil((f-109)/127);var h=[1,u,f,o,s,t,r,0];e.FileIndex[0].size=r<<6;h[7]=(e.FileIndex[0].start=h[0]+h[1]+h[2]+h[3]+h[4]+h[5])+(h[6]+7>>3);return h}(e);var n=qr(a[7]<<9);var i=0,s=0;{for(i=0;i<8;++i)n._W(1,B[i]);for(i=0;i<8;++i)n._W(2,0);n._W(2,62);n._W(2,3);n._W(2,65534);n._W(2,9);n._W(2,6);for(i=0;i<3;++i)n._W(2,0);n._W(4,0);n._W(4,a[2]);n._W(4,a[0]+a[1]+a[2]+a[3]-1);n._W(4,0);n._W(4,1<<12);n._W(4,a[3]?a[0]+a[1]+a[2]-1:I);n._W(4,a[3]);n._W(-4,a[1]?a[0]-1:I);n._W(4,a[1]);for(i=0;i<109;++i)n._W(-4,i<a[2]?a[1]+i:-1);}if(a[1]){for(s=0;s<a[1];++s){for(;i<236+s*127;++i)n._W(-4,i<a[2]?a[1]+i:-1);n._W(-4,s===a[1]-1?I:s+1);}}var l=function(e){for(s+=e;i<s-1;++i)n._W(-4,i+1);if(e){++i;n._W(-4,I);}};s=i=0;for(s+=a[1];i<s;++i)n._W(-4,W.DIFSECT);for(s+=a[2];i<s;++i)n._W(-4,W.FATSECT);l(a[3]);l(a[4]);var o=0,c=0;var f=e.FileIndex[0];for(;o<e.FileIndex.length;++o){f=e.FileIndex[o];if(!f.content)continue;c=f.content.length;if(c<4096)continue;f.start=s;l(c+511>>9);}l(a[6]+7>>3);while(n.l&511)n._W(-4,W.ENDOFCHAIN);s=i=0;for(o=0;o<e.FileIndex.length;++o){f=e.FileIndex[o];if(!f.content)continue;c=f.content.length;if(!c||c>=4096)continue;f.start=s;l(c+63>>6);}while(n.l&511)n._W(-4,W.ENDOFCHAIN);for(i=0;i<a[4]<<2;++i){var u=e.FullPaths[i];if(!u||u.length===0){for(o=0;o<17;++o)n._W(4,0);for(o=0;o<3;++o)n._W(4,-1);for(o=0;o<12;++o)n._W(4,0);continue}f=e.FileIndex[i];if(i===0)f.start=f.size?f.start-1:I;var h=i===0&&t.root||f.name;c=2*(h.length+1);n._W(64,h,"utf16le");n._W(2,c);n._W(1,f.type);n._W(1,f.color);n._W(-4,f.L);n._W(-4,f.R);n._W(-4,f.C);if(!f.clsid)for(o=0;o<4;++o)n._W(4,0);else n._W(16,f.clsid,"hex");n._W(4,f.state||0);n._W(4,0);n._W(4,0);n._W(4,0);n._W(4,0);n._W(4,f.start);n._W(4,f.size);n._W(4,0);}for(i=1;i<e.FileIndex.length;++i){f=e.FileIndex[i];if(f.size>=4096){n.l=f.start+1<<9;for(o=0;o<f.size;++o)n._W(1,f.content[o]);for(;o&511;++o)n._W(1,0);}}for(i=1;i<e.FileIndex.length;++i){f=e.FileIndex[i];if(f.size>0&&f.size<4096){for(o=0;o<f.size;++o)n._W(1,f.content[o]);for(;o&63;++o)n._W(1,0);}}while(n.l<n.length)n._W(1,0);return n}function R(e,r){var t=e.FullPaths.map(function(e){return e.toUpperCase()});var a=t.map(function(e){var r=e.split("/");return r[r.length-(e.slice(-1)=="/"?2:1)]});var n=false;if(r.charCodeAt(0)===47){n=true;r=t[0].slice(0,-1)+r;}else n=r.indexOf("/")!==-1;var i=r.toUpperCase();var s=n===true?t.indexOf(i):a.indexOf(i);if(s!==-1)return e.FileIndex[s];var l=!i.match(M);i=i.replace(D,"");if(l)i=i.replace(M,"!");for(s=0;s<t.length;++s){if((l?t[s].replace(M,"!"):t[s]).replace(D,"")==i)return e.FileIndex[s];if((l?a[s].replace(M,"!"):a[s]).replace(D,"")==i)return e.FileIndex[s]}return null}var P=64;var I=-2;var L="d0cf11e0a1b11ae1";var B=[208,207,17,224,161,177,26,225];var z="00000000000000000000000000000000";var W={MAXREGSECT:-6,DIFSECT:-4,FATSECT:-3,ENDOFCHAIN:I,FREESECT:-1,HEADER_SIGNATURE:L,HEADER_MINOR_VERSION:"3e00",MAXREGSID:-6,NOSTREAM:-1,HEADER_CLSID:z,EntryTypes:["unknown","storage","stream","lockbytes","property","root"]};function $(e,r,t){o();var a=N(e,t);l.writeFileSync(r,a);}function H(e){var r=new Array(e.length);for(var t=0;t<e.length;++t)r[t]=String.fromCharCode(e[t]);return r.join("")}function X(e,r){var t=N(e,r);switch(r&&r.type){case"file":o();l.writeFileSync(r.filename,t);return t;case"binary":return H(t);case"base64":return b.encode(H(t));}return t}var V;function G(e){try{var r=e.InflateRaw;var t=new r;t._processChunk(new Uint8Array([3,0]),t._finishFlushFlag);if(t.bytesRead)V=e;else throw new Error("zlib does not expose bytesRead")}catch(a){console.error("cannot use native zlib: "+(a.message||a));}}function Y(e,r){if(!V)return _e(e,r);var t=V.InflateRaw;var a=new t;var n=a._processChunk(e.slice(e.l),a._finishFlushFlag);e.l+=a.bytesRead;return n}function K(e){return V?V.deflateRawSync(e):he(e)}var J=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];var q=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];var Z=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];function Q(e){var r=(e<<1|e<<11)&139536|(e<<5|e<<15)&558144;return (r>>16|r>>8|r)&255}var ee=typeof Uint8Array!=="undefined";var re=ee?new Uint8Array(1<<8):[];for(var te=0;te<1<<8;++te)re[te]=Q(te);function ae(e,r){var t=re[e&255];if(r<=8)return t>>>8-r;t=t<<8|re[e>>8&255];if(r<=16)return t>>>16-r;t=t<<8|re[e>>16&255];return t>>>24-r}function ne(e,r){var t=r&7,a=r>>>3;return (e[a]|(t<=6?0:e[a+1]<<8))>>>t&3}function ie(e,r){var t=r&7,a=r>>>3;return (e[a]|(t<=5?0:e[a+1]<<8))>>>t&7}function se(e,r){var t=r&7,a=r>>>3;return (e[a]|(t<=4?0:e[a+1]<<8))>>>t&15}function le(e,r){var t=r&7,a=r>>>3;return (e[a]|(t<=3?0:e[a+1]<<8))>>>t&31}function oe(e,r){var t=r&7,a=r>>>3;return (e[a]|(t<=1?0:e[a+1]<<8))>>>t&127}function ce(e,r,t){var a=r&7,n=r>>>3,i=(1<<t)-1;var s=e[n]>>>a;if(t<8-a)return s&i;s|=e[n+1]<<8-a;if(t<16-a)return s&i;s|=e[n+2]<<16-a;if(t<24-a)return s&i;s|=e[n+3]<<24-a;return s&i}function fe(e,r){var t=e.length,a=2*t>r?2*t:r+5,n=0;if(t>=r)return e;if(w){var i=_(a);if(e.copy)e.copy(i);else for(;n<e.length;++n)i[n]=e[n];return i}else if(ee){var s=new Uint8Array(a);if(s.set)s.set(e);else for(;n<e.length;++n)s[n]=e[n];return s}e.length=a;return e}function ue(e){var r=new Array(e);for(var t=0;t<e;++t)r[t]=0;return r}var he=function(){var e=function(){return function e(r,t){var a=0;while(a<r.length){var n=Math.min(65535,r.length-a);var i=a+n==r.length;t._W(1,+i);t._W(2,n);t._W(2,~n&65535);while(n-- >0)t[t.l++]=r[a++];}return t.l}}();return function(r){var t=qr(50+Math.floor(r.length*1.1));var a=e(r,t);return t.slice(0,a)}}();function de(e,r,t){var a=1,n=0,i=0,s=0,l=0,o=e.length;var c=ee?new Uint16Array(32):ue(32);for(i=0;i<32;++i)c[i]=0;for(i=o;i<t;++i)e[i]=0;o=e.length;var f=ee?new Uint16Array(o):ue(o);for(i=0;i<o;++i){c[n=e[i]]++;if(a<n)a=n;f[i]=0;}c[0]=0;for(i=1;i<=a;++i)c[i+16]=l=l+c[i-1]<<1;for(i=0;i<o;++i){l=e[i];if(l!=0)f[i]=c[l+16]++;}var u=0;for(i=0;i<o;++i){u=e[i];if(u!=0){l=ae(f[i],a)>>a-u;for(s=(1<<a+4-u)-1;s>=0;--s)r[l|s<<u]=u&15|i<<4;}}return a}var pe=ee?new Uint16Array(512):ue(512);var me=ee?new Uint16Array(32):ue(32);if(!ee){for(var ve=0;ve<512;++ve)pe[ve]=0;for(ve=0;ve<32;++ve)me[ve]=0;}(function(){var e=[];var r=0;for(;r<32;r++)e.push(5);de(e,me,32);var t=[];r=0;for(;r<=143;r++)t.push(8);for(;r<=255;r++)t.push(9);for(;r<=279;r++)t.push(7);for(;r<=287;r++)t.push(8);de(t,pe,288);})();var ge=ee?new Uint16Array(32768):ue(32768);var be=ee?new Uint16Array(32768):ue(32768);var we=ee?new Uint16Array(128):ue(128);var ke=1,ye=1;function xe(e,r){var t=le(e,r)+257;r+=5;var a=le(e,r)+1;r+=5;var n=se(e,r)+4;r+=4;var i=0;var s=ee?new Uint8Array(19):ue(19);var l=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var o=1;var c=ee?new Uint8Array(8):ue(8);var f=ee?new Uint8Array(8):ue(8);var u=s.length;for(var h=0;h<n;++h){s[J[h]]=i=ie(e,r);if(o<i)o=i;c[i]++;r+=3;}var d=0;c[0]=0;for(h=1;h<=o;++h)f[h]=d=d+c[h-1]<<1;for(h=0;h<u;++h)if((d=s[h])!=0)l[h]=f[d]++;var p=0;for(h=0;h<u;++h){p=s[h];if(p!=0){d=re[l[h]]>>8-p;for(var m=(1<<7-p)-1;m>=0;--m)we[d|m<<p]=p&7|h<<3;}}var v=[];o=1;for(;v.length<t+a;){d=we[oe(e,r)];r+=d&7;switch(d>>>=3){case 16:i=3+ne(e,r);r+=2;d=v[v.length-1];while(i-- >0)v.push(d);break;case 17:i=3+ie(e,r);r+=3;while(i-- >0)v.push(0);break;case 18:i=11+oe(e,r);r+=7;while(i-- >0)v.push(0);break;default:v.push(d);if(o<d)o=d;break;}}var g=v.slice(0,t),b=v.slice(t);for(h=t;h<286;++h)g[h]=0;for(h=a;h<30;++h)b[h]=0;ke=de(g,ge,286);ye=de(b,be,30);return r}function Se(e,r){if(e[0]==3&&!(e[1]&3)){return [S(r),2]}var t=0;var a=0;var n=_(r?r:1<<18);var i=0;var s=n.length>>>0;var l=0,o=0;while((a&1)==0){a=ie(e,t);t+=3;if(a>>>1==0){if(t&7)t+=8-(t&7);var c=e[t>>>3]|e[(t>>>3)+1]<<8;t+=32;if(!r&&s<i+c){n=fe(n,i+c);s=n.length;}if(typeof e.copy==="function"){e.copy(n,i,t>>>3,(t>>>3)+c);i+=c;t+=8*c;}else while(c-- >0){n[i++]=e[t>>>3];t+=8;}continue}else if(a>>>1==1){l=9;o=5;}else {t=xe(e,t);l=ke;o=ye;}if(!r&&s<i+32767){n=fe(n,i+32767);s=n.length;}for(;;){var f=ce(e,t,l);var u=a>>>1==1?pe[f]:ge[f];t+=u&15;u>>>=4;if((u>>>8&255)===0)n[i++]=u;else if(u==256)break;else {u-=257;var h=u<8?0:u-4>>2;if(h>5)h=0;var d=i+q[u];if(h>0){d+=ce(e,t,h);t+=h;}f=ce(e,t,o);u=a>>>1==1?me[f]:be[f];t+=u&15;u>>>=4;var p=u<4?0:u-2>>1;var m=Z[u];if(p>0){m+=ce(e,t,p);t+=p;}if(!r&&s<d){n=fe(n,d);s=n.length;}while(i<d){n[i]=n[i-m];++i;}}}}return [r?n:n.slice(0,i),t+7>>>3]}function _e(e,r){var t=e.slice(e.l||0);var a=Se(t,r);e.l+=a[1];return a[0]}function Ce(e,r){if(e){if(typeof console!=="undefined")console.error(r);}else throw new Error(r)}function Ae(e,r){var t=e;Kr(t,0);var a=[],n=[];var i={FileIndex:a,FullPaths:n};E(i,{root:r.root});var l=t.length-4;while((t[l]!=80||t[l+1]!=75||t[l+2]!=5||t[l+3]!=6)&&l>=0)--l;t.l=l+4;t.l+=4;var o=t._R(2);t.l+=6;var c=t._R(4);t.l=c;for(l=0;l<o;++l){t.l+=20;var f=t._R(4);var u=t._R(4);var h=t._R(2);var d=t._R(2);var p=t._R(2);t.l+=8;var m=t._R(4);var v=s(t.slice(t.l+h,t.l+h+d));t.l+=h+d+p;var g=t.l;t.l=m+4;Ee(t,f,u,i,v);t.l=g;}return i}function Ee(e,r,t,a,n){e.l+=2;var l=e._R(2);var o=e._R(2);var c=i(e);if(l&8257)throw new Error("Unsupported ZIP encryption");var f=e._R(4);var u=e._R(4);var h=e._R(4);var d=e._R(2);var p=e._R(2);var m="";for(var v=0;v<d;++v)m+=String.fromCharCode(e[e.l++]);if(p){var g=s(e.slice(e.l,e.l+p));if((g[21589]||{}).mt)c=g[21589].mt;if(((n||{})[21589]||{}).mt)c=n[21589].mt;}e.l+=p;var b=e.slice(e.l,e.l+u);switch(o){case 8:b=Y(e,h);break;case 0:break;default:throw new Error("Unsupported ZIP Compression method "+o);}var w=false;if(l&8){f=e._R(4);if(f==134695760){f=e._R(4);w=true;}u=e._R(4);h=e._R(4);}if(u!=r)Ce(w,"Bad compressed size: "+r+" != "+u);if(h!=t)Ce(w,"Bad uncompressed size: "+t+" != "+h);var k=U.buf(b,0);if(f>>0!=k>>0)Ce(w,"Bad CRC32 checksum: "+f+" != "+k);Oe(a,m,b,{unsafe:true,mt:c});}function Fe(e,r){var t=r||{};var a=[],i=[];var s=qr(1);var l=t.compression?8:0,o=0;var f=0,u=0;var h=0,d=0;var p=e.FullPaths[0],m=p,v=e.FileIndex[0];var g=[];var b=0;for(f=1;f<e.FullPaths.length;++f){m=e.FullPaths[f].slice(p.length);v=e.FileIndex[f];if(!v.size||!v.content||m=="Sh33tJ5")continue;var w=h;var k=qr(m.length);for(u=0;u<m.length;++u)k._W(1,m.charCodeAt(u)&127);k=k.slice(0,k.l);g[d]=U.buf(v.content,0);var y=v.content;if(l==8)y=K(y);s=qr(30);s._W(4,67324752);s._W(2,20);s._W(2,o);s._W(2,l);if(v.mt)n(s,v.mt);else s._W(4,0);s._W(-4,g[d]);s._W(4,y.length);s._W(4,v.content.length);s._W(2,k.length);s._W(2,0);h+=s.length;a.push(s);h+=k.length;a.push(k);h+=y.length;a.push(y);s=qr(46);s._W(4,33639248);s._W(2,0);s._W(2,20);s._W(2,o);s._W(2,l);s._W(4,0);s._W(-4,g[d]);s._W(4,y.length);s._W(4,v.content.length);s._W(2,k.length);s._W(2,0);s._W(2,0);s._W(2,0);s._W(2,0);s._W(4,0);s._W(4,w);b+=s.l;i.push(s);b+=k.length;i.push(k);++d;}s=qr(22);s._W(4,101010256);s._W(2,0);s._W(2,0);s._W(2,d);s._W(2,d);s._W(4,b);s._W(4,h);s._W(2,0);return O([O(a),O(i),s])}function Te(e){var r={};E(r,e);return r}function Oe(e,r,t,n){var i=n&&n.unsafe;if(!i)E(e);var s=!i&&j.find(e,r);if(!s){var l=e.FullPaths[0];if(r.slice(0,l.length)==l)l=r;else {if(l.slice(-1)!="/")l+="/";l=(l+r).replace("//","/");}s={name:a(r),type:2};e.FileIndex.push(s);e.FullPaths.push(l);if(!i)j.utils.cfb_gc(e);}s.content=t;s.size=t?t.length:0;if(n){if(n.CLSID)s.clsid=n.CLSID;if(n.mt)s.mt=n.mt;if(n.ct)s.ct=n.ct;}return s}function De(e,r){E(e);var t=j.find(e,r);if(t)for(var a=0;a<e.FileIndex.length;++a)if(e.FileIndex[a]==t){e.FileIndex.splice(a,1);e.FullPaths.splice(a,1);return true}return false}function Me(e,r,t){E(e);var n=j.find(e,r);if(n)for(var i=0;i<e.FileIndex.length;++i)if(e.FileIndex[i]==n){e.FileIndex[i].name=a(t);e.FullPaths[i]=t;return true}return false}function Ne(e){T(e,true);}e.find=R;e.read=A;e.parse=c;e.write=X;e.writeFile=$;e.utils={cfb_new:Te,cfb_add:Oe,cfb_del:De,cfb_mov:Me,cfb_gc:Ne,ReadShift:jr,CheckField:Yr,prep_blob:Kr,bconcat:O,use_zlib:G,_deflateRaw:he,_inflateRaw:_e,consts:W};return e}();if(typeof commonjsRequire!=="undefined"&&'object'!=="undefined"&&typeof W==="undefined"){module.exports=j;}var H;if(typeof commonjsRequire!=="undefined")try{H=require$$0["default"];}catch(x){}function X(e){if(typeof e==="string")return A(e);if(Array.isArray(e))return F(e);return e}function V(e,r,t){if(typeof H!=="undefined"&&H.writeFileSync)return t?H.writeFileSync(e,r,t):H.writeFileSync(e,r);var a=t=="utf8"?Je(r):r;if(typeof IE_SaveFile!=="undefined")return IE_SaveFile(a,e);if(typeof Blob!=="undefined"){var n=new Blob([X(a)],{type:"application/octet-stream"});if(typeof navigator!=="undefined"&&navigator.msSaveBlob)return navigator.msSaveBlob(n,e);if(typeof saveAs!=="undefined")return saveAs(n,e);if(typeof URL!=="undefined"&&typeof document!=="undefined"&&document.createElement&&URL.createObjectURL){var i=URL.createObjectURL(n);if(typeof chrome==="object"&&typeof(chrome.downloads||{}).download=="function"){if(URL.revokeObjectURL&&typeof setTimeout!=="undefined")setTimeout(function(){URL.revokeObjectURL(i);},6e4);return chrome.downloads.download({url:i,filename:e,saveAs:true})}var s=document.createElement("a");if(s.download!=null){s.download=e;s.href=i;document.body.appendChild(s);s.click();document.body.removeChild(s);if(URL.revokeObjectURL&&typeof setTimeout!=="undefined")setTimeout(function(){URL.revokeObjectURL(i);},6e4);return i}}}if(typeof $!=="undefined"&&typeof File!=="undefined"&&typeof Folder!=="undefined")try{var l=File(e);l.open("w");l.encoding="binary";if(Array.isArray(r))r=E(r);l.write(r);l.close();return r}catch(o){if(!o.message||!o.message.match(/onstruct/))throw o}throw new Error("cannot save file "+e)}function G(e){if(typeof H!=="undefined")return H.readFileSync(e);if(typeof $!=="undefined"&&typeof File!=="undefined"&&typeof Folder!=="undefined")try{var r=File(e);r.open("r");r.encoding="binary";var t=r.read();r.close();return t}catch(a){if(!a.message||!a.message.match(/onstruct/))throw a}throw new Error("Cannot access file "+e)}function Y(e){var r=Object.keys(e),t=[];for(var a=0;a<r.length;++a)if(Object.prototype.hasOwnProperty.call(e,r[a]))t.push(r[a]);return t}function K(e,r){var t=[],a=Y(e);for(var n=0;n!==a.length;++n)if(t[e[a[n]][r]]==null)t[e[a[n]][r]]=a[n];return t}function J(e){var r=[],t=Y(e);for(var a=0;a!==t.length;++a)r[e[t[a]]]=t[a];return r}function q(e){var r=[],t=Y(e);for(var a=0;a!==t.length;++a)r[e[t[a]]]=parseInt(t[a],10);return r}function Z(e){var r=[],t=Y(e);for(var a=0;a!==t.length;++a){if(r[e[t[a]]]==null)r[e[t[a]]]=[];r[e[t[a]]].push(t[a]);}return r}var Q=new Date(1899,11,30,0,0,0);function ee(e,r){var t=e.getTime();if(r)t-=1462*24*60*60*1e3;var a=Q.getTime()+(e.getTimezoneOffset()-Q.getTimezoneOffset())*6e4;return (t-a)/(24*60*60*1e3)}var re=new Date;var te=Q.getTime()+(re.getTimezoneOffset()-Q.getTimezoneOffset())*6e4;var ae=re.getTimezoneOffset();function ne(e){var r=new Date;r.setTime(e*24*60*60*1e3+te);if(r.getTimezoneOffset()!==ae){r.setTime(r.getTime()+(r.getTimezoneOffset()-ae)*6e4);}return r}function ie(e){var r=0,t=0,a=false;var n=e.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);if(!n)throw new Error("|"+e+"| is not an ISO8601 Duration");for(var i=1;i!=n.length;++i){if(!n[i])continue;t=1;if(i>3)a=true;switch(n[i].slice(n[i].length-1)){case"Y":throw new Error("Unsupported ISO Duration Field: "+n[i].slice(n[i].length-1));case"D":t*=24;case"H":t*=60;case"M":if(!a)throw new Error("Unsupported ISO Duration Field: M");else t*=60;}r+=t*parseInt(n[i],10);}return r}var se=new Date("2017-02-19T19:06:09.000Z");if(isNaN(se.getFullYear()))se=new Date("2/19/17");var le=se.getFullYear()==2017;function oe(e,r){var t=new Date(e);if(le){if(r>0)t.setTime(t.getTime()+t.getTimezoneOffset()*60*1e3);else if(r<0)t.setTime(t.getTime()-t.getTimezoneOffset()*60*1e3);return t}if(e instanceof Date)return e;if(se.getFullYear()==1917&&!isNaN(t.getFullYear())){var a=t.getFullYear();if(e.indexOf(""+a)>-1)return t;t.setFullYear(t.getFullYear()+100);return t}var n=e.match(/\d+/g)||["2017","2","19","0","0","0"];var i=new Date(+n[0],+n[1]-1,+n[2],+n[3]||0,+n[4]||0,+n[5]||0);if(e.indexOf("Z")>-1)i=new Date(i.getTime()-i.getTimezoneOffset()*60*1e3);return i}function ce(e){var r="";for(var t=0;t!=e.length;++t)r+=String.fromCharCode(e[t]);return r}function fe(e){if(typeof JSON!="undefined"&&!Array.isArray(e))return JSON.parse(JSON.stringify(e));if(typeof e!="object"||e==null)return e;if(e instanceof Date)return new Date(e.getTime());var r={};for(var t in e)if(Object.prototype.hasOwnProperty.call(e,t))r[t]=fe(e[t]);return r}function he(e){var r=Number(e);if(isFinite(r))return r;if(!isNaN(r))return NaN;if(!/\d/.test(e))return r;var t=1;var a=e.replace(/([\d]),([\d])/g,"$1$2").replace(/[$]/g,"").replace(/[%]/g,function(){t*=100;return ""});if(!isNaN(r=Number(a)))return r/t;a=a.replace(/[(](.*)[)]/,function(e,r){t=-t;return r});if(!isNaN(r=Number(a)))return r/t;return r}function de(e){var r=new Date(e),t=new Date(NaN);var a=r.getYear(),n=r.getMonth(),i=r.getDate();if(isNaN(i))return t;if(a<0||a>8099)return t;if((n>0||i>1)&&a!=101)return r;if(e.toLowerCase().match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/))return r;if(e.match(/[^-0-9:,\/\\]/))return t;return r}var pe="abacaba".split(/(:?b)/i).length==5;function me(e,r,t){if(pe||typeof r=="string")return e.split(r);var a=e.split(r),n=[a[0]];for(var i=1;i<a.length;++i){n.push(t);n.push(a[i]);}return n}function ve(e){if(!e)return null;if(e.data)return d(e.data);if(e.asNodeBuffer&&w)return d(e.asNodeBuffer().toString("binary"));if(e.asBinary)return d(e.asBinary());if(e._data&&e._data.getContent)return d(ce(Array.prototype.slice.call(e._data.getContent(),0)));if(e.content&&e.type)return d(ce(e.content));return null}function ge(e){if(!e)return null;if(e.data)return f(e.data);if(e.asNodeBuffer&&w)return e.asNodeBuffer();if(e._data&&e._data.getContent){var r=e._data.getContent();if(typeof r=="string")return f(r);return Array.prototype.slice.call(r)}if(e.content&&e.type)return e.content;return null}function be(e){return e&&e.name.slice(-4)===".bin"?ge(e):ve(e)}function we(e,r){var t=e.FullPaths||Y(e.files);var a=r.toLowerCase().replace(/[\/]/g,"\\"),n=a.replace(/\\/g,"/");for(var i=0;i<t.length;++i){var s=t[i].replace(/^Root Entry[\/]/,"").toLowerCase();if(a==s||n==s)return e.files?e.files[t[i]]:e.FileIndex[i]}return null}function ke(e,r){var t=we(e,r);if(t==null)throw new Error("Cannot find file "+r+" in zip");return t}function ye(e,r,t){if(!t)return be(ke(e,r));if(!r)return null;try{return ye(e,r)}catch(a){return null}}function xe(e,r,t){if(!t)return ve(ke(e,r));if(!r)return null;try{return xe(e,r)}catch(a){return null}}function Se(e){var r=e.FullPaths||Y(e.files),t=[];for(var a=0;a<r.length;++a)if(r[a].slice(-1)!="/")t.push(r[a].replace(/^Root Entry[\/]/,""));return t.sort()}function _e(e,r,t){if(e.FullPaths)j.utils.cfb_add(e,r,typeof t=="string"?w?k(t):C(Je(t)):t);else e.file(r,t);}function Ae(){return j.utils.cfb_new()}function Ee(e,r){var t;switch(r.type){case"base64":t=j.read(e,{type:"base64"});break;case"binary":t=j.read(e,{type:"binary"});break;case"buffer":case"array":t=j.read(e,{type:"buffer"});break;default:throw new Error("Unrecognized type "+r.type);}return t}function Fe(e,r){if(e.charAt(0)=="/")return e.slice(1);var t=r.split("/");if(r.slice(-1)!="/")t.pop();var a=e.split("/");while(a.length!==0){var n=a.shift();if(n==="..")t.pop();else if(n!==".")t.push(n);}return t.join("/")}var Te='<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';var Oe=/([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;var De=/<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/gm;if(!Te.match(De))De=/<[^>]*>/g;var Me=/<\w*:/,Ne=/<(\/?)\w+:/;function Re(e,r,t){var a={};var n=0,i=0;for(;n!==e.length;++n)if((i=e.charCodeAt(n))===32||i===10||i===13)break;if(!r)a[0]=e.slice(0,n);if(n===e.length)return a;var s=e.match(Oe),l=0,o="",c=0,f="",u="",h=1;if(s)for(c=0;c!=s.length;++c){u=s[c];for(i=0;i!=u.length;++i)if(u.charCodeAt(i)===61)break;f=u.slice(0,i).trim();while(u.charCodeAt(i+1)==32)++i;h=(n=u.charCodeAt(i+1))==34||n==39?1:0;o=u.slice(i+1+h,u.length-h);for(l=0;l!=f.length;++l)if(f.charCodeAt(l)===58)break;if(l===f.length){if(f.indexOf("_")>0)f=f.slice(0,f.indexOf("_"));a[f]=o;if(!t)a[f.toLowerCase()]=o;}else {var d=(l===5&&f.slice(0,5)==="xmlns"?"xmlns":"")+f.slice(l+1);if(a[d]&&f.slice(l-3,l)=="ext")continue;a[d]=o;if(!t)a[d.toLowerCase()]=o;}}return a}function Pe(e){return e.replace(Ne,"<$1")}var Ie={"&quot;":'"',"&apos;":"'","&gt;":">","&lt;":"<","&amp;":"&"};var Le=J(Ie);var Be=function(){var e=/&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/gi,r=/_x([\da-fA-F]{4})_/gi;return function t(a){var n=a+"",i=n.indexOf("<![CDATA[");if(i==-1)return n.replace(e,function(e,r){return Ie[e]||String.fromCharCode(parseInt(r,e.indexOf("x")>-1?16:10))||e}).replace(r,function(e,r){return String.fromCharCode(parseInt(r,16))});var s=n.indexOf("]]>");return t(n.slice(0,i))+n.slice(i+9,s)+t(n.slice(s+3))}}();var ze=/[&<>'"]/g,We=/[\u0000-\u0008\u000b-\u001f]/g;function $e(e){var r=e+"";return r.replace(ze,function(e){return Le[e]}).replace(We,function(e){return "_x"+("000"+e.charCodeAt(0).toString(16)).slice(-4)+"_"})}var je=/[\u0000-\u001f]/g;function He(e){var r=e+"";return r.replace(ze,function(e){return Le[e]}).replace(/\n/g,"<br/>").replace(je,function(e){return "&#x"+("000"+e.charCodeAt(0).toString(16)).slice(-4)+";"})}function Ye(e){switch(e){case 1:case true:case"1":case"true":case"TRUE":return true;default:return false;}}var Ke=function Jl(e){var r="",t=0,a=0,n=0,i=0,s=0,l=0;while(t<e.length){a=e.charCodeAt(t++);if(a<128){r+=String.fromCharCode(a);continue}n=e.charCodeAt(t++);if(a>191&&a<224){s=(a&31)<<6;s|=n&63;r+=String.fromCharCode(s);continue}i=e.charCodeAt(t++);if(a<240){r+=String.fromCharCode((a&15)<<12|(n&63)<<6|i&63);continue}s=e.charCodeAt(t++);l=((a&7)<<18|(n&63)<<12|(i&63)<<6|s&63)-65536;r+=String.fromCharCode(55296+(l>>>10&1023));r+=String.fromCharCode(56320+(l&1023));}return r};var Je=function(e){var r=[],t=0,a=0,n=0;while(t<e.length){a=e.charCodeAt(t++);switch(true){case a<128:r.push(String.fromCharCode(a));break;case a<2048:r.push(String.fromCharCode(192+(a>>6)));r.push(String.fromCharCode(128+(a&63)));break;case a>=55296&&a<57344:a-=55296;n=e.charCodeAt(t++)-56320+(a<<10);r.push(String.fromCharCode(240+(n>>18&7)));r.push(String.fromCharCode(144+(n>>12&63)));r.push(String.fromCharCode(128+(n>>6&63)));r.push(String.fromCharCode(128+(n&63)));break;default:r.push(String.fromCharCode(224+(a>>12)));r.push(String.fromCharCode(128+(a>>6&63)));
	r.push(String.fromCharCode(128+(a&63)));}}return r.join("")};if(w){var qe=function ql(e){var r=Buffer.alloc(2*e.length),t,a,n=1,i=0,s=0,l;for(a=0;a<e.length;a+=n){n=1;if((l=e.charCodeAt(a))<128)t=l;else if(l<224){t=(l&31)*64+(e.charCodeAt(a+1)&63);n=2;}else if(l<240){t=(l&15)*4096+(e.charCodeAt(a+1)&63)*64+(e.charCodeAt(a+2)&63);n=3;}else {n=4;t=(l&7)*262144+(e.charCodeAt(a+1)&63)*4096+(e.charCodeAt(a+2)&63)*64+(e.charCodeAt(a+3)&63);t-=65536;s=55296+(t>>>10&1023);t=56320+(t&1023);}if(s!==0){r[i++]=s&255;r[i++]=s>>>8;s=0;}r[i++]=t%256;r[i++]=t>>>8;}return r.slice(0,i).toString("ucs2")};var Ze="foo bar bazâð£";if(Ke(Ze)==qe(Ze))Ke=qe;var Qe=function Zl(e){return k(e,"binary").toString("utf8")};if(Ke(Ze)==Qe(Ze))Ke=Qe;Je=function(e){return k(e,"utf8").toString("binary")};}var er=function(){var e={};return function r(t,a){var n=t+"|"+(a||"");if(e[n])return e[n];return e[n]=new RegExp("<(?:\\w+:)?"+t+'(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?'+t+">",a||"")}}();var rr=function(){var e=[["nbsp"," "],["middot","·"],["quot",'"'],["apos","'"],["gt",">"],["lt","<"],["amp","&"]].map(function(e){return [new RegExp("&"+e[0]+";","ig"),e[1]]});return function r(t){var a=t.replace(/^[\t\n\r ]+/,"").replace(/[\t\n\r ]+$/,"").replace(/>\s+/g,">").replace(/\s+</g,"<").replace(/[\t\n\r ]+/g," ").replace(/<\s*[bB][rR]\s*\/?>/g,"\n").replace(/<[^>]*>/g,"");for(var n=0;n<e.length;++n)a=a.replace(e[n][0],e[n][1]);return a}}();var tr=function(){var e={};return function r(t){if(e[t]!==undefined)return e[t];return e[t]=new RegExp("<(?:vt:)?"+t+">([\\s\\S]*?)</(?:vt:)?"+t+">","g")}}();var ar=/<\/?(?:vt:)?variant>/g,nr=/<(?:vt:)([^>]*)>([\s\S]*)</;function ir(e,r){var t=Re(e);var a=e.match(tr(t.baseType))||[];var n=[];if(a.length!=t.size){if(r.WTF)throw new Error("unexpected vector length "+a.length+" != "+t.size);return n}a.forEach(function(e){var r=e.replace(ar,"").match(nr);if(r)n.push({v:Ke(r[2]),t:r[1]});});return n}var sr=/(^\s|\s$|\n)/;function lr(e,r){return "<"+e+(r.match(sr)?' xml:space="preserve"':"")+">"+r+"</"+e+">"}function or(e){return Y(e).map(function(r){return " "+r+'="'+e[r]+'"'}).join("")}function cr(e,r,t){return "<"+e+(t!=null?or(t):"")+(r!=null?(r.match(sr)?' xml:space="preserve"':"")+">"+r+"</"+e:"/")+">"}function fr(e,r){try{return e.toISOString().replace(/\.\d*/,"")}catch(t){if(r)throw t}return ""}function ur(e,r){switch(typeof e){case"string":var t=cr("vt:lpwstr",$e(e));if(r)t=t.replace(/&quot;/g,"_x0022_");return t;case"number":return cr((e|0)==e?"vt:i4":"vt:r8",$e(String(e)));case"boolean":return cr("vt:bool",e?"true":"false");}if(e instanceof Date)return cr("vt:filetime",fr(e));throw new Error("Unable to serialize "+e)}var hr={dc:"http://purl.org/dc/elements/1.1/",dcterms:"http://purl.org/dc/terms/",dcmitype:"http://purl.org/dc/dcmitype/",mx:"http://schemas.microsoft.com/office/mac/excel/2008/main",r:"http://schemas.openxmlformats.org/officeDocument/2006/relationships",sjs:"http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",vt:"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",xsi:"http://www.w3.org/2001/XMLSchema-instance",xsd:"http://www.w3.org/2001/XMLSchema"};hr.main=["http://schemas.openxmlformats.org/spreadsheetml/2006/main","http://purl.oclc.org/ooxml/spreadsheetml/main","http://schemas.microsoft.com/office/excel/2006/main","http://schemas.microsoft.com/office/excel/2006/2"];var dr={o:"urn:schemas-microsoft-com:office:office",x:"urn:schemas-microsoft-com:office:excel",ss:"urn:schemas-microsoft-com:office:spreadsheet",dt:"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",mv:"http://macVmlSchemaUri",v:"urn:schemas-microsoft-com:vml",html:"http://www.w3.org/TR/REC-html40"};function pr(e,r){var t=1-2*(e[r+7]>>>7);var a=((e[r+7]&127)<<4)+(e[r+6]>>>4&15);var n=e[r+6]&15;for(var i=5;i>=0;--i)n=n*256+e[r+i];if(a==2047)return n==0?t*Infinity:NaN;if(a==0)a=-1022;else {a-=1023;n+=Math.pow(2,52);}return t*Math.pow(2,a-52)*n}function mr(e,r,t){var a=(r<0||1/r==-Infinity?1:0)<<7,n=0,i=0;var s=a?-r:r;if(!isFinite(s)){n=2047;i=isNaN(r)?26985:0;}else if(s==0)n=i=0;else {n=Math.floor(Math.log(s)/Math.LN2);i=s*Math.pow(2,52-n);if(n<=-1023&&(!isFinite(i)||i<Math.pow(2,52))){n=-1022;}else {i-=Math.pow(2,52);n+=1023;}}for(var l=0;l<=5;++l,i/=256)e[t+l]=i&255;e[t+6]=(n&15)<<4|i&15;e[t+7]=n>>4|a;}var vr=function(e){var r=[],t=10240;for(var a=0;a<e[0].length;++a)if(e[0][a])for(var n=0,i=e[0][a].length;n<i;n+=t)r.push.apply(r,e[0][a].slice(n,n+t));return r};var gr=vr;var br=function(e,r,t){var a=[];for(var n=r;n<t;n+=2)a.push(String.fromCharCode(Br(e,n)));return a.join("").replace(D,"")};var wr=br;var kr=function(e,r,t){var a=[];for(var n=r;n<r+t;++n)a.push(("0"+e[n].toString(16)).slice(-2));return a.join("")};var yr=kr;var xr=function(e,r,t){var a=[];for(var n=r;n<t;n++)a.push(String.fromCharCode(Lr(e,n)));return a.join("")};var Sr=xr;var _r=function(e,r){var t=Wr(e,r);return t>0?xr(e,r+4,r+4+t-1):""};var Cr=_r;var Ar=function(e,r){var t=Wr(e,r);return t>0?xr(e,r+4,r+4+t-1):""};var Er=Ar;var Fr=function(e,r){var t=2*Wr(e,r);return t>0?xr(e,r+4,r+4+t-1):""};var Tr=Fr;var Or,Dr;Or=Dr=function Ql(e,r){var t=Wr(e,r);return t>0?br(e,r+4,r+4+t):""};var Mr=function(e,r){var t=Wr(e,r);return t>0?xr(e,r+4,r+4+t):""};var Nr=Mr;var Rr,Pr;Rr=Pr=function(e,r){return pr(e,r)};if(w){br=function(e,r,t){if(!Buffer.isBuffer(e))return wr(e,r,t);return e.toString("utf16le",r,t).replace(D,"")};kr=function(e,r,t){return Buffer.isBuffer(e)?e.toString("hex",r,r+t):yr(e,r,t)};_r=function ro(e,r){if(!Buffer.isBuffer(e))return Cr(e,r);var t=e.readUInt32LE(r);return t>0?e.toString("utf8",r+4,r+4+t-1):""};Ar=function to(e,r){if(!Buffer.isBuffer(e))return Er(e,r);var t=e.readUInt32LE(r);return t>0?e.toString("utf8",r+4,r+4+t-1):""};Fr=function ao(e,r){if(!Buffer.isBuffer(e))return Tr(e,r);var t=2*e.readUInt32LE(r);return e.toString("utf16le",r+4,r+4+t-1)};Or=function no(e,r){if(!Buffer.isBuffer(e))return Dr(e,r);var t=e.readUInt32LE(r);return e.toString("utf16le",r+4,r+4+t)};Mr=function io(e,r){if(!Buffer.isBuffer(e))return Nr(e,r);var t=e.readUInt32LE(r);return e.toString("utf8",r+4,r+4+t)};xr=function so(e,r,t){return Buffer.isBuffer(e)?e.toString("utf8",r,t):Sr(e,r,t)};vr=function(e){return e[0].length>0&&Buffer.isBuffer(e[0][0])?Buffer.concat(e[0]):gr(e)};O=function(e){return Buffer.isBuffer(e[0])?Buffer.concat(e):[].concat.apply([],e)};Rr=function lo(e,r){if(Buffer.isBuffer(e))return e.readDoubleLE(r);return Pr(e,r)};}if(typeof cptable!=="undefined"){br=function(e,r,t){return cptable.utils.decode(1200,e.slice(r,t)).replace(D,"")};xr=function(e,r,t){return cptable.utils.decode(65001,e.slice(r,t))};_r=function(e,r){var a=Wr(e,r);return a>0?cptable.utils.decode(t,e.slice(r+4,r+4+a-1)):""};Ar=function(e,t){var a=Wr(e,t);return a>0?cptable.utils.decode(r,e.slice(t+4,t+4+a-1)):""};Fr=function(e,r){var t=2*Wr(e,r);return t>0?cptable.utils.decode(1200,e.slice(r+4,r+4+t-1)):""};Or=function(e,r){var t=Wr(e,r);return t>0?cptable.utils.decode(1200,e.slice(r+4,r+4+t)):""};Mr=function(e,r){var t=Wr(e,r);return t>0?cptable.utils.decode(65001,e.slice(r+4,r+4+t)):""};}var Lr=function(e,r){return e[r]};var Br=function(e,r){return e[r+1]*(1<<8)+e[r]};var zr=function(e,r){var t=e[r+1]*(1<<8)+e[r];return t<32768?t:(65535-t+1)*-1};var Wr=function(e,r){return e[r+3]*(1<<24)+(e[r+2]<<16)+(e[r+1]<<8)+e[r]};var $r=function(e,r){return e[r+3]<<24|e[r+2]<<16|e[r+1]<<8|e[r]};var Ur=function(e,r){return e[r]<<24|e[r+1]<<16|e[r+2]<<8|e[r+3]};function jr(e,t){var a="",n,i,s=[],l,o,c,f;switch(t){case"dbcs":f=this.l;if(w&&Buffer.isBuffer(this))a=this.slice(this.l,this.l+2*e).toString("utf16le");else for(c=0;c<e;++c){a+=String.fromCharCode(Br(this,f));f+=2;}e*=2;break;case"utf8":a=xr(this,this.l,this.l+e);break;case"utf16le":e*=2;a=br(this,this.l,this.l+e);break;case"wstr":if(typeof cptable!=="undefined")a=cptable.utils.decode(r,this.slice(this.l,this.l+2*e));else return jr.call(this,e,"dbcs");e=2*e;break;case"lpstr-ansi":a=_r(this,this.l);e=4+Wr(this,this.l);break;case"lpstr-cp":a=Ar(this,this.l);e=4+Wr(this,this.l);break;case"lpwstr":a=Fr(this,this.l);e=4+2*Wr(this,this.l);break;case"lpp4":e=4+Wr(this,this.l);a=Or(this,this.l);if(e&2)e+=2;break;case"8lpp4":e=4+Wr(this,this.l);a=Mr(this,this.l);if(e&3)e+=4-(e&3);break;case"cstr":e=0;a="";while((l=Lr(this,this.l+e++))!==0)s.push(p(l));a=s.join("");break;case"_wstr":e=0;a="";while((l=Br(this,this.l+e))!==0){s.push(p(l));e+=2;}e+=2;a=s.join("");break;case"dbcs-cont":a="";f=this.l;for(c=0;c<e;++c){if(this.lens&&this.lens.indexOf(f)!==-1){l=Lr(this,f);this.l=f+1;o=jr.call(this,e-c,l?"dbcs-cont":"sbcs-cont");return s.join("")+o}s.push(p(Br(this,f)));f+=2;}a=s.join("");e*=2;break;case"cpstr":if(typeof cptable!=="undefined"){a=cptable.utils.decode(r,this.slice(this.l,this.l+e));break}case"sbcs-cont":a="";f=this.l;for(c=0;c!=e;++c){if(this.lens&&this.lens.indexOf(f)!==-1){l=Lr(this,f);this.l=f+1;o=jr.call(this,e-c,l?"dbcs-cont":"sbcs-cont");return s.join("")+o}s.push(p(Lr(this,f)));f+=1;}a=s.join("");break;default:switch(e){case 1:n=Lr(this,this.l);this.l++;return n;case 2:n=(t==="i"?zr:Br)(this,this.l);this.l+=2;return n;case 4:case-4:if(t==="i"||(this[this.l+3]&128)===0){n=(e>0?$r:Ur)(this,this.l);this.l+=4;return n}else {i=Wr(this,this.l);this.l+=4;}return i;case 8:case-8:if(t==="f"){if(e==8)i=Rr(this,this.l);else i=Rr([this[this.l+7],this[this.l+6],this[this.l+5],this[this.l+4],this[this.l+3],this[this.l+2],this[this.l+1],this[this.l+0]],0);this.l+=8;return i}else e=8;case 16:a=kr(this,this.l,e);break;}}this.l+=e;return a}var Hr=function(e,r,t){e[t]=r&255;e[t+1]=r>>>8&255;e[t+2]=r>>>16&255;e[t+3]=r>>>24&255;};var Xr=function(e,r,t){e[t]=r&255;e[t+1]=r>>8&255;e[t+2]=r>>16&255;e[t+3]=r>>24&255;};var Vr=function(e,r,t){e[t]=r&255;e[t+1]=r>>>8&255;};function Gr(e,r,a){var n=0,i=0;if(a==="dbcs"){for(i=0;i!=r.length;++i)Vr(this,r.charCodeAt(i),this.l+2*i);n=2*r.length;}else if(a==="sbcs"){if(typeof cptable!=="undefined"&&t==874){for(i=0;i!=r.length;++i){var s=cptable.utils.encode(t,r.charAt(i));this[this.l+i]=s[0];}}else {r=r.replace(/[^\x00-\x7F]/g,"_");for(i=0;i!=r.length;++i)this[this.l+i]=r.charCodeAt(i)&255;}n=r.length;}else if(a==="hex"){for(;i<e;++i){this[this.l++]=parseInt(r.slice(2*i,2*i+2),16)||0;}return this}else if(a==="utf16le"){var l=Math.min(this.l+e,this.length);for(i=0;i<Math.min(r.length,e);++i){var o=r.charCodeAt(i);this[this.l++]=o&255;this[this.l++]=o>>8;}while(this.l<l)this[this.l++]=0;return this}else switch(e){case 1:n=1;this[this.l]=r&255;break;case 2:n=2;this[this.l]=r&255;r>>>=8;this[this.l+1]=r&255;break;case 3:n=3;this[this.l]=r&255;r>>>=8;this[this.l+1]=r&255;r>>>=8;this[this.l+2]=r&255;break;case 4:n=4;Hr(this,r,this.l);break;case 8:n=8;if(a==="f"){mr(this,r,this.l);break}case 16:break;case-4:n=4;Xr(this,r,this.l);break;}this.l+=n;return this}function Yr(e,r){var t=kr(this,this.l,e.length>>1);if(t!==e)throw new Error(r+"Expected "+e+" saw "+t);this.l+=e.length>>1;}function Kr(e,r){e.l=r;e._R=jr;e.chk=Yr;e._W=Gr;}function qr(e){var r=S(e);Kr(r,0);return r}function Zr(e,r,t){if(!e)return;var a,n,i;Kr(e,e.l||0);var s=e.length,l=0,o=0;while(e.l<s){l=e._R(1);if(l&128)l=(l&127)+((e._R(1)&127)<<7);var c=XLSBRecordEnum[l]||XLSBRecordEnum[65535];a=e._R(1);i=a&127;for(n=1;n<4&&a&128;++n)i+=((a=e._R(1))&127)<<7*n;o=e.l+i;var f=c.f&&c.f(e,i,t);e.l=o;if(r(f,c.n,l))return}}function Qr(){var e=[],r=w?256:2048;var t=function o(e){var r=qr(e);Kr(r,0);return r};var a=t(r);var n=function c(){if(!a)return;if(a.length>a.l){a=a.slice(0,a.l);a.l=a.length;}if(a.length>0)e.push(a);a=null;};var i=function f(e){if(a&&e<a.length-a.l)return a;n();return a=t(Math.max(e+1,r))};var s=function u(){n();return vr([e])};var l=function h(e){n();a=e;if(a.l==null)a.l=a.length;i(r);};return {next:i,push:l,end:s,_bufs:e}}function it(e){return parseInt(ot(e),10)-1}function st(e){return ""+(e+1)}function ot(e){return e.replace(/\$(\d+)$/,"$1")}function ct(e){var r=ht(e),t=0,a=0;for(;a!==r.length;++a)t=26*t+r.charCodeAt(a)-64;return t-1}function ft(e){if(e<0)throw new Error("invalid column "+e);var r="";for(++e;e;e=Math.floor((e-1)/26))r=String.fromCharCode((e-1)%26+65)+r;return r}function ht(e){return e.replace(/^\$([A-Z])/,"$1")}function dt(e){return e.replace(/(\$?[A-Z]*)(\$?\d*)/,"$1,$2").split(",")}function pt(e){var r=0,t=0;for(var a=0;a<e.length;++a){var n=e.charCodeAt(a);if(n>=48&&n<=57)r=10*r+(n-48);else if(n>=65&&n<=90)t=26*t+(n-64);}return {c:t-1,r:r-1}}function mt(e){var r=e.c+1;var t="";for(;r;r=(r-1)/26|0)t=String.fromCharCode((r-1)%26+65)+t;return t+(e.r+1)}function vt(e){var r=e.indexOf(":");if(r==-1)return {s:pt(e),e:pt(e)};return {s:pt(e.slice(0,r)),e:pt(e.slice(r+1))}}function gt(e,r){if(typeof r==="undefined"||typeof r==="number"){return gt(e.s,e.e)}if(typeof e!=="string")e=mt(e);if(typeof r!=="string")r=mt(r);return e==r?e:e+":"+r}function bt(e){var r={s:{c:0,r:0},e:{c:0,r:0}};var t=0,a=0,n=0;var i=e.length;for(t=0;a<i;++a){if((n=e.charCodeAt(a)-64)<1||n>26)break;t=26*t+n;}r.s.c=--t;for(t=0;a<i;++a){if((n=e.charCodeAt(a)-48)<0||n>9)break;t=10*t+n;}r.s.r=--t;if(a===i||n!=10){r.e.c=r.s.c;r.e.r=r.s.r;return r}++a;for(t=0;a!=i;++a){if((n=e.charCodeAt(a)-64)<1||n>26)break;t=26*t+n;}r.e.c=--t;for(t=0;a!=i;++a){if((n=e.charCodeAt(a)-48)<0||n>9)break;t=10*t+n;}r.e.r=--t;return r}function wt(e,r){var t=e.t=="d"&&r instanceof Date;if(e.z!=null)try{return e.w=N.format(e.z,t?ee(r):r)}catch(a){}try{return e.w=N.format((e.XF||{}).numFmtId||(t?14:0),t?ee(r):r)}catch(a){return ""+r}}function kt(e,r,t){if(e==null||e.t==null||e.t=="z")return "";if(e.w!==undefined)return e.w;if(e.t=="d"&&!e.z&&t&&t.dateNF)e.z=t.dateNF;if(e.t=="e")return Vt[e.v]||e.v;if(r==undefined)return wt(e,e.v);return wt(e,r)}function yt(e,r){var t=r&&r.sheet?r.sheet:"Sheet1";var a={};a[t]=e;return {SheetNames:[t],Sheets:a}}function xt(e,r,t){var a=t||{};var n=e?Array.isArray(e):a.dense;var i=e||(n?[]:{});var s=0,l=0;if(i&&a.origin!=null){if(typeof a.origin=="number")s=a.origin;else {var o=typeof a.origin=="string"?pt(a.origin):a.origin;s=o.r;l=o.c;}if(!i["!ref"])i["!ref"]="A1:A1";}var c={s:{c:1e7,r:1e7},e:{c:0,r:0}};if(i["!ref"]){var f=bt(i["!ref"]);c.s.c=f.s.c;c.s.r=f.s.r;c.e.c=Math.max(c.e.c,f.e.c);c.e.r=Math.max(c.e.r,f.e.r);if(s==-1)c.e.r=s=f.e.r+1;}for(var u=0;u!=r.length;++u){if(!r[u])continue;if(!Array.isArray(r[u]))throw new Error("aoa_to_sheet expects an array of arrays");for(var h=0;h!=r[u].length;++h){if(typeof r[u][h]==="undefined")continue;var d={v:r[u][h]};var p=s+u,m=l+h;if(c.s.r>p)c.s.r=p;if(c.s.c>m)c.s.c=m;if(c.e.r<p)c.e.r=p;if(c.e.c<m)c.e.c=m;if(r[u][h]&&typeof r[u][h]==="object"&&!Array.isArray(r[u][h])&&!(r[u][h]instanceof Date))d=r[u][h];else {if(Array.isArray(d.v)){d.f=r[u][h][1];d.v=d.v[0];}if(d.v===null){if(d.f)d.t="n";else if(a.nullError){d.t="e";d.v=0;}else if(!a.sheetStubs)continue;else d.t="z";}else if(typeof d.v==="number")d.t="n";else if(typeof d.v==="boolean")d.t="b";else if(d.v instanceof Date){d.z=a.dateNF||N._table[14];if(a.cellDates){d.t="d";d.w=N.format(d.z,ee(d.v));}else {d.t="n";d.v=ee(d.v);d.w=N.format(d.z,d.v);}}else d.t="s";}if(n){if(!i[p])i[p]=[];if(i[p][m]&&i[p][m].z)d.z=i[p][m].z;i[p][m]=d;}else {var g=mt({c:m,r:p});if(i[g]&&i[g].z)d.z=i[g].z;i[g]=d;}}}if(c.s.c<1e7)i["!ref"]=gt(c);return i}function St(e,r){return xt(null,e,r)}var _t=2;var Ct=3;var At=11;var Et=12;var Ft=19;var Tt=30;var Ot=64;var Dt=65;var Mt=71;var Nt=4096;var Rt=80;var Lt={1:{n:"CodePage",t:_t},2:{n:"Category",t:Rt},3:{n:"PresentationFormat",t:Rt},4:{n:"ByteCount",t:Ct},5:{n:"LineCount",t:Ct},6:{n:"ParagraphCount",t:Ct},7:{n:"SlideCount",t:Ct},8:{n:"NoteCount",t:Ct},9:{n:"HiddenCount",t:Ct},10:{n:"MultimediaClipCount",t:Ct},11:{n:"ScaleCrop",t:At},12:{n:"HeadingPairs",t:Nt|Et},13:{n:"TitlesOfParts",t:Nt|Tt},14:{n:"Manager",t:Rt},15:{n:"Company",t:Rt},16:{n:"LinksUpToDate",t:At},17:{n:"CharacterCount",t:Ct},19:{n:"SharedDoc",t:At},22:{n:"HyperlinksChanged",t:At},23:{n:"AppVersion",t:Ct,p:"version"},24:{n:"DigSig",t:Dt},26:{n:"ContentType",t:Rt},27:{n:"ContentStatus",t:Rt},28:{n:"Language",t:Rt},29:{n:"Version",t:Rt},255:{},2147483648:{n:"Locale",t:Ft},2147483651:{n:"Behavior",t:Ft},1919054434:{}};var Bt={1:{n:"CodePage",t:_t},2:{n:"Title",t:Rt},3:{n:"Subject",t:Rt},4:{n:"Author",t:Rt},5:{n:"Keywords",t:Rt},6:{n:"Comments",t:Rt},7:{n:"Template",t:Rt},8:{n:"LastAuthor",t:Rt},9:{n:"RevNumber",t:Rt},10:{n:"EditTime",t:Ot},11:{n:"LastPrinted",t:Ot},12:{n:"CreatedDate",t:Ot},13:{n:"ModifiedDate",t:Ot},14:{n:"PageCount",t:Ct},15:{n:"WordCount",t:Ct},16:{n:"CharCount",t:Ct},17:{n:"Thumbnail",t:Mt},18:{n:"Application",t:Rt},19:{n:"DocSecurity",t:Ct},255:{},2147483648:{n:"Locale",t:Ft},2147483651:{n:"Behavior",t:Ft},1919054434:{}};K(Lt,"n");K(Bt,"n");function jt(e){return e.map(function(e){return [e>>16&255,e>>8&255,e&255]})}var Ht=jt([0,16777215,16711680,65280,255,16776960,16711935,65535,0,16777215,16711680,65280,255,16776960,16711935,65535,8388608,32768,128,8421376,8388736,32896,12632256,8421504,10066431,10040166,16777164,13434879,6684774,16744576,26316,13421823,128,16711935,16776960,65535,8388736,8388608,32896,255,52479,13434879,13434828,16777113,10079487,16751052,13408767,16764057,3368703,3394764,10079232,16763904,16750848,16737792,6710937,9868950,13158,3381606,13056,3355392,10040064,10040166,3355545,3355443,16777215,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);var Xt=fe(Ht);var Vt={0:"#NULL!",7:"#DIV/0!",15:"#VALUE!",23:"#REF!",29:"#NAME?",36:"#NUM!",42:"#N/A",43:"#GETTING_DATA",255:"#WTF?"};var Gt=q(Vt);var Yt={"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":"workbooks","application/vnd.ms-excel.binIndexWs":"TODO","application/vnd.ms-excel.intlmacrosheet":"TODO","application/vnd.ms-excel.binIndexMs":"TODO","application/vnd.openxmlformats-package.core-properties+xml":"coreprops","application/vnd.openxmlformats-officedocument.custom-properties+xml":"custprops","application/vnd.openxmlformats-officedocument.extended-properties+xml":"extprops","application/vnd.openxmlformats-officedocument.customXmlProperties+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty":"TODO","application/vnd.ms-excel.pivotTable":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.chart+xml":"TODO","application/vnd.ms-office.chartcolorstyle+xml":"TODO","application/vnd.ms-office.chartstyle+xml":"TODO","application/vnd.ms-office.chartex+xml":"TODO","application/vnd.ms-excel.calcChain":"calcchains","application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml":"calcchains","application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings":"TODO","application/vnd.ms-office.activeX":"TODO","application/vnd.ms-office.activeX+xml":"TODO","application/vnd.ms-excel.attachedToolbars":"TODO","application/vnd.ms-excel.connections":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":"TODO","application/vnd.ms-excel.externalLink":"links","application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml":"links","application/vnd.ms-excel.sheetMetadata":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml":"TODO","application/vnd.ms-excel.pivotCacheDefinition":"TODO","application/vnd.ms-excel.pivotCacheRecords":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml":"TODO","application/vnd.ms-excel.queryTable":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml":"TODO","application/vnd.ms-excel.userNames":"TODO","application/vnd.ms-excel.revisionHeaders":"TODO","application/vnd.ms-excel.revisionLog":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml":"TODO","application/vnd.ms-excel.tableSingleCells":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml":"TODO","application/vnd.ms-excel.slicer":"TODO","application/vnd.ms-excel.slicerCache":"TODO","application/vnd.ms-excel.slicer+xml":"TODO","application/vnd.ms-excel.slicerCache+xml":"TODO","application/vnd.ms-excel.wsSortMap":"TODO","application/vnd.ms-excel.table":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":"TODO","application/vnd.openxmlformats-officedocument.theme+xml":"themes","application/vnd.openxmlformats-officedocument.themeOverride+xml":"TODO","application/vnd.ms-excel.Timeline+xml":"TODO","application/vnd.ms-excel.TimelineCache+xml":"TODO","application/vnd.ms-office.vbaProject":"vba","application/vnd.ms-office.vbaProjectSignature":"vba","application/vnd.ms-office.volatileDependencies":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml":"TODO","application/vnd.ms-excel.controlproperties+xml":"TODO","application/vnd.openxmlformats-officedocument.model+data":"TODO","application/vnd.ms-excel.Survey+xml":"TODO","application/vnd.openxmlformats-officedocument.drawing+xml":"drawings","application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml":"TODO","application/vnd.openxmlformats-officedocument.vmlDrawing":"TODO","application/vnd.openxmlformats-package.relationships+xml":"rels","application/vnd.openxmlformats-officedocument.oleObject":"TODO","image/png":"TODO",sheet:"js"};var Kt=function(){var e={workbooks:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",xlsm:"application/vnd.ms-excel.sheet.macroEnabled.main+xml",xlsb:"application/vnd.ms-excel.sheet.binary.macroEnabled.main",xlam:"application/vnd.ms-excel.addin.macroEnabled.main+xml",xltx:"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"},strs:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",xlsb:"application/vnd.ms-excel.sharedStrings"},comments:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",xlsb:"application/vnd.ms-excel.comments"},sheets:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",xlsb:"application/vnd.ms-excel.worksheet"},charts:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",xlsb:"application/vnd.ms-excel.chartsheet"},dialogs:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",xlsb:"application/vnd.ms-excel.dialogsheet"},macros:{xlsx:"application/vnd.ms-excel.macrosheet+xml",xlsb:"application/vnd.ms-excel.macrosheet"},styles:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",xlsb:"application/vnd.ms-excel.styles"}};Y(e).forEach(function(r){["xlsm","xlam"].forEach(function(t){if(!e[r][t])e[r][t]=e[r].xlsx;});});Y(e).forEach(function(r){Y(e[r]).forEach(function(t){Yt[e[r][t]]=r;});});return e}();var Jt=Z(Yt);hr.CT="http://schemas.openxmlformats.org/package/2006/content-types";function qt(){return {workbooks:[],sheets:[],charts:[],dialogs:[],macros:[],rels:[],strs:[],comments:[],links:[],coreprops:[],extprops:[],custprops:[],themes:[],styles:[],calcchains:[],vba:[],drawings:[],TODO:[],xmlns:""}}function Zt(e){var r=qt();if(!e||!e.match)return r;var t={};(e.match(De)||[]).forEach(function(e){var a=Re(e);switch(a[0].replace(Me,"<")){case"<?xml":break;case"<Types":r.xmlns=a["xmlns"+(a[0].match(/<(\w+):/)||["",""])[1]];break;case"<Default":t[a.Extension]=a.ContentType;break;case"<Override":if(r[Yt[a.ContentType]]!==undefined)r[Yt[a.ContentType]].push(a.PartName);break;}});if(r.xmlns!==hr.CT)throw new Error("Unknown Namespace: "+r.xmlns);r.calcchain=r.calcchains.length>0?r.calcchains[0]:"";r.sst=r.strs.length>0?r.strs[0]:"";r.style=r.styles.length>0?r.styles[0]:"";r.defaults=t;delete r.calcchains;return r}var Qt=cr("Types",null,{xmlns:hr.CT,"xmlns:xsd":hr.xsd,"xmlns:xsi":hr.xsi});var ea=[["xml","application/xml"],["bin","application/vnd.ms-excel.sheet.binary.macroEnabled.main"],["vml","application/vnd.openxmlformats-officedocument.vmlDrawing"],["data","application/vnd.openxmlformats-officedocument.model+data"],["bmp","image/bmp"],["png","image/png"],["gif","image/gif"],["emf","image/x-emf"],["wmf","image/x-wmf"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["tif","image/tiff"],["tiff","image/tiff"],["pdf","application/pdf"],["rels",Jt.rels[0]]].map(function(e){return cr("Default",null,{Extension:e[0],ContentType:e[1]})});function ra(e,r){var t=[],a;t[t.length]=Te;t[t.length]=Qt;t=t.concat(ea);var n=function(n){if(e[n]&&e[n].length>0){a=e[n][0];t[t.length]=cr("Override",null,{PartName:(a[0]=="/"?"":"/")+a,ContentType:Kt[n][r.bookType||"xlsx"]});}};var i=function(a){(e[a]||[]).forEach(function(e){t[t.length]=cr("Override",null,{PartName:(e[0]=="/"?"":"/")+e,ContentType:Kt[a][r.bookType||"xlsx"]});});};var s=function(r){(e[r]||[]).forEach(function(e){t[t.length]=cr("Override",null,{PartName:(e[0]=="/"?"":"/")+e,ContentType:Jt[r][0]});});};n("workbooks");i("sheets");i("charts");s("themes");["strs","styles"].forEach(n);["coreprops","extprops","custprops"].forEach(s);s("vba");s("comments");s("drawings");if(t.length>2){t[t.length]="</Types>";t[1]=t[1].replace("/>",">");}return t.join("")}var ta={WB:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",SHEET:"http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",HLINK:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",VML:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",XPATH:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",XMISS:"http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",XLINK:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",CXML:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",CXMLP:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",VBA:"http://schemas.microsoft.com/office/2006/relationships/vbaProject"};function aa(e){var r=e.lastIndexOf("/");return e.slice(0,r+1)+"_rels/"+e.slice(r+1)+".rels"}function na(e,r){var t={"!id":{}};if(!e)return t;if(r.charAt(0)!=="/"){r="/"+r;}var a={};(e.match(De)||[]).forEach(function(e){var n=Re(e);if(n[0]==="<Relationship"){var i={};i.Type=n.Type;i.Target=n.Target;i.Id=n.Id;if(n.TargetMode)i.TargetMode=n.TargetMode;var s=n.TargetMode==="External"?n.Target:Fe(n.Target,r);t[s]=i;a[n.Id]=i;}});t["!id"]=a;return t}hr.RELS="http://schemas.openxmlformats.org/package/2006/relationships";var ia=cr("Relationships",null,{xmlns:hr.RELS});function sa(e){var r=[Te,ia];Y(e["!id"]).forEach(function(t){r[r.length]=cr("Relationship",null,e["!id"][t]);});if(r.length>2){r[r.length]="</Relationships>";r[1]=r[1].replace("/>",">");}return r.join("")}var la=[ta.HLINK,ta.XPATH,ta.XMISS];function oa(e,r,t,a,n,i){if(!n)n={};if(!e["!id"])e["!id"]={};if(r<0)for(r=1;e["!id"]["rId"+r];++r){}n.Id="rId"+r;n.Type=a;n.Target=t;if(i)n.TargetMode=i;else if(la.indexOf(n.Type)>-1)n.TargetMode="External";if(e["!id"][n.Id])throw new Error("Cannot rewrite rId "+r);e["!id"][n.Id]=n;e[("/"+n.Target).replace("//","/")]=n;return r}var ca=[["cp:category","Category"],["cp:contentStatus","ContentStatus"],["cp:keywords","Keywords"],["cp:lastModifiedBy","LastAuthor"],["cp:lastPrinted","LastPrinted"],["cp:revision","RevNumber"],["cp:version","Version"],["dc:creator","Author"],["dc:description","Comments"],["dc:identifier","Identifier"],["dc:language","Language"],["dc:subject","Subject"],["dc:title","Title"],["dcterms:created","CreatedDate","date"],["dcterms:modified","ModifiedDate","date"]];hr.CORE_PROPS="http://schemas.openxmlformats.org/package/2006/metadata/core-properties";ta.CORE_PROPS="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";var fa=function(){var e=new Array(ca.length);for(var r=0;r<ca.length;++r){var t=ca[r];var a="(?:"+t[0].slice(0,t[0].indexOf(":"))+":)"+t[0].slice(t[0].indexOf(":")+1);e[r]=new RegExp("<"+a+"[^>]*>([\\s\\S]*?)</"+a+">");}return e}();function ua(e){var r={};e=Ke(e);for(var t=0;t<ca.length;++t){var a=ca[t],n=e.match(fa[t]);if(n!=null&&n.length>0)r[a[1]]=Be(n[1]);if(a[2]==="date"&&r[a[1]])r[a[1]]=oe(r[a[1]]);}return r}var ha=cr("cp:coreProperties",null,{"xmlns:cp":hr.CORE_PROPS,"xmlns:dc":hr.dc,"xmlns:dcterms":hr.dcterms,"xmlns:dcmitype":hr.dcmitype,"xmlns:xsi":hr.xsi});function da(e,r,t,a,n){if(n[e]!=null||r==null||r==="")return;n[e]=r;r=$e(r);a[a.length]=t?cr(e,r,t):lr(e,r);}function pa(e,r){var t=r||{};var a=[Te,ha],n={};if(!e&&!t.Props)return a.join("");if(e){if(e.CreatedDate!=null)da("dcterms:created",typeof e.CreatedDate==="string"?e.CreatedDate:fr(e.CreatedDate,t.WTF),{"xsi:type":"dcterms:W3CDTF"},a,n);if(e.ModifiedDate!=null)da("dcterms:modified",typeof e.ModifiedDate==="string"?e.ModifiedDate:fr(e.ModifiedDate,t.WTF),{"xsi:type":"dcterms:W3CDTF"},a,n);}for(var i=0;i!=ca.length;++i){var s=ca[i];var l=t.Props&&t.Props[s[1]]!=null?t.Props[s[1]]:e?e[s[1]]:null;if(l===true)l="1";else if(l===false)l="0";else if(typeof l=="number")l=String(l);if(l!=null)da(s[0],l,null,a,n);}if(a.length>2){a[a.length]="</cp:coreProperties>";a[1]=a[1].replace("/>",">");}return a.join("")}var ma=[["Application","Application","string"],["AppVersion","AppVersion","string"],["Company","Company","string"],["DocSecurity","DocSecurity","string"],["Manager","Manager","string"],["HyperlinksChanged","HyperlinksChanged","bool"],["SharedDoc","SharedDoc","bool"],["LinksUpToDate","LinksUpToDate","bool"],["ScaleCrop","ScaleCrop","bool"],["HeadingPairs","HeadingPairs","raw"],["TitlesOfParts","TitlesOfParts","raw"]];
	hr.EXT_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties";ta.EXT_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties";function ga(e,r,t,a){var n=[];if(typeof e=="string")n=ir(e,a);else for(var i=0;i<e.length;++i)n=n.concat(e[i].map(function(e){return {v:e}}));var s=typeof r=="string"?ir(r,a).map(function(e){return e.v}):r;var l=0,o=0;if(s.length>0)for(var c=0;c!==n.length;c+=2){o=+n[c+1].v;switch(n[c].v){case"Worksheets":case"工作表":case"Листы":case"أوراق العمل":case"ワークシート":case"גליונות עבודה":case"Arbeitsblätter":case"Çalışma Sayfaları":case"Feuilles de calcul":case"Fogli di lavoro":case"Folhas de cálculo":case"Planilhas":case"Regneark":case"Hojas de cálculo":case"Werkbladen":t.Worksheets=o;t.SheetNames=s.slice(l,l+o);break;case"Named Ranges":case"Rangos con nombre":case"名前付き一覧":case"Benannte Bereiche":case"Navngivne områder":t.NamedRanges=o;t.DefinedNames=s.slice(l,l+o);break;case"Charts":case"Diagramme":t.Chartsheets=o;t.ChartNames=s.slice(l,l+o);break;}l+=o;}}function ba(e,r,t){var a={};if(!r)r={};e=Ke(e);ma.forEach(function(t){var n=(e.match(er(t[0]))||[])[1];switch(t[2]){case"string":if(n)r[t[1]]=Be(n);break;case"bool":r[t[1]]=n==="true";break;case"raw":var i=e.match(new RegExp("<"+t[0]+"[^>]*>([\\s\\S]*?)</"+t[0]+">"));if(i&&i.length>0)a[t[1]]=i[1];break;}});if(a.HeadingPairs&&a.TitlesOfParts)ga(a.HeadingPairs,a.TitlesOfParts,r,t);return r}var wa=cr("Properties",null,{xmlns:hr.EXT_PROPS,"xmlns:vt":hr.vt});function ka(e){var r=[],t=cr;if(!e)e={};e.Application="SheetJS";r[r.length]=Te;r[r.length]=wa;ma.forEach(function(a){if(e[a[1]]===undefined)return;var n;switch(a[2]){case"string":n=$e(String(e[a[1]]));break;case"bool":n=e[a[1]]?"true":"false";break;}if(n!==undefined)r[r.length]=t(a[0],n);});r[r.length]=t("HeadingPairs",t("vt:vector",t("vt:variant","<vt:lpstr>Worksheets</vt:lpstr>")+t("vt:variant",t("vt:i4",String(e.Worksheets))),{size:2,baseType:"variant"}));r[r.length]=t("TitlesOfParts",t("vt:vector",e.SheetNames.map(function(e){return "<vt:lpstr>"+$e(e)+"</vt:lpstr>"}).join(""),{size:e.Worksheets,baseType:"lpstr"}));if(r.length>2){r[r.length]="</Properties>";r[1]=r[1].replace("/>",">");}return r.join("")}hr.CUST_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties";ta.CUST_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties";var ya=/<[^>]+>[^<]*/g;function xa(e,r){var t={},a="";var n=e.match(ya);if(n)for(var i=0;i!=n.length;++i){var s=n[i],l=Re(s);switch(l[0]){case"<?xml":break;case"<Properties":break;case"<property":a=Be(l.name);break;case"</property>":a=null;break;default:if(s.indexOf("<vt:")===0){var o=s.split(">");var c=o[0].slice(4),f=o[1];switch(c){case"lpstr":case"bstr":case"lpwstr":t[a]=Be(f);break;case"bool":t[a]=Ye(f);break;case"i1":case"i2":case"i4":case"i8":case"int":case"uint":t[a]=parseInt(f,10);break;case"r4":case"r8":case"decimal":t[a]=parseFloat(f);break;case"filetime":case"date":t[a]=oe(f);break;case"cy":case"error":t[a]=Be(f);break;default:if(c.slice(-1)=="/")break;if(r.WTF&&typeof console!=="undefined")console.warn("Unexpected",s,c,o);}}else if(s.slice(0,2)==="</");else if(r.WTF)throw new Error(s);}}return t}var Sa=cr("Properties",null,{xmlns:hr.CUST_PROPS,"xmlns:vt":hr.vt});function _a(e){var r=[Te,Sa];if(!e)return r.join("");var t=1;Y(e).forEach(function a(n){++t;r[r.length]=cr("property",ur(e[n],true),{fmtid:"{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",pid:t,name:$e(n)});});if(r.length>2){r[r.length]="</Properties>";r[1]=r[1].replace("/>",">");}return r.join("")}var Ca=function(){var e={1:437,2:850,3:1252,4:1e4,100:852,101:866,102:865,103:861,104:895,105:620,106:737,107:857,120:950,121:949,122:936,123:932,124:874,125:1255,126:1256,150:10007,151:10029,152:10006,200:1250,201:1251,202:1254,203:1253,0:20127,8:865,9:437,10:850,11:437,13:437,14:850,15:437,16:850,17:437,18:850,19:932,20:850,21:437,22:850,23:865,24:437,25:437,26:850,27:437,28:863,29:850,31:852,34:852,35:852,36:860,37:850,38:866,55:850,64:852,77:936,78:949,79:950,80:874,87:1252,88:1252,89:1252,108:863,134:737,135:852,136:857,204:1257,255:16969};var r=J({1:437,2:850,3:1252,4:1e4,100:852,101:866,102:865,103:861,104:895,105:620,106:737,107:857,120:950,121:949,122:936,123:932,124:874,125:1255,126:1256,150:10007,151:10029,152:10006,200:1250,201:1251,202:1254,203:1253,0:20127});var a=[2,3,48,49,131,139,140,245];function n(r,t){var a=[];var n=S(1);switch(t.type){case"base64":n=C(b.decode(r));break;case"binary":n=C(r);break;case"buffer":case"array":n=r;break;}Kr(n,0);var i=n._R(1);var s=!!(i&136);var l=false,o=false;switch(i){case 2:break;case 3:break;case 48:l=true;s=true;break;case 49:l=true;s=true;break;case 131:break;case 139:break;case 140:o=true;break;case 245:break;default:throw new Error("DBF Unsupported Version: "+i.toString(16));}var c=0,f=521;if(i==2)c=n._R(2);n.l+=3;if(i!=2)c=n._R(4);if(c>1048576)c=1e6;if(i!=2)f=n._R(2);var u=n._R(2);var h=t.codepage||1252;if(i!=2){n.l+=16;n._R(1);if(n[n.l]!==0)h=e[n[n.l]];n.l+=1;n.l+=2;}if(o)n.l+=36;var d=[],p={};var m=Math.min(n.length,i==2?521:f-10-(l?264:0));var v=o?32:11;while(n.l<m&&n[n.l]!=13){p={};p.name=cptable.utils.decode(h,n.slice(n.l,n.l+v)).replace(/[\u0000\r\n].*$/g,"");n.l+=v;p.type=String.fromCharCode(n._R(1));if(i!=2&&!o)p.offset=n._R(4);p.len=n._R(1);if(i==2)p.offset=n._R(2);p.dec=n._R(1);if(p.name.length)d.push(p);if(i!=2)n.l+=o?13:14;switch(p.type){case"B":if((!l||p.len!=8)&&t.WTF)console.log("Skipping "+p.name+":"+p.type);break;case"G":case"P":if(t.WTF)console.log("Skipping "+p.name+":"+p.type);break;case"+":case"0":case"@":case"C":case"D":case"F":case"I":case"L":case"M":case"N":case"O":case"T":case"Y":break;default:throw new Error("Unknown Field Type: "+p.type);}}if(n[n.l]!==13)n.l=f-1;if(n._R(1)!==13)throw new Error("DBF Terminator not found "+n.l+" "+n[n.l]);n.l=f;var g=0,w=0;a[0]=[];for(w=0;w!=d.length;++w)a[0][w]=d[w].name;while(c-- >0){if(n[n.l]===42){n.l+=u;continue}++n.l;a[++g]=[];w=0;for(w=0;w!=d.length;++w){var k=n.slice(n.l,n.l+d[w].len);n.l+=d[w].len;Kr(k,0);var y=cptable.utils.decode(h,k);switch(d[w].type){case"C":if(y.trim().length)a[g][w]=y.replace(/\s+$/,"");break;case"D":if(y.length===8)a[g][w]=new Date(+y.slice(0,4),+y.slice(4,6)-1,+y.slice(6,8));else a[g][w]=y;break;case"F":a[g][w]=parseFloat(y.trim());break;case"+":case"I":a[g][w]=o?k._R(-4,"i")^2147483648:k._R(4,"i");break;case"L":switch(y.trim().toUpperCase()){case"Y":case"T":a[g][w]=true;break;case"N":case"F":a[g][w]=false;break;case"":case"?":break;default:throw new Error("DBF Unrecognized L:|"+y+"|");}break;case"M":if(!s)throw new Error("DBF Unexpected MEMO for type "+i.toString(16));a[g][w]="##MEMO##"+(o?parseInt(y.trim(),10):k._R(4));break;case"N":y=y.replace(/\u0000/g,"").trim();if(y&&y!=".")a[g][w]=+y||0;break;case"@":a[g][w]=new Date(k._R(-8,"f")-621356832e5);break;case"T":a[g][w]=new Date((k._R(4)-2440588)*864e5+k._R(4));break;case"Y":a[g][w]=k._R(4,"i")/1e4;break;case"O":a[g][w]=-k._R(-8,"f");break;case"B":if(l&&d[w].len==8){a[g][w]=k._R(8,"f");break}case"G":case"P":k.l+=d[w].len;break;case"0":if(d[w].name==="_NullFlags")break;default:throw new Error("DBF Unsupported data type "+d[w].type);}}}if(i!=2)if(n.l<n.length&&n[n.l++]!=26)throw new Error("DBF EOF Marker missing "+(n.l-1)+" of "+n.length+" "+n[n.l-1].toString(16));if(t&&t.sheetRows)a=a.slice(0,t.sheetRows);return a}function i(e,r){var t=r||{};if(!t.dateNF)t.dateNF="yyyymmdd";return St(n(e,t),t)}function s(e,r){try{return yt(i(e,r),r)}catch(t){if(r&&r.WTF)throw t}return {SheetNames:[],Sheets:{}}}var l={B:8,C:250,L:1,D:8,"?":0,"":0};function c(e,a){var n=a||{};if(+n.codepage>=0)o(+n.codepage);if(n.type=="string")throw new Error("Cannot write DBF to JS string");var i=Qr();var s=Pl(e,{header:1,raw:true,cellDates:true});var c=s[0],f=s.slice(1);var u=0,h=0,d=0,p=1;for(u=0;u<c.length;++u){if(u==null)continue;++d;if(typeof c[u]==="number")c[u]=c[u].toString(10);if(typeof c[u]!=="string")throw new Error("DBF Invalid column name "+c[u]+" |"+typeof c[u]+"|");if(c.indexOf(c[u])!==u)for(h=0;h<1024;++h)if(c.indexOf(c[u]+"_"+h)==-1){c[u]+="_"+h;break}}var m=bt(e["!ref"]);var v=[];for(u=0;u<=m.e.c-m.s.c;++u){var g=[];for(h=0;h<f.length;++h){if(f[h][u]!=null)g.push(f[h][u]);}if(g.length==0||c[u]==null){v[u]="?";continue}var b="",w="";for(h=0;h<g.length;++h){switch(typeof g[h]){case"number":w="B";break;case"string":w="C";break;case"boolean":w="L";break;case"object":w=g[h]instanceof Date?"D":"C";break;default:w="C";}b=b&&b!=w?"C":w;if(b=="C")break}p+=l[b]||0;v[u]=b;}var k=i.next(32);k._W(4,318902576);k._W(4,f.length);k._W(2,296+32*d);k._W(2,p);for(u=0;u<4;++u)k._W(4,0);k._W(4,0|(+r[t]||3)<<8);for(u=0,h=0;u<c.length;++u){if(c[u]==null)continue;var y=i.next(32);var x=(c[u].slice(-10)+"\0\0\0\0\0\0\0\0\0\0\0").slice(0,11);y._W(1,x,"sbcs");y._W(1,v[u]=="?"?"C":v[u],"sbcs");y._W(4,h);y._W(1,l[v[u]]||0);y._W(1,0);y._W(1,2);y._W(4,0);y._W(1,0);y._W(4,0);y._W(4,0);h+=l[v[u]]||0;}var S=i.next(264);S._W(4,13);for(u=0;u<65;++u)S._W(4,0);for(u=0;u<f.length;++u){var _=i.next(p);_._W(1,0);for(h=0;h<c.length;++h){if(c[h]==null)continue;switch(v[h]){case"L":_._W(1,f[u][h]==null?63:f[u][h]?84:70);break;case"B":_._W(8,f[u][h]||0,"f");break;case"D":if(!f[u][h])_._W(8,"00000000","sbcs");else {_._W(4,("0000"+f[u][h].getFullYear()).slice(-4),"sbcs");_._W(2,("00"+(f[u][h].getMonth()+1)).slice(-2),"sbcs");_._W(2,("00"+f[u][h].getDate()).slice(-2),"sbcs");}break;case"C":var C=String(f[u][h]||"");_._W(1,C,"sbcs");for(d=0;d<250-C.length;++d)_._W(1,32);break;}}}i.next(1)._W(1,26);return i.end()}return {versions:a,to_workbook:s,to_sheet:i,from_sheet:c}}();var Aa=function(){var e={AA:"À",BA:"Á",CA:"Â",DA:195,HA:"Ä",JA:197,AE:"È",BE:"É",CE:"Ê",HE:"Ë",AI:"Ì",BI:"Í",CI:"Î",HI:"Ï",AO:"Ò",BO:"Ó",CO:"Ô",DO:213,HO:"Ö",AU:"Ù",BU:"Ú",CU:"Û",HU:"Ü",Aa:"à",Ba:"á",Ca:"â",Da:227,Ha:"ä",Ja:229,Ae:"è",Be:"é",Ce:"ê",He:"ë",Ai:"ì",Bi:"í",Ci:"î",Hi:"ï",Ao:"ò",Bo:"ó",Co:"ô",Do:245,Ho:"ö",Au:"ù",Bu:"ú",Cu:"û",Hu:"ü",KC:"Ç",Kc:"ç",q:"æ",z:"œ",a:"Æ",j:"Œ",DN:209,Dn:241,Hy:255,S:169,c:170,R:174,"B ":180,0:176,1:177,2:178,3:179,5:181,6:182,7:183,Q:185,k:186,b:208,i:216,l:222,s:240,y:248,"!":161,'"':162,"#":163,"(":164,"%":165,"'":167,"H ":168,"+":171,";":187,"<":188,"=":189,">":190,"?":191,"{":223};var r=new RegExp("N("+Y(e).join("|").replace(/\|\|\|/,"|\\||").replace(/([?()+])/g,"\\$1")+"|\\|)","gm");var t=function(r,t){var a=e[t];return typeof a=="number"?m(a):a};var a=function(e,r,t){var a=r.charCodeAt(0)-32<<4|t.charCodeAt(0)-48;return a==59?e:m(a)};e["|"]=254;function n(e,r){switch(r.type){case"base64":return i(b.decode(e),r);case"binary":return i(e,r);case"buffer":return i(w&&Buffer.isBuffer(e)?e.toString("binary"):E(e),r);case"array":return i(ce(e),r);}throw new Error("Unrecognized type "+r.type)}function i(e,n){var i=e.split(/[\n\r]+/),s=-1,l=-1,c=0,f=0,u=[];var h=[];var d=null;var p={},m=[],v=[],g=[];var b=0,w;if(+n.codepage>=0)o(+n.codepage);for(;c!==i.length;++c){b=0;var k=i[c].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g,a).replace(r,t);var y=k.replace(/;;/g,"\0").split(";").map(function(e){return e.replace(/\u0000/g,";")});var x=y[0],S;if(k.length>0)switch(x){case"ID":break;case"E":break;case"B":break;case"O":break;case"W":break;case"P":if(y[1].charAt(0)=="P")h.push(k.slice(3).replace(/;;/g,";"));break;case"C":var _=false,C=false,A=false,E=false,F=-1,T=-1;for(f=1;f<y.length;++f)switch(y[f].charAt(0)){case"A":break;case"X":l=parseInt(y[f].slice(1))-1;C=true;break;case"Y":s=parseInt(y[f].slice(1))-1;if(!C)l=0;for(w=u.length;w<=s;++w)u[w]=[];break;case"K":S=y[f].slice(1);if(S.charAt(0)==='"')S=S.slice(1,S.length-1);else if(S==="TRUE")S=true;else if(S==="FALSE")S=false;else if(!isNaN(he(S))){S=he(S);if(d!==null&&N.is_date(d))S=ne(S);}else if(!isNaN(de(S).getDate())){S=oe(S);}if(typeof cptable!=="undefined"&&typeof S=="string"&&(n||{}).type!="string"&&(n||{}).codepage)S=cptable.utils.decode(n.codepage,S);_=true;break;case"E":E=true;var O=qn(y[f].slice(1),{r:s,c:l});u[s][l]=[u[s][l],O];break;case"S":A=true;u[s][l]=[u[s][l],"S5S"];break;case"G":break;case"R":F=parseInt(y[f].slice(1))-1;break;case"C":T=parseInt(y[f].slice(1))-1;break;default:if(n&&n.WTF)throw new Error("SYLK bad record "+k);}if(_){if(u[s][l]&&u[s][l].length==2)u[s][l][0]=S;else u[s][l]=S;d=null;}if(A){if(E)throw new Error("SYLK shared formula cannot have own formula");var D=F>-1&&u[F][T];if(!D||!D[1])throw new Error("SYLK shared formula cannot find base");u[s][l][1]=ei(D[1],{r:s-F,c:l-T});}break;case"F":var M=0;for(f=1;f<y.length;++f)switch(y[f].charAt(0)){case"X":l=parseInt(y[f].slice(1))-1;++M;break;case"Y":s=parseInt(y[f].slice(1))-1;for(w=u.length;w<=s;++w)u[w]=[];break;case"M":b=parseInt(y[f].slice(1))/20;break;case"F":break;case"G":break;case"P":d=h[parseInt(y[f].slice(1))];break;case"S":break;case"D":break;case"N":break;case"W":g=y[f].slice(1).split(" ");for(w=parseInt(g[0],10);w<=parseInt(g[1],10);++w){b=parseInt(g[2],10);v[w-1]=b===0?{hidden:true}:{wch:b};nn(v[w-1]);}break;case"C":l=parseInt(y[f].slice(1))-1;if(!v[l])v[l]={};break;case"R":s=parseInt(y[f].slice(1))-1;if(!m[s])m[s]={};if(b>0){m[s].hpt=b;m[s].hpx=cn(b);}else if(b===0)m[s].hidden=true;break;default:if(n&&n.WTF)throw new Error("SYLK bad record "+k);}if(M<1)d=null;break;default:if(n&&n.WTF)throw new Error("SYLK bad record "+k);}}if(m.length>0)p["!rows"]=m;if(v.length>0)p["!cols"]=v;if(n&&n.sheetRows)u=u.slice(0,n.sheetRows);return [u,p]}function s(e,r){var t=n(e,r);var a=t[0],i=t[1];var s=St(a,r);Y(i).forEach(function(e){s[e]=i[e];});return s}function l(e,r){return yt(s(e,r),r)}function c(e,r,t,a){var n="C;Y"+(t+1)+";X"+(a+1)+";K";switch(e.t){case"n":n+=e.v||0;if(e.f&&!e.F)n+=";E"+Qn(e.f,{r:t,c:a});break;case"b":n+=e.v?"TRUE":"FALSE";break;case"e":n+=e.w||e.v;break;case"d":n+='"'+(e.w||e.v)+'"';break;case"s":n+='"'+e.v.replace(/"/g,"")+'"';break;}return n}function f(e,r){r.forEach(function(r,t){var a="F;W"+(t+1)+" "+(t+1)+" ";if(r.hidden)a+="0";else {if(typeof r.width=="number"&&!r.wpx)r.wpx=Qa(r.width);if(typeof r.wpx=="number"&&!r.wch)r.wch=en(r.wpx);if(typeof r.wch=="number")a+=Math.round(r.wch);}if(a.charAt(a.length-1)!=" ")e.push(a);});}function u(e,r){r.forEach(function(r,t){var a="F;";if(r.hidden)a+="M0;";else if(r.hpt)a+="M"+20*r.hpt+";";else if(r.hpx)a+="M"+20*on(r.hpx)+";";if(a.length>2)e.push(a+"R"+(t+1));});}function h(e,r){var t=["ID;PWXL;N;E"],a=[];var n=bt(e["!ref"]),i;var s=Array.isArray(e);var l="\r\n";t.push("P;PGeneral");t.push("F;P0;DG0G8;M255");if(e["!cols"])f(t,e["!cols"]);if(e["!rows"])u(t,e["!rows"]);t.push("B;Y"+(n.e.r-n.s.r+1)+";X"+(n.e.c-n.s.c+1)+";D"+[n.s.c,n.s.r,n.e.c,n.e.r].join(" "));for(var o=n.s.r;o<=n.e.r;++o){for(var h=n.s.c;h<=n.e.c;++h){var d=mt({r:o,c:h});i=s?(e[o]||[])[h]:e[d];if(!i||i.v==null&&(!i.f||i.F))continue;a.push(c(i,e,o,h));}}return t.join(l)+l+a.join(l)+l+"E"+l}return {to_workbook:l,to_sheet:s,from_sheet:h}}();var Ea=function(){function e(e,t){switch(t.type){case"base64":return r(b.decode(e),t);case"binary":return r(e,t);case"buffer":return r(w&&Buffer.isBuffer(e)?e.toString("binary"):E(e),t);case"array":return r(ce(e),t);}throw new Error("Unrecognized type "+t.type)}function r(e,r){var t=e.split("\n"),a=-1,n=-1,i=0,s=[];for(;i!==t.length;++i){if(t[i].trim()==="BOT"){s[++a]=[];n=0;continue}if(a<0)continue;var l=t[i].trim().split(",");var o=l[0],c=l[1];++i;var f=t[i]||"";while((f.match(/["]/g)||[]).length&1&&i<t.length-1)f+="\n"+t[++i];f=f.trim();switch(+o){case-1:if(f==="BOT"){s[++a]=[];n=0;continue}else if(f!=="EOD")throw new Error("Unrecognized DIF special command "+f);break;case 0:if(f==="TRUE")s[a][n]=true;else if(f==="FALSE")s[a][n]=false;else if(!isNaN(he(c)))s[a][n]=he(c);else if(!isNaN(de(c).getDate()))s[a][n]=oe(c);else s[a][n]=c;++n;break;case 1:f=f.slice(1,f.length-1);f=f.replace(/""/g,'"');if(f&&f.match(/^=".*"$/))f=f.slice(2,-1);s[a][n++]=f!==""?f:null;break;}if(f==="EOD")break}if(r&&r.sheetRows)s=s.slice(0,r.sheetRows);return s}function t(r,t){return St(e(r,t),t)}function a(e,r){return yt(t(e,r),r)}var n=function(){var e=function t(e,r,a,n,i){e.push(r);e.push(a+","+n);e.push('"'+i.replace(/"/g,'""')+'"');};var r=function a(e,r,t,n){e.push(r+","+t);e.push(r==1?'"'+n.replace(/"/g,'""')+'"':n);};return function n(t){var a=[];var n=bt(t["!ref"]),i;var s=Array.isArray(t);e(a,"TABLE",0,1,"sheetjs");e(a,"VECTORS",0,n.e.r-n.s.r+1,"");e(a,"TUPLES",0,n.e.c-n.s.c+1,"");e(a,"DATA",0,0,"");for(var l=n.s.r;l<=n.e.r;++l){r(a,-1,0,"BOT");for(var o=n.s.c;o<=n.e.c;++o){var c=mt({r:l,c:o});i=s?(t[l]||[])[o]:t[c];if(!i){r(a,1,0,"");continue}switch(i.t){case"n":var f=i.w;if(!f&&i.v!=null)f=i.v;if(f==null){if(i.f&&!i.F)r(a,1,0,"="+i.f);else r(a,1,0,"");}else r(a,0,f,"V");break;case"b":r(a,0,i.v?1:0,i.v?"TRUE":"FALSE");break;case"s":r(a,1,0,isNaN(i.v)?i.v:'="'+i.v+'"');break;case"d":if(!i.w)i.w=N.format(i.z||N._table[14],ee(oe(i.v)));r(a,0,i.w,"V");break;default:r(a,1,0,"");}}}r(a,-1,0,"EOD");var u="\r\n";var h=a.join(u);return h}}();return {to_workbook:a,to_sheet:t,from_sheet:n}}();var Fa=function(){function e(e){return e.replace(/\\b/g,"\\").replace(/\\c/g,":").replace(/\\n/g,"\n")}function r(e){return e.replace(/\\/g,"\\b").replace(/:/g,"\\c").replace(/\n/g,"\\n")}function t(r,t){var a=r.split("\n"),n=-1,i=-1,s=0,l=[];for(;s!==a.length;++s){var o=a[s].trim().split(":");if(o[0]!=="cell")continue;var c=pt(o[1]);if(l.length<=c.r)for(n=l.length;n<=c.r;++n)if(!l[n])l[n]=[];n=c.r;i=c.c;switch(o[2]){case"t":l[n][i]=e(o[3]);break;case"v":l[n][i]=+o[3];break;case"vtf":var f=o[o.length-1];case"vtc":switch(o[3]){case"nl":l[n][i]=+o[4]?true:false;break;default:l[n][i]=+o[4];break;}if(o[2]=="vtf")l[n][i]=[l[n][i],f];}}if(t&&t.sheetRows)l=l.slice(0,t.sheetRows);return l}function a(e,r){return St(t(e,r),r)}function n(e,r){return yt(a(e,r),r)}var i=["socialcalc:version:1.5","MIME-Version: 1.0","Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"].join("\n");var s=["--SocialCalcSpreadsheetControlSave","Content-type: text/plain; charset=UTF-8"].join("\n")+"\n";var l=["# SocialCalc Spreadsheet Control Save","part:sheet"].join("\n");var o="--SocialCalcSpreadsheetControlSave--";function c(e){if(!e||!e["!ref"])return "";var t=[],a=[],n,i="";var s=vt(e["!ref"]);var l=Array.isArray(e);for(var o=s.s.r;o<=s.e.r;++o){for(var c=s.s.c;c<=s.e.c;++c){i=mt({r:o,c:c});n=l?(e[o]||[])[c]:e[i];if(!n||n.v==null||n.t==="z")continue;a=["cell",i,"t"];switch(n.t){case"s":case"str":a.push(r(n.v));break;case"n":if(!n.f){a[2]="v";a[3]=n.v;}else {a[2]="vtf";a[3]="n";a[4]=n.v;a[5]=r(n.f);}break;case"b":a[2]="vt"+(n.f?"f":"c");a[3]="nl";a[4]=n.v?"1":"0";a[5]=r(n.f||(n.v?"TRUE":"FALSE"));break;case"d":var f=ee(oe(n.v));a[2]="vtc";a[3]="nd";a[4]=""+f;a[5]=n.w||N.format(n.z||N._table[14],f);break;case"e":continue;}t.push(a.join(":"));}}t.push("sheet:c:"+(s.e.c-s.s.c+1)+":r:"+(s.e.r-s.s.r+1)+":tvf:1");t.push("valueformat:1:text-wiki");return t.join("\n")}function f(e){return [i,s,l,s,c(e),o].join("\n")}return {to_workbook:n,to_sheet:a,from_sheet:f}}();var Ta=function(){function e(e,r,t,a,n){if(n.raw)r[t][a]=e;else if(e==="");else if(e==="TRUE")r[t][a]=true;else if(e==="FALSE")r[t][a]=false;else if(!isNaN(he(e)))r[t][a]=he(e);else if(!isNaN(de(e).getDate()))r[t][a]=oe(e);else r[t][a]=e;}function r(r,t){var a=t||{};var n=[];if(!r||r.length===0)return n;var i=r.split(/[\r\n]/);var s=i.length-1;while(s>=0&&i[s].length===0)--s;var l=10,o=0;var c=0;for(;c<=s;++c){o=i[c].indexOf(" ");if(o==-1)o=i[c].length;else o++;l=Math.max(l,o);}for(c=0;c<=s;++c){n[c]=[];var f=0;e(i[c].slice(0,l).trim(),n,c,f,a);for(f=1;f<=(i[c].length-l)/10+1;++f)e(i[c].slice(l+(f-1)*10,l+f*10).trim(),n,c,f,a);}if(a.sheetRows)n=n.slice(0,a.sheetRows);return n}var t={44:",",9:"\t",59:";",124:"|"};var a={44:3,9:2,59:1,124:0};function n(e){var r={},n=false,i=0,s=0;for(;i<e.length;++i){if((s=e.charCodeAt(i))==34)n=!n;else if(!n&&s in t)r[s]=(r[s]||0)+1;}s=[];for(i in r)if(Object.prototype.hasOwnProperty.call(r,i)){s.push([r[i],i]);}if(!s.length){r=a;for(i in r)if(Object.prototype.hasOwnProperty.call(r,i)){s.push([r[i],i]);}}s.sort(function(e,r){return e[0]-r[0]||a[e[1]]-a[r[1]]});return t[s.pop()[1]]||44}function i(e,r){var t=r||{};var a="";var i=t.dense?[]:{};var s={s:{c:0,r:0},e:{c:0,r:0}};if(e.slice(0,4)=="sep="){if(e.charCodeAt(5)==13&&e.charCodeAt(6)==10){a=e.charAt(4);e=e.slice(7);}else if(e.charCodeAt(5)==13||e.charCodeAt(5)==10){a=e.charAt(4);e=e.slice(6);}else a=n(e.slice(0,1024));}else if(t&&t.FS)a=t.FS;else a=n(e.slice(0,1024));var l=0,o=0,c=0;var f=0,u=0,h=a.charCodeAt(0),d=false,p=0,m=e.charCodeAt(0);e=e.replace(/\r\n/gm,"\n");var g=t.dateNF!=null?B(t.dateNF):null;function b(){var r=e.slice(f,u);var a={};if(r.charAt(0)=='"'&&r.charAt(r.length-1)=='"')r=r.slice(1,-1).replace(/""/g,'"');if(r.length===0)a.t="z";else if(t.raw){a.t="s";a.v=r;}else if(r.trim().length===0){a.t="s";a.v=r;}else if(r.charCodeAt(0)==61){if(r.charCodeAt(1)==34&&r.charCodeAt(r.length-1)==34){a.t="s";a.v=r.slice(2,-1).replace(/""/g,'"');}else if(ti(r)){a.t="n";a.f=r.slice(1);}else {a.t="s";a.v=r;}}else if(r=="TRUE"){a.t="b";a.v=true;}else if(r=="FALSE"){a.t="b";a.v=false;}else if(!isNaN(c=he(r))){a.t="n";if(t.cellText!==false)a.w=r;a.v=c;}else if(!isNaN(de(r).getDate())||g&&r.match(g)){a.z=t.dateNF||N._table[14];var n=0;if(g&&r.match(g)){r=z(r,t.dateNF,r.match(g)||[]);n=1;}if(t.cellDates){a.t="d";a.v=oe(r,n);}else {a.t="n";a.v=ee(oe(r,n));}if(t.cellText!==false)a.w=N.format(a.z,a.v instanceof Date?ee(a.v):a.v);if(!t.cellNF)delete a.z;}else {a.t="s";a.v=r;}if(a.t=="z");else if(t.dense){if(!i[l])i[l]=[];i[l][o]=a;}else i[mt({c:o,r:l})]=a;f=u+1;m=e.charCodeAt(f);if(s.e.c<o)s.e.c=o;if(s.e.r<l)s.e.r=l;if(p==h)++o;else {o=0;++l;if(t.sheetRows&&t.sheetRows<=l)return true}}e:for(;u<e.length;++u)switch(p=e.charCodeAt(u)){case 34:if(m===34)d=!d;break;case h:case 10:case 13:if(!d&&b())break e;break;}if(u-f>0)b();i["!ref"]=gt(s);return i}function s(e,t){if(!(t&&t.PRN))return i(e,t);if(t.FS)return i(e,t);if(e.slice(0,4)=="sep=")return i(e,t);if(e.indexOf("\t")>=0||e.indexOf(",")>=0||e.indexOf(";")>=0)return i(e,t);return St(r(e,t),t)}function l(e,r){var t="",a=r.type=="string"?[0,0,0,0]:pl(e,r);switch(r.type){case"base64":t=b.decode(e);break;case"binary":t=e;break;case"buffer":if(r.codepage==65001)t=e.toString("utf8");else if(r.codepage&&typeof cptable!=="undefined")t=cptable.utils.decode(r.codepage,e);else t=w&&Buffer.isBuffer(e)?e.toString("binary"):E(e);break;case"array":t=ce(e);break;case"string":t=e;break;default:throw new Error("Unrecognized type "+r.type);}if(a[0]==239&&a[1]==187&&a[2]==191)t=Ke(t.slice(3));else if(r.type!="string"&&r.codepage==65001)t=Ke(t);else if(r.type=="binary"&&typeof cptable!=="undefined"&&r.codepage)t=cptable.utils.decode(r.codepage,cptable.utils.encode(28591,t));if(t.slice(0,19)=="socialcalc:version:")return Fa.to_sheet(r.type=="string"?t:Ke(t),r);return s(t,r)}function o(e,r){return yt(l(e,r),r)}function c(e){var r=[];var t=bt(e["!ref"]),a;var n=Array.isArray(e);for(var i=t.s.r;i<=t.e.r;++i){var s=[];for(var l=t.s.c;l<=t.e.c;++l){var o=mt({r:i,c:l});a=n?(e[i]||[])[l]:e[o];if(!a||a.v==null){s.push("          ");continue}var c=(a.w||(kt(a),a.w)||"").slice(0,10);while(c.length<10)c+=" ";s.push(c+(l===0?" ":""));}r.push(s.join(""));}return r.join("\n")}return {to_workbook:o,to_sheet:l,from_sheet:c}}();function Oa(e,r){var t=r||{},a=!!t.WTF;t.WTF=true;try{var n=Aa.to_workbook(e,t);t.WTF=a;return n}catch(i){t.WTF=a;if(!i.message.match(/SYLK bad record ID/)&&a)throw i;return Ta.to_workbook(e,r)}}function Da(e){var r={},t=e.match(De),a=0;var n=false;if(t)for(;a!=t.length;++a){var s=Re(t[a]);switch(s[0].replace(/\w*:/g,"")){case"<condense":break;case"<extend":break;case"<shadow":if(!s.val)break;case"<shadow>":case"<shadow/>":r.shadow=1;break;case"</shadow>":break;case"<charset":if(s.val=="1")break;r.cp=i[parseInt(s.val,10)];break;case"<outline":if(!s.val)break;case"<outline>":case"<outline/>":r.outline=1;break;case"</outline>":break;case"<rFont":r.name=s.val;break;case"<sz":r.sz=s.val;break;case"<strike":if(!s.val)break;case"<strike>":case"<strike/>":r.strike=1;break;case"</strike>":break;case"<u":if(!s.val)break;switch(s.val){case"double":r.uval="double";break;case"singleAccounting":r.uval="single-accounting";break;case"doubleAccounting":r.uval="double-accounting";break;}case"<u>":case"<u/>":r.u=1;break;case"</u>":break;case"<b":if(s.val=="0")break;case"<b>":case"<b/>":r.b=1;break;case"</b>":break;case"<i":if(s.val=="0")break;case"<i>":case"<i/>":r.i=1;break;case"</i>":break;case"<color":if(s.rgb)r.color=s.rgb.slice(2,8);break;case"<family":r.family=s.val;break;case"<vertAlign":r.valign=s.val;break;case"<scheme":break;case"<extLst":case"<extLst>":case"</extLst>":break;case"<ext":n=true;break;case"</ext>":n=false;break;default:if(s[0].charCodeAt(1)!==47&&!n)throw new Error("Unrecognized rich format "+s[0]);}}return r}var Ma=function(){var e=er("t"),r=er("rPr");function t(t){var a=t.match(e);if(!a)return {t:"s",v:""};var n={t:"s",v:Be(a[1])};var i=t.match(r);if(i)n.s=Da(i[1]);return n}var a=/<(?:\w+:)?r>/g,n=/<\/(?:\w+:)?r>/;return function i(e){return e.replace(a,"").split(n).map(t).filter(function(e){return e.v})}}();var Na=function co(){var e=/(\r\n|\n)/g;function r(e,r,t){var a=[];if(e.u)a.push("text-decoration: underline;");if(e.uval)a.push("text-underline-style:"+e.uval+";");if(e.sz)a.push("font-size:"+e.sz+"pt;");if(e.outline)a.push("text-effect: outline;");if(e.shadow)a.push("text-shadow: auto;");r.push('<span style="'+a.join("")+'">');if(e.b){r.push("<b>");t.push("</b>");}if(e.i){r.push("<i>");t.push("</i>");}if(e.strike){r.push("<s>");t.push("</s>");}var n=e.valign||"";if(n=="superscript"||n=="super")n="sup";else if(n=="subscript")n="sub";if(n!=""){r.push("<"+n+">");t.push("</"+n+">");}t.push("</span>");return e}function t(t){var a=[[],t.v,[]];if(!t.v)return "";if(t.s)r(t.s,a[0],a[2]);return a[0].join("")+a[1].replace(e,"<br/>")+a[2].join("")}return function a(e){return e.map(t).join("")}}();var Ra=/<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g,Pa=/<(?:\w+:)?r>/;var Ia=/<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;function La(e,r){var t=r?r.cellHTML:true;var a={};if(!e)return {t:""};if(e.match(/^\s*<(?:\w+:)?t[^>]*>/)){a.t=Be(Ke(e.slice(e.indexOf(">")+1).split(/<\/(?:\w+:)?t>/)[0]||""));a.r=Ke(e);if(t)a.h=He(a.t);}else if(e.match(Pa)){a.r=Ke(e);a.t=Be(Ke((e.replace(Ia,"").match(Ra)||[]).join("").replace(De,"")));if(t)a.h=Na(Ma(a.r));}return a}var Ba=/<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;var za=/<(?:\w+:)?(?:si|sstItem)>/g;var Wa=/<\/(?:\w+:)?(?:si|sstItem)>/;function $a(e,r){var t=[],a="";if(!e)return t;var n=e.match(Ba);if(n){a=n[2].replace(za,"").split(Wa);for(var i=0;i!=a.length;++i){var s=La(a[i].trim(),r);if(s!=null)t[t.length]=s;}n=Re(n[1]);t.Count=n.count;t.Unique=n.uniqueCount;}return t}ta.SST="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings";var Ua=/^\s|\s$|[\t\n\r]/;function ja(e,r){if(!r.bookSST)return "";var t=[Te];t[t.length]=cr("sst",null,{xmlns:hr.main[0],count:e.Count,uniqueCount:e.Unique});for(var a=0;a!=e.length;++a){if(e[a]==null)continue;var n=e[a];var i="<si>";if(n.r)i+=n.r;else {i+="<t";if(!n.t)n.t="";if(n.t.match(Ua))i+=' xml:space="preserve"';i+=">"+$e(n.t)+"</t>";}i+="</si>";t[t.length]=i;}if(t.length>2){t[t.length]="</sst>";t[1]=t[1].replace("/>",">");}return t.join("")}function Ha(e){var r=e.slice(e[0]==="#"?1:0).slice(0,6);return [parseInt(r.slice(0,2),16),parseInt(r.slice(2,4),16),parseInt(r.slice(4,6),16)]}function Xa(e){for(var r=0,t=1;r!=3;++r)t=t*256+(e[r]>255?255:e[r]<0?0:e[r]);return t.toString(16).toUpperCase().slice(1)}function Va(e){var r=e[0]/255,t=e[1]/255,a=e[2]/255;var n=Math.max(r,t,a),i=Math.min(r,t,a),s=n-i;if(s===0)return [0,0,r];var l=0,o=0,c=n+i;o=s/(c>1?2-c:c);switch(n){case r:l=((t-a)/s+6)%6;break;case t:l=(a-r)/s+2;break;case a:l=(r-t)/s+4;break;}return [l/6,o,c/2]}function Ga(e){var r=e[0],t=e[1],a=e[2];var n=t*2*(a<.5?a:1-a),i=a-n/2;var s=[i,i,i],l=6*r;var o;if(t!==0)switch(l|0){case 0:case 6:o=n*l;s[0]+=n;s[1]+=o;break;case 1:o=n*(2-l);s[0]+=o;s[1]+=n;break;case 2:o=n*(l-2);s[1]+=n;s[2]+=o;break;case 3:o=n*(4-l);s[1]+=o;s[2]+=n;break;case 4:o=n*(l-4);s[2]+=n;s[0]+=o;break;case 5:o=n*(6-l);s[2]+=o;s[0]+=n;break;}for(var c=0;c!=3;++c)s[c]=Math.round(s[c]*255);return s}function Ya(e,r){if(r===0)return e;var t=Va(Ha(e));if(r<0)t[2]=t[2]*(1+r);else t[2]=1-(1-t[2])*(1-r);return Xa(Ga(t))}var Ka=6,Ja=15,qa=1,Za=Ka;function Qa(e){return Math.floor((e+Math.round(128/Za)/256)*Za)}function en(e){return Math.floor((e-5)/Za*100+.5)/100}function rn(e){return Math.round((e*Za+5)/Za*256)/256}function tn(e){return rn(en(Qa(e)))}function an(e){var r=Math.abs(e-tn(e)),t=Za;if(r>.005)for(Za=qa;Za<Ja;++Za)if(Math.abs(e-tn(e))<=r){r=Math.abs(e-tn(e));t=Za;}Za=t;}function nn(e){if(e.width){e.wpx=Qa(e.width);e.wch=en(e.wpx);e.MDW=Za;}else if(e.wpx){e.wch=en(e.wpx);e.width=rn(e.wch);e.MDW=Za;}else if(typeof e.wch=="number"){e.width=rn(e.wch);e.wpx=Qa(e.width);e.MDW=Za;}if(e.customWidth)delete e.customWidth;}var sn=96,ln=sn;function on(e){return e*96/ln}function cn(e){return e*ln/96}function un(e,r,t,a){r.Borders=[];var n={};var i=false;(e[0].match(De)||[]).forEach(function(e){var t=Re(e);switch(Pe(t[0])){case"<borders":case"<borders>":case"</borders>":break;case"<border":case"<border>":case"<border/>":n={};if(t.diagonalUp)n.diagonalUp=Ye(t.diagonalUp);if(t.diagonalDown)n.diagonalDown=Ye(t.diagonalDown);r.Borders.push(n);break;case"</border>":break;case"<left/>":break;case"<left":case"<left>":break;case"</left>":break;case"<right/>":break;case"<right":case"<right>":break;case"</right>":break;case"<top/>":break;case"<top":case"<top>":break;case"</top>":break;case"<bottom/>":break;case"<bottom":case"<bottom>":break;case"</bottom>":break;case"<diagonal":case"<diagonal>":case"<diagonal/>":break;case"</diagonal>":break;case"<horizontal":case"<horizontal>":case"<horizontal/>":break;case"</horizontal>":break;case"<vertical":case"<vertical>":case"<vertical/>":break;case"</vertical>":break;case"<start":case"<start>":case"<start/>":break;case"</start>":break;case"<end":case"<end>":case"<end/>":break;case"</end>":break;case"<color":case"<color>":break;case"<color/>":case"</color>":break;case"<extLst":case"<extLst>":case"</extLst>":break;case"<ext":i=true;break;case"</ext>":i=false;break;default:if(a&&a.WTF){if(!i)throw new Error("unrecognized "+t[0]+" in borders")}}});}function hn(e,r,t,a){r.Fills=[];var n={};var i=false;(e[0].match(De)||[]).forEach(function(e){var t=Re(e);switch(Pe(t[0])){case"<fills":case"<fills>":case"</fills>":break;case"<fill>":case"<fill":case"<fill/>":n={};r.Fills.push(n);break;case"</fill>":break;case"<gradientFill>":break;case"<gradientFill":case"</gradientFill>":r.Fills.push(n);n={};break;case"<patternFill":case"<patternFill>":if(t.patternType)n.patternType=t.patternType;break;case"<patternFill/>":case"</patternFill>":break;case"<bgColor":if(!n.bgColor)n.bgColor={};if(t.indexed)n.bgColor.indexed=parseInt(t.indexed,10);if(t.theme)n.bgColor.theme=parseInt(t.theme,10);if(t.tint)n.bgColor.tint=parseFloat(t.tint);if(t.rgb)n.bgColor.rgb=t.rgb.slice(-6);break;case"<bgColor/>":case"</bgColor>":
	break;case"<fgColor":if(!n.fgColor)n.fgColor={};if(t.theme)n.fgColor.theme=parseInt(t.theme,10);if(t.tint)n.fgColor.tint=parseFloat(t.tint);if(t.rgb!=null)n.fgColor.rgb=t.rgb.slice(-6);break;case"<fgColor/>":case"</fgColor>":break;case"<stop":case"<stop/>":break;case"</stop>":break;case"<color":case"<color/>":break;case"</color>":break;case"<extLst":case"<extLst>":case"</extLst>":break;case"<ext":i=true;break;case"</ext>":i=false;break;default:if(a&&a.WTF){if(!i)throw new Error("unrecognized "+t[0]+" in fills")}}});}function dn(e,r,t,a){r.Fonts=[];var n={};var s=false;(e[0].match(De)||[]).forEach(function(e){var l=Re(e);switch(Pe(l[0])){case"<fonts":case"<fonts>":case"</fonts>":break;case"<font":case"<font>":break;case"</font>":case"<font/>":r.Fonts.push(n);n={};break;case"<name":if(l.val)n.name=Ke(l.val);break;case"<name/>":case"</name>":break;case"<b":n.bold=l.val?Ye(l.val):1;break;case"<b/>":n.bold=1;break;case"<i":n.italic=l.val?Ye(l.val):1;break;case"<i/>":n.italic=1;break;case"<u":switch(l.val){case"none":n.underline=0;break;case"single":n.underline=1;break;case"double":n.underline=2;break;case"singleAccounting":n.underline=33;break;case"doubleAccounting":n.underline=34;break;}break;case"<u/>":n.underline=1;break;case"<strike":n.strike=l.val?Ye(l.val):1;break;case"<strike/>":n.strike=1;break;case"<outline":n.outline=l.val?Ye(l.val):1;break;case"<outline/>":n.outline=1;break;case"<shadow":n.shadow=l.val?Ye(l.val):1;break;case"<shadow/>":n.shadow=1;break;case"<condense":n.condense=l.val?Ye(l.val):1;break;case"<condense/>":n.condense=1;break;case"<extend":n.extend=l.val?Ye(l.val):1;break;case"<extend/>":n.extend=1;break;case"<sz":if(l.val)n.sz=+l.val;break;case"<sz/>":case"</sz>":break;case"<vertAlign":if(l.val)n.vertAlign=l.val;break;case"<vertAlign/>":case"</vertAlign>":break;case"<family":if(l.val)n.family=parseInt(l.val,10);break;case"<family/>":case"</family>":break;case"<scheme":if(l.val)n.scheme=l.val;break;case"<scheme/>":case"</scheme>":break;case"<charset":if(l.val=="1")break;l.codepage=i[parseInt(l.val,10)];break;case"<color":if(!n.color)n.color={};if(l.auto)n.color.auto=Ye(l.auto);if(l.rgb)n.color.rgb=l.rgb.slice(-6);else if(l.indexed){n.color.index=parseInt(l.indexed,10);var o=Xt[n.color.index];if(n.color.index==81)o=Xt[1];if(!o)o=Xt[1];n.color.rgb=o[0].toString(16)+o[1].toString(16)+o[2].toString(16);}else if(l.theme){n.color.theme=parseInt(l.theme,10);if(l.tint)n.color.tint=parseFloat(l.tint);if(l.theme&&t.themeElements&&t.themeElements.clrScheme){n.color.rgb=Ya(t.themeElements.clrScheme[n.color.theme].rgb,n.color.tint||0);}}break;case"<color/>":case"</color>":break;case"<AlternateContent":s=true;break;case"</AlternateContent>":s=false;break;case"<extLst":case"<extLst>":case"</extLst>":break;case"<ext":s=true;break;case"</ext>":s=false;break;default:if(a&&a.WTF){if(!s)throw new Error("unrecognized "+l[0]+" in fonts")}}});}function pn(e,r,t){r.NumberFmt=[];var a=Y(N._table);for(var n=0;n<a.length;++n)r.NumberFmt[a[n]]=N._table[a[n]];var i=e[0].match(De);if(!i)return;for(n=0;n<i.length;++n){var s=Re(i[n]);switch(Pe(s[0])){case"<numFmts":case"</numFmts>":case"<numFmts/>":case"<numFmts>":break;case"<numFmt":{var l=Be(Ke(s.formatCode)),o=parseInt(s.numFmtId,10);r.NumberFmt[o]=l;if(o>0){if(o>392){for(o=392;o>60;--o)if(r.NumberFmt[o]==null)break;r.NumberFmt[o]=l;}N.load(l,o);}}break;case"</numFmt>":break;default:if(t.WTF)throw new Error("unrecognized "+s[0]+" in numFmts");}}}function mn(e){var r=["<numFmts>"];[[5,8],[23,26],[41,44],[50,392]].forEach(function(t){for(var a=t[0];a<=t[1];++a)if(e[a]!=null)r[r.length]=cr("numFmt",null,{numFmtId:a,formatCode:$e(e[a])});});if(r.length===1)return "";r[r.length]="</numFmts>";r[0]=cr("numFmts",null,{count:r.length-2}).replace("/>",">");return r.join("")}var vn=["numFmtId","fillId","fontId","borderId","xfId"];var gn=["applyAlignment","applyBorder","applyFill","applyFont","applyNumberFormat","applyProtection","pivotButton","quotePrefix"];function bn(e,r,t){r.CellXf=[];var a;var n=false;(e[0].match(De)||[]).forEach(function(e){var i=Re(e),s=0;switch(Pe(i[0])){case"<cellXfs":case"<cellXfs>":case"<cellXfs/>":case"</cellXfs>":break;case"<xf":case"<xf/>":a=i;delete a[0];for(s=0;s<vn.length;++s)if(a[vn[s]])a[vn[s]]=parseInt(a[vn[s]],10);for(s=0;s<gn.length;++s)if(a[gn[s]])a[gn[s]]=Ye(a[gn[s]]);if(r.NumberFmt&&a.numFmtId>392){for(s=392;s>60;--s)if(r.NumberFmt[a.numFmtId]==r.NumberFmt[s]){a.numFmtId=s;break}}r.CellXf.push(a);break;case"</xf>":break;case"<alignment":case"<alignment/>":var l={};if(i.vertical)l.vertical=i.vertical;if(i.horizontal)l.horizontal=i.horizontal;if(i.textRotation!=null)l.textRotation=i.textRotation;if(i.indent)l.indent=i.indent;if(i.wrapText)l.wrapText=Ye(i.wrapText);a.alignment=l;break;case"</alignment>":break;case"<protection":break;case"</protection>":case"<protection/>":break;case"<AlternateContent":n=true;break;case"</AlternateContent>":n=false;break;case"<extLst":case"<extLst>":case"</extLst>":break;case"<ext":n=true;break;case"</ext>":n=false;break;default:if(t&&t.WTF){if(!n)throw new Error("unrecognized "+i[0]+" in cellXfs")}}});}function wn(e){var r=[];r[r.length]=cr("cellXfs",null);e.forEach(function(e){r[r.length]=cr("xf",null,e);});r[r.length]="</cellXfs>";if(r.length===2)return "";r[0]=cr("cellXfs",null,{count:r.length-2}).replace("/>",">");return r.join("")}var kn=function fo(){var e=/<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;var r=/<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;var t=/<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;var a=/<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;var n=/<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;return function i(s,l,o){var c={};if(!s)return c;s=s.replace(/<!--([\s\S]*?)-->/gm,"").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm,"");var f;if(f=s.match(e))pn(f,c,o);if(f=s.match(a))dn(f,c,l,o);if(f=s.match(t))hn(f,c,l,o);if(f=s.match(n))un(f,c,l,o);if(f=s.match(r))bn(f,c,o);return c}}();var yn=cr("styleSheet",null,{xmlns:hr.main[0],"xmlns:vt":hr.vt});ta.STY="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles";function xn(e,r){var t=[Te,yn],a;if(e.SSF&&(a=mn(e.SSF))!=null)t[t.length]=a;t[t.length]='<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';t[t.length]='<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';t[t.length]='<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';t[t.length]='<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';if(a=wn(r.cellXfs))t[t.length]=a;t[t.length]='<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';t[t.length]='<dxfs count="0"/>';t[t.length]='<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';if(t.length>2){t[t.length]="</styleSheet>";t[1]=t[1].replace("/>",">");}return t.join("")}ta.THEME="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";var Sn=["</a:lt1>","</a:dk1>","</a:lt2>","</a:dk2>","</a:accent1>","</a:accent2>","</a:accent3>","</a:accent4>","</a:accent5>","</a:accent6>","</a:hlink>","</a:folHlink>"];function _n(e,r,t){r.themeElements.clrScheme=[];var a={};(e[0].match(De)||[]).forEach(function(e){var n=Re(e);switch(n[0]){case"<a:clrScheme":case"</a:clrScheme>":break;case"<a:srgbClr":a.rgb=n.val;break;case"<a:sysClr":a.rgb=n.lastClr;break;case"<a:dk1>":case"</a:dk1>":case"<a:lt1>":case"</a:lt1>":case"<a:dk2>":case"</a:dk2>":case"<a:lt2>":case"</a:lt2>":case"<a:accent1>":case"</a:accent1>":case"<a:accent2>":case"</a:accent2>":case"<a:accent3>":case"</a:accent3>":case"<a:accent4>":case"</a:accent4>":case"<a:accent5>":case"</a:accent5>":case"<a:accent6>":case"</a:accent6>":case"<a:hlink>":case"</a:hlink>":case"<a:folHlink>":case"</a:folHlink>":if(n[0].charAt(1)==="/"){r.themeElements.clrScheme[Sn.indexOf(n[0])]=a;a={};}else {a.name=n[0].slice(3,n[0].length-1);}break;default:if(t&&t.WTF)throw new Error("Unrecognized "+n[0]+" in clrScheme");}});}function Cn(){}function An(){}var En=/<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;var Fn=/<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;var Tn=/<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;function On(e,r,t){r.themeElements={};var a;[["clrScheme",En,_n],["fontScheme",Fn,Cn],["fmtScheme",Tn,An]].forEach(function(n){if(!(a=e.match(n[1])))throw new Error(n[0]+" not found in themeElements");n[2](a,r,t);});}var Dn=/<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;function Mn(e,r){if(!e||e.length===0)return Mn(Nn());var t;var a={};if(!(t=e.match(Dn)))throw new Error("themeElements not found in theme");On(t[0],a,r);a.raw=e;return a}function Nn(e,r){if(r&&r.themeXLSX)return r.themeXLSX;if(e&&typeof e.raw=="string")return e.raw;var t=[Te];t[t.length]='<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';t[t.length]="<a:themeElements>";t[t.length]='<a:clrScheme name="Office">';t[t.length]='<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';t[t.length]='<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';t[t.length]='<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';t[t.length]='<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';t[t.length]='<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';t[t.length]='<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';t[t.length]='<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';t[t.length]='<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';t[t.length]='<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';t[t.length]='<a:accent6><a:srgbClr val="F79646"/></a:accent6>';t[t.length]='<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';t[t.length]='<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';t[t.length]="</a:clrScheme>";t[t.length]='<a:fontScheme name="Office">';t[t.length]="<a:majorFont>";t[t.length]='<a:latin typeface="Cambria"/>';t[t.length]='<a:ea typeface=""/>';t[t.length]='<a:cs typeface=""/>';t[t.length]='<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';t[t.length]='<a:font script="Hang" typeface="맑은 고딕"/>';t[t.length]='<a:font script="Hans" typeface="宋体"/>';t[t.length]='<a:font script="Hant" typeface="新細明體"/>';t[t.length]='<a:font script="Arab" typeface="Times New Roman"/>';t[t.length]='<a:font script="Hebr" typeface="Times New Roman"/>';t[t.length]='<a:font script="Thai" typeface="Tahoma"/>';t[t.length]='<a:font script="Ethi" typeface="Nyala"/>';t[t.length]='<a:font script="Beng" typeface="Vrinda"/>';t[t.length]='<a:font script="Gujr" typeface="Shruti"/>';t[t.length]='<a:font script="Khmr" typeface="MoolBoran"/>';t[t.length]='<a:font script="Knda" typeface="Tunga"/>';t[t.length]='<a:font script="Guru" typeface="Raavi"/>';t[t.length]='<a:font script="Cans" typeface="Euphemia"/>';t[t.length]='<a:font script="Cher" typeface="Plantagenet Cherokee"/>';t[t.length]='<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';t[t.length]='<a:font script="Tibt" typeface="Microsoft Himalaya"/>';t[t.length]='<a:font script="Thaa" typeface="MV Boli"/>';t[t.length]='<a:font script="Deva" typeface="Mangal"/>';t[t.length]='<a:font script="Telu" typeface="Gautami"/>';t[t.length]='<a:font script="Taml" typeface="Latha"/>';t[t.length]='<a:font script="Syrc" typeface="Estrangelo Edessa"/>';t[t.length]='<a:font script="Orya" typeface="Kalinga"/>';t[t.length]='<a:font script="Mlym" typeface="Kartika"/>';t[t.length]='<a:font script="Laoo" typeface="DokChampa"/>';t[t.length]='<a:font script="Sinh" typeface="Iskoola Pota"/>';t[t.length]='<a:font script="Mong" typeface="Mongolian Baiti"/>';t[t.length]='<a:font script="Viet" typeface="Times New Roman"/>';t[t.length]='<a:font script="Uigh" typeface="Microsoft Uighur"/>';t[t.length]='<a:font script="Geor" typeface="Sylfaen"/>';t[t.length]="</a:majorFont>";t[t.length]="<a:minorFont>";t[t.length]='<a:latin typeface="Calibri"/>';t[t.length]='<a:ea typeface=""/>';t[t.length]='<a:cs typeface=""/>';t[t.length]='<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';t[t.length]='<a:font script="Hang" typeface="맑은 고딕"/>';t[t.length]='<a:font script="Hans" typeface="宋体"/>';t[t.length]='<a:font script="Hant" typeface="新細明體"/>';t[t.length]='<a:font script="Arab" typeface="Arial"/>';t[t.length]='<a:font script="Hebr" typeface="Arial"/>';t[t.length]='<a:font script="Thai" typeface="Tahoma"/>';t[t.length]='<a:font script="Ethi" typeface="Nyala"/>';t[t.length]='<a:font script="Beng" typeface="Vrinda"/>';t[t.length]='<a:font script="Gujr" typeface="Shruti"/>';t[t.length]='<a:font script="Khmr" typeface="DaunPenh"/>';t[t.length]='<a:font script="Knda" typeface="Tunga"/>';t[t.length]='<a:font script="Guru" typeface="Raavi"/>';t[t.length]='<a:font script="Cans" typeface="Euphemia"/>';t[t.length]='<a:font script="Cher" typeface="Plantagenet Cherokee"/>';t[t.length]='<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';t[t.length]='<a:font script="Tibt" typeface="Microsoft Himalaya"/>';t[t.length]='<a:font script="Thaa" typeface="MV Boli"/>';t[t.length]='<a:font script="Deva" typeface="Mangal"/>';t[t.length]='<a:font script="Telu" typeface="Gautami"/>';t[t.length]='<a:font script="Taml" typeface="Latha"/>';t[t.length]='<a:font script="Syrc" typeface="Estrangelo Edessa"/>';t[t.length]='<a:font script="Orya" typeface="Kalinga"/>';t[t.length]='<a:font script="Mlym" typeface="Kartika"/>';t[t.length]='<a:font script="Laoo" typeface="DokChampa"/>';t[t.length]='<a:font script="Sinh" typeface="Iskoola Pota"/>';t[t.length]='<a:font script="Mong" typeface="Mongolian Baiti"/>';t[t.length]='<a:font script="Viet" typeface="Arial"/>';t[t.length]='<a:font script="Uigh" typeface="Microsoft Uighur"/>';t[t.length]='<a:font script="Geor" typeface="Sylfaen"/>';t[t.length]="</a:minorFont>";t[t.length]="</a:fontScheme>";t[t.length]='<a:fmtScheme name="Office">';t[t.length]="<a:fillStyleLst>";t[t.length]='<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:lin ang="16200000" scaled="1"/>';t[t.length]="</a:gradFill>";t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:lin ang="16200000" scaled="0"/>';t[t.length]="</a:gradFill>";t[t.length]="</a:fillStyleLst>";t[t.length]="<a:lnStyleLst>";t[t.length]='<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';t[t.length]='<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';t[t.length]='<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';t[t.length]="</a:lnStyleLst>";t[t.length]="<a:effectStyleLst>";t[t.length]="<a:effectStyle>";t[t.length]="<a:effectLst>";t[t.length]='<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';t[t.length]="</a:effectLst>";t[t.length]="</a:effectStyle>";t[t.length]="<a:effectStyle>";t[t.length]="<a:effectLst>";t[t.length]='<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';t[t.length]="</a:effectLst>";t[t.length]="</a:effectStyle>";t[t.length]="<a:effectStyle>";t[t.length]="<a:effectLst>";t[t.length]='<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';t[t.length]="</a:effectLst>";t[t.length]='<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';t[t.length]='<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';t[t.length]="</a:effectStyle>";t[t.length]="</a:effectStyleLst>";t[t.length]="<a:bgFillStyleLst>";t[t.length]='<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';t[t.length]="</a:gradFill>";t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';t[t.length]="</a:gradFill>";t[t.length]="</a:bgFillStyleLst>";t[t.length]="</a:fmtScheme>";t[t.length]="</a:themeElements>";t[t.length]="<a:objectDefaults>";t[t.length]="<a:spDef>";t[t.length]='<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';t[t.length]="</a:spDef>";t[t.length]="<a:lnDef>";t[t.length]='<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';t[t.length]="</a:lnDef>";t[t.length]="</a:objectDefaults>";t[t.length]="<a:extraClrSchemeLst/>";t[t.length]="</a:theme>";return t.join("")}function Rn(){}function Pn(e,r,t,a){if(!e)return e;var n=a||{};var i=false;Zr(e,function l(e,r,t){switch(t){case 359:case 363:case 364:case 366:case 367:case 368:case 369:case 370:case 371:case 472:case 577:case 578:case 579:case 580:case 581:case 582:case 583:case 584:case 585:case 586:case 587:break;case 35:i=true;break;case 36:i=false;break;default:if((r||"").indexOf("Begin")>0);else if((r||"").indexOf("End")>0);else if(!i||n.WTF)throw new Error("Unexpected record "+t.toString(16)+" "+r);}},n);}ta.IMG="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";ta.DRAW="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing";function In(e,r){if(!e)return "??";var t=(e.match(/<c:chart [^>]*r:id="([^"]*)"/)||["",""])[1];return r["!id"][t].Target}var Ln=1024;function Bn(e,r){var t=[21600,21600];var a=["m0,0l0",t[1],t[0],t[1],t[0],"0xe"].join(",");var n=[cr("xml",null,{"xmlns:v":dr.v,"xmlns:o":dr.o,"xmlns:x":dr.x,"xmlns:mv":dr.mv}).replace(/\/>/,">"),cr("o:shapelayout",cr("o:idmap",null,{"v:ext":"edit",data:e}),{"v:ext":"edit"}),cr("v:shapetype",[cr("v:stroke",null,{joinstyle:"miter"}),cr("v:path",null,{gradientshapeok:"t","o:connecttype":"rect"})].join(""),{id:"_x0000_t202","o:spt":202,coordsize:t.join(","),path:a})];while(Ln<e*1e3)Ln+=1e3;r.forEach(function(e){var r=pt(e[0]);var t={color2:"#BEFF82",type:"gradient"};if(t.type=="gradient")t.angle="-180";var a=t.type=="gradient"?cr("o:fill",null,{type:"gradientUnscaled","v:ext":"view"}):null;var i=cr("v:fill",a,t);var s={on:"t",obscured:"t"};++Ln;n=n.concat(["<v:shape"+or({id:"_x0000_s"+Ln,type:"#_x0000_t202",style:"position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10"+(e[1].hidden?";visibility:hidden":""),fillcolor:"#ECFAD4",strokecolor:"#edeaa1"})+">",i,cr("v:shadow",null,s),cr("v:path",null,{"o:connecttype":"none"}),'<v:textbox><div style="text-align:left"></div></v:textbox>','<x:ClientData ObjectType="Note">',"<x:MoveWithCells/>","<x:SizeWithCells/>",lr("x:Anchor",[r.c+1,0,r.r+1,0,r.c+3,20,r.r+5,20].join(",")),lr("x:AutoFill","False"),lr("x:Row",String(r.r)),lr("x:Column",String(r.c)),e[1].hidden?"":"<x:Visible/>","</x:ClientData>","</v:shape>"]);});n.push("</xml>");return n.join("")}ta.CMNT="http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments";function zn(e,r){var t=Array.isArray(e);var a;r.forEach(function(r){var n=pt(r.ref);if(t){if(!e[n.r])e[n.r]=[];a=e[n.r][n.c];}else a=e[r.ref];if(!a){a={t:"z"};if(t)e[n.r][n.c]=a;else e[r.ref]=a;var i=bt(e["!ref"]||"BDWGO1000001:A1");if(i.s.r>n.r)i.s.r=n.r;if(i.e.r<n.r)i.e.r=n.r;if(i.s.c>n.c)i.s.c=n.c;if(i.e.c<n.c)i.e.c=n.c;var s=gt(i);if(s!==e["!ref"])e["!ref"]=s;}if(!a.c)a.c=[];var l={a:r.author,t:r.t,r:r.r};if(r.h)l.h=r.h;a.c.push(l);});}function Wn(e,r){if(e.match(/<(?:\w+:)?comments *\/>/))return [];var t=[];var a=[];var n=e.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);if(n&&n[1])n[1].split(/<\/\w*:?author>/).forEach(function(e){if(e===""||e.trim()==="")return;var r=e.match(/<(?:\w+:)?author[^>]*>(.*)/);if(r)t.push(r[1]);});var i=e.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);if(i&&i[1])i[1].split(/<\/\w*:?comment>/).forEach(function(e){if(e===""||e.trim()==="")return;var n=e.match(/<(?:\w+:)?comment[^>]*>/);if(!n)return;var i=Re(n[0]);var s={author:i.authorId&&t[i.authorId]||"sheetjsghost",ref:i.ref,guid:i.guid};var l=pt(i.ref);if(r.sheetRows&&r.sheetRows<=l.r)return;var o=e.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);var c=!!o&&!!o[1]&&La(o[1])||{r:"",t:"",h:""};s.r=c.r;if(c.r=="<t></t>")c.t=c.h="";s.t=(c.t||"").replace(/\r\n/g,"\n").replace(/\r/g,"\n");if(r.cellHTML)s.h=c.h;a.push(s);});return a}var $n=cr("comments",null,{xmlns:hr.main[0]});function Un(e){var r=[Te,$n];var t=[];r.push("<authors>");e.forEach(function(e){e[1].forEach(function(e){var a=$e(e.a);if(t.indexOf(a)>-1)return;t.push(a);r.push("<author>"+a+"</author>");});});r.push("</authors>");r.push("<commentList>");e.forEach(function(e){e[1].forEach(function(a){r.push('<comment ref="'+e[0]+'" authorId="'+t.indexOf($e(a.a))+'"><text>');r.push(lr("t",a.t==null?"":$e(a.t)));r.push("</text></comment>");});});r.push("</commentList>");if(r.length>2){r[r.length]="</comments>";r[1]=r[1].replace("/>",">");}return r.join("")}var jn="application/vnd.ms-office.vbaProject";var Vn=["xlsb","xlsm","xlam","biff8","xla"];ta.DS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet";ta.MS="http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet";function Gn(){return {"!type":"dialog"}}function Yn(){return {"!type":"dialog"}}function Kn(){return {"!type":"macro"}}function Jn(){return {"!type":"macro"}}var qn=function(){var e=/(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;var r={r:0,c:0};function t(e,t,a,n){var i=false,s=false;if(a.length==0)s=true;else if(a.charAt(0)=="["){s=true;a=a.slice(1,-1);}if(n.length==0)i=true;else if(n.charAt(0)=="["){i=true;n=n.slice(1,-1);}var l=a.length>0?parseInt(a,10)|0:0,o=n.length>0?parseInt(n,10)|0:0;if(i)o+=r.c;else --o;if(s)l+=r.r;else --l;return t+(i?"":"$")+ft(o)+(s?"":"$")+st(l)}return function a(n,i){r=i;return n.replace(e,t)}}();var Zn=/(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;var Qn=function(){return function e(r,t){return r.replace(Zn,function(e,r,a,n,i,s){var l=ct(n)-(a?0:t.c);var o=it(s)-(i?0:t.r);var c=o==0?"":!i?"["+o+"]":o+1;var f=l==0?"":!a?"["+l+"]":l+1;return r+"R"+c+"C"+f})}}();function ei(e,r){return e.replace(Zn,function(e,t,a,n,i,s){return t+(a=="$"?a+n:ft(ct(n)+r.c))+(i=="$"?i+s:st(it(s)+r.r))})}function ri(e,r,t){var a=vt(r),n=a.s,i=pt(t);var s={r:i.r-n.r,c:i.c-n.c};return ei(e,s)}function ti(e){if(e.length==1)return false;return true}function ai(e){return e.replace(/_xlfn\./g,"")}var ni={};var ii={};ta.WS=["http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet","http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"];var si=typeof Map!=="undefined";function li(e,r,t){var a=0,n=e.length;if(t){if(si?t.has(r):Object.prototype.hasOwnProperty.call(t,r)){var i=si?t.get(r):t[r];for(;a<i.length;++a){if(e[i[a]].t===r){e.Count++;return i[a]}}}}else for(;a<n;++a){if(e[a].t===r){e.Count++;return a}}e[n]={t:r};e.Count++;e.Unique++;if(t){if(si){if(!t.has(r))t.set(r,[]);t.get(r).push(n);}else {if(!Object.prototype.hasOwnProperty.call(t,r))t[r]=[];t[r].push(n);}}return n}function oi(e,r){var t={min:e+1,max:e+1};var a=-1;if(r.MDW)Za=r.MDW;if(r.width!=null)t.customWidth=1;else if(r.wpx!=null)a=en(r.wpx);else if(r.wch!=null)a=r.wch;if(a>-1){t.width=rn(a);t.customWidth=1;}else if(r.width!=null)t.width=r.width;if(r.hidden)t.hidden=true;if(r.level!=null){t.outlineLevel=t.level=r.level;}return t}function ci(e,r){if(!e)return;var t=[.7,.7,.75,.75,.3,.3];if(r=="xlml")t=[1,1,1,1,.5,.5];if(e.left==null)e.left=t[0];if(e.right==null)e.right=t[1];if(e.top==null)e.top=t[2];if(e.bottom==null)e.bottom=t[3];if(e.header==null)e.header=t[4];if(e.footer==null)e.footer=t[5];}function fi(e,r,t){var a=t.revssf[r.z!=null?r.z:"General"];var n=60,i=e.length;if(a==null&&t.ssf){for(;n<392;++n)if(t.ssf[n]==null){N.load(r.z,n);t.ssf[n]=r.z;t.revssf[r.z]=a=n;break}}for(n=0;n!=i;++n)if(e[n].numFmtId===a)return n;e[i]={numFmtId:a,fontId:0,fillId:0,borderId:0,xfId:0,applyNumberFormat:1};return i}function ui(e,r,t,a,n,i){try{if(a.cellNF)e.z=N._table[r];}catch(s){if(a.WTF)throw s}if(e.t==="z"&&!a.cellStyles)return;if(e.t==="d"&&typeof e.v==="string")e.v=oe(e.v);if((!a||a.cellText!==false)&&e.t!=="z")try{if(N._table[r]==null)N.load(I[r]||"General",r);if(e.t==="e")e.w=e.w||Vt[e.v];else if(r===0){if(e.t==="n"){if((e.v|0)===e.v)e.w=N._general_int(e.v);else e.w=N._general_num(e.v);}else if(e.t==="d"){var l=ee(e.v);if((l|0)===l)e.w=N._general_int(l);else e.w=N._general_num(l);}else if(e.v===undefined)return "";else e.w=N._general(e.v,ii);}else if(e.t==="d")e.w=N.format(r,ee(e.v),ii);else e.w=N.format(r,e.v,ii);}catch(s){if(a.WTF)throw s}if(!a.cellStyles)return;if(t!=null)try{e.s=i.Fills[t];if(e.s.fgColor&&e.s.fgColor.theme&&!e.s.fgColor.rgb){e.s.fgColor.rgb=Ya(n.themeElements.clrScheme[e.s.fgColor.theme].rgb,e.s.fgColor.tint||0);if(a.WTF)e.s.fgColor.raw_rgb=n.themeElements.clrScheme[e.s.fgColor.theme].rgb;}if(e.s.bgColor&&e.s.bgColor.theme){e.s.bgColor.rgb=Ya(n.themeElements.clrScheme[e.s.bgColor.theme].rgb,e.s.bgColor.tint||0);if(a.WTF)e.s.bgColor.raw_rgb=n.themeElements.clrScheme[e.s.bgColor.theme].rgb;}}catch(s){if(a.WTF&&i.Fills)throw s}}function hi(e,r,t){if(e&&e["!ref"]){var a=bt(e["!ref"]);if(a.e.c<a.s.c||a.e.r<a.s.r)throw new Error("Bad range ("+t+"): "+e["!ref"])}}function di(e,r){var t=bt(r);if(t.s.r<=t.e.r&&t.s.c<=t.e.c&&t.s.r>=0&&t.s.c>=0)e["!ref"]=gt(t);}var pi=/<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;var mi=/<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/;var vi=/<(?:\w:)?hyperlink [^>]*>/gm;var gi=/"(\w*:\w*)"/;var bi=/<(?:\w:)?col\b[^>]*[\/]?>/g;var wi=/<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;var ki=/<(?:\w:)?pageMargins[^>]*\/>/g;var yi=/<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/;var xi=/<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/;var Si=/<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;function _i(e,r,t,a,n,i,s){if(!e)return e;if(!a)a={"!id":{}};var l=r.dense?[]:{};var o={s:{r:2e6,c:2e6},e:{r:0,c:0}};var c="",f="";var u=e.match(mi);if(u){c=e.slice(0,u.index);f=e.slice(u.index+u[0].length);}else c=f=e;var h=c.match(yi);if(h)Ai(h[0],l,n,t);else if(h=c.match(xi))Ei(h[0],h[1]||"",l,n,t);var d=(c.match(/<(?:\w*:)?dimension/)||{index:-1}).index;if(d>0){var p=c.slice(d,d+50).match(gi);if(p)di(l,p[1]);}var m=c.match(Si);if(m&&m[1])Wi(m[1],n);var g=[];if(r.cellStyles){var b=c.match(bi);if(b)Pi(g,b);}if(u)ji(u[1],l,r,o,i,s);var w=f.match(wi);if(w)l["!autofilter"]=Li(w[0]);var k=[];var y=f.match(pi);if(y)for(d=0;d!=y.length;++d)k[d]=bt(y[d].slice(y[d].indexOf('"')+1));var x=f.match(vi);if(x)Mi(l,x,a);var S=f.match(ki);if(S)l["!margins"]=Ni(Re(S[0]));if(!l["!ref"]&&o.e.c>=o.s.c&&o.e.r>=o.s.r)l["!ref"]=gt(o);if(r.sheetRows>0&&l["!ref"]){var _=bt(l["!ref"]);if(r.sheetRows<=+_.e.r){_.e.r=r.sheetRows-1;if(_.e.r>o.e.r)_.e.r=o.e.r;if(_.e.r<_.s.r)_.s.r=_.e.r;if(_.e.c>o.e.c)_.e.c=o.e.c;if(_.e.c<_.s.c)_.s.c=_.e.c;l["!fullref"]=l["!ref"];l["!ref"]=gt(_);}}if(g.length>0)l["!cols"]=g;if(k.length>0)l["!merges"]=k;return l}function Ci(e){if(e.length===0)return "";var r='<mergeCells count="'+e.length+'">';for(var t=0;t!=e.length;++t)r+='<mergeCell ref="'+gt(e[t])+'"/>';return r+"</mergeCells>"}function Ai(e,r,t,a){var n=Re(e);if(!t.Sheets[a])t.Sheets[a]={};if(n.codeName)t.Sheets[a].CodeName=Be(Ke(n.codeName));}function Ei(e,r,t,a,n,i,s){Ai(e.slice(0,e.indexOf(">")),t,a,n);}function Fi(e,r,t,a,n){var i=false;var s={},l=null;if(a.bookType!=="xlsx"&&r.vbaraw){var o=r.SheetNames[t];try{if(r.Workbook)o=r.Workbook.Sheets[t].CodeName||o;}catch(c){}i=true;s.codeName=Je($e(o));}if(e&&e["!outline"]){var f={summaryBelow:1,summaryRight:1};if(e["!outline"].above)f.summaryBelow=0;if(e["!outline"].left)f.summaryRight=0;l=(l||"")+cr("outlinePr",null,f);}if(!i&&!l)return;n[n.length]=cr("sheetPr",l,s);}var Ti=["objects","scenarios","selectLockedCells","selectUnlockedCells"];var Oi=["formatColumns","formatRows","formatCells","insertColumns","insertRows","insertHyperlinks","deleteColumns","deleteRows","sort","autoFilter","pivotTables"];function Di(e){var r={sheet:1};Ti.forEach(function(t){if(e[t]!=null&&e[t])r[t]="1";});Oi.forEach(function(t){if(e[t]!=null&&!e[t])r[t]="0";});if(e.password)r.password=crypto_CreatePasswordVerifier_Method1(e.password).toString(16).toUpperCase();return cr("sheetProtection",null,r)}function Mi(e,r,t){var a=Array.isArray(e);for(var n=0;n!=r.length;++n){var i=Re(Ke(r[n]),true);if(!i.ref)return;var s=((t||{})["!id"]||[])[i.id];if(s){i.Target=s.Target;if(i.location)i.Target+="#"+Be(i.location);}else {i.Target="#"+Be(i.location);s={Target:i.Target,TargetMode:"Internal"};}i.Rel=s;if(i.tooltip){i.Tooltip=i.tooltip;delete i.tooltip;}var l=bt(i.ref);for(var o=l.s.r;o<=l.e.r;++o)for(var c=l.s.c;c<=l.e.c;++c){var f=mt({c:c,r:o});if(a){if(!e[o])e[o]=[];if(!e[o][c])e[o][c]={t:"z",v:undefined};e[o][c].l=i;}else {if(!e[f])e[f]={t:"z",v:undefined};e[f].l=i;}}}}function Ni(e){var r={};["left","right","top","bottom","header","footer"].forEach(function(t){if(e[t])r[t]=parseFloat(e[t]);});return r}function Ri(e){ci(e);return cr("pageMargins",null,e)}function Pi(e,r){var t=false;for(var a=0;a!=r.length;++a){var n=Re(r[a],true);if(n.hidden)n.hidden=Ye(n.hidden);
	var i=parseInt(n.min,10)-1,s=parseInt(n.max,10)-1;if(n.outlineLevel)n.level=+n.outlineLevel||0;delete n.min;delete n.max;n.width=+n.width;if(!t&&n.width){t=true;an(n.width);}nn(n);while(i<=s)e[i++]=fe(n);}}function Ii(e,r){var t=["<cols>"],a;for(var n=0;n!=r.length;++n){if(!(a=r[n]))continue;t[t.length]=cr("col",null,oi(n,a));}t[t.length]="</cols>";return t.join("")}function Li(e){var r={ref:(e.match(/ref="([^"]*)"/)||[])[1]};return r}function Bi(e,r,t,a){var n=typeof e.ref=="string"?e.ref:gt(e.ref);if(!t.Workbook)t.Workbook={Sheets:[]};if(!t.Workbook.Names)t.Workbook.Names=[];var i=t.Workbook.Names;var s=vt(n);if(s.s.r==s.e.r){s.e.r=vt(r["!ref"]).e.r;n=gt(s);}for(var l=0;l<i.length;++l){var o=i[l];if(o.Name!="_xlnm._FilterDatabase")continue;if(o.Sheet!=a)continue;o.Ref="'"+t.SheetNames[a]+"'!"+n;break}if(l==i.length)i.push({Name:"_xlnm._FilterDatabase",Sheet:a,Ref:"'"+t.SheetNames[a]+"'!"+n});return cr("autoFilter",null,{ref:n})}var zi=/<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;function Wi(e,r){if(!r.Views)r.Views=[{}];(e.match(zi)||[]).forEach(function(e,t){var a=Re(e);if(!r.Views[t])r.Views[t]={};if(+a.zoomScale)r.Views[t].zoom=+a.zoomScale;if(Ye(a.rightToLeft))r.Views[t].RTL=true;});}function $i(e,r,t,a){var n={workbookViewId:"0"};if((((a||{}).Workbook||{}).Views||[])[0])n.rightToLeft=a.Workbook.Views[0].RTL?"1":"0";return cr("sheetViews",cr("sheetView",null,n),{})}function Ui(e,r,t,a){if(e.v===undefined&&typeof e.f!=="string"||e.t==="z")return "";var n="";var i=e.t,s=e.v;if(e.t!=="z")switch(e.t){case"b":n=e.v?"1":"0";break;case"n":n=""+e.v;break;case"e":n=Vt[e.v];break;case"d":if(a&&a.cellDates)n=oe(e.v,-1).toISOString();else {e=fe(e);e.t="n";n=""+(e.v=ee(oe(e.v)));}if(typeof e.z==="undefined")e.z=N._table[14];break;default:n=e.v;break;}var l=lr("v",$e(n)),o={r:r};var c=fi(a.cellXfs,e,a);if(c!==0)o.s=c;switch(e.t){case"n":break;case"d":o.t="d";break;case"b":o.t="b";break;case"e":o.t="e";break;case"z":break;default:if(e.v==null){delete e.t;break}if(e.v.length>32767)throw new Error("Text length must not exceed 32767 characters");if(a&&a.bookSST){l=lr("v",""+li(a.Strings,e.v,a.revStrings));o.t="s";break}o.t="str";break;}if(e.t!=i){e.t=i;e.v=s;}if(typeof e.f=="string"&&e.f){var f=e.F&&e.F.slice(0,r.length)==r?{t:"array",ref:e.F}:null;l=cr("f",$e(e.f),f)+(e.v!=null?l:"");}if(e.l)t["!links"].push([r,e.l]);if(e.c)t["!comments"].push([r,e.c]);return cr("c",l,o)}var ji=function(){var e=/<(?:\w+:)?c[ \/>]/,r=/<\/(?:\w+:)?row>/;var t=/r=["']([^"']*)["']/,a=/<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;var n=/ref=["']([^"']*)["']/;var i=er("v"),s=er("f");return function l(o,c,f,u,h,d){var p=0,m="",v=[],g=[],b=0,w=0,k=0,y="",x;var S,_=0,C=0;var A,E;var F=0,T=0;var O=Array.isArray(d.CellXf),D;var M=[];var R=[];var P=Array.isArray(c);var I=[],L={},B=false;var z=!!f.sheetStubs;for(var W=o.split(r),$=0,U=W.length;$!=U;++$){m=W[$].trim();var j=m.length;if(j===0)continue;var H=0;e:for(p=0;p<j;++p)switch(m[p]){case">":if(m[p-1]!="/"){++p;break e}if(f&&f.cellStyles){S=Re(m.slice(H,p),true);_=S.r!=null?parseInt(S.r,10):_+1;C=-1;if(f.sheetRows&&f.sheetRows<_)continue;L={};B=false;if(S.ht){B=true;L.hpt=parseFloat(S.ht);L.hpx=cn(L.hpt);}if(S.hidden=="1"){B=true;L.hidden=true;}if(S.outlineLevel!=null){B=true;L.level=+S.outlineLevel;}if(B)I[_-1]=L;}break;case"<":H=p;break;}if(H>=p)break;S=Re(m.slice(H,p),true);_=S.r!=null?parseInt(S.r,10):_+1;C=-1;if(f.sheetRows&&f.sheetRows<_)continue;if(u.s.r>_-1)u.s.r=_-1;if(u.e.r<_-1)u.e.r=_-1;if(f&&f.cellStyles){L={};B=false;if(S.ht){B=true;L.hpt=parseFloat(S.ht);L.hpx=cn(L.hpt);}if(S.hidden=="1"){B=true;L.hidden=true;}if(S.outlineLevel!=null){B=true;L.level=+S.outlineLevel;}if(B)I[_-1]=L;}v=m.slice(p).split(e);for(var X=0;X!=v.length;++X)if(v[X].trim().charAt(0)!="<")break;v=v.slice(X);for(p=0;p!=v.length;++p){m=v[p].trim();if(m.length===0)continue;g=m.match(t);b=p;w=0;k=0;m="<c "+(m.slice(0,1)=="<"?">":"")+m;if(g!=null&&g.length===2){b=0;y=g[1];for(w=0;w!=y.length;++w){if((k=y.charCodeAt(w)-64)<1||k>26)break;b=26*b+k;}--b;C=b;}else ++C;for(w=0;w!=m.length;++w)if(m.charCodeAt(w)===62)break;++w;S=Re(m.slice(0,w),true);if(!S.r)S.r=mt({r:_-1,c:C});y=m.slice(w);x={t:""};if((g=y.match(i))!=null&&g[1]!=="")x.v=Be(g[1]);if(f.cellFormula){if((g=y.match(s))!=null&&g[1]!==""){x.f=Be(Ke(g[1])).replace(/\r\n/g,"\n");if(!f.xlfn)x.f=ai(x.f);if(g[0].indexOf('t="array"')>-1){x.F=(y.match(n)||[])[1];if(x.F.indexOf(":")>-1)M.push([bt(x.F),x.F]);}else if(g[0].indexOf('t="shared"')>-1){E=Re(g[0]);var V=Be(Ke(g[1]));if(!f.xlfn)V=ai(V);R[parseInt(E.si,10)]=[E,V,S.r];}}else if(g=y.match(/<f[^>]*\/>/)){E=Re(g[0]);if(R[E.si])x.f=ri(R[E.si][1],R[E.si][2],S.r);}var G=pt(S.r);for(w=0;w<M.length;++w)if(G.r>=M[w][0].s.r&&G.r<=M[w][0].e.r)if(G.c>=M[w][0].s.c&&G.c<=M[w][0].e.c)x.F=M[w][1];}if(S.t==null&&x.v===undefined){if(x.f||x.F){x.v=0;x.t="n";}else if(!z)continue;else x.t="z";}else x.t=S.t||"n";if(u.s.c>C)u.s.c=C;if(u.e.c<C)u.e.c=C;switch(x.t){case"n":if(x.v==""||x.v==null){if(!z)continue;x.t="z";}else x.v=parseFloat(x.v);break;case"s":if(typeof x.v=="undefined"){if(!z)continue;x.t="z";}else {A=ni[parseInt(x.v,10)];x.v=A.t;x.r=A.r;if(f.cellHTML)x.h=A.h;}break;case"str":x.t="s";x.v=x.v!=null?Ke(x.v):"";if(f.cellHTML)x.h=He(x.v);break;case"inlineStr":g=y.match(a);x.t="s";if(g!=null&&(A=La(g[1]))){x.v=A.t;if(f.cellHTML)x.h=A.h;}else x.v="";break;case"b":x.v=Ye(x.v);break;case"d":if(f.cellDates)x.v=oe(x.v,1);else {x.v=ee(oe(x.v,1));x.t="n";}break;case"e":if(!f||f.cellText!==false)x.w=x.v;x.v=Gt[x.v];break;}F=T=0;D=null;if(O&&S.s!==undefined){D=d.CellXf[S.s];if(D!=null){if(D.numFmtId!=null)F=D.numFmtId;if(f.cellStyles){if(D.fillId!=null)T=D.fillId;}}}ui(x,F,T,f,h,d);if(f.cellDates&&O&&x.t=="n"&&N.is_date(N._table[F])){x.t="d";x.v=ne(x.v);}if(P){var Y=pt(S.r);if(!c[Y.r])c[Y.r]=[];c[Y.r][Y.c]=x;}else c[S.r]=x;}}if(I.length>0)c["!rows"]=I;}}();function Hi(e,r,t,a){var n=[],i=[],s=bt(e["!ref"]),l="",o,c="",f=[],u=0,h=0,d=e["!rows"];var p=Array.isArray(e);var m={r:c},v,g=-1;for(h=s.s.c;h<=s.e.c;++h)f[h]=ft(h);for(u=s.s.r;u<=s.e.r;++u){i=[];c=st(u);for(h=s.s.c;h<=s.e.c;++h){o=f[h]+c;var b=p?(e[u]||[])[h]:e[o];if(b===undefined)continue;if((l=Ui(b,o,e,r))!=null)i.push(l);}if(i.length>0||d&&d[u]){m={r:c};if(d&&d[u]){v=d[u];if(v.hidden)m.hidden=1;g=-1;if(v.hpx)g=on(v.hpx);else if(v.hpt)g=v.hpt;if(g>-1){m.ht=g;m.customHeight=1;}if(v.level){m.outlineLevel=v.level;}}n[n.length]=cr("row",i.join(""),m);}}if(d)for(;u<d.length;++u){if(d&&d[u]){m={r:u+1};v=d[u];if(v.hidden)m.hidden=1;g=-1;if(v.hpx)g=on(v.hpx);else if(v.hpt)g=v.hpt;if(g>-1){m.ht=g;m.customHeight=1;}if(v.level){m.outlineLevel=v.level;}n[n.length]=cr("row","",m);}}return n.join("")}var Xi=cr("worksheet",null,{xmlns:hr.main[0],"xmlns:r":hr.r});function Vi(e,r,t,a){var n=[Te,Xi];var i=t.SheetNames[e],s=0,l="";var o=t.Sheets[i];if(o==null)o={};var c=o["!ref"]||"A1";var f=bt(c);if(f.e.c>16383||f.e.r>1048575){if(r.WTF)throw new Error("Range "+c+" exceeds format limit A1:XFD1048576");f.e.c=Math.min(f.e.c,16383);f.e.r=Math.min(f.e.c,1048575);c=gt(f);}if(!a)a={};o["!comments"]=[];var u=[];Fi(o,t,e,r,n);n[n.length]=cr("dimension",null,{ref:c});n[n.length]=$i(o,r,e,t);if(r.sheetFormat)n[n.length]=cr("sheetFormatPr",null,{defaultRowHeight:r.sheetFormat.defaultRowHeight||"16",baseColWidth:r.sheetFormat.baseColWidth||"10",outlineLevelRow:r.sheetFormat.outlineLevelRow||"7"});if(o["!cols"]!=null&&o["!cols"].length>0)n[n.length]=Ii(o,o["!cols"]);n[s=n.length]="<sheetData/>";o["!links"]=[];if(o["!ref"]!=null){l=Hi(o,r);if(l.length>0)n[n.length]=l;}if(n.length>s+1){n[n.length]="</sheetData>";n[s]=n[s].replace("/>",">");}if(o["!protect"])n[n.length]=Di(o["!protect"]);if(o["!autofilter"]!=null)n[n.length]=Bi(o["!autofilter"],o,t,e);if(o["!merges"]!=null&&o["!merges"].length>0)n[n.length]=Ci(o["!merges"]);var h=-1,d,p=-1;if(o["!links"].length>0){n[n.length]="<hyperlinks>";o["!links"].forEach(function(e){if(!e[1].Target)return;d={ref:e[0]};if(e[1].Target.charAt(0)!="#"){p=oa(a,-1,$e(e[1].Target).replace(/#.*$/,""),ta.HLINK);d["r:id"]="rId"+p;}if((h=e[1].Target.indexOf("#"))>-1)d.location=$e(e[1].Target.slice(h+1));if(e[1].Tooltip)d.tooltip=$e(e[1].Tooltip);n[n.length]=cr("hyperlink",null,d);});n[n.length]="</hyperlinks>";}delete o["!links"];if(o["!margins"]!=null)n[n.length]=Ri(o["!margins"]);if(!r||r.ignoreEC||r.ignoreEC==void 0)n[n.length]=lr("ignoredErrors",cr("ignoredError",null,{numberStoredAsText:1,sqref:c}));if(u.length>0){p=oa(a,-1,"../drawings/drawing"+(e+1)+".xml",ta.DRAW);n[n.length]=cr("drawing",null,{"r:id":"rId"+p});o["!drawing"]=u;}if(o["!comments"].length>0){p=oa(a,-1,"../drawings/vmlDrawing"+(e+1)+".vml",ta.VML);n[n.length]=cr("legacyDrawing",null,{"r:id":"rId"+p});o["!legacy"]=p;}if(n.length>1){n[n.length]="</worksheet>";n[1]=n[1].replace("/>",">");}return n.join("")}ta.CHART="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart";ta.CHARTEX="http://schemas.microsoft.com/office/2014/relationships/chartEx";function Gi(e){var r=[];var t=e.match(/^<c:numCache>/);var a;(e.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/gm)||[]).forEach(function(e){var a=e.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);if(!a)return;r[+a[1]]=t?+a[2]:a[2];});var n=Be((e.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/)||["","General"])[1]);(e.match(/<c:f>(.*?)<\/c:f>/gm)||[]).forEach(function(e){a=e.replace(/<.*?>/g,"");});return [r,n,a]}function Yi(e,r,t,a,n,i){var s=i||{"!type":"chart"};if(!e)return i;var l=0,o=0,c="A";var f={s:{r:2e6,c:2e6},e:{r:0,c:0}};(e.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm)||[]).forEach(function(e){var r=Gi(e);f.s.r=f.s.c=0;f.e.c=l;c=ft(l);r[0].forEach(function(e,t){s[c+st(t)]={t:"n",v:e,z:r[1]};o=t;});if(f.e.r<o)f.e.r=o;++l;});if(l>0)s["!ref"]=gt(f);return s}ta.CS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet";cr("chartsheet",null,{xmlns:hr.main[0],"xmlns:r":hr.r});function Ji(e,r,t,a,n){if(!e)return e;if(!a)a={"!id":{}};var i={"!type":"chart","!drawel":null,"!rel":""};var s;var l=e.match(yi);if(l)Ai(l[0],i,n,t);if(s=e.match(/drawing r:id="(.*?)"/))i["!rel"]=s[1];if(a["!id"][i["!rel"]])i["!drawel"]=a["!id"][i["!rel"]];return i}function Qi(e,r,t,a,n){if(!e)return e;if(!a)a={"!id":{}};var i={"!type":"chart","!drawel":null,"!rel":""};var l=false;Zr(e,function o(e,a,c){switch(c){case 550:i["!rel"]=e;break;case 651:if(!n.Sheets[t])n.Sheets[t]={};if(e.name)n.Sheets[t].CodeName=e.name;break;case 562:case 652:case 669:case 679:case 551:case 552:case 476:case 3072:break;case 35:l=true;break;case 36:l=false;break;case 37:break;case 38:break;default:if((a||"").indexOf("Begin")>0);else if((a||"").indexOf("End")>0);else if(!l||r.WTF)throw new Error("Unexpected record "+c+" "+a);}},r);if(a["!id"][i["!rel"]])i["!drawel"]=a["!id"][i["!rel"]];return i}var rs=[["allowRefreshQuery",false,"bool"],["autoCompressPictures",true,"bool"],["backupFile",false,"bool"],["checkCompatibility",false,"bool"],["CodeName",""],["date1904",false,"bool"],["defaultThemeVersion",0,"int"],["filterPrivacy",false,"bool"],["hidePivotFieldList",false,"bool"],["promptedSolutions",false,"bool"],["publishItems",false,"bool"],["refreshAllConnections",false,"bool"],["saveExternalLinkValues",true,"bool"],["showBorderUnselectedTables",true,"bool"],["showInkAnnotation",true,"bool"],["showObjects","all"],["showPivotChartFilter",false,"bool"],["updateLinks","userSet"]];var ts=[["activeTab",0,"int"],["autoFilterDateGrouping",true,"bool"],["firstSheet",0,"int"],["minimized",false,"bool"],["showHorizontalScroll",true,"bool"],["showSheetTabs",true,"bool"],["showVerticalScroll",true,"bool"],["tabRatio",600,"int"],["visibility","visible"]];var as=[];var ns=[["calcCompleted","true"],["calcMode","auto"],["calcOnSave","true"],["concurrentCalc","true"],["fullCalcOnLoad","false"],["fullPrecision","true"],["iterate","false"],["iterateCount","100"],["iterateDelta","0.001"],["refMode","A1"]];function is(e,r){for(var t=0;t!=e.length;++t){var a=e[t];for(var n=0;n!=r.length;++n){var i=r[n];if(a[i[0]]==null)a[i[0]]=i[1];else switch(i[2]){case"bool":if(typeof a[i[0]]=="string")a[i[0]]=Ye(a[i[0]]);break;case"int":if(typeof a[i[0]]=="string")a[i[0]]=parseInt(a[i[0]],10);break;}}}}function ss(e,r){for(var t=0;t!=r.length;++t){var a=r[t];if(e[a[0]]==null)e[a[0]]=a[1];else switch(a[2]){case"bool":if(typeof e[a[0]]=="string")e[a[0]]=Ye(e[a[0]]);break;case"int":if(typeof e[a[0]]=="string")e[a[0]]=parseInt(e[a[0]],10);break;}}}function ls(e){ss(e.WBProps,rs);ss(e.CalcPr,ns);is(e.WBView,ts);is(e.Sheets,as);ii.date1904=Ye(e.WBProps.date1904);}var cs="][*?/\\".split("");function fs(e,r){if(e.length>31){if(r)return false;throw new Error("Sheet names cannot exceed 31 chars")}var t=true;cs.forEach(function(a){if(e.indexOf(a)==-1)return;if(!r)throw new Error("Sheet name cannot contain : \\ / ? * [ ]");t=false;});return t}function us(e,r,t){e.forEach(function(a,n){fs(a);for(var i=0;i<n;++i)if(a==e[i])throw new Error("Duplicate Sheet Name: "+a);if(t){var s=r&&r[n]&&r[n].CodeName||a;if(s.charCodeAt(0)==95&&s.length>22)throw new Error("Bad Code Name: Worksheet"+s)}});}function hs(e){if(!e||!e.SheetNames||!e.Sheets)throw new Error("Invalid Workbook");if(!e.SheetNames.length)throw new Error("Workbook is empty");var r=e.Workbook&&e.Workbook.Sheets||[];us(e.SheetNames,r,!!e.vbaraw);for(var t=0;t<e.SheetNames.length;++t)hi(e.Sheets[e.SheetNames[t]],e.SheetNames[t],t);}var ds=/<\w+:workbook/;function ps(e,r){if(!e)throw new Error("Could not find file");var t={AppVersion:{},WBProps:{},WBView:[],Sheets:[],CalcPr:{},Names:[],xmlns:""};var a=false,n="xmlns";var i={},s=0;e.replace(De,function l(o,c){var f=Re(o);switch(Pe(f[0])){case"<?xml":break;case"<workbook":if(o.match(ds))n="xmlns"+o.match(/<(\w+):/)[1];t.xmlns=f[n];break;case"</workbook>":break;case"<fileVersion":delete f[0];t.AppVersion=f;break;case"<fileVersion/>":case"</fileVersion>":break;case"<fileSharing":break;case"<fileSharing/>":break;case"<workbookPr":case"<workbookPr/>":rs.forEach(function(e){if(f[e[0]]==null)return;switch(e[2]){case"bool":t.WBProps[e[0]]=Ye(f[e[0]]);break;case"int":t.WBProps[e[0]]=parseInt(f[e[0]],10);break;default:t.WBProps[e[0]]=f[e[0]];}});if(f.codeName)t.WBProps.CodeName=Ke(f.codeName);break;case"</workbookPr>":break;case"<workbookProtection":break;case"<workbookProtection/>":break;case"<bookViews":case"<bookViews>":case"</bookViews>":break;case"<workbookView":case"<workbookView/>":delete f[0];t.WBView.push(f);break;case"</workbookView>":break;case"<sheets":case"<sheets>":case"</sheets>":break;case"<sheet":switch(f.state){case"hidden":f.Hidden=1;break;case"veryHidden":f.Hidden=2;break;default:f.Hidden=0;}delete f.state;f.name=Be(Ke(f.name));delete f[0];t.Sheets.push(f);break;case"</sheet>":break;case"<functionGroups":case"<functionGroups/>":break;case"<functionGroup":break;case"<externalReferences":case"</externalReferences>":case"<externalReferences>":break;case"<externalReference":break;case"<definedNames/>":break;case"<definedNames>":case"<definedNames":a=true;break;case"</definedNames>":a=false;break;case"<definedName":{i={};i.Name=Ke(f.name);if(f.comment)i.Comment=f.comment;if(f.localSheetId)i.Sheet=+f.localSheetId;if(Ye(f.hidden||"0"))i.Hidden=true;s=c+o.length;}break;case"</definedName>":{i.Ref=Be(Ke(e.slice(s,c)));t.Names.push(i);}break;case"<definedName/>":break;case"<calcPr":delete f[0];t.CalcPr=f;break;case"<calcPr/>":delete f[0];t.CalcPr=f;break;case"</calcPr>":break;case"<oleSize":break;case"<customWorkbookViews>":case"</customWorkbookViews>":case"<customWorkbookViews":break;case"<customWorkbookView":case"</customWorkbookView>":break;case"<pivotCaches>":case"</pivotCaches>":case"<pivotCaches":break;case"<pivotCache":break;case"<smartTagPr":case"<smartTagPr/>":break;case"<smartTagTypes":case"<smartTagTypes>":case"</smartTagTypes>":break;case"<smartTagType":break;case"<webPublishing":case"<webPublishing/>":break;case"<fileRecoveryPr":case"<fileRecoveryPr/>":break;case"<webPublishObjects>":case"<webPublishObjects":case"</webPublishObjects>":break;case"<webPublishObject":break;case"<extLst":case"<extLst>":case"</extLst>":case"<extLst/>":break;case"<ext":a=true;break;case"</ext>":a=false;break;case"<ArchID":break;case"<AlternateContent":case"<AlternateContent>":a=true;break;case"</AlternateContent>":a=false;break;case"<revisionPtr":break;default:if(!a&&r.WTF)throw new Error("unrecognized "+f[0]+" in workbook");}return o});if(hr.main.indexOf(t.xmlns)===-1)throw new Error("Unknown Namespace: "+t.xmlns);ls(t);return t}var ms=cr("workbook",null,{xmlns:hr.main[0],"xmlns:r":hr.r});function vs(e){var r=[Te];r[r.length]=ms;var t=e.Workbook&&(e.Workbook.Names||[]).length>0;var a={codeName:"ThisWorkbook"};if(e.Workbook&&e.Workbook.WBProps){rs.forEach(function(r){if(e.Workbook.WBProps[r[0]]==null)return;if(e.Workbook.WBProps[r[0]]==r[1])return;a[r[0]]=e.Workbook.WBProps[r[0]];});if(e.Workbook.WBProps.CodeName){a.codeName=e.Workbook.WBProps.CodeName;delete a.CodeName;}}r[r.length]=cr("workbookPr",null,a);var n=e.Workbook&&e.Workbook.Sheets||[];var i=0;if(n&&n[0]&&!!n[0].Hidden){r[r.length]="<bookViews>";for(i=0;i!=e.SheetNames.length;++i){if(!n[i])break;if(!n[i].Hidden)break}if(i==e.SheetNames.length)i=0;r[r.length]='<workbookView firstSheet="'+i+'" activeTab="'+i+'"/>';r[r.length]="</bookViews>";}r[r.length]="<sheets>";for(i=0;i!=e.SheetNames.length;++i){var s={name:$e(e.SheetNames[i].slice(0,31))};s.sheetId=""+(i+1);s["r:id"]="rId"+(i+1);if(n[i])switch(n[i].Hidden){case 1:s.state="hidden";break;case 2:s.state="veryHidden";break;}r[r.length]=cr("sheet",null,s);}r[r.length]="</sheets>";if(t){r[r.length]="<definedNames>";if(e.Workbook&&e.Workbook.Names)e.Workbook.Names.forEach(function(e){var t={name:e.Name};if(e.Comment)t.comment=e.Comment;if(e.Sheet!=null)t.localSheetId=""+e.Sheet;if(e.Hidden)t.hidden="1";if(!e.Ref)return;r[r.length]=cr("definedName",$e(e.Ref),t);});r[r.length]="</definedNames>";}if(r.length>2){r[r.length]="</workbook>";r[1]=r[1].replace("/>",">");}return r.join("")}function gs(e,r,t){if(r.slice(-4)===".bin")return parse_wb_bin(e,t);return ps(e,t)}function bs(e,r,t,a,n,i,s,l){if(r.slice(-4)===".bin")return parse_ws_bin(e,a,t,n,i,s,l);return _i(e,a,t,n,i,s,l)}function ws(e,r,t,a,n,i,s,l){if(r.slice(-4)===".bin")return Qi(e,a,t,n,i);return Ji(e,a,t,n,i)}function ks(e,r,t,a,n,i,s,l){if(r.slice(-4)===".bin")return Kn();return Jn()}function ys(e,r,t,a,n,i,s,l){if(r.slice(-4)===".bin")return Gn();return Yn()}function xs(e,r,t,a){if(r.slice(-4)===".bin")return parse_sty_bin(e,t,a);return kn(e,t,a)}function Ss(e,r,t){return Mn(e,t)}function _s(e,r,t){if(r.slice(-4)===".bin")return parse_sst_bin(e,t);return $a(e,t)}function Cs(e,r,t){if(r.slice(-4)===".bin")return parse_comments_bin(e,t);return Wn(e,t)}function As(e,r,t){if(r.slice(-4)===".bin")return parse_cc_bin(e,r,t);return parse_cc_xml(e,r,t)}function Es(e,r,t,a){if(t.slice(-4)===".bin")return Pn(e,r,t,a);return Rn()}function Fs(e,r,t){return (r.slice(-4)===".bin"?write_wb_bin:vs)(e,t)}function Ts(e,r,t,a,n){return (r.slice(-4)===".bin"?write_ws_bin:Vi)(e,t,a,n)}function Ds(e,r,t){return (r.slice(-4)===".bin"?write_sty_bin:xn)(e,t)}function Ms(e,r,t){return (r.slice(-4)===".bin"?write_sst_bin:ja)(e,t)}function Ns(e,r,t){return (r.slice(-4)===".bin"?write_comments_bin:Un)(e,t)}var Rs=function(){function e(e,r){var t=r||{};var a=t.dense?[]:{};e=e.replace(/<!--.*?-->/g,"");var n=e.match(/<table/i);if(!n)throw new Error("Invalid HTML: could not find <table>");var i=e.match(/<\/table/i);var s=n.index,l=i&&i.index||e.length;var o=me(e.slice(s,l),/(:?<tr[^>]*>)/i,"<tr>");var c=-1,f=0,u=0,h=0;var d={s:{r:1e7,c:1e7},e:{r:0,c:0}};var p=[];for(s=0;s<o.length;++s){var m=o[s].trim();var g=m.slice(0,3).toLowerCase();if(g=="<tr"){++c;if(t.sheetRows&&t.sheetRows<=c){--c;break}f=0;continue}if(g!="<td"&&g!="<th")continue;var b=m.split(/<\/t[dh]>/i);for(l=0;l<b.length;++l){var w=b[l].trim();if(!w.match(/<t[dh]/i))continue;var k=w,y=0;while(k.charAt(0)=="<"&&(y=k.indexOf(">"))>-1)k=k.slice(y+1);for(var x=0;x<p.length;++x){var S=p[x];if(S.s.c==f&&S.s.r<c&&c<=S.e.r){f=S.e.c+1;x=-1;}}var _=Re(w.slice(0,w.indexOf(">")));h=_.colspan?+_.colspan:1;if((u=+_.rowspan)>1||h>1)p.push({s:{r:c,c:f},e:{r:c+(u||1)-1,c:f+h-1}});var C=_.t||_["data-t"]||"";if(!k.length){f+=h;continue}k=rr(k);if(d.s.r>c)d.s.r=c;if(d.e.r<c)d.e.r=c;if(d.s.c>f)d.s.c=f;if(d.e.c<f)d.e.c=f;if(!k.length)continue;var A={t:"s",v:k};if(t.raw||!k.trim().length||C=="s");else if(k==="TRUE")A={t:"b",v:true};else if(k==="FALSE")A={t:"b",v:false};else if(!isNaN(he(k)))A={t:"n",v:he(k)};else if(!isNaN(de(k).getDate())){A={t:"d",v:oe(k)};if(!t.cellDates)A={t:"n",v:ee(A.v)};A.z=t.dateNF||N._table[14];}if(t.dense){if(!a[c])a[c]=[];a[c][f]=A;}else a[mt({r:c,c:f})]=A;f+=h;}}a["!ref"]=gt(d);if(p.length)a["!merges"]=p;return a}function r(r,t){var a=r.match(/<table.*?>[\s\S]*?<\/table>/gi);if(!a||a.length==0)throw new Error("Invalid HTML: could not find <table>");if(a.length==1)return yt(e(a[0],t),t);var n=jl.book_new();a.forEach(function(r,a){jl.book_append_sheet(n,e(r,t),"Sheet"+(a+1));});return n}function t(e,r,t,a){var n=e["!merges"]||[];var i=[];for(var s=r.s.c;s<=r.e.c;++s){var l=0,o=0;for(var c=0;c<n.length;++c){if(n[c].s.r>t||n[c].s.c>s)continue;if(n[c].e.r<t||n[c].e.c<s)continue;if(n[c].s.r<t||n[c].s.c<s){l=-1;break}l=n[c].e.r-n[c].s.r+1;o=n[c].e.c-n[c].s.c+1;break}if(l<0)continue;var f=mt({r:t,c:s});var u=a.dense?(e[t]||[])[s]:e[f];var h=u&&u.v!=null&&(u.h||He(u.w||(kt(u),u.w)||""))||"";var d={};if(l>1)d.rowspan=l;if(o>1)d.colspan=o;if(a.editable)h='<span contenteditable="true">'+h+"</span>";else if(u){d["data-t"]=u&&u.t||"z";if(u.v!=null)d["data-v"]=u.v;if(u.z!=null)d["data-z"]=u.z;if(u.l&&(u.l.Target||"#").charAt(0)!="#")h='<a href="'+u.l.Target+'">'+h+"</a>";}d.id=(a.id||"sjs")+"-"+f;i.push(cr("td",h,d));}var p="<tr>";return p+i.join("")+"</tr>"}function a(e,r,t){var a=[];return a.join("")+"<table"+(t&&t.id?' id="'+t.id+'"':"")+">"}var n='<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';var i="</body></html>";function s(e,r){var s=r||{};var l=s.header!=null?s.header:n;var o=s.footer!=null?s.footer:i;var c=[l];var f=vt(e["!ref"]);s.dense=Array.isArray(e);c.push(a(e,f,s));for(var u=f.s.r;u<=f.e.r;++u)c.push(t(e,f,u,s));c.push("</table>"+o);return c.join("")}return {to_workbook:r,to_sheet:e,_row:t,BEGIN:n,END:i,_preamble:a,from_sheet:s}}();function Ps(e,r,t){var a=t||{};var n=0,i=0;if(a.origin!=null){if(typeof a.origin=="number")n=a.origin;else {var s=typeof a.origin=="string"?pt(a.origin):a.origin;n=s.r;i=s.c;}}var l=r.getElementsByTagName("tr");var o=Math.min(a.sheetRows||1e7,l.length);var c={s:{r:0,c:0},e:{r:n,c:i}};if(e["!ref"]){var f=vt(e["!ref"]);c.s.r=Math.min(c.s.r,f.s.r);c.s.c=Math.min(c.s.c,f.s.c);c.e.r=Math.max(c.e.r,f.e.r);c.e.c=Math.max(c.e.c,f.e.c);if(n==-1)c.e.r=n=f.e.r+1;}var u=[],h=0;var d=e["!rows"]||(e["!rows"]=[]);var p=0,m=0,g=0,b=0,w=0,k=0;if(!e["!cols"])e["!cols"]=[];for(;p<l.length&&m<o;++p){var y=l[p];if(Bs(y)){if(a.display)continue;d[m]={hidden:true};}var x=y.children;for(g=b=0;g<x.length;++g){var S=x[g];if(a.display&&Bs(S))continue;var _=S.hasAttribute("data-v")?S.getAttribute("data-v"):S.hasAttribute("v")?S.getAttribute("v"):rr(S.innerHTML);var C=S.getAttribute("data-z")||S.getAttribute("z");for(h=0;h<u.length;++h){var A=u[h];if(A.s.c==b+i&&A.s.r<m+n&&m+n<=A.e.r){b=A.e.c+1-i;h=-1;}}k=+S.getAttribute("colspan")||1;if((w=+S.getAttribute("rowspan")||1)>1||k>1)u.push({s:{r:m+n,c:b+i},e:{r:m+n+(w||1)-1,c:b+i+(k||1)-1}});var E={t:"s",v:_};var F=S.getAttribute("data-t")||S.getAttribute("t")||"";if(_!=null){if(_.length==0)E.t=F||"z";else if(a.raw||_.trim().length==0||F=="s");else if(_==="TRUE")E={t:"b",v:true};else if(_==="FALSE")E={t:"b",v:false};else if(!isNaN(he(_)))E={t:"n",v:he(_)};else if(!isNaN(de(_).getDate())){E={t:"d",v:oe(_)};if(!a.cellDates)E={t:"n",v:ee(E.v)};E.z=a.dateNF||N._table[14];}}if(E.z===undefined&&C!=null)E.z=C;var T="",O=S.getElementsByTagName("A");if(O&&O.length)for(var D=0;D<O.length;++D)if(O[D].hasAttribute("href")){T=O[D].getAttribute("href");if(T.charAt(0)!="#")break}if(T&&T.charAt(0)!="#")E.l={Target:T};if(a.dense){if(!e[m+n])e[m+n]=[];e[m+n][b+i]=E;}else e[mt({c:b+i,r:m+n})]=E;if(c.e.c<b+i)c.e.c=b+i;b+=k;}++m;}if(u.length)e["!merges"]=(e["!merges"]||[]).concat(u);c.e.r=Math.max(c.e.r,m-1+n);e["!ref"]=gt(c);if(m>=o)e["!fullref"]=gt((c.e.r=l.length-p+m-1+n,c));return e}function Is(e,r){var t=r||{};var a=t.dense?[]:{};return Ps(a,e,r)}function Ls(e,r){return yt(Is(e,r),r)}function Bs(e){var r="";var t=zs(e);if(t)r=t(e).getPropertyValue("display");if(!r)r=e.style.display;return r==="none"}function zs(e){if(e.ownerDocument.defaultView&&typeof e.ownerDocument.defaultView.getComputedStyle==="function")return e.ownerDocument.defaultView.getComputedStyle;if(typeof getComputedStyle==="function")return getComputedStyle;return null}var Ws=function(){var e=function(e){var r=e.replace(/[\t\r\n]/g," ").trim().replace(/ +/g," ").replace(/<text:s\/>/g," ").replace(/<text:s text:c="(\d+)"\/>/g,function(e,r){return Array(parseInt(r,10)+1).join(" ")}).replace(/<text:tab[^>]*\/>/g,"\t").replace(/<text:line-break\/>/g,"\n");var t=Be(r.replace(/<[^>]*>/g,""));return [t]};var r={day:["d","dd"],month:["m","mm"],year:["y","yy"],hours:["h","hh"],minutes:["m","mm"],seconds:["s","ss"],"am-pm":["A/P","AM/PM"],"day-of-week":["ddd","dddd"],era:["e","ee"],quarter:["\\Qm",'m\\"th quarter"']};return function t(a,n){var i=n||{};var s=xlml_normalize(a);var l=[],o;var c;var f={name:""},u="",h=0;var d;var p;var m={},g=[];var b=i.dense?[]:{};var w,k;var y={value:""};var x="",S=0;var C=[];var A=-1,E=-1,F={s:{r:1e6,c:1e7},e:{r:0,c:0}};var T=0;var O={};var D=[],M={},N=0,R=0;var P=[],I=1,L=1;var B=[];var z={Names:[]};var W={};var $=["",""];var U=[],j={};var H="",X=0;var V=false,G=false;var Y=0;xlmlregex.lastIndex=0;s=s.replace(/<!--([\s\S]*?)-->/gm,"").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm,"");while(w=xlmlregex.exec(s))switch(w[3]=w[3].replace(/_.*$/,"")){case"table":case"工作表":if(w[1]==="/"){if(F.e.c>=F.s.c&&F.e.r>=F.s.r)b["!ref"]=gt(F);else b["!ref"]="A1:A1";if(i.sheetRows>0&&i.sheetRows<=F.e.r){b["!fullref"]=b["!ref"];F.e.r=i.sheetRows-1;b["!ref"]=gt(F);}if(D.length)b["!merges"]=D;if(P.length)b["!rows"]=P;d.name=d["名称"]||d.name;if(typeof JSON!=="undefined")JSON.stringify(d);g.push(d.name);m[d.name]=b;G=false;}else if(w[0].charAt(w[0].length-2)!=="/"){d=Re(w[0],false);A=E=-1;F.s.r=F.s.c=1e7;F.e.r=F.e.c=0;b=i.dense?[]:{};D=[];P=[];G=true;}break;case"table-row-group":if(w[1]==="/")--T;else ++T;break;case"table-row":case"行":if(w[1]==="/"){A+=I;I=1;break}p=Re(w[0],false);if(p["行号"])A=p["行号"]-1;else if(A==-1)A=0;I=+p["number-rows-repeated"]||1;if(I<10)for(Y=0;Y<I;++Y)if(T>0)P[A+Y]={level:T};E=-1;break;case"covered-table-cell":if(w[1]!=="/")++E;if(i.sheetStubs){if(i.dense){if(!b[A])b[A]=[];b[A][E]={t:"z"};}else b[mt({r:A,c:E})]={t:"z"};}x="";C=[];break;case"table-cell":case"数据":if(w[0].charAt(w[0].length-2)==="/"){++E;y=Re(w[0],false);L=parseInt(y["number-columns-repeated"]||"1",10);k={t:"z",v:null};if(y.formula&&i.cellFormula!=false)k.f=ods_to_csf_formula(Be(y.formula));if((y["数据类型"]||y["value-type"])=="string"){k.t="s";k.v=Be(y["string-value"]||"");if(i.dense){if(!b[A])b[A]=[];b[A][E]=k;}else {b[mt({r:A,c:E})]=k;}}E+=L-1;}else if(w[1]!=="/"){++E;x="";S=0;C=[];L=1;var K=I?A+I-1:A;if(E>F.e.c)F.e.c=E;if(E<F.s.c)F.s.c=E;if(A<F.s.r)F.s.r=A;if(K>F.e.r)F.e.r=K;y=Re(w[0],false);U=[];j={};k={t:y["数据类型"]||y["value-type"],v:null};if(i.cellFormula){if(y.formula)y.formula=Be(y.formula);if(y["number-matrix-columns-spanned"]&&y["number-matrix-rows-spanned"]){N=parseInt(y["number-matrix-rows-spanned"],10)||0;R=parseInt(y["number-matrix-columns-spanned"],10)||0;M={s:{r:A,c:E},e:{r:A+N-1,c:E+R-1}};k.F=gt(M);B.push([M,k.F]);}if(y.formula)k.f=ods_to_csf_formula(y.formula);else for(Y=0;Y<B.length;++Y)if(A>=B[Y][0].s.r&&A<=B[Y][0].e.r)if(E>=B[Y][0].s.c&&E<=B[Y][0].e.c)k.F=B[Y][1];}if(y["number-columns-spanned"]||y["number-rows-spanned"]){N=parseInt(y["number-rows-spanned"],10)||0;R=parseInt(y["number-columns-spanned"],10)||0;M={s:{r:A,c:E},e:{r:A+N-1,c:E+R-1}};D.push(M);}if(y["number-columns-repeated"])L=parseInt(y["number-columns-repeated"],10);switch(k.t){case"boolean":k.t="b";k.v=Ye(y["boolean-value"]);break;case"float":k.t="n";k.v=parseFloat(y.value);break;case"percentage":k.t="n";k.v=parseFloat(y.value);break;case"currency":k.t="n";k.v=parseFloat(y.value);break;case"date":k.t="d";k.v=oe(y["date-value"]);if(!i.cellDates){k.t="n";k.v=ee(k.v);}k.z="m/d/yy";break;case"time":k.t="n";k.v=ie(y["time-value"])/86400;if(i.cellDates){k.t="d";k.v=ne(k.v);}k.z="HH:MM:SS";break;case"number":k.t="n";k.v=parseFloat(y["数据数值"]);break;default:if(k.t==="string"||k.t==="text"||!k.t){k.t="s";if(y["string-value"]!=null){x=Be(y["string-value"]);C=[];}}else throw new Error("Unsupported value type "+k.t);}}else {V=false;if(k.t==="s"){k.v=x||"";if(C.length)k.R=C;V=S==0;}if(W.Target)k.l=W;if(U.length>0){k.c=U;U=[];}if(x&&i.cellText!==false)k.w=x;if(V){k.t="z";delete k.v;}if(!V||i.sheetStubs){if(!(i.sheetRows&&i.sheetRows<=A)){for(var J=0;J<I;++J){L=parseInt(y["number-columns-repeated"]||"1",10);if(i.dense){if(!b[A+J])b[A+J]=[];b[A+J][E]=J==0?k:fe(k);while(--L>0)b[A+J][E+L]=fe(k);}else {b[mt({r:A+J,c:E})]=k;while(--L>0)b[mt({r:A+J,c:E+L})]=fe(k);}if(F.e.c<=E)F.e.c=E;}}}L=parseInt(y["number-columns-repeated"]||"1",10);E+=L-1;L=0;k={};x="";C=[];}W={};break;case"document":case"document-content":case"电子表格文档":case"spreadsheet":case"主体":case"scripts":case"styles":case"font-face-decls":case"master-styles":if(w[1]==="/"){if((o=l.pop())[0]!==w[3])throw "Bad state: "+o}else if(w[0].charAt(w[0].length-2)!=="/")l.push([w[3],true]);break;case"annotation":if(w[1]==="/"){if((o=l.pop())[0]!==w[3])throw "Bad state: "+o;j.t=x;if(C.length)j.R=C;j.a=H;U.push(j);}else if(w[0].charAt(w[0].length-2)!=="/"){l.push([w[3],false]);}H="";X=0;x="";S=0;C=[];break;case"creator":if(w[1]==="/"){H=s.slice(X,w.index);}else X=w.index+w[0].length;break;case"meta":case"元数据":case"settings":case"config-item-set":case"config-item-map-indexed":case"config-item-map-entry":case"config-item-map-named":case"shapes":case"frame":case"text-box":case"image":case"data-pilot-tables":case"list-style":case"form":case"dde-links":case"event-listeners":case"chart":if(w[1]==="/"){if((o=l.pop())[0]!==w[3])throw "Bad state: "+o}else if(w[0].charAt(w[0].length-2)!=="/")l.push([w[3],false]);x="";S=0;C=[];break;case"scientific-number":break;case"currency-symbol":break;case"currency-style":break;case"number-style":case"percentage-style":case"date-style":case"time-style":if(w[1]==="/"){O[f.name]=u;if((o=l.pop())[0]!==w[3])throw "Bad state: "+o}else if(w[0].charAt(w[0].length-2)!=="/"){u="";f=Re(w[0],false);l.push([w[3],true]);}break;case"script":break;case"libraries":break;case"automatic-styles":break;case"default-style":case"page-layout":break;case"style":break;case"map":break;case"font-face":break;case"paragraph-properties":break;case"table-properties":break;case"table-column-properties":break;case"table-row-properties":break;case"table-cell-properties":break;case"number":switch(l[l.length-1][0]){case"time-style":case"date-style":c=Re(w[0],false);u+=r[w[3]][c.style==="long"?1:0];break;}break;case"fraction":break;case"day":case"month":case"year":case"era":case"day-of-week":case"week-of-year":case"quarter":case"hours":case"minutes":case"seconds":case"am-pm":
	switch(l[l.length-1][0]){case"time-style":case"date-style":c=Re(w[0],false);u+=r[w[3]][c.style==="long"?1:0];break;}break;case"boolean-style":break;case"boolean":break;case"text-style":break;case"text":if(w[0].slice(-2)==="/>")break;else if(w[1]==="/")switch(l[l.length-1][0]){case"number-style":case"date-style":case"time-style":u+=s.slice(h,w.index);break;}else h=w.index+w[0].length;break;case"named-range":c=Re(w[0],false);$=ods_to_csf_3D(c["cell-range-address"]);var q={Name:c.name,Ref:$[0]+"!"+$[1]};if(G)q.Sheet=g.length;z.Names.push(q);break;case"text-content":break;case"text-properties":break;case"embedded-text":break;case"body":case"电子表格":break;case"forms":break;case"table-column":break;case"table-header-rows":break;case"table-rows":break;case"table-column-group":break;case"table-header-columns":break;case"table-columns":break;case"null-date":break;case"graphic-properties":break;case"calculation-settings":break;case"named-expressions":break;case"label-range":break;case"label-ranges":break;case"named-expression":break;case"sort":break;case"sort-by":break;case"sort-groups":break;case"tab":break;case"line-break":break;case"span":break;case"p":case"文本串":if(["master-styles"].indexOf(l[l.length-1][0])>-1)break;if(w[1]==="/"&&(!y||!y["string-value"])){var Z=e(s.slice(S,w.index));x=(x.length>0?x+"\n":"")+Z[0];}else {Re(w[0],false);S=w.index+w[0].length;}break;case"s":break;case"database-range":if(w[1]==="/")break;try{$=ods_to_csf_3D(Re(w[0])["target-range-address"]);m[$[0]]["!autofilter"]={ref:$[1]};}catch(Q){}break;case"date":break;case"object":break;case"title":case"标题":break;case"desc":break;case"binary-data":break;case"table-source":break;case"scenario":break;case"iteration":break;case"content-validations":break;case"content-validation":break;case"help-message":break;case"error-message":break;case"database-ranges":break;case"filter":break;case"filter-and":break;case"filter-or":break;case"filter-condition":break;case"list-level-style-bullet":break;case"list-level-style-number":break;case"list-level-properties":break;case"sender-firstname":case"sender-lastname":case"sender-initials":case"sender-title":case"sender-position":case"sender-email":case"sender-phone-private":case"sender-fax":case"sender-company":case"sender-phone-work":case"sender-street":case"sender-city":case"sender-postal-code":case"sender-country":case"sender-state-or-province":case"author-name":case"author-initials":case"chapter":case"file-name":case"template-name":case"sheet-name":break;case"event-listener":break;case"initial-creator":case"creation-date":case"print-date":case"generator":case"document-statistic":case"user-defined":case"editing-duration":case"editing-cycles":break;case"config-item":break;case"page-number":break;case"page-count":break;case"time":break;case"cell-range-source":break;case"detective":break;case"operation":break;case"highlighted-range":break;case"data-pilot-table":case"source-cell-range":case"source-service":case"data-pilot-field":case"data-pilot-level":case"data-pilot-subtotals":case"data-pilot-subtotal":case"data-pilot-members":case"data-pilot-member":case"data-pilot-display-info":case"data-pilot-sort-info":case"data-pilot-layout-info":case"data-pilot-field-reference":case"data-pilot-groups":case"data-pilot-group":case"data-pilot-group-member":break;case"rect":break;case"dde-connection-decls":case"dde-connection-decl":case"dde-link":case"dde-source":break;case"properties":break;case"property":break;case"a":if(w[1]!=="/"){W=Re(w[0],false);if(!W.href)break;W.Target=Be(W.href);delete W.href;if(W.Target.charAt(0)=="#"&&W.Target.indexOf(".")>-1){$=ods_to_csf_3D(W.Target.slice(1));W.Target="#"+$[0]+"!"+$[1];}else if(W.Target.match(/^\.\.[\\\/]/))W.Target=W.Target.slice(3);}break;case"table-protection":break;case"data-pilot-grand-total":break;case"office-document-common-attrs":break;default:switch(w[2]){case"dc:":case"calcext:":case"loext:":case"ooo:":case"chartooo:":case"draw:":case"style:":case"chart:":case"form:":case"uof:":case"表:":case"字:":break;default:if(i.WTF)throw new Error(w);}}var re={Sheets:m,SheetNames:g,Workbook:z};if(i.bookSheets)delete re.Sheets;return re}}();function $s(e,r){r=r||{};if(we(e,"META-INF/manifest.xml"))parse_manifest(ye(e,"META-INF/manifest.xml"),r);var t=xe(e,"content.xml");if(!t)throw new Error("Missing content.xml in ODS / UOF file");var a=Ws(Ke(t),r);if(we(e,"meta.xml"))a.Props=ua(ye(e,"meta.xml"));return a}var js=function(){var e=["<office:master-styles>",'<style:master-page style:name="mp1" style:page-layout-name="mp1">',"<style:header/>",'<style:header-left style:display="false"/>',"<style:footer/>",'<style:footer-left style:display="false"/>',"</style:master-page>","</office:master-styles>"].join("");var r="<office:document-styles "+or({"xmlns:office":"urn:oasis:names:tc:opendocument:xmlns:office:1.0","xmlns:table":"urn:oasis:names:tc:opendocument:xmlns:table:1.0","xmlns:style":"urn:oasis:names:tc:opendocument:xmlns:style:1.0","xmlns:text":"urn:oasis:names:tc:opendocument:xmlns:text:1.0","xmlns:draw":"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0","xmlns:fo":"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0","xmlns:xlink":"http://www.w3.org/1999/xlink","xmlns:dc":"http://purl.org/dc/elements/1.1/","xmlns:number":"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0","xmlns:svg":"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0","xmlns:of":"urn:oasis:names:tc:opendocument:xmlns:of:1.2","office:version":"1.2"})+">"+e+"</office:document-styles>";return function t(){return Te+r}}();var Hs=function(){var e=function(e){return $e(e).replace(/  +/g,function(e){return '<text:s text:c="'+e.length+'"/>'}).replace(/\t/g,"<text:tab/>").replace(/\n/g,"</text:p><text:p>").replace(/^ /,"<text:s/>").replace(/ $/,"<text:s/>")};var r="          <table:table-cell />\n";var t="          <table:covered-table-cell/>\n";var a=function(a,n,i){var s=[];s.push('      <table:table table:name="'+$e(n.SheetNames[i])+'" table:style-name="ta1">\n');var l=0,o=0,c=vt(a["!ref"]||"A1");var f=a["!merges"]||[],u=0;var h=Array.isArray(a);if(a["!cols"]){for(o=0;o<=c.e.c;++o)s.push("        <table:table-column"+(a["!cols"][o]?' table:style-name="co'+a["!cols"][o].ods+'"':"")+"></table:table-column>\n");}var d="",p=a["!rows"]||[];for(l=0;l<c.s.r;++l){d=p[l]?' table:style-name="ro'+p[l].ods+'"':"";s.push("        <table:table-row"+d+"></table:table-row>\n");}for(;l<=c.e.r;++l){d=p[l]?' table:style-name="ro'+p[l].ods+'"':"";s.push("        <table:table-row"+d+">\n");for(o=0;o<c.s.c;++o)s.push(r);for(;o<=c.e.c;++o){var m=false,v={},g="";for(u=0;u!=f.length;++u){if(f[u].s.c>o)continue;if(f[u].s.r>l)continue;if(f[u].e.c<o)continue;if(f[u].e.r<l)continue;if(f[u].s.c!=o||f[u].s.r!=l)m=true;v["table:number-columns-spanned"]=f[u].e.c-f[u].s.c+1;v["table:number-rows-spanned"]=f[u].e.r-f[u].s.r+1;break}if(m){s.push(t);continue}var b=mt({r:l,c:o}),w=h?(a[l]||[])[o]:a[b];if(w&&w.f){v["table:formula"]=$e(csf_to_ods_formula(w.f));if(w.F){if(w.F.slice(0,b.length)==b){var k=vt(w.F);v["table:number-matrix-columns-spanned"]=k.e.c-k.s.c+1;v["table:number-matrix-rows-spanned"]=k.e.r-k.s.r+1;}}}if(!w){s.push(r);continue}switch(w.t){case"b":g=w.v?"TRUE":"FALSE";v["office:value-type"]="boolean";v["office:boolean-value"]=w.v?"true":"false";break;case"n":g=w.w||String(w.v||0);v["office:value-type"]="float";v["office:value"]=w.v||0;break;case"s":case"str":g=w.v==null?"":w.v;v["office:value-type"]="string";break;case"d":g=w.w||oe(w.v).toISOString();v["office:value-type"]="date";v["office:date-value"]=oe(w.v).toISOString();v["table:style-name"]="ce1";break;default:s.push(r);continue;}var y=e(g);if(w.l&&w.l.Target){var x=w.l.Target;x=x.charAt(0)=="#"?"#"+csf_to_ods_3D(x.slice(1)):x;if(x.charAt(0)!="#"&&!x.match(/^\w+:/))x="../"+x;y=cr("text:a",y,{"xlink:href":x.replace(/&/g,"&amp;")});}s.push("          "+cr("table:table-cell",cr("text:p",y,{}),v)+"\n");}s.push("        </table:table-row>\n");}s.push("      </table:table>\n");return s.join("")};var n=function(e,r){e.push(" <office:automatic-styles>\n");e.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');e.push('   <number:month number:style="long"/>\n');e.push("   <number:text>/</number:text>\n");e.push('   <number:day number:style="long"/>\n');e.push("   <number:text>/</number:text>\n");e.push("   <number:year/>\n");e.push("  </number:date-style>\n");var t=0;r.SheetNames.map(function(e){return r.Sheets[e]}).forEach(function(r){if(!r)return;if(r["!cols"]){for(var a=0;a<r["!cols"].length;++a)if(r["!cols"][a]){var n=r["!cols"][a];if(n.width==null&&n.wpx==null&&n.wch==null)continue;nn(n);n.ods=t;var i=r["!cols"][a].wpx+"px";e.push('  <style:style style:name="co'+t+'" style:family="table-column">\n');e.push('   <style:table-column-properties fo:break-before="auto" style:column-width="'+i+'"/>\n');e.push("  </style:style>\n");++t;}}});var a=0;r.SheetNames.map(function(e){return r.Sheets[e]}).forEach(function(r){if(!r)return;if(r["!rows"]){for(var t=0;t<r["!rows"].length;++t)if(r["!rows"][t]){r["!rows"][t].ods=a;var n=r["!rows"][t].hpx+"px";e.push('  <style:style style:name="ro'+a+'" style:family="table-row">\n');e.push('   <style:table-row-properties fo:break-before="auto" style:row-height="'+n+'"/>\n');e.push("  </style:style>\n");++a;}}});e.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');e.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');e.push("  </style:style>\n");e.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');e.push(" </office:automatic-styles>\n");};return function i(e,r){var t=[Te];var i=or({"xmlns:office":"urn:oasis:names:tc:opendocument:xmlns:office:1.0","xmlns:table":"urn:oasis:names:tc:opendocument:xmlns:table:1.0","xmlns:style":"urn:oasis:names:tc:opendocument:xmlns:style:1.0","xmlns:text":"urn:oasis:names:tc:opendocument:xmlns:text:1.0","xmlns:draw":"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0","xmlns:fo":"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0","xmlns:xlink":"http://www.w3.org/1999/xlink","xmlns:dc":"http://purl.org/dc/elements/1.1/","xmlns:meta":"urn:oasis:names:tc:opendocument:xmlns:meta:1.0","xmlns:number":"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0","xmlns:presentation":"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0","xmlns:svg":"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0","xmlns:chart":"urn:oasis:names:tc:opendocument:xmlns:chart:1.0","xmlns:dr3d":"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0","xmlns:math":"http://www.w3.org/1998/Math/MathML","xmlns:form":"urn:oasis:names:tc:opendocument:xmlns:form:1.0","xmlns:script":"urn:oasis:names:tc:opendocument:xmlns:script:1.0","xmlns:ooo":"http://openoffice.org/2004/office","xmlns:ooow":"http://openoffice.org/2004/writer","xmlns:oooc":"http://openoffice.org/2004/calc","xmlns:dom":"http://www.w3.org/2001/xml-events","xmlns:xforms":"http://www.w3.org/2002/xforms","xmlns:xsd":"http://www.w3.org/2001/XMLSchema","xmlns:xsi":"http://www.w3.org/2001/XMLSchema-instance","xmlns:sheet":"urn:oasis:names:tc:opendocument:sh33tjs:1.0","xmlns:rpt":"http://openoffice.org/2005/report","xmlns:of":"urn:oasis:names:tc:opendocument:xmlns:of:1.2","xmlns:xhtml":"http://www.w3.org/1999/xhtml","xmlns:grddl":"http://www.w3.org/2003/g/data-view#","xmlns:tableooo":"http://openoffice.org/2009/table","xmlns:drawooo":"http://openoffice.org/2010/draw","xmlns:calcext":"urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0","xmlns:loext":"urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0","xmlns:field":"urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0","xmlns:formx":"urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0","xmlns:css3t":"http://www.w3.org/TR/css3-text/","office:version":"1.2"});var s=or({"xmlns:config":"urn:oasis:names:tc:opendocument:xmlns:config:1.0","office:mimetype":"application/vnd.oasis.opendocument.spreadsheet"});if(r.bookType=="fods"){t.push("<office:document"+i+s+">\n");t.push(write_meta_ods().replace(/office:document-meta/g,"office:meta"));}else t.push("<office:document-content"+i+">\n");n(t,e);t.push("  <office:body>\n");t.push("    <office:spreadsheet>\n");for(var l=0;l!=e.SheetNames.length;++l)t.push(a(e.Sheets[e.SheetNames[l]],e,l));t.push("    </office:spreadsheet>\n");t.push("  </office:body>\n");if(r.bookType=="fods")t.push("</office:document>");else t.push("</office:document-content>");return t.join("")}}();function Xs(e,r){if(r.bookType=="fods")return Hs(e,r);var t=Ae();var a="";var n=[];var i=[];a="mimetype";_e(t,a,"application/vnd.oasis.opendocument.spreadsheet");a="content.xml";_e(t,a,Hs(e,r));n.push([a,"text/xml"]);i.push([a,"ContentFile"]);a="styles.xml";_e(t,a,js(e,r));n.push([a,"text/xml"]);i.push([a,"StylesFile"]);a="meta.xml";_e(t,a,Te+write_meta_ods());n.push([a,"text/xml"]);i.push([a,"MetadataFile"]);a="manifest.rdf";_e(t,a,write_rdf(i));n.push([a,"application/rdf+xml"]);a="META-INF/manifest.xml";_e(t,a,write_manifest(n));return t}function Vs(e,r){if(!r)return 0;var t=e.SheetNames.indexOf(r);if(t==-1)throw new Error("Sheet not found: "+r);return t}function Gs(e){return function r(t,a){var n=Vs(t,a.sheet);return e.from_sheet(t.Sheets[t.SheetNames[n]],a,t)}}var Ys=Gs(Rs);var Ks=Gs({from_sheet:Bl});var Js=Gs(typeof Aa!=="undefined"?Aa:{});var qs=Gs(typeof Ea!=="undefined"?Ea:{});var Zs=Gs(typeof Ta!=="undefined"?Ta:{});var Qs=Gs(typeof RTF!=="undefined"?RTF:{});var el=Gs({from_sheet:zl});var rl=Gs(typeof Ca!=="undefined"?Ca:{});var tl=Gs(typeof Fa!=="undefined"?Fa:{});var al=Gs(typeof WK_!=="undefined"?{from_sheet:WK_.sheet_to_wk1}:{});function nl(e){return function r(t){for(var a=0;a!=e.length;++a){var n=e[a];if(t[n[0]]===undefined)t[n[0]]=n[1];if(n[2]==="n")t[n[0]]=Number(t[n[0]]);}}}var il=function(e){nl([["cellNF",false],["cellHTML",true],["cellFormula",true],["cellStyles",false],["cellText",true],["cellDates",false],["sheetStubs",false],["sheetRows",0,"n"],["bookDeps",false],["bookSheets",false],["bookProps",false],["bookFiles",false],["bookVBA",false],["password",""],["WTF",false]])(e);};var sl=nl([["cellDates",false],["bookSST",false],["bookType","xlsx"],["compression",false],["WTF",false]]);function ll(e){if(ta.WS.indexOf(e)>-1)return "sheet";if(ta.CS&&e==ta.CS)return "chart";if(ta.DS&&e==ta.DS)return "dialog";if(ta.MS&&e==ta.MS)return "macro";return e&&e.length?e:"sheet"}function ol(e,r){if(!e)return 0;try{e=r.map(function a(r){if(!r.id)r.id=r.strRelID;return [r.name,e["!id"][r.id].Target,ll(e["!id"][r.id].Type)]});}catch(t){return null}return !e||e.length===0?null:e}function cl(e,r,t,a,n,i,s,l,o,c,f,u){try{i[a]=na(xe(e,t,true),r);var h=ye(e,r);var d;switch(l){case"sheet":d=bs(h,r,n,o,i[a],c,f,u);break;case"chart":d=ws(h,r,n,o,i[a],c,f,u);if(!d||!d["!drawel"])break;var p=Fe(d["!drawel"].Target,r);var m=aa(p);var v=In(xe(e,p,true),na(xe(e,m,true),p));var g=Fe(v,p);var b=aa(g);d=Yi(xe(e,g,true),g,o,na(xe(e,b,true),g),c,d);break;case"macro":d=ks(h,r,n,o,i[a],c,f,u);break;case"dialog":d=ys(h,r,n,o,i[a],c,f,u);break;default:throw new Error("Unrecognized sheet type "+l);}s[a]=d;var w=[];if(i&&i[a])Y(i[a]).forEach(function(t){if(i[a][t].Type==ta.CMNT){var n=Fe(i[a][t].Target,r);w=Cs(ye(e,n,true),n,o);if(!w||!w.length)return;zn(d,w);}});}catch(k){if(o.WTF)throw k}}function fl(e){return e.charAt(0)=="/"?e.slice(1):e}function ul(e,r){R(N);r=r||{};il(r);if(we(e,"META-INF/manifest.xml"))return $s(e,r);if(we(e,"objectdata.xml"))return $s(e,r);if(we(e,"Index/Document.iwa"))throw new Error("Unsupported NUMBERS file");if(!we(e,"[Content_Types].xml")){if(we(e,"index.xml.gz"))throw new Error("Unsupported NUMBERS 08 file");if(we(e,"index.xml"))throw new Error("Unsupported NUMBERS 09 file");throw new Error("Unsupported ZIP file")}var t=Se(e);var a=Zt(xe(e,"[Content_Types].xml"));var n=false;var i,s;if(a.workbooks.length===0){s="xl/workbook.xml";if(ye(e,s,true))a.workbooks.push(s);}if(a.workbooks.length===0){s="xl/workbook.bin";if(!ye(e,s,true))throw new Error("Could not find workbook");a.workbooks.push(s);n=true;}if(a.workbooks[0].slice(-3)=="bin")n=true;var l={};var o={};if(!r.bookSheets&&!r.bookProps){ni=[];if(a.sst)try{ni=_s(ye(e,fl(a.sst)),a.sst,r);}catch(c){if(r.WTF)throw c}if(r.cellStyles&&a.themes.length)l=Ss(xe(e,a.themes[0].replace(/^\//,""),true)||"",a.themes[0],r);if(a.style)o=xs(ye(e,fl(a.style)),a.style,l,r);}a.links.map(function(t){try{var a=na(xe(e,aa(fl(t))),t);return Es(ye(e,fl(t)),a,t,r)}catch(n){}});var f=gs(ye(e,fl(a.workbooks[0])),a.workbooks[0],r);var u={},h="";if(a.coreprops.length){h=ye(e,fl(a.coreprops[0]),true);if(h)u=ua(h);if(a.extprops.length!==0){h=ye(e,fl(a.extprops[0]),true);if(h)ba(h,u,r);}}var d={};if(!r.bookSheets||r.bookProps){if(a.custprops.length!==0){h=xe(e,fl(a.custprops[0]),true);if(h)d=xa(h,r);}}var p={};if(r.bookSheets||r.bookProps){if(f.Sheets)i=f.Sheets.map(function O(e){return e.name});else if(u.Worksheets&&u.SheetNames.length>0)i=u.SheetNames;if(r.bookProps){p.Props=u;p.Custprops=d;}if(r.bookSheets&&typeof i!=="undefined")p.SheetNames=i;if(r.bookSheets?p.SheetNames:r.bookProps)return p}i={};var m={};if(r.bookDeps&&a.calcchain)m=As(ye(e,fl(a.calcchain)),a.calcchain,r);var v=0;var g={};var b,w;{var k=f.Sheets;u.Worksheets=k.length;u.SheetNames=[];for(var y=0;y!=k.length;++y){u.SheetNames[y]=k[y].name;}}var x=n?"bin":"xml";var S=a.workbooks[0].lastIndexOf("/");var _=(a.workbooks[0].slice(0,S+1)+"_rels/"+a.workbooks[0].slice(S+1)+".rels").replace(/^\//,"");if(!we(e,_))_="xl/_rels/workbook."+x+".rels";var C=na(xe(e,_,true),_);if(C)C=ol(C,f.Sheets);var A=ye(e,"xl/worksheets/sheet.xml",true)?1:0;e:for(v=0;v!=u.Worksheets;++v){var E="sheet";if(C&&C[v]){b="xl/"+C[v][1].replace(/[\/]?xl\//,"");if(!we(e,b))b=C[v][1];if(!we(e,b))b=_.replace(/_rels\/.*$/,"")+C[v][1];E=C[v][2];}else {b="xl/worksheets/sheet"+(v+1-A)+"."+x;b=b.replace(/sheet0\./,"sheet.");}w=b.replace(/^(.*)(\/)([^\/]*)$/,"$1/_rels/$3.rels");if(r&&r.sheets!=null)switch(typeof r.sheets){case"number":if(v!=r.sheets)continue e;break;case"string":if(u.SheetNames[v].toLowerCase()!=r.sheets.toLowerCase())continue e;break;default:if(Array.isArray&&Array.isArray(r.sheets)){var F=false;for(var T=0;T!=r.sheets.length;++T){if(typeof r.sheets[T]=="number"&&r.sheets[T]==v)F=1;if(typeof r.sheets[T]=="string"&&r.sheets[T].toLowerCase()==u.SheetNames[v].toLowerCase())F=1;}if(!F)continue e}}cl(e,b,w,u.SheetNames[v],v,g,i,E,r,f,l,o);}p={Directory:a,Workbook:f,Props:u,Custprops:d,Deps:m,Sheets:i,SheetNames:u.SheetNames,Strings:ni,Styles:o,Themes:l,SSF:N.get_table()};if(r&&r.bookFiles){if(e.files){p.keys=t;p.files=e.files;}else {p.keys=[];p.files={};e.FullPaths.forEach(function(r,t){r=r.replace(/^Root Entry[\/]/,"");p.keys.push(r);p.files[r]=e.FileIndex[t];});}}if(r&&r.bookVBA){if(a.vba.length>0)p.vbaraw=ye(e,fl(a.vba[0]),true);else if(a.defaults&&a.defaults.bin===jn)p.vbaraw=ye(e,"xl/vbaProject.bin",true);}return p}function hl(e,r){var t=r||{};var a="Workbook",n=j.find(e,a);try{a="/!DataSpaces/Version";n=j.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);parse_DataSpaceVersionInfo(n.content);a="/!DataSpaces/DataSpaceMap";n=j.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);var i=parse_DataSpaceMap(n.content);if(i.length!==1||i[0].comps.length!==1||i[0].comps[0].t!==0||i[0].name!=="StrongEncryptionDataSpace"||i[0].comps[0].v!=="EncryptedPackage")throw new Error("ECMA-376 Encrypted file bad "+a);a="/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";n=j.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);var s=parse_DataSpaceDefinition(n.content);if(s.length!=1||s[0]!="StrongEncryptionTransform")throw new Error("ECMA-376 Encrypted file bad "+a);a="/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";n=j.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);parse_Primary(n.content);}catch(l){}a="/EncryptionInfo";n=j.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);var o=parse_EncryptionInfo(n.content);a="/EncryptedPackage";n=j.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);if(o[0]==4&&typeof decrypt_agile!=="undefined")return decrypt_agile(o[1],n.content,t.password||"",t);if(o[0]==2&&typeof decrypt_std76!=="undefined")return decrypt_std76(o[1],n.content,t.password||"",t);throw new Error("File is password-protected")}function dl(e,r){Ln=1024;if(r.bookType=="ods")return Xs(e,r);if(e&&!e.SSF){e.SSF=N.get_table();}if(e&&e.SSF){R(N);N.load_table(e.SSF);r.revssf=q(e.SSF);r.revssf[e.SSF[65535]]=0;r.ssf=e.SSF;}r.rels={};r.wbrels={};r.Strings=[];r.Strings.Count=0;r.Strings.Unique=0;if(si)r.revStrings=new Map;else {r.revStrings={};r.revStrings.foo=[];delete r.revStrings.foo;}var t=r.bookType=="xlsb"?"bin":"xml";var a=Vn.indexOf(r.bookType)>-1;var n=qt();sl(r=r||{});var i=Ae();var s="",l=0;r.cellXfs=[];fi(r.cellXfs,{},{revssf:{General:0}});if(!e.Props)e.Props={};s="docProps/core.xml";_e(i,s,pa(e.Props,r));n.coreprops.push(s);oa(r.rels,2,s,ta.CORE_PROPS);s="docProps/app.xml";if(e.Props&&e.Props.SheetNames);else if(!e.Workbook||!e.Workbook.Sheets)e.Props.SheetNames=e.SheetNames;else {var o=[];for(var c=0;c<e.SheetNames.length;++c)if((e.Workbook.Sheets[c]||{}).Hidden!=2)o.push(e.SheetNames[c]);e.Props.SheetNames=o;}e.Props.Worksheets=e.Props.SheetNames.length;_e(i,s,ka(e.Props));n.extprops.push(s);oa(r.rels,3,s,ta.EXT_PROPS);if(e.Custprops!==e.Props&&Y(e.Custprops||{}).length>0){s="docProps/custom.xml";_e(i,s,_a(e.Custprops));n.custprops.push(s);oa(r.rels,4,s,ta.CUST_PROPS);}for(l=1;l<=e.SheetNames.length;++l){var f={"!id":{}};var u=e.Sheets[e.SheetNames[l-1]];var h=(u||{})["!type"]||"sheet";switch(h){case"chart":default:s="xl/worksheets/sheet"+l+"."+t;_e(i,s,Ts(l-1,s,r,e,f));n.sheets.push(s);oa(r.wbrels,-1,"worksheets/sheet"+l+"."+t,ta.WS[0]);}if(u){var d=u["!comments"];var p=false;if(d&&d.length>0){var m="xl/comments"+l+"."+t;_e(i,m,Ns(d,m,r));n.comments.push(m);oa(f,-1,"../comments"+l+"."+t,ta.CMNT);p=true;}if(u["!legacy"]){if(p)_e(i,"xl/drawings/vmlDrawing"+l+".vml",Bn(l,u["!comments"]));}delete u["!comments"];delete u["!legacy"];}if(f["!id"].rId1)_e(i,aa(s),sa(f));}if(r.Strings!=null&&r.Strings.length>0){s="xl/sharedStrings."+t;_e(i,s,Ms(r.Strings,s,r));n.strs.push(s);oa(r.wbrels,-1,"sharedStrings."+t,ta.SST);}s="xl/workbook."+t;_e(i,s,Fs(e,s,r));n.workbooks.push(s);oa(r.rels,1,s,ta.WB);s="xl/theme/theme1.xml";_e(i,s,Nn(e.Themes,r));n.themes.push(s);oa(r.wbrels,-1,"theme/theme1.xml",ta.THEME);s="xl/styles."+t;_e(i,s,Ds(e,s,r));n.styles.push(s);oa(r.wbrels,-1,"styles."+t,ta.STY);if(e.vbaraw&&a){s="xl/vbaProject.bin";_e(i,s,e.vbaraw);n.vba.push(s);oa(r.wbrels,-1,"vbaProject.bin",ta.VBA);}_e(i,"[Content_Types].xml",ra(n,r));_e(i,"_rels/.rels",sa(r.rels));_e(i,"xl/_rels/workbook."+t+".rels",sa(r.wbrels));delete r.revssf;delete r.ssf;return i}function pl(e,r){var t="";switch((r||{}).type||"base64"){case"buffer":return [e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]];case"base64":t=b.decode(e.slice(0,12));break;case"binary":t=e;break;case"array":return [e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]];default:throw new Error("Unrecognized type "+(r&&r.type||"undefined"));}return [t.charCodeAt(0),t.charCodeAt(1),t.charCodeAt(2),t.charCodeAt(3),t.charCodeAt(4),t.charCodeAt(5),t.charCodeAt(6),t.charCodeAt(7)]}function ml(e,r){if(j.find(e,"EncryptedPackage"))return hl(e,r);return parse_xlscfb(e,r)}function vl(e,r){var t,a=e;var n=r||{};if(!n.type)n.type=w&&Buffer.isBuffer(e)?"buffer":"base64";t=Ee(a,n);return ul(t,n)}function gl(e,r){var t=0;e:while(t<e.length)switch(e.charCodeAt(t)){case 10:case 13:case 32:++t;break;case 60:return parse_xlml(e.slice(t),r);default:break e;}return Ta.to_workbook(e,r)}function bl(e,r){var t="",a=pl(e,r);switch(r.type){case"base64":t=b.decode(e);break;case"binary":t=e;break;case"buffer":t=e.toString("binary");break;case"array":t=ce(e);break;default:throw new Error("Unrecognized type "+r.type);}if(a[0]==239&&a[1]==187&&a[2]==191)t=Ke(t);return gl(t,r)}function wl(e,r){var t=e;if(r.type=="base64")t=b.decode(t);t=cptable.utils.decode(1200,t.slice(2),"str");r.type="binary";return gl(t,r)}function kl(e){return !e.match(/[^\x00-\x7F]/)?e:Je(e)}function yl(e,r,t,a){if(a){t.type="string";return Ta.to_workbook(e,t)}return Ta.to_workbook(r,t)}function xl(e,r){c();var t=r||{};if(typeof ArrayBuffer!=="undefined"&&e instanceof ArrayBuffer)return xl(new Uint8Array(e),(t=fe(t),t.type="array",t));var a=e,n=[0,0,0,0],i=false;if(t.cellStyles){t.cellNF=true;t.sheetStubs=true;}ii={};if(t.dateNF)ii.dateNF=t.dateNF;if(!t.type)t.type=w&&Buffer.isBuffer(e)?"buffer":"base64";if(t.type=="file"){t.type=w?"buffer":"binary";a=G(e);}if(t.type=="string"){i=true;t.type="binary";t.codepage=65001;a=kl(e);}if(t.type=="array"&&typeof Uint8Array!=="undefined"&&e instanceof Uint8Array&&typeof ArrayBuffer!=="undefined"){var s=new ArrayBuffer(3),l=new Uint8Array(s);l.foo="bar";if(!l.foo){t=fe(t);t.type="array";return xl(T(a),t)}}switch((n=pl(a,t))[0]){case 208:if(n[1]===207&&n[2]===17&&n[3]===224&&n[4]===161&&n[5]===177&&n[6]===26&&n[7]===225)return ml(j.read(a,t),t);break;case 9:if(n[1]<=8)return parse_xlscfb(a,t);break;case 60:return parse_xlml(a,t);case 73:if(n[1]===73&&n[2]===42&&n[3]===0)throw new Error("TIFF Image File is not a spreadsheet");if(n[1]===68)return Oa(a,t);break;case 84:if(n[1]===65&&n[2]===66&&n[3]===76)return Ea.to_workbook(a,t);break;case 80:return n[1]===75&&n[2]<9&&n[3]<9?vl(a,t):yl(e,a,t,i);case 239:return n[3]===60?parse_xlml(a,t):yl(e,a,t,i);case 255:if(n[1]===254){return wl(a,t)}else if(n[1]===0&&n[2]===2&&n[3]===0)return WK_.to_workbook(a,t);break;case 0:if(n[1]===0){if(n[2]>=2&&n[3]===0)return WK_.to_workbook(a,t);if(n[2]===0&&(n[3]===8||n[3]===9))return WK_.to_workbook(a,t)}break;case 3:case 131:case 139:case 140:return Ca.to_workbook(a,t);case 123:if(n[1]===92&&n[2]===114&&n[3]===116)return RTF.to_workbook(a,t);break;case 10:case 13:case 32:return bl(a,t);case 137:if(n[1]===80&&n[2]===78&&n[3]===71)throw new Error("PNG Image File is not a spreadsheet");break;}if(Ca.versions.indexOf(n[0])>-1&&n[2]<=12&&n[3]<=31)return Ca.to_workbook(a,t);return yl(e,a,t,i)}function Sl(e,r){var t=r||{};t.type="file";return xl(e,t)}function _l(e,r){switch(r.type){case"base64":case"binary":break;case"buffer":case"array":r.type="";break;case"file":return V(r.file,j.write(e,{type:w?"buffer":""}));case"string":throw new Error("'string' output type invalid for '"+r.bookType+"' files");default:throw new Error("Unrecognized type "+r.type);}return j.write(e,r)}function Cl(e,r){var t=fe(r||{});var a=dl(e,t);var n={};if(t.compression)n.compression="DEFLATE";if(t.password)n.type=w?"nodebuffer":"string";else switch(t.type){case"base64":n.type="base64";break;case"binary":n.type="string";break;case"string":throw new Error("'string' output type invalid for '"+t.bookType+"' files");case"buffer":case"file":n.type=w?"nodebuffer":"string";break;default:throw new Error("Unrecognized type "+t.type);}var i=a.FullPaths?j.write(a,{fileType:"zip",type:{nodebuffer:"buffer",string:"binary"}[n.type]||n.type}):a.generate(n);if(t.password&&typeof encrypt_agile!=="undefined")return _l(encrypt_agile(i,t.password),t);if(t.type==="file")return V(t.file,i);return t.type=="string"?Ke(i):i}function Al(e,r){var t=r||{};var a=write_xlscfb(e,t);return _l(a,t)}function El(e,r,t){if(!t)t="";var a=t+e;switch(r.type){case"base64":return b.encode(Je(a));case"binary":return Je(a);case"string":return e;case"file":return V(r.file,a,"utf8");case"buffer":{if(w)return k(a,"utf8");else return El(a,{type:"binary"}).split("").map(function(e){return e.charCodeAt(0)})}}throw new Error("Unrecognized type "+r.type)}function Fl(e,r){switch(r.type){case"base64":return b.encode(e);case"binary":return e;case"string":return e;case"file":return V(r.file,e,"binary");case"buffer":{if(w)return k(e,"binary");else return e.split("").map(function(e){return e.charCodeAt(0)})}}throw new Error("Unrecognized type "+r.type)}function Tl(e,r){switch(r.type){case"string":case"base64":case"binary":var t="";for(var a=0;a<e.length;++a)t+=String.fromCharCode(e[a]);return r.type=="base64"?b.encode(t):r.type=="string"?Ke(t):t;case"file":return V(r.file,e);case"buffer":return e;default:throw new Error("Unrecognized type "+r.type);}}function Ol(e,r){c();hs(e);var t=fe(r||{});if(t.cellStyles){t.cellNF=true;t.sheetStubs=true;}if(t.type=="array"){t.type="binary";var a=Ol(e,t);t.type="array";return A(a)}switch(t.bookType||"xlsb"){case"xml":case"xlml":return El(write_xlml(e,t),t);case"slk":case"sylk":return El(Js(e,t),t);case"htm":case"html":return El(Ys(e,t),t);case"txt":return Fl(el(e,t),t);case"csv":return El(Ks(e,t),t,"\ufeff");case"dif":return El(qs(e,t),t);case"dbf":return Tl(rl(e,t),t);case"prn":return El(Zs(e,t),t);case"rtf":return El(Qs(e,t),t);case"eth":return El(tl(e,t),t);case"fods":return El(Xs(e,t),t);case"wk1":return Tl(al(e,t),t);case"wk3":return Tl(WK_.book_to_wk3(e,t),t);case"biff2":if(!t.biff)t.biff=2;case"biff3":if(!t.biff)t.biff=3;case"biff4":if(!t.biff)t.biff=4;return Tl(write_biff_buf(e,t),t);case"biff5":if(!t.biff)t.biff=5;case"biff8":case"xla":case"xls":if(!t.biff)t.biff=8;return Al(e,t);case"xlsx":case"xlsm":case"xlam":case"xlsb":case"ods":return Cl(e,t);default:throw new Error("Unrecognized bookType |"+t.bookType+"|");}}function Dl(e){if(e.bookType)return;var r={xls:"biff8",htm:"html",slk:"sylk",socialcalc:"eth",Sh33tJS:"WTF"};var t=e.file.slice(e.file.lastIndexOf(".")).toLowerCase();if(t.match(/^\.[a-z]+$/))e.bookType=t.slice(1);e.bookType=r[e.bookType]||e.bookType;}function Ml(e,r,t){var a=t||{};a.type="file";a.file=r;Dl(a);return Ol(e,a)}function Nl(e,r,t,a){var n=t||{};n.type="file";n.file=e;Dl(n);n.type="buffer";var i=a;if(!(i instanceof Function))i=t;return H.writeFile(e,Ol(r,n),i)}function Rl(e,r,t,a,n,i,s,l){var o=st(t);var c=l.defval,f=l.raw||!Object.prototype.hasOwnProperty.call(l,"raw");var u=true;var h=n===1?[]:{};if(n!==1){if(Object.defineProperty)try{Object.defineProperty(h,"__rowNum__",{value:t,enumerable:false});}catch(d){h.__rowNum__=t;}else h.__rowNum__=t;}if(!s||e[t])for(var p=r.s.c;p<=r.e.c;++p){var m=s?e[t][p]:e[a[p]+o];if(m===undefined||m.t===undefined){if(c===undefined)continue;if(i[p]!=null){h[i[p]]=c;}continue}var v=m.v;switch(m.t){case"z":if(v==null)break;continue;case"e":v=v==0?null:void 0;break;case"s":case"d":case"b":case"n":break;default:throw new Error("unrecognized type "+m.t);}if(i[p]!=null){if(v==null){if(m.t=="e"&&v===null)h[i[p]]=null;else if(c!==undefined)h[i[p]]=c;else if(f&&v===null)h[i[p]]=null;else continue}else {h[i[p]]=f||l.rawNumbers&&m.t=="n"?v:kt(m,v,l);}if(v!=null)u=false;}}return {row:h,isempty:u}}function Pl(e,r){if(e==null||e["!ref"]==null)return [];var t={t:"n",v:0},a=0,n=1,i=[],s=0,l="";var o={s:{r:0,c:0},e:{r:0,c:0}};var c=r||{};var f=c.range!=null?c.range:e["!ref"];if(c.header===1)a=1;else if(c.header==="A")a=2;else if(Array.isArray(c.header))a=3;else if(c.header==null)a=0;switch(typeof f){case"string":o=bt(f);break;case"number":o=bt(e["!ref"]);o.s.r=f;break;default:o=f;}if(a>0)n=0;var u=st(o.s.r);var h=[];var d=[];var p=0,m=0;var v=Array.isArray(e);var g=o.s.r,b=0,w=0;if(v&&!e[g])e[g]=[];for(b=o.s.c;b<=o.e.c;++b){h[b]=ft(b);t=v?e[g][b]:e[h[b]+u];switch(a){case 1:i[b]=b-o.s.c;break;case 2:i[b]=h[b];break;case 3:i[b]=c.header[b-o.s.c];break;default:if(t==null)t={w:"__EMPTY",t:"s"};l=s=kt(t,null,c);m=0;for(w=0;w<i.length;++w)if(i[w]==l)l=s+"_"+ ++m;i[b]=l;}}for(g=o.s.r+n;g<=o.e.r;++g){var k=Rl(e,o,g,h,a,i,v,c);if(k.isempty===false||(a===1?c.blankrows!==false:!!c.blankrows))d[p++]=k.row;}d.length=p;return d}var Il=/"/g;function Ll(e,r,t,a,n,i,s,l){var o=true;var c=[],f="",u=st(t);for(var h=r.s.c;h<=r.e.c;++h){if(!a[h])continue;var d=l.dense?(e[t]||[])[h]:e[a[h]+u];if(d==null)f="";else if(d.v!=null){o=false;f=""+(l.rawNumbers&&d.t=="n"?d.v:kt(d,null,l));for(var p=0,m=0;p!==f.length;++p)if((m=f.charCodeAt(p))===n||m===i||m===34||l.forceQuotes){
	f='"'+f.replace(Il,'""')+'"';break}if(f=="ID")f='"ID"';}else if(d.f!=null&&!d.F){o=false;f="="+d.f;if(f.indexOf(",")>=0)f='"'+f.replace(Il,'""')+'"';}else f="";c.push(f);}if(l.blankrows===false&&o)return null;return c.join(s)}function Bl(e,r){var t=[];var a=r==null?{}:r;if(e==null||e["!ref"]==null)return "";var n=bt(e["!ref"]);var i=a.FS!==undefined?a.FS:",",s=i.charCodeAt(0);var l=a.RS!==undefined?a.RS:"\n",o=l.charCodeAt(0);var c=new RegExp((i=="|"?"\\|":i)+"+$");var f="",u=[];a.dense=Array.isArray(e);var h=a.skipHidden&&e["!cols"]||[];var d=a.skipHidden&&e["!rows"]||[];for(var p=n.s.c;p<=n.e.c;++p)if(!(h[p]||{}).hidden)u[p]=ft(p);for(var m=n.s.r;m<=n.e.r;++m){if((d[m]||{}).hidden)continue;f=Ll(e,n,m,u,s,o,i,a);if(f==null){continue}if(a.strip)f=f.replace(c,"");t.push(f+l);}delete a.dense;return t.join("")}function zl(e,r){if(!r)r={};r.FS="\t";r.RS="\n";var t=Bl(e,r);if(typeof cptable=="undefined"||r.type=="string")return t;var a=cptable.utils.encode(1200,t,"str");return String.fromCharCode(255)+String.fromCharCode(254)+a}function Wl(e){var r="",t,a="";if(e==null||e["!ref"]==null)return [];var n=bt(e["!ref"]),i="",s=[],l;var o=[];var c=Array.isArray(e);for(l=n.s.c;l<=n.e.c;++l)s[l]=ft(l);for(var f=n.s.r;f<=n.e.r;++f){i=st(f);for(l=n.s.c;l<=n.e.c;++l){r=s[l]+i;t=c?(e[f]||[])[l]:e[r];a="";if(t===undefined)continue;else if(t.F!=null){r=t.F;if(!t.f)continue;a=t.f;if(r.indexOf(":")==-1)r=r+":"+r;}if(t.f!=null)a=t.f;else if(t.t=="z")continue;else if(t.t=="n"&&t.v!=null)a=""+t.v;else if(t.t=="b")a=t.v?"TRUE":"FALSE";else if(t.w!==undefined)a="'"+t.w;else if(t.v===undefined)continue;else if(t.t=="s")a="'"+t.v;else a=""+t.v;o[o.length]=r+"="+a;}}return o}function $l(e,r,t){var a=t||{};var n=+!a.skipHeader;var i=e||{};var s=0,l=0;if(i&&a.origin!=null){if(typeof a.origin=="number")s=a.origin;else {var o=typeof a.origin=="string"?pt(a.origin):a.origin;s=o.r;l=o.c;}}var c;var f={s:{c:0,r:0},e:{c:l,r:s+r.length-1+n}};if(i["!ref"]){var u=bt(i["!ref"]);f.e.c=Math.max(f.e.c,u.e.c);f.e.r=Math.max(f.e.r,u.e.r);if(s==-1){s=u.e.r+1;f.e.r=s+r.length-1+n;}}else {if(s==-1){s=0;f.e.r=r.length-1+n;}}var h=a.header||[],d=0;r.forEach(function(e,r){Y(e).forEach(function(t){if((d=h.indexOf(t))==-1)h[d=h.length]=t;var o=e[t];var f="z";var u="";var p=mt({c:l+d,r:s+r+n});c=jl.sheet_get_cell(i,p);if(o&&typeof o==="object"&&!(o instanceof Date)){i[p]=o;}else {if(typeof o=="number")f="n";else if(typeof o=="boolean")f="b";else if(typeof o=="string")f="s";else if(o instanceof Date){f="d";if(!a.cellDates){f="n";o=ee(o);}u=a.dateNF||N._table[14];}else if(o===null&&a.nullError){f="e";o=0;}if(!c)i[p]=c={t:f,v:o};else {c.t=f;c.v=o;delete c.w;delete c.R;if(u)c.z=u;}if(u)c.z=u;}});});f.e.c=Math.max(f.e.c,l+h.length-1);var p=st(s);if(n)for(d=0;d<h.length;++d)i[ft(d+l)+p]={t:"s",v:h[d]};i["!ref"]=gt(f);return i}function Ul(e,r){return $l(null,e,r)}var jl={encode_col:ft,encode_row:st,encode_cell:mt,encode_range:gt,decode_col:ct,decode_row:it,split_cell:dt,decode_cell:pt,decode_range:vt,format_cell:kt,get_formulae:Wl,make_csv:Bl,make_json:Pl,make_formulae:Wl,sheet_add_aoa:xt,sheet_add_json:$l,sheet_add_dom:Ps,aoa_to_sheet:St,json_to_sheet:Ul,table_to_sheet:Is,table_to_book:Ls,sheet_to_csv:Bl,sheet_to_txt:zl,sheet_to_json:Pl,sheet_to_html:Rs.from_sheet,sheet_to_formulae:Wl,sheet_to_row_object_array:Pl};(function(e){e.consts=e.consts||{};function r(r){r.forEach(function(r){e.consts[r[0]]=r[1];});}function t(e,r,t){return e[r]!=null?e[r]:e[r]=t}function a(e,r,t){if(typeof r=="string"){if(Array.isArray(e)){var n=pt(r);if(!e[n.r])e[n.r]=[];return e[n.r][n.c]||(e[n.r][n.c]={t:"z"})}return e[r]||(e[r]={t:"z"})}if(typeof r!="number")return a(e,mt(r));return a(e,mt({r:r,c:t||0}))}e.sheet_get_cell=a;function n(e,r){if(typeof r=="number"){if(r>=0&&e.SheetNames.length>r)return r;throw new Error("Cannot find sheet # "+r)}else if(typeof r=="string"){var t=e.SheetNames.indexOf(r);if(t>-1)return t;throw new Error("Cannot find sheet name |"+r+"|")}else throw new Error("Cannot find sheet |"+r+"|")}e.book_new=function(){return {SheetNames:[],Sheets:{}}};e.book_append_sheet=function(e,r,t){if(!t)for(var a=1;a<=65535;++a,t=undefined)if(e.SheetNames.indexOf(t="Sheet"+a)==-1)break;if(!t||e.SheetNames.length>=65535)throw new Error("Too many worksheets");fs(t);if(e.SheetNames.indexOf(t)>=0)throw new Error("Worksheet with name |"+t+"| already exists!");e.SheetNames.push(t);e.Sheets[t]=r;};e.book_set_sheet_visibility=function(e,r,a){t(e,"Workbook",{});t(e.Workbook,"Sheets",[]);var i=n(e,r);t(e.Workbook.Sheets,i,{});switch(a){case 0:case 1:case 2:break;default:throw new Error("Bad sheet visibility setting "+a);}e.Workbook.Sheets[i].Hidden=a;};r([["SHEET_VISIBLE",0],["SHEET_HIDDEN",1],["SHEET_VERY_HIDDEN",2]]);e.cell_set_number_format=function(e,r){e.z=r;return e};e.cell_set_hyperlink=function(e,r,t){if(!r){delete e.l;}else {e.l={Target:r};if(t)e.l.Tooltip=t;}return e};e.cell_set_internal_link=function(r,t,a){return e.cell_set_hyperlink(r,"#"+t,a)};e.cell_add_comment=function(e,r,t){if(!e.c)e.c=[];e.c.push({t:r,a:t||"SheetJS"});};e.sheet_set_array_formula=function(e,r,t){var n=typeof r!="string"?r:bt(r);var i=typeof r=="string"?r:gt(r);for(var s=n.s.r;s<=n.e.r;++s)for(var l=n.s.c;l<=n.e.c;++l){var o=a(e,s,l);o.t="n";o.F=i;delete o.v;if(s==n.s.r&&l==n.s.c)o.f=t;}return e};return e})(jl);if(typeof parse_xlscfb!=="undefined")e.parse_xlscfb=parse_xlscfb;e.parse_zip=ul;e.read=xl;e.readFile=Sl;e.readFileSync=Sl;e.write=Ol;e.writeFile=Ml;e.writeFileSync=Ml;e.writeFileAsync=Nl;e.utils=jl;e.SSF=N;if(typeof j!=="undefined")e.CFB=j;}make_xlsx_lib(exports);if(typeof window!=="undefined"&&!window.XLSX)try{window.XLSX=XLSX;}catch(e){}});

	var FileSaver = createCommonjsModule(function (module) {
	/* FileSaver.js
	 * A saveAs() FileSaver implementation.
	 * 1.3.2
	 * 2016-06-16 18:25:19
	 *
	 * By Eli Grey, http://eligrey.com
	 * License: MIT
	 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
	 */

	/*global self */
	/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

	/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

	var saveAs = saveAs || (function(view) {
		// IE <10 is explicitly unsupported
		if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
			return;
		}
		var
			  doc = view.document
			  // only get URL when necessary in case Blob.js hasn't overridden it yet
			, get_URL = function() {
				return view.URL || view.webkitURL || view;
			}
			, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
			, can_use_save_link = "download" in save_link
			, click = function(node) {
				var event = new MouseEvent("click");
				node.dispatchEvent(event);
			}
			, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
			, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
			, throw_outside = function(ex) {
				(view.setImmediate || view.setTimeout)(function() {
					throw ex;
				}, 0);
			}
			, force_saveable_type = "application/octet-stream"
			// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
			, arbitrary_revoke_timeout = 1000 * 40 // in ms
			, revoke = function(file) {
				var revoker = function() {
					if (typeof file === "string") { // file is an object URL
						get_URL().revokeObjectURL(file);
					} else { // file is a File
						file.remove();
					}
				};
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
			, dispatch = function(filesaver, event_types, event) {
				event_types = [].concat(event_types);
				var i = event_types.length;
				while (i--) {
					var listener = filesaver["on" + event_types[i]];
					if (typeof listener === "function") {
						try {
							listener.call(filesaver, event || filesaver);
						} catch (ex) {
							throw_outside(ex);
						}
					}
				}
			}
			, auto_bom = function(blob) {
				// prepend BOM for UTF-8 XML and text/* types (including HTML)
				// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
				if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
					return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
				}
				return blob;
			}
			, FileSaver = function(blob, name, no_auto_bom) {
				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				// First try a.download, then web filesystem, then object URLs
				var
					  filesaver = this
					, type = blob.type
					, force = type === force_saveable_type
					, object_url
					, dispatch_all = function() {
						dispatch(filesaver, "writestart progress write writeend".split(" "));
					}
					// on any filesys errors revert to saving with object URLs
					, fs_error = function() {
						if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
							// Safari doesn't allow downloading of blob urls
							var reader = new FileReader();
							reader.onloadend = function() {
								var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
								var popup = view.open(url, '_blank');
								if(!popup) view.location.href = url;
								url=undefined; // release reference before dispatching
								filesaver.readyState = filesaver.DONE;
								dispatch_all();
							};
							reader.readAsDataURL(blob);
							filesaver.readyState = filesaver.INIT;
							return;
						}
						// don't create more object URLs than needed
						if (!object_url) {
							object_url = get_URL().createObjectURL(blob);
						}
						if (force) {
							view.location.href = object_url;
						} else {
							var opened = view.open(object_url, "_blank");
							if (!opened) {
								// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
								view.location.href = object_url;
							}
						}
						filesaver.readyState = filesaver.DONE;
						dispatch_all();
						revoke(object_url);
					}
				;
				filesaver.readyState = filesaver.INIT;

				if (can_use_save_link) {
					object_url = get_URL().createObjectURL(blob);
					setTimeout(function() {
						save_link.href = object_url;
						save_link.download = name;
						click(save_link);
						dispatch_all();
						revoke(object_url);
						filesaver.readyState = filesaver.DONE;
					});
					return;
				}

				fs_error();
			}
			, FS_proto = FileSaver.prototype
			, saveAs = function(blob, name, no_auto_bom) {
				return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
			}
		;
		// IE 10+ (native saveAs)
		if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
			return function(blob, name, no_auto_bom) {
				name = name || blob.name || "download";

				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				return navigator.msSaveOrOpenBlob(blob, name);
			};
		}

		FS_proto.abort = function(){};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;

		FS_proto.error =
		FS_proto.onwritestart =
		FS_proto.onprogress =
		FS_proto.onwrite =
		FS_proto.onabort =
		FS_proto.onerror =
		FS_proto.onwriteend =
			null;

		return saveAs;
	}(
		   typeof self !== "undefined" && self
		|| typeof window !== "undefined" && window
		|| commonjsGlobal.content
	));
	// `self` is undefined in Firefox for Android content script context
	// while `this` is nsIContentFrameMessageManager
	// with an attribute `content` that corresponds to the window

	if (module.exports) {
	  module.exports.saveAs = saveAs;
	}
	});

	const charts = {
	  BubbleChart: {toolsPageChartType: "bubbles", marker: "bubble", icon: "🎈", encoding: "y"},
	  //  BubbleMap: {toolsPageChartType: "map", marker: "bubble", icon: "🌍", encoding: "color"},
	  LineChart: {toolsPageChartType: "linechart", marker: "line", icon: "〽️", encoding: "y"}
	};

	class _VizabiSpreadsheet extends sharedComponents.BaseComponent {
	  constructor (config) {

	    config.template = `
        <div id="vzb-spreadsheet-title"></div>
        <div id="vzb-spreadsheet-about"></div>
        <div id="vzb-spreadsheet-actions"></div>
        <div id="vzb-spreadsheet-table"></div>  
      `;

	    super(config);
	  }

	  setup() {
	    this.DOM = {
	      title: this.element.select("#vzb-spreadsheet-title"),
	      about: this.element.select("#vzb-spreadsheet-about"),
	      actions: this.element.select("#vzb-spreadsheet-actions"),
	      table: this.element.select("#vzb-spreadsheet-table")
	    };

	    this.root.element.classed("vzb-timeslider-off", true);

	    this.treemenu = () => this.root.findChild({type: "TreeMenu"});
	    this.DOM.title.on("click", () => this.treemenu().updateView().toggle());
	  }

	  get MDL() {
	    return {
	      number: this.model.encoding.number,
	      frame: this.model.encoding.frame
	    };
	  }

	  draw() {
	    this.localise = this.services.locale.auto();
	    this.fixHeaders = this.ui.fixHeaders;

	    //if (this.updateLayoutProfile()) return; //return if exists with error
	    this.DOM.title.classed("vzb-disabled", this.treemenu().state.ownReadiness !== sharedComponents.Utils.STATUS.READY);

	    if (this.treemenu().state.ownReadiness == sharedComponents.Utils.STATUS.READY) {
	      this.treemenu()
	        .alignX(this.services.locale.isRTL() ? "right" : "left")
	        .alignY("top")
	        .title("")
	        .scaletypeSelectorDisabled(true)
	        .encoding("number");
	      if (!this.MDL.number.data.concept) {
	        this.treemenu().showWhenReady(true);
	      }
	    }

	    this.addReaction(this._drawLoading);
	    this.addReaction(this._drawTitle);
	    this.addReaction(this._drawAboutSection);
	    this.addReaction(this._drawActionsSection);
	    this.addReaction(this._drawDataTable);  
	  }

	  _drawTitle() {
	    const concept = this.MDL.number.data.conceptProps;  
	    this.DOM.title.text(concept ? concept.name : "Select an indicator");
	  }

	  get dataMap() {
	    return this.model.dataMapCache.groupBy(this.model.dataMapCache.key.slice(0, -1), this.model.dataMapCache.key.slice(-1));
	  }

	  _drawLoading() {
	    const concept = this.MDL.number.data.concept;
	    if (!concept) return;

	    this.DOM.table.select(".viz-spreadsheet-keytable-wrapper").remove();
	    this.DOM.table.select(".viz-spreadsheet-table-wrapper").remove();
	    this.DOM.table.classed("vzb-spreadsheet-table-fix-headers", this.fixHeaders);
	    this.DOM.table.append("div").attr("class","vzb-spreadsheet-loading").text("data table is loading...");
	  }

	  _drawDataTable() {
	    this.DOM.table.selectAll("div.vzb-spreadsheet-loading").remove();

	    mobx.runInAction(() => {
	      const concept = this.MDL.number.data.concept;
	      if (!concept) return;
	    
	      this.DOM.table.select(".viz-spreadsheet-keytable-wrapper").remove();
	      this.DOM.table.select(".viz-spreadsheet-table-wrapper").remove();
	      this.DOM.table.classed("vzb-spreadsheet-table-fix-headers", this.fixHeaders);
	      this.DOM.actions.classed("vzb-hidden", false);
	  
	      const frameConcept = this.MDL.frame.data.concept;
	      const steps = this.MDL.frame.domainValues.map(v => ({[frameConcept]: v}));
	      const timeFormatter = this.localise;
	      const valueFormatter = this.localise;
	      const KEYS = this.dataMap.key;
	  
	      const table = this.DOM.table
	        .append("div")
	        .classed("viz-spreadsheet-table-wrapper", true)
	        .append("table")
	        .attr("id", "table_" + this.id)
	        .classed("viz-spreadsheet-table", true);

	      const scrollBarWidth = this.fixHeaders ? table.node().offsetWidth - table.node().clientWidth : 0;

	      table.selectAll("tr").data([{}, ...this.dataMap.values()])
	        .enter().append("tr")
	        .attr("class", (d, i) => i ? "viz-spreadsheet-tablerow" : "viz-spreadsheet-headrow")
	        .each(function(r, i){
	          const labelObj = i == 0 ? {} : r.values().next().value.label;
	          d3.select(this).selectAll("td").data(KEYS.concat(steps))
	            .enter().append("td")
	            .classed("viz-spreadsheet-keycell", (c,j) => j<KEYS.length)
	            .text((c, j) => {
	              if (i==0 && j<KEYS.length) return c;
	              if (j<KEYS.length) return labelObj[c];
	              if (i==0) return timeFormatter(c[frameConcept]);
	              return valueFormatter(r.get(c)?.number) || "";
	            });
	        });

	      if (this.fixHeaders) {

	        const keysTable = this.DOM.table
	          .append("div")
	          .classed("viz-spreadsheet-keytable-wrapper", true)
	          .lower()
	          .append("table")
	          .classed("viz-spreadsheet-keytable", true)
	          .style("height", `calc(100% - ${scrollBarWidth}px)`);

	        keysTable.selectAll("tr").data([{}, ...this.dataMap.values()])
	          .enter().append("tr")
	          .attr("class", (d, i) => i ? "viz-spreadsheet-tablerow" : "viz-spreadsheet-headrow")
	          .each(function(r, i){
	            const labelObj = i == 0 ? {} : r.values().next().value.label;
	            d3.select(this).selectAll("td").data(KEYS)
	              .enter().append("td")
	              .attr("data-caption", c => i == 0 ? c : null)
	              .text(c => {
	                if (i==0) return "";
	                return labelObj[c];
	              });
	          });

	        const tableHeader = table
	          .clone(true).lower()
	          .attr("class", "viz-spreadsheet-table-header")
	          .style("margin-right", scrollBarWidth + "px");

	        table.on("scroll", function () {
	          keysTable.node().scrollTop = this.scrollTop;
	          tableHeader.node().scrollLeft = this.scrollLeft;
	        });
	      }
	    });
	  }

	  _drawAboutSection() {
	    const concept = this.MDL.number.data.conceptProps;
	    if (!concept) return;

	    //    const dataAvailable = this.model.data.dataAvailability.datapoints
	    //      .reduce((result, item) => {
	    //        if (item.value !== which) return result;
	    //        result.push({
	    //          key: [...item.key].join(","),
	    //          value: [...item.key]
	    //        })
	    //        return result;
	    //      }, []);
	    //
	    //    let viewAbout = this.element.select("#vzb-spreadsheet-content").select("#about");
	    //
	    //    const selectorEl = viewAbout.append("div").style("display", dataAvailable.length > 1 ? "block" : "none")
	    //      .call(selection => selection.append("div").classed("vzb-spreadsheet-conceptkey", true).text("dimensions"))
	    //      .append("div").classed("vzb-spreadsheet-conceptvalue", true)
	    //      .append("div").classed("vzb-spreadsheet-select", true)
	    //      .append("select").on("change", function(evt) {
	    //        const d = d3.select(this.options[this.options.selectedIndex]).datum();
	    //        _this.model.marker.setSpace(d.value);
	    //        utils.defer(() => _this.model.marker.startLoading());
	    //      })
	    //    selectorEl.selectAll("option").data(dataAvailable, d => d.key).enter().append("option").text(d => d.key);
	    //
	    //    const allKeys = utils.unique(this.model.marker._getAllDimensions()).join(",");
	    //    const selectedIndex = dataAvailable.map(d => d.key).indexOf(allKeys);
	    //    selectorEl.property("selectedIndex", selectedIndex === -1 ? 0: selectedIndex);
	    //    if (selectedIndex === -1) selectorEl.dispatch("change");
	    //
	    //    this.model.marker.number.setWhich({concept: which, dataSource: "data"});

	    
	    this.DOM.about.selectAll("div").remove();
	    
	    this.DOM.about.selectAll("div.concept")
	      .data(["description", "source", "source_url"].filter(f => concept[f]))
	      .enter().append("div")
	      .html(d=>{
	        let value = d == "source_url" ? sharedComponents.LegacyUtils.normaliseLink(concept[d]) : concept[d];
	        value = (value || "").indexOf("http")==0 ? ('<a href="' + value + '">' + value + "</a>") : value;

	        return '<span class="vzb-spreadsheet-conceptkey">' + d + ":</span>" +
	        '<span class="vzb-spreadsheet-conceptvalue">' + value + "</span>";
	      });


	  }

	  _drawActionsSection() {
	    const concept = this.MDL.number.data.conceptProps;
	    if (!concept) return;

	    this.DOM.actions.selectAll("div").remove();

	    this.DOM.actions.classed("vzb-hidden", true);    

	    this.DOM.actions.append("div")
	      .attr("class", "vzb-spreadsheet-viewas")
	      .text("View as:")
	      .selectAll("a").data(Object.keys(charts))
	      .enter().append("a")
	      .text(chart=>charts[chart].icon)
	      .attr("title", chart=>chart)
	      .attr("target", "_blank")
	      .attr("href", chart => this._viewAs(charts[chart], concept)); 

	    this.DOM.actions.append("div")
	      .attr("class", "vzb-spreadsheet-downloadas")
	      .text("Download as:")
	      .selectAll("a").data(["csv", "xlsx"])
	      .enter().append("a")
	      .text(type=>type)
	      .on("click", (event, type) => this._download(type, concept.concept));  
	  }
	  
	  _viewAs(chart, concept){
	    const scaleType = (JSON.parse(concept.scales) || [])[0] || "linear";
	    return window.location.origin + window.location.pathname 
	      + `#$model$markers$${chart.marker}$encoding$${chart.encoding}$data$concept=${concept.concept};&scale$domain:null&zoomed:null&type=${scaleType};;;;;;&chart-type=${chart.toolsPageChartType}&url=v1`;    
	  }

	  _download(type, fileName){
	    function s2ab(s) {
	      if(typeof ArrayBuffer !== "undefined") {
	        const buf = new ArrayBuffer(s.length);
	        const view = new Uint8Array(buf);
	        for (let i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;
	        return buf;
	      } else {
	        const buf = new Array(s.length);
	        for (let i=0; i!=s.length; ++i) buf[i] = s.charCodeAt(i) & 0xFF;
	        return buf;
	      }
	    }

	    function export_table_to_excel(id, type, fileName) {
	      const wb = xlsx_mini_min.utils.table_to_book(document.getElementById(id), { sheet: fileName.slice(0, 31) });
	      const wbout = xlsx_mini_min.write(wb, { bookType: type, bookSST: true, type: "binary" });
	      const fName = `${fileName}.${type}`;
	      try {
	        FileSaver.saveAs(new Blob([s2ab(wbout)],{type:"application/octet-stream"}), fName);
	      } catch(e) { if(typeof console != "undefined") console.log(e, wbout); }
	      return wbout;
	    }

	    export_table_to_excel("table_" + this.id, type, fileName);    
	  }

	}

	const VizabiSpreadsheet = mobx.decorate(_VizabiSpreadsheet, {
	  "dataMap": mobx.computed,
	  "MDL": mobx.computed
	});

	class Spreadsheet extends sharedComponents.BaseComponent {

	  constructor(config){

	    config.Vizabi.utils.applyDefaults(config.model.markers.spreadsheet.config, Spreadsheet.DEFAULT_CORE);    
	    //clear constant if concept is set
	    if (config.model.markers.spreadsheet.config.encoding.number.data.concept) {
	      config.model.markers.spreadsheet.config.encoding.number.data.constant = undefined;
	    }


	    const marker = config.model.markers.spreadsheet;

	    config.name = "spreadsheet";

	    config.subcomponents = [{
	      type: VizabiSpreadsheet,
	      placeholder: ".vzb-spreadsheet",
	      model: marker,
	      name: "chart"
	    },{
	      type: sharedComponents.TreeMenu,
	      placeholder: ".vzb-treemenu",
	      model: marker,
	      name: "tree-menu"
	    }];

	    config.template = `
      <div class="vzb-spreadsheet"></div>
      <div class="vzb-treemenu"></div>
    `;
	  
	    config.services = {
	      Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
	      locale: new sharedComponents.LocaleService(config.locale),
	      layout: new sharedComponents.LayoutService({placeholder: config.placeholder})
	    };

	    super(config);
	  }
	}


	Spreadsheet.DEFAULT_UI = {
	  chart: {
	    fixHeaders: true
	  },
	};

	Spreadsheet.DEFAULT_CORE = {
	  requiredEncodings: ["number"],
	  encoding: {
	    "number": {
	      data: {
	        constant: "true"
	      },
	      scale: {
	        allowedTypes: ["linear", "log", "genericLog", "pow", "point"]
	      }
	    },
	    "label": {
	      data: {
	        modelType: "entityPropertyDataConfig"
	      }
	    },
	    "frame": {
	      modelType: "frame"
	    }
	  }
	};

	Spreadsheet.versionInfo = { version: "4.0.0", build: 1687773699667, package: {"homepage":"https://github.com/vizabi/spreadsheet#readme","name":"@vizabi/spreadsheet","description":"Spreadsheet tool for Vizabi"}, sharedComponents: sharedComponents.versionInfo};

	exports.Base = Spreadsheet;

	Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/combo#readme v1.1.1 build 1712094856742 Copyright 2024 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('mobx'), require('@vizabi/shared-components')) :
  typeof define === 'function' && define.amd ? define(['exports', 'mobx', '@vizabi/shared-components'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Combo = {}, global.mobx, global.VizabiSharedComponents));
})(window, (function (exports, mobx, sharedComponents) {
  const SPLIT_DIRECTION_ICON = `
  <svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="511.261px" height="511.261px" viewBox="0 0 511.261 511.261" style="enable-background:new 0 0 511.261 511.261;" xml:space="preserve">
    <g>
      <path d="M430.25,379.655l-75.982-43.869v59.771H120.73V151.966h59.774l-43.869-75.983L92.767,0L48.898,75.983L5.029,151.966h59.775v271.557c0,15.443,12.52,27.965,27.963,27.965h261.5v59.773l75.982-43.869l75.982-43.867L430.25,379.655z"/>
    </g>
  </svg>`;


  class Combo extends sharedComponents.BaseComponent {

    constructor(config){
      
      const toolComponents = config.options.toolComponents ? config.options.toolComponents : [BubbleChart.Base, ExtApiMap.Base];
      const toolPlaceholders = toolComponents.map(toolComponent => `vzb-${toolComponent.name.toLowerCase()}`);
    
      const markerName = config.options?.markerNames?.main || "bubble";
      const fullMarker = config.model.markers[markerName];

      config.Vizabi.utils.applyDefaults(fullMarker.config, toolComponents[0].DEFAULT_CORE(markerName));   
      config.Vizabi.utils.applyDefaults(fullMarker.config, toolComponents[1].DEFAULT_CORE(markerName));   
      
      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);
      
      config.model.markers[markerName] = marker;

      config.name = "combo";

      config.subcomponents = [{
        type: toolComponents[0].mainComponent,
        placeholder: "." + toolPlaceholders[0],
        model: marker,
        name: "chart"
      },{
        type: toolComponents[1].mainComponent,
        placeholder: "." + toolPlaceholders[1],
        model: marker,
        name: "chart"
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        model: marker,
        name: "time-slider"
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        model: marker,
        name: "speed-slider"
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        model: marker,
        name: "tree-menu"
      },{
        type: sharedComponents.DataWarning,
        placeholder: ".vzb-datawarning",
        options: {button: ".vzb-datawarning-button"},
        model: marker,
        name: "data-warning"
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        model: marker,
        name: "buttons"
      },{
        type: sharedComponents.SpaceConfig,
        placeholder: ".vzb-spaceconfig",
        options: {button: ".vzb-spaceconfig-button"},
        model: marker,
        name: "space-config"
      },{
        type: sharedComponents.ErrorMessage,
        placeholder: ".vzb-errormessage",
        model: marker,
        name: "error-message"
      }];

      config.template = `
    <div class="vzb-tool-combo vzb-split-vertical">
      <div class="vzb-chart-combo ${toolPlaceholders[0]}"></div>
      <div class="vzb-chart-combo ${toolPlaceholders[1]}"></div>
      <div class="vzb-split-line vzb-split-line-front"></div>
      <div class="vzb-split-direction-button"></div>
      <div class="vzb-split-overlay vzb-hidden"></div>
      <div class="vzb-split-line vzb-split-line-drag vzb-hidden"></div>
    </div>
    <div class="vzb-animationcontrols">
      <div class="vzb-timeslider"></div>
      <div class="vzb-speedslider"></div>
    </div>
    <div class="vzb-sidebar">
      <div class="vzb-dialogs"></div>
      <div class="vzb-buttonlist"></div>
    </div>
    <div class="vzb-treemenu"></div>
    <div class="vzb-datawarning"></div>
    <div class="vzb-spaceconfig"></div>
    <div class="vzb-datanotes"></div>
    <div class="vzb-errormessage"></div>
    `;

      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);

      this.splashMarker = splashMarker;
    }

    setup(options) {
      this.DOM = {
        comboTool: this.element.select(".vzb-tool-combo"),
        splitDirectionButton: this.element.select(".vzb-split-direction-button"),
        splitOverlay: this.element.select(".vzb-split-overlay"),
        splitLine: this.element.select(".vzb-split-line"),
        splitLineDrag: this.element.select(".vzb-split-line-drag")
      };

      sharedComponents.LegacyUtils.setIcon(this.DOM.splitDirectionButton, SPLIT_DIRECTION_ICON);

      const _this = this;
      this.DOM.splitLine.datum({});
      this.DOM.splitLine.call(
        d3.drag()
          .on("start", (event, d) => {
            if (_this.root.ui.chart.splitVertical) {
              d.xMin = 15;
              d.xMax = _this.toolWidth - 15;
              _this.DOM.splitLineDrag.attr("style", `transform: translateX(${event.x}px)`);
            } else {
              d.yMin = 15;
              d.yMax = _this.toolHeight - 15;
              _this.DOM.splitLineDrag.attr("style", `transform: translateY(${event.y}px)`);
            }
            _this.DOM.splitOverlay.classed("vzb-hidden", false);
            _this.DOM.splitLineDrag.classed("vzb-hidden", false);
          })
          .on("drag", (event, d) => {
            if (_this.root.ui.chart.splitVertical) {
              d._x = event.x < d.xMin ? d.xMin : event.x > d.xMax ? d.xMax : event.x;
              _this.DOM.splitLineDrag.attr("style", `transform: translateX(${d._x}px)`);
            } else {
              d._y = event.y < d.yMin ? d.yMin : event.y > d.yMax ? d.yMax : event.y;
              _this.DOM.splitLineDrag.attr("style", `transform: translateY(${d._y}px)`);
            }
          })
          .on("end", () => {
            _this.DOM.splitOverlay.classed("vzb-hidden", true);
            _this.DOM.splitLineDrag.classed("vzb-hidden", true);
            _this.DOM.splitLineDrag.attr("style", null);
          })
          .on("end.update", (event, d) => {
            mobx.runInAction(() => {
              if (_this.root.ui.chart.splitVertical) {
                _this.root.ui.chart.splitRatio = +((d._x / _this.toolWidth).toFixed(2));
              } else {
                _this.root.ui.chart.splitRatio = +((d._y / _this.toolHeight).toFixed(2));
              }
            });
          })
      );
      this.DOM.splitDirectionButton.on("click", () => {
        mobx.runInAction(() => {
          this.root.ui.chart.splitVertical = !this.root.ui.chart.splitVertical;
          this.root.ui.chart.splitRatio = 0.5;
        });
      });

    }

    changeSplitRatioOrDirection() {
      const styleAttr = this.DOM.comboTool.attr("style");
      const classAttr = this.DOM.comboTool.attr("class");
      const splitVertical = this.root.ui.chart.splitVertical;
      
      const splitDirectionClasses = ["vzb-split-horizontal", "vzb-split-vertical"];
      const classArray = splitVertical ? splitDirectionClasses : splitDirectionClasses.reverse();
      
      if (classAttr.includes(classArray[0])) {
        this.DOM.comboTool.classed(classArray[0], false);
        this.DOM.comboTool.classed(classArray[1], true);    
      }

      const ratio = this.root.ui.chart.splitRatio;
      const newStyleAttr = (splitVertical ? "grid-template-columns" : "grid-template-rows") + `: ${ratio}fr ${Math.floor(100-ratio*100)/100}fr`;
      
      if (newStyleAttr !== styleAttr) {
        this.DOM.comboTool.attr("style", newStyleAttr);
      }
      setTimeout(() => {
        this.services.layout._resizeHandler();
      }, 0);
    }

    resize() {
      this.services.layout.size;

      this.toolHeight = (this.DOM.comboTool.node().clientHeight) || 0;
      this.toolWidth = (this.DOM.comboTool.node().clientWidth) || 0;    
    }

    draw() {
      this.addReaction(this.resize);
      this.addReaction(this.changeSplitRatioOrDirection);
    }

  }
  Combo.DEFAULT_UI = {
    chart: {
      splitVertical: false,
      splitRatio: 0.5,
      map: {
        "showBubbles": true,
        "showAreas": false,
        "showMap": true,
        "mapEngine": "mapbox",
        "mapStyle": "mapbox://styles/mapbox/light-v9",    
        overflowBottom: 50
      },
      opacitySelectDim: 0.3,
      opacityRegular: 0.5,
      cursorMode: "arrow",
      panWithArrow: true,
      zoomOnScrolling: true,
    }
  };

  Combo.versionInfo = { version: "1.1.1", build: 1712094856742, package: {"homepage":"https://github.com/vizabi/combo#readme","name":"@vizabi/combo","description":"Vizabi combo"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = Combo;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// https://github.com/vizabi/extapimap#readme v4.2.1 build 1712091923818 Copyright 2024 Gapminder Foundation and contributors
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vizabi/shared-components'), require('d3'), require('mobx')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vizabi/shared-components', 'd3', 'mobx'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ExtApiMap = {}, global.VizabiSharedComponents, global.d3, global.mobx));
})(window, (function (exports, sharedComponents, d3$1, mobx) {
  // topojson
  var topojson = (function() {
    var topojson = {
      version: "1.6.19",
      mesh: function(topology) {
        return object(topology, meshArcs.apply(this, arguments));
      },
      meshArcs: meshArcs,
      merge: function(topology) {
        return object(topology, mergeArcs.apply(this, arguments));
      },
      mergeArcs: mergeArcs,
      feature: featureOrCollection,
      neighbors: neighbors,
      presimplify: presimplify
    };

    function stitchArcs(topology, arcs) {
      var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

      // Stitch empty arcs first, since they may be subsumed by other arcs.
      arcs.forEach(function(i, j) {
        var arc = topology.arcs[i < 0 ? ~i : i],
          t;
        if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
          t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
        }
      });

      arcs.forEach(function(i) {
        var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

        if (f = fragmentByEnd[start]) {
          delete fragmentByEnd[f.end];
          f.push(i);
          f.end = end;
          if (g = fragmentByStart[end]) {
            delete fragmentByStart[g.start];
            var fg = g === f ? f : f.concat(g);
            fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else if (f = fragmentByStart[end]) {
          delete fragmentByStart[f.start];
          f.unshift(i);
          f.start = start;
          if (g = fragmentByEnd[start]) {
            delete fragmentByEnd[g.end];
            var gf = g === f ? f : g.concat(f);
            fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else {
          f = [i];
          fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
        }
      });

      function ends(i) {
        var arc = topology.arcs[i < 0 ? ~i : i],
          p0 = arc[0],
          p1;
        if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
          p1[0] += dp[0], p1[1] += dp[1];
        });
        else p1 = arc[arc.length - 1];
        return i < 0 ? [p1, p0] : [p0, p1];
      }

      function flush(fragmentByEnd, fragmentByStart) {
        for (var k in fragmentByEnd) {
          var f = fragmentByEnd[k];
          delete fragmentByStart[f.start];
          delete f.start;
          delete f.end;
          f.forEach(function(i) {
            stitchedArcs[i < 0 ? ~i : i] = 1;
          });
          fragments.push(f);
        }
      }

      flush(fragmentByEnd, fragmentByStart);
      flush(fragmentByStart, fragmentByEnd);
      arcs.forEach(function(i) {
        if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
      });

      return fragments;
    }

    function meshArcs(topology, o, filter) {
      var arcs = [];

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({
          i: i,
          g: geom
        });
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      if (arguments.length > 1) {
        var geomsByArc = [],
          geom;

        var geometryType = {
          LineString: line,
          MultiLineString: polygon,
          Polygon: polygon,
          MultiPolygon: function(arcs) {
            arcs.forEach(polygon);
          }
        };

        geometry(o);

        geomsByArc.forEach(arguments.length < 3 ? function(geoms) {
          arcs.push(geoms[0].i);
        } : function(geoms) {
          if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
        });
      } else {
        for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
      }

      return {
        type: "MultiLineString",
        arcs: stitchArcs(topology, arcs)
      };
    }

    function mergeArcs(topology, objects) {
      var polygonsByArc = {},
        polygons = [],
        components = [];

      objects.forEach(function(o) {
        if (o.type === "Polygon") register(o.arcs);
        else if (o.type === "MultiPolygon") o.arcs.forEach(register);
      });

      function register(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
          });
        });
        polygons.push(polygon);
      }

      function exterior(ring) {
        return cartesianRingArea(object(topology, {
          type: "Polygon",
          arcs: [ring]
        }).coordinates[0]) > 0; // TODO allow spherical?
      }

      polygons.forEach(function(polygon) {
        if (!polygon._) {
          var component = [],
            neighbors = [polygon];
          polygon._ = 1;
          components.push(component);
          while (polygon = neighbors.pop()) {
            component.push(polygon);
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                  if (!polygon._) {
                    polygon._ = 1;
                    neighbors.push(polygon);
                  }
                });
              });
            });
          }
        }
      });

      polygons.forEach(function(polygon) {
        delete polygon._;
      });

      return {
        type: "MultiPolygon",
        arcs: components.map(function(polygons) {
          var arcs = [];

          // Extract the exterior (unique) arcs.
          polygons.forEach(function(polygon) {
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                  arcs.push(arc);
                }
              });
            });
          });

          // Stitch the arcs into one or more rings.
          arcs = stitchArcs(topology, arcs);

          // If more than one ring is returned,
          // at most one of these rings can be the exterior;
          // this exterior ring has the same winding order
          // as any exterior ring in the original polygons.
          if ((n = arcs.length) > 1) {
            var sgn = exterior(polygons[0][0]);
            for (var i = 0, t; i < n; ++i) {
              if (sgn === exterior(arcs[i])) {
                t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
                break;
              }
            }
          }

          return arcs;
        })
      };
    }

    function featureOrCollection(topology, o) {
      return o.type === "GeometryCollection" ? {
        type: "FeatureCollection",
        features: o.geometries.map(function(o) {
          return feature(topology, o);
        })
      } : feature(topology, o);
    }

    function feature(topology, o) {
      var f = {
        type: "Feature",
        id: o.id,
        properties: o.properties || {},
        geometry: object(topology, o)
      };
      if (o.id == null) delete f.id;
      return f;
    }

    function object(topology, o) {
      var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

      function arc(i, points) {
        if (points.length) points.pop();
        for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
          points.push(p = a[k].slice());
          absolute(p, k);
        }
        if (i < 0) reverse(points, n);
      }

      function point(p) {
        p = p.slice();
        absolute(p, 0);
        return p;
      }

      function line(arcs) {
        var points = [];
        for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
        if (points.length < 2) points.push(points[0].slice());
        return points;
      }

      function ring(arcs) {
        var points = line(arcs);
        while (points.length < 4) points.push(points[0].slice());
        return points;
      }

      function polygon(arcs) {
        return arcs.map(ring);
      }

      function geometry(o) {
        var t = o.type;
        return t === "GeometryCollection" ? {
          type: t,
          geometries: o.geometries.map(geometry)
        } : t in geometryType ? {
          type: t,
          coordinates: geometryType[t](o)
        } : null;
      }

      var geometryType = {
        Point: function(o) {
          return point(o.coordinates);
        },
        MultiPoint: function(o) {
          return o.coordinates.map(point);
        },
        LineString: function(o) {
          return line(o.arcs);
        },
        MultiLineString: function(o) {
          return o.arcs.map(line);
        },
        Polygon: function(o) {
          return polygon(o.arcs);
        },
        MultiPolygon: function(o) {
          return o.arcs.map(polygon);
        }
      };

      return geometry(o);
    }

    function reverse(array, n) {
      var t, j = array.length,
        i = j - n;
      while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
    }

    function bisect(a, x) {
      var lo = 0,
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (a[mid] < x) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    }

    function neighbors(objects) {
      var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() {
          return [];
        });

      function line(arcs, i) {
        arcs.forEach(function(a) {
          if (a < 0) a = ~a;
          var o = indexesByArc[a];
          if (o) o.push(i);
          else indexesByArc[a] = [i];
        });
      }

      function polygon(arcs, i) {
        arcs.forEach(function(arc) {
          line(arc, i);
        });
      }

      function geometry(o, i) {
        if (o.type === "GeometryCollection") o.geometries.forEach(function(o) {
          geometry(o, i);
        });
        else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs, i) {
          arcs.forEach(function(arc) {
            polygon(arc, i);
          });
        }
      };

      objects.forEach(geometry);

      for (var i in indexesByArc) {
        for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
          for (var k = j + 1; k < m; ++k) {
            var ij = indexes[j],
              ik = indexes[k],
              n;
            if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
            if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
          }
        }
      }

      return neighbors;
    }

    function presimplify(topology, triangleArea) {
      var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

      if (!triangleArea) triangleArea = cartesianTriangleArea;

      topology.arcs.forEach(function(arc) {
        var triangles = [],
          maxArea = 0,
          triangle;

        // To store each point鈥檚 effective area, we create a new array rather than
        // extending the passed-in point to workaround a Chrome/V8 bug (getting
        // stuck in smi mode). For midpoints, the initial effective area of
        // Infinity will be computed in the next step.
        for (var i = 0, n = arc.length, p; i < n; ++i) {
          p = arc[i];
          absolute(arc[i] = [p[0], p[1], Infinity], i);
        }

        for (var i = 1, n = arc.length - 1; i < n; ++i) {
          triangle = arc.slice(i - 1, i + 2);
          triangle[1][2] = triangleArea(triangle);
          triangles.push(triangle);
          heap.push(triangle);
        }

        for (var i = 0, n = triangles.length; i < n; ++i) {
          triangle = triangles[i];
          triangle.previous = triangles[i - 1];
          triangle.next = triangles[i + 1];
        }

        while (triangle = heap.pop()) {
          var previous = triangle.previous,
            next = triangle.next;

          // If the area of the current point is less than that of the previous point
          // to be eliminated, use the latter's area instead. This ensures that the
          // current point cannot be eliminated without eliminating previously-
          // eliminated points.
          if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
          else maxArea = triangle[1][2];

          if (previous) {
            previous.next = next;
            previous[2] = triangle[2];
            update(previous);
          }

          if (next) {
            next.previous = previous;
            next[0] = triangle[0];
            update(next);
          }
        }

        arc.forEach(relative);
      });

      function update(triangle) {
        heap.remove(triangle);
        triangle[1][2] = triangleArea(triangle);
        heap.push(triangle);
      }

      return topology;
    }

    function cartesianRingArea(ring) {
      var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

      while (++i < n) {
        a = b;
        b = ring[i];
        area += a[0] * b[1] - a[1] * b[0];
      }

      return area * .5;
    }

    function cartesianTriangleArea(triangle) {
      var a = triangle[0],
        b = triangle[1],
        c = triangle[2];
      return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
    }

    function compareArea(a, b) {
      return a[1][2] - b[1][2];
    }

    function minAreaHeap() {
      var heap = {},
        array = [],
        size = 0;

      heap.push = function(object) {
        up(array[object._ = size] = object, size++);
        return size;
      };

      heap.pop = function() {
        if (size <= 0) return;
        var removed = array[0],
          object;
        if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
        return removed;
      };

      heap.remove = function(removed) {
        var i = removed._,
          object;
        if (array[i] !== removed) return; // invalid request
        if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] =
          object, i);
        return i;
      };

      function up(object, i) {
        while (i > 0) {
          var j = ((i + 1) >> 1) - 1,
            parent = array[j];
          if (compareArea(object, parent) >= 0) break;
          array[parent._ = i] = parent;
          array[object._ = i = j] = object;
        }
      }

      function down(object, i) {
        while (true) {
          var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
          if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
          if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
          if (j === i) break;
          array[child._ = i] = child;
          array[object._ = i = j] = object;
        }
      }

      return heap;
    }

    function transformAbsolute(transform) {
      if (!transform) return noop;
      var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
      return function(point, i) {
        if (!i) x0 = y0 = 0;
        point[0] = (x0 += point[0]) * kx + dx;
        point[1] = (y0 += point[1]) * ky + dy;
      };
    }

    function transformRelative(transform) {
      if (!transform) return noop;
      var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
      return function(point, i) {
        if (!i) x0 = y0 = 0;
        var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
        point[0] = x1 - x0;
        point[1] = y1 - y0;
        x0 = x1;
        y0 = y1;
      };
    }

    function noop() {}

    return topojson;
  }());

  function d3GeoProjection() {
    d3.geoProject = function(object, projection) {
      var stream = projection.stream;
      if (!stream) throw new Error("not yet supported");
      return (object && d3_geo_projectObjectType.hasOwnProperty(object.type) ? d3_geo_projectObjectType[object.type] : d3_geo_projectGeometry)(object, stream);
    };
    function d3_geo_projectFeature(object, stream) {
      return {
        type: "Feature",
        id: object.id,
        properties: object.properties,
        geometry: d3_geo_projectGeometry(object.geometry, stream)
      };
    }
    function d3_geo_projectGeometry(geometry, stream) {
      if (!geometry) return null;
      if (geometry.type === "GeometryCollection") return {
        type: "GeometryCollection",
        geometries: object.geometries.map(function(geometry) {
          return d3_geo_projectGeometry(geometry, stream);
        })
      };
      if (!d3_geo_projectGeometryType.hasOwnProperty(geometry.type)) return null;
      var sink = d3_geo_projectGeometryType[geometry.type];
      d3.geoUstream(geometry, stream(sink));
      return sink.result();
    }
    var d3_geo_projectObjectType = {
      Feature: d3_geo_projectFeature,
      FeatureCollection: function(object, stream) {
        return {
          type: "FeatureCollection",
          features: object.features.map(function(feature) {
            return d3_geo_projectFeature(feature, stream);
          })
        };
      }
    };
    var d3_geo_projectPoints = [], d3_geo_projectLines = [];
    var d3_geo_projectPoint = {
      point: function(x, y) {
        d3_geo_projectPoints.push([x, y]);
      },
      result: function() {
        var result = !d3_geo_projectPoints.length ? null : d3_geo_projectPoints.length < 2 ? {
          type: "Point",
          coordinates: d3_geo_projectPoints[0]
        } : {
          type: "MultiPoint",
          coordinates: d3_geo_projectPoints
        };
        d3_geo_projectPoints = [];
        return result;
      }
    };
    var d3_geo_projectLine = {
      lineStart: d3_geo_projectNoop,
      point: function(x, y) {
        d3_geo_projectPoints.push([x, y]);
      },
      lineEnd: function() {
        if (d3_geo_projectPoints.length) d3_geo_projectLines.push(d3_geo_projectPoints),
        d3_geo_projectPoints = [];
      },
      result: function() {
        var result = !d3_geo_projectLines.length ? null : d3_geo_projectLines.length < 2 ? {
          type: "LineString",
          coordinates: d3_geo_projectLines[0]
        } : {
          type: "MultiLineString",
          coordinates: d3_geo_projectLines
        };
        d3_geo_projectLines = [];
        return result;
      }
    };
    var d3_geo_projectPolygon = {
      polygonStart: d3_geo_projectNoop,
      lineStart: d3_geo_projectNoop,
      point: function(x, y) {
        d3_geo_projectPoints.push([x, y]);
      },
      lineEnd: function() {
        var n = d3_geo_projectPoints.length;
        if (n) {
          do d3_geo_projectPoints.push(d3_geo_projectPoints[0].slice()); while (++n < 4);
          d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];
        }
      },
      polygonEnd: d3_geo_projectNoop,
      result: function() {
        if (!d3_geo_projectLines.length) return null;
        var polygons = [], holes = [];
        d3_geo_projectLines.forEach(function(ring) {
          if (d3_geo_projectClockwise(ring)) polygons.push([ring]); else holes.push(ring);
        });
        holes.forEach(function(hole) {
          var point = hole[0];
          polygons.some(function(polygon) {
            if (d3_geo_projectContains(polygon[0], point)) {
              polygon.push(hole);
              return true;
            }
            return false;
          }) || polygons.push([hole]);
        });
        d3_geo_projectLines = [];
        return !polygons.length ? null : polygons.length > 1 ? {
          type: "MultiPolygon",
          coordinates: polygons
        } : {
          type: "Polygon",
          coordinates: polygons[0]
        };
      }
    };
    var d3_geo_projectGeometryType = {
      Point: d3_geo_projectPoint,
      MultiPoint: d3_geo_projectPoint,
      LineString: d3_geo_projectLine,
      MultiLineString: d3_geo_projectLine,
      Polygon: d3_geo_projectPolygon,
      MultiPolygon: d3_geo_projectPolygon,
      Sphere: d3_geo_projectPolygon
    };
    function d3_geo_projectNoop() {}
    function d3_geo_projectClockwise(ring) {
      if ((n = ring.length) < 4) return false;
      var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area <= 0;
    }
    function d3_geo_projectContains(ring, point) {
      var x = point[0], y = point[1], contains = false;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;
      }
      return contains;
    }
    var ε = 1e-6, ε2 = ε * ε, π = Math.PI, halfπ = π / 2, sqrtπ = Math.sqrt(π), radians = π / 180, degrees = 180 / π;
    function sinci(x) {
      return x ? x / Math.sin(x) : 1;
    }
    function sgn(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function asin(x) {
      return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function acos(x) {
      return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function asqrt(x) {
      return x > 0 ? Math.sqrt(x) : 0;
    }
    var projection = d3.geoProjection, projectionMutator = d3.geoProjectionMutator;
    d3.geoInterrupt = function(project) {
      var lobes = [[[[-π, 0], [0, halfπ], [π, 0]]], [[[-π, 0], [0, -halfπ], [π, 0]]]];
      var bounds;
      function forward(λ, φ) {
        var sign = φ < 0 ? -1 : +1, hemilobes = lobes[+(φ < 0)];
        for (var i = 0, n = hemilobes.length - 1; i < n && λ > hemilobes[i][2][0]; ++i) ;
        var coordinates = project(λ - hemilobes[i][1][0], φ);
        coordinates[0] += project(hemilobes[i][1][0], sign * φ > sign * hemilobes[i][0][1] ? hemilobes[i][0][1] : φ)[0];
        return coordinates;
      }
      function reset() {
        bounds = lobes.map(function(hemilobes) {
          return hemilobes.map(function(lobe) {
            var x0 = project(lobe[0][0], lobe[0][1])[0], x1 = project(lobe[2][0], lobe[2][1])[0], y0 = project(lobe[1][0], lobe[0][1])[1], y1 = project(lobe[1][0], lobe[1][1])[1], t;
            if (y0 > y1) t = y0, y0 = y1, y1 = t;
            return [[x0, y0], [x1, y1]];
          });
        });
      }
      if (project.invert) forward.invert = function(x, y) {
        var hemibounds = bounds[+(y < 0)], hemilobes = lobes[+(y < 0)];
        for (var i = 0, n = hemibounds.length; i < n; ++i) {
          var b = hemibounds[i];
          if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
            var coordinates = project.invert(x - project(hemilobes[i][1][0], 0)[0], y);
            coordinates[0] += hemilobes[i][1][0];
            return pointEqual(forward(coordinates[0], coordinates[1]), [x, y]) ? coordinates : null;
          }
        }
      };
      var projection = d3.geoProjection(forward), stream_ = projection.stream;
      projection.stream = function(stream) {
        var rotate = projection.rotate(), rotateStream = stream_(stream), sphereStream = (projection.rotate([0, 0]),
        stream_(stream));
        projection.rotate(rotate);
        rotateStream.sphere = function() {
          d3.geoStream(sphere(), sphereStream);
        };
        return rotateStream;
      };
      projection.lobes = function(_) {
        if (!arguments.length) return lobes.map(function(lobes) {
          return lobes.map(function(lobe) {
            return [[lobe[0][0] * 180 / π, lobe[0][1] * 180 / π], [lobe[1][0] * 180 / π, lobe[1][1] * 180 / π], [lobe[2][0] * 180 / π, lobe[2][1] * 180 / π]];
          });
        });
        lobes = _.map(function(lobes) {
          return lobes.map(function(lobe) {
            return [[lobe[0][0] * π / 180, lobe[0][1] * π / 180], [lobe[1][0] * π / 180, lobe[1][1] * π / 180], [lobe[2][0] * π / 180, lobe[2][1] * π / 180]];
          });
        });
        reset();
        return projection;
      };
      function sphere() {
        var ε = 1e-6, coordinates = [];
        for (var i = 0, n = lobes[0].length; i < n; ++i) {
          var lobe = lobes[0][i], λ0 = lobe[0][0] * 180 / π, φ0 = lobe[0][1] * 180 / π, φ1 = lobe[1][1] * 180 / π, λ2 = lobe[2][0] * 180 / π, φ2 = lobe[2][1] * 180 / π;
          coordinates.push(resample([[λ0 + ε, φ0 + ε], [λ0 + ε, φ1 - ε], [λ2 - ε, φ1 - ε], [λ2 - ε, φ2 + ε]], 30));
        }
        for (var i = lobes[1].length - 1; i >= 0; --i) {
          var lobe = lobes[1][i], λ0 = lobe[0][0] * 180 / π, φ0 = lobe[0][1] * 180 / π, φ1 = lobe[1][1] * 180 / π, λ2 = lobe[2][0] * 180 / π, φ2 = lobe[2][1] * 180 / π;
          coordinates.push(resample([[λ2 - ε, φ2 - ε], [λ2 - ε, φ1 + ε], [λ0 + ε, φ1 + ε], [λ0 + ε, φ0 - ε]], 30));
        }
        return {
          type: "Polygon",
          coordinates: [d3.merge(coordinates)]
        };
      }
      function resample(coordinates, m) {
        var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];
        while (++i < n) {
          p1 = coordinates[i];
          dx = (p1[0] - p0[0]) / m;
          dy = (p1[1] - p0[1]) / m;
          for (var j = 0; j < m; ++j) resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
          p0 = p1;
        }
        resampled.push(p1);
        return resampled;
      }
      function pointEqual(a, b) {
        return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
      }
      return projection;
    };
    function airy(β) {
      var tanβ_2 = Math.tan(.5 * β), B = 2 * Math.log(Math.cos(.5 * β)) / (tanβ_2 * tanβ_2);
      function forward(λ, φ) {
        var cosλ = Math.cos(λ), cosφ = Math.cos(φ), sinφ = Math.sin(φ), cosz = cosφ * cosλ, K = -((1 - cosz ? Math.log(.5 * (1 + cosz)) / (1 - cosz) : -.5) + B / (1 + cosz));
        return [K * cosφ * Math.sin(λ), K * sinφ];
      }
      forward.invert = function(x, y) {
        var ρ = Math.sqrt(x * x + y * y), z = β * -.5, i = 50, δ;
        if (!ρ) return [0, 0];
        do {
          var z_2 = .5 * z, cosz_2 = Math.cos(z_2), sinz_2 = Math.sin(z_2), tanz_2 = Math.tan(z_2), lnsecz_2 = Math.log(1 / cosz_2);
          z -= δ = (2 / tanz_2 * lnsecz_2 - B * tanz_2 - ρ) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - B / (2 * cosz_2 * cosz_2));
        } while (Math.abs(δ) > ε && --i > 0);
        var sinz = Math.sin(z);
        return [Math.atan2(x * sinz, ρ * Math.cos(z)), asin(y * sinz / ρ)];
      };
      return forward;
    }
    function airyProjection() {
      var β = halfπ, m = projectionMutator(airy), p = m(β);
      p.radius = function(_) {
        if (!arguments.length) return β / π * 180;
        return m(β = _ * π / 180);
      };
      return p;
    }
    (d3.geoAiry = airyProjection).raw = airy;
    function aitoff(λ, φ) {
      var cosφ = Math.cos(φ), sinciα = sinci(acos(cosφ * Math.cos(λ /= 2)));
      return [2 * cosφ * Math.sin(λ) * sinciα, Math.sin(φ) * sinciα];
    }
    aitoff.invert = function(x, y) {
      if (x * x + 4 * y * y > π * π + ε) return;
      var λ = x, φ = y, i = 25;
      do {
        var sinλ = Math.sin(λ), sinλ_2 = Math.sin(λ / 2), cosλ_2 = Math.cos(λ / 2), sinφ = Math.sin(φ), cosφ = Math.cos(φ), sin_2φ = Math.sin(2 * φ), sin2φ = sinφ * sinφ, cos2φ = cosφ * cosφ, sin2λ_2 = sinλ_2 * sinλ_2, C = 1 - cos2φ * cosλ_2 * cosλ_2, E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = 2 * E * cosφ * sinλ_2 - x, fy = E * sinφ - y, δxδλ = F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ), δxδφ = F * (.5 * sinλ * sin_2φ - E * 2 * sinφ * sinλ_2), δyδλ = F * .25 * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ), δyδφ = F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ), denominator = δxδφ * δyδλ - δyδφ * δxδλ;
        if (!denominator) break;
        var δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ, φ -= δφ;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return [λ, φ];
    };
    (d3.geoAitoff = function() {
      return projection(aitoff);
    }).raw = aitoff;
    function armadillo(φ0) {
      var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sφ0 = φ0 > 0 ? 1 : -1, tanφ0 = Math.tan(sφ0 * φ0), k = (1 + sinφ0 - cosφ0) / 2;
      function forward(λ, φ) {
        var cosφ = Math.cos(φ), cosλ = Math.cos(λ /= 2);
        return [(1 + cosφ) * Math.sin(λ), (sφ0 * φ > -Math.atan2(cosλ, tanφ0) - .001 ? 0 : -sφ0 * 10) + k + Math.sin(φ) * cosφ0 - (1 + cosφ) * sinφ0 * cosλ];
      }
      forward.invert = function(x, y) {
        var λ = 0, φ = 0, i = 50;
        do {
          var cosλ = Math.cos(λ), sinλ = Math.sin(λ), cosφ = Math.cos(φ), sinφ = Math.sin(φ), A = 1 + cosφ, fx = A * sinλ - x, fy = k + sinφ * cosφ0 - A * sinφ0 * cosλ - y, δxδλ = .5 * A * cosλ, δxδφ = -sinλ * sinφ, δyδλ = .5 * sinφ0 * A * sinλ, δyδφ = cosφ0 * cosφ + sinφ0 * cosλ * sinφ, denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = .5 * (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
          λ -= δλ, φ -= δφ;
        } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
        return sφ0 * φ > -Math.atan2(Math.cos(λ), tanφ0) - .001 ? [λ * 2, φ] : null;
      };
      return forward;
    }
    function armadilloProjection() {
      var φ0 = π / 9, sφ0 = φ0 > 0 ? 1 : -1, tanφ0 = Math.tan(sφ0 * φ0), m = projectionMutator(armadillo), p = m(φ0), stream_ = p.stream;
      p.parallel = function(_) {
        if (!arguments.length) return φ0 / π * 180;
        tanφ0 = Math.tan((sφ0 = (φ0 = _ * π / 180) > 0 ? 1 : -1) * φ0);
        return m(φ0);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          sphereStream.polygonStart(), sphereStream.lineStart();
          for (var λ = sφ0 * -180; sφ0 * λ < 180; λ += sφ0 * 90) sphereStream.point(λ, sφ0 * 90);
          while (sφ0 * (λ -= φ0) >= -180) {
            sphereStream.point(λ, sφ0 * -Math.atan2(Math.cos(λ * radians / 2), tanφ0) * degrees);
          }
          sphereStream.lineEnd(), sphereStream.polygonEnd();
        };
        return rotateStream;
      };
      return p;
    }
    (d3.geoArmadillo = armadilloProjection).raw = armadillo;
    function tanh(x) {
      x = Math.exp(2 * x);
      return (x - 1) / (x + 1);
    }
    function sinh(x) {
      return .5 * (Math.exp(x) - Math.exp(-x));
    }
    function cosh(x) {
      return .5 * (Math.exp(x) + Math.exp(-x));
    }
    function arsinh(x) {
      return Math.log(x + asqrt(x * x + 1));
    }
    function arcosh(x) {
      return Math.log(x + asqrt(x * x - 1));
    }
    function august(λ, φ) {
      var tanφ = Math.tan(φ / 2), k = asqrt(1 - tanφ * tanφ), c = 1 + k * Math.cos(λ /= 2), x = Math.sin(λ) * k / c, y = tanφ / c, x2 = x * x, y2 = y * y;
      return [4 / 3 * x * (3 + x2 - 3 * y2), 4 / 3 * y * (3 + 3 * x2 - y2)];
    }
    august.invert = function(x, y) {
      x *= 3 / 8, y *= 3 / 8;
      if (!x && Math.abs(y) > 1) return null;
      var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3η = Math.sqrt(.5 * (s - Math.sqrt(s * s - 4 * y * y))), η = asin(sin3η) / 3, ξ = sin3η ? arcosh(Math.abs(y / sin3η)) / 3 : arsinh(Math.abs(x)) / 3, cosη = Math.cos(η), coshξ = cosh(ξ), d = coshξ * coshξ - cosη * cosη;
      return [sgn(x) * 2 * Math.atan2(sinh(ξ) * cosη, .25 - d), sgn(y) * 2 * Math.atan2(coshξ * Math.sin(η), .25 + d)];
    };
    (d3.geoAugust = function() {
      return projection(august);
    }).raw = august;
    var bakerφ = Math.log(1 + Math.SQRT2);
    function baker(λ, φ) {
      var φ0 = Math.abs(φ);
      return φ0 < π / 4 ? [λ, Math.log(Math.tan(π / 4 + φ / 2))] : [λ * Math.cos(φ0) * (2 * Math.SQRT2 - 1 / Math.sin(φ0)), sgn(φ) * (2 * Math.SQRT2 * (φ0 - π / 4) - Math.log(Math.tan(φ0 / 2)))];
    }
    baker.invert = function(x, y) {
      if ((y0 = Math.abs(y)) < bakerφ) return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      var sqrt8 = Math.sqrt(8), φ = π / 4, i = 25, δ, y0;
      do {
        var cosφ_2 = Math.cos(φ / 2), tanφ_2 = Math.tan(φ / 2);
        φ -= δ = (sqrt8 * (φ - π / 4) - Math.log(tanφ_2) - y0) / (sqrt8 - .5 * cosφ_2 * cosφ_2 / tanφ_2);
      } while (Math.abs(δ) > ε2 && --i > 0);
      return [x / (Math.cos(φ) * (sqrt8 - 1 / Math.sin(φ))), sgn(y) * φ];
    };
    (d3.geoBaker = function() {
      return projection(baker);
    }).raw = baker;
    var berghausAzimuthalEquidistant = d3.geoAzimuthalEquidistant.raw;
    function berghaus(n) {
      var k = 2 * π / n;
      function forward(λ, φ) {
        var p = berghausAzimuthalEquidistant(λ, φ);
        if (Math.abs(λ) > halfπ) {
          var θ = Math.atan2(p[1], p[0]), r = Math.sqrt(p[0] * p[0] + p[1] * p[1]), θ0 = k * Math.round((θ - halfπ) / k) + halfπ, α = Math.atan2(Math.sin(θ -= θ0), 2 - Math.cos(θ));
          θ = θ0 + asin(π / r * Math.sin(α)) - α;
          p[0] = r * Math.cos(θ);
          p[1] = r * Math.sin(θ);
        }
        return p;
      }
      forward.invert = function(x, y) {
        var r = Math.sqrt(x * x + y * y);
        if (r > halfπ) {
          var θ = Math.atan2(y, x), θ0 = k * Math.round((θ - halfπ) / k) + halfπ, s = θ > θ0 ? -1 : 1, A = r * Math.cos(θ0 - θ), cotα = 1 / Math.tan(s * Math.acos((A - π) / Math.sqrt(π * (π - 2 * A) + r * r)));
          θ = θ0 + 2 * Math.atan((cotα + s * Math.sqrt(cotα * cotα - 3)) / 3);
          x = r * Math.cos(θ), y = r * Math.sin(θ);
        }
        return berghausAzimuthalEquidistant.invert(x, y);
      };
      return forward;
    }
    function berghausProjection() {
      var n = 5, m = projectionMutator(berghaus), p = m(n), stream_ = p.stream, ε = .01, cr = -Math.cos(ε * radians), sr = Math.sin(ε * radians);
      p.lobes = function(_) {
        if (!arguments.length) return n;
        return m(n = +_);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          sphereStream.polygonStart(), sphereStream.lineStart();
          for (var i = 0, δ = 360 / n, δ0 = 2 * π / n, φ = 90 - 180 / n, φ0 = halfπ; i < n; ++i,
          φ -= δ, φ0 -= δ0) {
            sphereStream.point(Math.atan2(sr * Math.cos(φ0), cr) * degrees, asin(sr * Math.sin(φ0)) * degrees);
            if (φ < -90) {
              sphereStream.point(-90, -180 - φ - ε);
              sphereStream.point(-90, -180 - φ + ε);
            } else {
              sphereStream.point(90, φ + ε);
              sphereStream.point(90, φ - ε);
            }
          }
          sphereStream.lineEnd(), sphereStream.polygonEnd();
        };
        return rotateStream;
      };
      return p;
    }
    (d3.geoBerghaus = berghausProjection).raw = berghaus;
    function mollweideBromleyθ(Cp) {
      return function(θ) {
        var Cpsinθ = Cp * Math.sin(θ), i = 30, δ;
        do θ -= δ = (θ + Math.sin(θ) - Cpsinθ) / (1 + Math.cos(θ)); while (Math.abs(δ) > ε && --i > 0);
        return θ / 2;
      };
    }
    function mollweideBromley(Cx, Cy, Cp) {
      var θ = mollweideBromleyθ(Cp);
      function forward(λ, φ) {
        return [Cx * λ * Math.cos(φ = θ(φ)), Cy * Math.sin(φ)];
      }
      forward.invert = function(x, y) {
        var θ = asin(y / Cy);
        return [x / (Cx * Math.cos(θ)), asin((2 * θ + Math.sin(2 * θ)) / Cp)];
      };
      return forward;
    }
    var mollweideθ = mollweideBromleyθ(π), mollweide = mollweideBromley(Math.SQRT2 / halfπ, Math.SQRT2, π);
    (d3.geoMollweide = function() {
      return projection(mollweide);
    }).raw = mollweide;
    function boggs(λ, φ) {
      var k = 2.00276, θ = mollweideθ(φ);
      return [k * λ / (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)), (φ + Math.SQRT2 * Math.sin(θ)) / k];
    }
    boggs.invert = function(x, y) {
      var k = 2.00276, ky = k * y, θ = y < 0 ? -π / 4 : π / 4, i = 25, δ, φ;
      do {
        φ = ky - Math.SQRT2 * Math.sin(θ);
        θ -= δ = (Math.sin(2 * θ) + 2 * θ - π * Math.sin(φ)) / (2 * Math.cos(2 * θ) + 2 + π * Math.cos(φ) * Math.SQRT2 * Math.cos(θ));
      } while (Math.abs(δ) > ε && --i > 0);
      φ = ky - Math.SQRT2 * Math.sin(θ);
      return [x * (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)) / k, φ];
    };
    (d3.geoBoggs = function() {
      return projection(boggs);
    }).raw = boggs;
    function parallel1Projection(projectAt) {
      var φ0 = 0, m = projectionMutator(projectAt), p = m(φ0);
      p.parallel = function(_) {
        if (!arguments.length) return φ0 / π * 180;
        return m(φ0 = _ * π / 180);
      };
      return p;
    }
    function sinusoidal(λ, φ) {
      return [λ * Math.cos(φ), φ];
    }
    sinusoidal.invert = function(x, y) {
      return [x / Math.cos(y), y];
    };
    (d3.geoSinusoidal = function() {
      return projection(sinusoidal);
    }).raw = sinusoidal;
    function bonne(φ0) {
      if (!φ0) return sinusoidal;
      var cotφ0 = 1 / Math.tan(φ0);
      function forward(λ, φ) {
        var ρ = cotφ0 + φ0 - φ, E = ρ ? λ * Math.cos(φ) / ρ : ρ;
        return [ρ * Math.sin(E), cotφ0 - ρ * Math.cos(E)];
      }
      forward.invert = function(x, y) {
        var ρ = Math.sqrt(x * x + (y = cotφ0 - y) * y), φ = cotφ0 + φ0 - ρ;
        return [ρ / Math.cos(φ) * Math.atan2(x, y), φ];
      };
      return forward;
    }
    (d3.geoBonne = function() {
      return parallel1Projection(bonne).parallel(45);
    }).raw = bonne;
    var bromley = mollweideBromley(1, 4 / π, π);
    (d3.geoBromley = function() {
      return projection(bromley);
    }).raw = bromley;
    function chamberlin(points) {
      points = points.map(function(p) {
        return [p[0], p[1], Math.sin(p[1]), Math.cos(p[1])];
      });
      for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {
        b = points[i];
        a.v = chamberlinDistanceAzimuth(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
        a.point = [0, 0];
      }
      var β0 = chamberlinAngle(points[0].v[0], points[2].v[0], points[1].v[0]), β1 = chamberlinAngle(points[0].v[0], points[1].v[0], points[2].v[0]), β2 = π - β0;
      points[2].point[1] = 0;
      points[0].point[0] = -(points[1].point[0] = .5 * points[0].v[0]);
      var mean = [points[2].point[0] = points[0].point[0] + points[2].v[0] * Math.cos(β0), 2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * Math.sin(β0))];
      function forward(λ, φ) {
        var sinφ = Math.sin(φ), cosφ = Math.cos(φ), v = new Array(3);
        for (var i = 0; i < 3; ++i) {
          var p = points[i];
          v[i] = chamberlinDistanceAzimuth(φ - p[1], p[3], p[2], cosφ, sinφ, λ - p[0]);
          if (!v[i][0]) return p.point;
          v[i][1] = chamberlinLongitude(v[i][1] - p.v[1]);
        }
        var point = mean.slice();
        for (var i = 0; i < 3; ++i) {
          var j = i == 2 ? 0 : i + 1;
          var a = chamberlinAngle(points[i].v[0], v[i][0], v[j][0]);
          if (v[i][1] < 0) a = -a;
          if (!i) {
            point[0] += v[i][0] * Math.cos(a);
            point[1] -= v[i][0] * Math.sin(a);
          } else if (i == 1) {
            a = β1 - a;
            point[0] -= v[i][0] * Math.cos(a);
            point[1] -= v[i][0] * Math.sin(a);
          } else {
            a = β2 - a;
            point[0] += v[i][0] * Math.cos(a);
            point[1] += v[i][0] * Math.sin(a);
          }
        }
        point[0] /= 3, point[1] /= 3;
        return point;
      }
      return forward;
    }
    function chamberlinProjection() {
      var points = [[0, 0], [0, 0], [0, 0]], m = projectionMutator(chamberlin), p = m(points), rotate = p.rotate;
      delete p.rotate;
      p.points = function(_) {
        if (!arguments.length) return points;
        points = _;
        var origin = d3.geoCentroid({
          type: "MultiPoint",
          coordinates: points
        }), r = [-origin[0], -origin[1]];
        rotate.call(p, r);
        return m(points.map(d3.geoRotation(r)).map(chamberlinRadians));
      };
      return p.points([[-150, 55], [-35, 55], [-92.5, 10]]);
    }
    function chamberlinDistanceAzimuth(dφ, c1, s1, c2, s2, dλ) {
      var cosdλ = Math.cos(dλ), r;
      if (Math.abs(dφ) > 1 || Math.abs(dλ) > 1) {
        r = acos(s1 * s2 + c1 * c2 * cosdλ);
      } else {
        var sindφ = Math.sin(.5 * dφ), sindλ = Math.sin(.5 * dλ);
        r = 2 * asin(Math.sqrt(sindφ * sindφ + c1 * c2 * sindλ * sindλ));
      }
      if (Math.abs(r) > ε) {
        return [r, Math.atan2(c2 * Math.sin(dλ), c1 * s2 - s1 * c2 * cosdλ)];
      }
      return [0, 0];
    }
    function chamberlinAngle(b, c, a) {
      return acos(.5 * (b * b + c * c - a * a) / (b * c));
    }
    function chamberlinLongitude(λ) {
      return λ - 2 * π * Math.floor((λ + π) / (2 * π));
    }
    function chamberlinRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }
    (d3.geoChamberlin = chamberlinProjection).raw = chamberlin;
    function collignon(λ, φ) {
      var α = asqrt(1 - Math.sin(φ));
      return [2 / sqrtπ * λ * α, sqrtπ * (1 - α)];
    }
    collignon.invert = function(x, y) {
      var λ = (λ = y / sqrtπ - 1) * λ;
      return [λ > 0 ? x * Math.sqrt(π / λ) / 2 : 0, asin(1 - λ)];
    };
    (d3.geoCollignon = function() {
      return projection(collignon);
    }).raw = collignon;
    function craig(φ0) {
      var tanφ0 = Math.tan(φ0);
      function forward(λ, φ) {
        return [λ, (λ ? λ / Math.sin(λ) : 1) * (Math.sin(φ) * Math.cos(λ) - tanφ0 * Math.cos(φ))];
      }
      forward.invert = tanφ0 ? function(x, y) {
        if (x) y *= Math.sin(x) / x;
        var cosλ = Math.cos(x);
        return [x, 2 * Math.atan2(Math.sqrt(cosλ * cosλ + tanφ0 * tanφ0 - y * y) - cosλ, tanφ0 - y)];
      } : function(x, y) {
        return [x, asin(x ? y * Math.tan(x) / x : y)];
      };
      return forward;
    }
    (d3.geoCraig = function() {
      return parallel1Projection(craig);
    }).raw = craig;
    function craster(λ, φ) {
      var sqrt3 = Math.sqrt(3);
      return [sqrt3 * λ * (2 * Math.cos(2 * φ / 3) - 1) / sqrtπ, sqrt3 * sqrtπ * Math.sin(φ / 3)];
    }
    craster.invert = function(x, y) {
      var sqrt3 = Math.sqrt(3), φ = 3 * asin(y / (sqrt3 * sqrtπ));
      return [sqrtπ * x / (sqrt3 * (2 * Math.cos(2 * φ / 3) - 1)), φ];
    };
    (d3.geoCraster = function() {
      return projection(craster);
    }).raw = craster;
    function cylindricalEqualArea(φ0) {
      var cosφ0 = Math.cos(φ0);
      function forward(λ, φ) {
        return [λ * cosφ0, Math.sin(φ) / cosφ0];
      }
      forward.invert = function(x, y) {
        return [x / cosφ0, asin(y * cosφ0)];
      };
      return forward;
    }
    (d3.geoCylindricalEqualArea = function() {
      return parallel1Projection(cylindricalEqualArea);
    }).raw = cylindricalEqualArea;
    function cylindricalStereographic(φ0) {
      var cosφ0 = Math.cos(φ0);
      function forward(λ, φ) {
        return [λ * cosφ0, (1 + cosφ0) * Math.tan(φ * .5)];
      }
      forward.invert = function(x, y) {
        return [x / cosφ0, Math.atan(y / (1 + cosφ0)) * 2];
      };
      return forward;
    }
    (d3.geoCylindricalStereographic = function() {
      return parallel1Projection(cylindricalStereographic);
    }).raw = cylindricalStereographic;
    function eckert1(λ, φ) {
      var α = Math.sqrt(8 / (3 * π));
      return [α * λ * (1 - Math.abs(φ) / π), α * φ];
    }
    eckert1.invert = function(x, y) {
      var α = Math.sqrt(8 / (3 * π)), φ = y / α;
      return [x / (α * (1 - Math.abs(φ) / π)), φ];
    };
    (d3.geoEckert1 = function() {
      return projection(eckert1);
    }).raw = eckert1;
    function eckert2(λ, φ) {
      var α = Math.sqrt(4 - 3 * Math.sin(Math.abs(φ)));
      return [2 / Math.sqrt(6 * π) * λ * α, sgn(φ) * Math.sqrt(2 * π / 3) * (2 - α)];
    }
    eckert2.invert = function(x, y) {
      var α = 2 - Math.abs(y) / Math.sqrt(2 * π / 3);
      return [x * Math.sqrt(6 * π) / (2 * α), sgn(y) * asin((4 - α * α) / 3)];
    };
    (d3.geoEckert2 = function() {
      return projection(eckert2);
    }).raw = eckert2;
    function eckert3(λ, φ) {
      var k = Math.sqrt(π * (4 + π));
      return [2 / k * λ * (1 + Math.sqrt(1 - 4 * φ * φ / (π * π))), 4 / k * φ];
    }
    eckert3.invert = function(x, y) {
      var k = Math.sqrt(π * (4 + π)) / 2;
      return [x * k / (1 + asqrt(1 - y * y * (4 + π) / (4 * π))), y * k / 2];
    };
    (d3.geoEckert3 = function() {
      return projection(eckert3);
    }).raw = eckert3;
    function eckert4(λ, φ) {
      var k = (2 + halfπ) * Math.sin(φ);
      φ /= 2;
      for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
        var cosφ = Math.cos(φ);
        φ -= δ = (φ + Math.sin(φ) * (cosφ + 2) - k) / (2 * cosφ * (1 + cosφ));
      }
      return [2 / Math.sqrt(π * (4 + π)) * λ * (1 + Math.cos(φ)), 2 * Math.sqrt(π / (4 + π)) * Math.sin(φ)];
    }
    eckert4.invert = function(x, y) {
      var A = .5 * y * Math.sqrt((4 + π) / π), k = asin(A), c = Math.cos(k);
      return [x / (2 / Math.sqrt(π * (4 + π)) * (1 + c)), asin((k + A * (c + 2)) / (2 + halfπ))];
    };
    (d3.geoEckert4 = function() {
      return projection(eckert4);
    }).raw = eckert4;
    function eckert5(λ, φ) {
      return [λ * (1 + Math.cos(φ)) / Math.sqrt(2 + π), 2 * φ / Math.sqrt(2 + π)];
    }
    eckert5.invert = function(x, y) {
      var k = Math.sqrt(2 + π), φ = y * k / 2;
      return [k * x / (1 + Math.cos(φ)), φ];
    };
    (d3.geoEckert5 = function() {
      return projection(eckert5);
    }).raw = eckert5;
    function eckert6(λ, φ) {
      var k = (1 + halfπ) * Math.sin(φ);
      for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
        φ -= δ = (φ + Math.sin(φ) - k) / (1 + Math.cos(φ));
      }
      k = Math.sqrt(2 + π);
      return [λ * (1 + Math.cos(φ)) / k, 2 * φ / k];
    }
    eckert6.invert = function(x, y) {
      var j = 1 + halfπ, k = Math.sqrt(j / 2);
      return [x * 2 * k / (1 + Math.cos(y *= k)), asin((y + Math.sin(y)) / j)];
    };
    (d3.geoEckert6 = function() {
      return projection(eckert6);
    }).raw = eckert6;
    function eisenlohr(λ, φ) {
      var s0 = Math.sin(λ /= 2), c0 = Math.cos(λ), k = Math.sqrt(Math.cos(φ)), c1 = Math.cos(φ /= 2), t = Math.sin(φ) / (c1 + Math.SQRT2 * c0 * k), c = Math.sqrt(2 / (1 + t * t)), v = Math.sqrt((Math.SQRT2 * c1 + (c0 + s0) * k) / (Math.SQRT2 * c1 + (c0 - s0) * k));
      return [eisenlohrK * (c * (v - 1 / v) - 2 * Math.log(v)), eisenlohrK * (c * t * (v + 1 / v) - 2 * Math.atan(t))];
    }
    eisenlohr.invert = function(x, y) {
      var p = d3.geoAugust.raw.invert(x / 1.2, y * 1.065);
      if (!p) return null;
      var λ = p[0], φ = p[1], i = 20;
      x /= eisenlohrK, y /= eisenlohrK;
      do {
        var _0 = λ / 2, _1 = φ / 2, s0 = Math.sin(_0), c0 = Math.cos(_0), s1 = Math.sin(_1), c1 = Math.cos(_1), cos1 = Math.cos(φ), k = Math.sqrt(cos1), t = s1 / (c1 + Math.SQRT2 * c0 * k), t2 = t * t, c = Math.sqrt(2 / (1 + t2)), v0 = Math.SQRT2 * c1 + (c0 + s0) * k, v1 = Math.SQRT2 * c1 + (c0 - s0) * k, v2 = v0 / v1, v = Math.sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * Math.log(v) - x, fy = c * t * vp1v - 2 * Math.atan(t) - y, δtδλ = s1 && Math.SQRT1_2 * k * s0 * t2 / s1, δtδφ = (Math.SQRT2 * c0 * c1 + k) / (2 * (c1 + Math.SQRT2 * c0 * k) * (c1 + Math.SQRT2 * c0 * k) * k), δcδt = -.5 * t * c * c * c, δcδλ = δcδt * δtδλ, δcδφ = δcδt * δtδφ, A = (A = 2 * c1 + Math.SQRT2 * k * (c0 - s0)) * A * v, δvδλ = (Math.SQRT2 * c0 * c1 * k + cos1) / A, δvδφ = -(Math.SQRT2 * s0 * s1) / (k * A), δxδλ = vm1v * δcδλ - 2 * δvδλ / v + c * (δvδλ + δvδλ / v2), δxδφ = vm1v * δcδφ - 2 * δvδφ / v + c * (δvδφ + δvδφ / v2), δyδλ = t * vp1v * δcδλ - 2 * δtδλ / (1 + t2) + c * vp1v * δtδλ + c * t * (δvδλ - δvδλ / v2), δyδφ = t * vp1v * δcδφ - 2 * δtδφ / (1 + t2) + c * vp1v * δtδφ + c * t * (δvδφ - δvδφ / v2), denominator = δxδφ * δyδλ - δyδφ * δxδλ;
        if (!denominator) break;
        var δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ;
        φ = Math.max(-halfπ, Math.min(halfπ, φ - δφ));
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return Math.abs(Math.abs(φ) - halfπ) < ε ? [0, φ] : i && [λ, φ];
    };
    var eisenlohrK = 3 + 2 * Math.SQRT2;
    (d3.geoEisenlohr = function() {
      return projection(eisenlohr);
    }).raw = eisenlohr;
    function fahey(λ, φ) {
      var t = Math.tan(φ / 2);
      return [λ * faheyK * asqrt(1 - t * t), (1 + faheyK) * t];
    }
    fahey.invert = function(x, y) {
      var t = y / (1 + faheyK);
      return [x ? x / (faheyK * asqrt(1 - t * t)) : 0, 2 * Math.atan(t)];
    };
    var faheyK = Math.cos(35 * radians);
    (d3.geoFahey = function() {
      return projection(fahey);
    }).raw = fahey;
    function foucaut(λ, φ) {
      var k = φ / 2, cosk = Math.cos(k);
      return [2 * λ / sqrtπ * Math.cos(φ) * cosk * cosk, sqrtπ * Math.tan(k)];
    }
    foucaut.invert = function(x, y) {
      var k = Math.atan(y / sqrtπ), cosk = Math.cos(k), φ = 2 * k;
      return [x * sqrtπ * .5 / (Math.cos(φ) * cosk * cosk), φ];
    };
    (d3.geoFoucaut = function() {
      return projection(foucaut);
    }).raw = foucaut;
    d3.geoGilbert = function(projection) {
      var e = d3.geoEquirectangular().scale(degrees).translate([0, 0]);
      function gilbert(coordinates) {
        return projection([coordinates[0] * .5, asin(Math.tan(coordinates[1] * .5 * radians)) * degrees]);
      }
      if (projection.invert) gilbert.invert = function(coordinates) {
        coordinates = projection.invert(coordinates);
        coordinates[0] *= 2;
        coordinates[1] = 2 * Math.atan(Math.sin(coordinates[1] * radians)) * degrees;
        return coordinates;
      };
      gilbert.stream = function(stream) {
        stream = projection.stream(stream);
        var s = e.stream({
          point: function(λ, φ) {
            stream.point(λ * .5, asin(Math.tan(-φ * .5 * radians)) * degrees);
          },
          lineStart: function() {
            stream.lineStart();
          },
          lineEnd: function() {
            stream.lineEnd();
          },
          polygonStart: function() {
            stream.polygonStart();
          },
          polygonEnd: function() {
            stream.polygonEnd();
          }
        });
        s.sphere = function() {
          stream.sphere();
        };
        s.valid = false;
        return s;
      };
      return gilbert;
    };
    var gingeryAzimuthalEquidistant = d3.geoAzimuthalEquidistant.raw;
    function gingery(ρ, n) {
      var k = 2 * π / n, ρ2 = ρ * ρ;
      function forward(λ, φ) {
        var p = gingeryAzimuthalEquidistant(λ, φ), x = p[0], y = p[1], r2 = x * x + y * y;
        if (r2 > ρ2) {
          var r = Math.sqrt(r2), θ = Math.atan2(y, x), θ0 = k * Math.round(θ / k), α = θ - θ0, ρcosα = ρ * Math.cos(α), k_ = (ρ * Math.sin(α) - α * Math.sin(ρcosα)) / (halfπ - ρcosα), s_ = arcLength_(α, k_), e = (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
          x = r;
          var i = 50, δ;
          do {
            x -= δ = (ρ + gingeryIntegrate(s_, ρcosα, x) * e - r) / (s_(x) * e);
          } while (Math.abs(δ) > ε && --i > 0);
          y = α * Math.sin(x);
          if (x < halfπ) y -= k_ * (x - halfπ);
          var s = Math.sin(θ0), c = Math.cos(θ0);
          p[0] = x * c - y * s;
          p[1] = x * s + y * c;
        }
        return p;
      }
      forward.invert = function(x, y) {
        var r2 = x * x + y * y;
        if (r2 > ρ2) {
          var r = Math.sqrt(r2), θ = Math.atan2(y, x), θ0 = k * Math.round(θ / k), dθ = θ - θ0, x = r * Math.cos(dθ);
          y = r * Math.sin(dθ);
          var x_halfπ = x - halfπ, sinx = Math.sin(x), α = y / sinx, δ = x < halfπ ? Infinity : 0, i = 10;
          while (true) {
            var ρsinα = ρ * Math.sin(α), ρcosα = ρ * Math.cos(α), sinρcosα = Math.sin(ρcosα), halfπ_ρcosα = halfπ - ρcosα, k_ = (ρsinα - α * sinρcosα) / halfπ_ρcosα, s_ = arcLength_(α, k_);
            if (Math.abs(δ) < ε2 || !--i) break;
            α -= δ = (α * sinx - k_ * x_halfπ - y) / (sinx - x_halfπ * 2 * (halfπ_ρcosα * (ρcosα + α * ρsinα * Math.cos(ρcosα) - sinρcosα) - ρsinα * (ρsinα - α * sinρcosα)) / (halfπ_ρcosα * halfπ_ρcosα));
          }
          r = ρ + gingeryIntegrate(s_, ρcosα, x) * (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
          θ = θ0 + α;
          x = r * Math.cos(θ);
          y = r * Math.sin(θ);
        }
        return gingeryAzimuthalEquidistant.invert(x, y);
      };
      return forward;
    }
    function arcLength_(α, k) {
      return function(x) {
        var y_ = α * Math.cos(x);
        if (x < halfπ) y_ -= k;
        return Math.sqrt(1 + y_ * y_);
      };
    }
    function gingeryProjection() {
      var n = 6, ρ = 30 * radians, cρ = Math.cos(ρ), sρ = Math.sin(ρ), m = projectionMutator(gingery), p = m(ρ, n), stream_ = p.stream, ε = .01, cr = -Math.cos(ε * radians), sr = Math.sin(ε * radians);
      p.radius = function(_) {
        if (!arguments.length) return ρ * degrees;
        cρ = Math.cos(ρ = _ * radians);
        sρ = Math.sin(ρ);
        return m(ρ, n);
      };
      p.lobes = function(_) {
        if (!arguments.length) return n;
        return m(ρ, n = +_);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          sphereStream.polygonStart(), sphereStream.lineStart();
          for (var i = 0, δ = 2 * π / n, φ = 0; i < n; ++i, φ -= δ) {
            sphereStream.point(Math.atan2(sr * Math.cos(φ), cr) * degrees, Math.asin(sr * Math.sin(φ)) * degrees);
            sphereStream.point(Math.atan2(sρ * Math.cos(φ - δ / 2), cρ) * degrees, Math.asin(sρ * Math.sin(φ - δ / 2)) * degrees);
          }
          sphereStream.lineEnd(), sphereStream.polygonEnd();
        };
        return rotateStream;
      };
      return p;
    }
    function gingeryIntegrate(f, a, b) {
      var n = 50, h = (b - a) / n, s = f(a) + f(b);
      for (var i = 1, x = a; i < n; ++i) s += 2 * f(x += h);
      return s * .5 * h;
    }
    (d3.geoGingery = gingeryProjection).raw = gingery;
    function ginzburgPolyconic(a, b, c, d, e, f, g, h) {
      if (arguments.length < 8) h = 0;
      function forward(λ, φ) {
        if (!φ) return [a * λ / π, 0];
        var φ2 = φ * φ, xB = a + φ2 * (b + φ2 * (c + φ2 * d)), yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)), m = (xB * xB + yB * yB) / (2 * yB), α = λ * Math.asin(xB / m) / π;
        return [m * Math.sin(α), φ * (1 + φ2 * h) + m * (1 - Math.cos(α))];
      }
      forward.invert = function(x, y) {
        var λ = π * x / a, φ = y, δλ, δφ, i = 50;
        do {
          var φ2 = φ * φ, xB = a + φ2 * (b + φ2 * (c + φ2 * d)), yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dαdλ = Math.asin(xB / m) / π, α = λ * dαdλ;
          xB2 = xB * xB, dxBdφ = (2 * b + φ2 * (4 * c + φ2 * 6 * d)) * φ, dyBdφ = e + φ2 * (3 * f + φ2 * 5 * g),
          dpdφ = 2 * (xB * dxBdφ + yB * (dyBdφ - 1)), dqdφ = 2 * (dyBdφ - 1), dmdφ = (dpdφ * q - p * dqdφ) / (q * q),
          cosα = Math.cos(α), sinα = Math.sin(α), mcosα = m * cosα, msinα = m * sinα, dαdφ = λ / π * (1 / asqrt(1 - xB2 / m2)) * (dxBdφ * m - xB * dmdφ) / m2,
          fx = msinα - x, fy = φ * (1 + φ2 * h) + m - mcosα - y, δxδφ = dmdφ * sinα + mcosα * dαdφ,
          δxδλ = mcosα * dαdλ, δyδφ = 1 + dmdφ - (dmdφ * cosα - msinα * dαdφ), δyδλ = msinα * dαdλ,
          denominator = δxδφ * δyδλ - δyδφ * δxδλ;
          if (!denominator) break;
          λ -= δλ = (fy * δxδφ - fx * δyδφ) / denominator;
          φ -= δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
        return [λ, φ];
      };
      return forward;
    }
    var ginzburg4 = ginzburgPolyconic(2.8284, -1.6988, .75432, -.18071, 1.76003, -.38914, .042555);
    (d3.geoGinzburg4 = function() {
      return projection(ginzburg4);
    }).raw = ginzburg4;
    var ginzburg5 = ginzburgPolyconic(2.583819, -.835827, .170354, -.038094, 1.543313, -.411435, .082742);
    (d3.geoGinzburg5 = function() {
      return projection(ginzburg5);
    }).raw = ginzburg5;
    var ginzburg6 = ginzburgPolyconic(5 / 6 * π, -.62636, -.0344, 0, 1.3493, -.05524, 0, .045);
    (d3.geoGinzburg6 = function() {
      return projection(ginzburg6);
    }).raw = ginzburg6;
    function ginzburg8(λ, φ) {
      var λ2 = λ * λ, φ2 = φ * φ;
      return [λ * (1 - .162388 * φ2) * (.87 - 952426e-9 * λ2 * λ2), φ * (1 + φ2 / 12)];
    }
    ginzburg8.invert = function(x, y) {
      var λ = x, φ = y, i = 50, δ;
      do {
        var φ2 = φ * φ;
        φ -= δ = (φ * (1 + φ2 / 12) - y) / (1 + φ2 / 4);
      } while (Math.abs(δ) > ε && --i > 0);
      i = 50;
      x /= 1 - .162388 * φ2;
      do {
        var λ4 = (λ4 = λ * λ) * λ4;
        λ -= δ = (λ * (.87 - 952426e-9 * λ4) - x) / (.87 - .00476213 * λ4);
      } while (Math.abs(δ) > ε && --i > 0);
      return [λ, φ];
    };
    (d3.geoGinzburg8 = function() {
      return projection(ginzburg8);
    }).raw = ginzburg8;
    var ginzburg9 = ginzburgPolyconic(2.6516, -.76534, .19123, -.047094, 1.36289, -.13965, .031762);
    (d3.geoGinzburg9 = function() {
      return projection(ginzburg9);
    }).raw = ginzburg9;
    function quincuncialProjection(projectHemisphere) {
      var dx = projectHemisphere(halfπ, 0)[0] - projectHemisphere(-halfπ, 0)[0];
      function projection() {
        var quincuncial = false, m = projectionMutator(projectAt), p = m(quincuncial);
        p.quincuncial = function(_) {
          if (!arguments.length) return quincuncial;
          return m(quincuncial = !!_);
        };
        return p;
      }
      function projectAt(quincuncial) {
        var forward = quincuncial ? function(λ, φ) {
          var t = Math.abs(λ) < halfπ, p = projectHemisphere(t ? λ : λ > 0 ? λ - π : λ + π, φ);
          var x = (p[0] - p[1]) * Math.SQRT1_2, y = (p[0] + p[1]) * Math.SQRT1_2;
          if (t) return [x, y];
          var d = dx * Math.SQRT1_2, s = x > 0 ^ y > 0 ? -1 : 1;
          return [s * x - sgn(y) * d, s * y - sgn(x) * d];
        } : function(λ, φ) {
          var s = λ > 0 ? -.5 : .5, point = projectHemisphere(λ + s * π, φ);
          point[0] -= s * dx;
          return point;
        };
        if (projectHemisphere.invert) forward.invert = quincuncial ? function(x0, y0) {
          var x = (x0 + y0) * Math.SQRT1_2, y = (y0 - x0) * Math.SQRT1_2, t = Math.abs(x) < .5 * dx && Math.abs(y) < .5 * dx;
          if (!t) {
            var d = dx * Math.SQRT1_2, s = x > 0 ^ y > 0 ? -1 : 1, x1 = -s * (x0 + (y > 0 ? 1 : -1) * d), y1 = -s * (y0 + (x > 0 ? 1 : -1) * d);
            x = (-x1 - y1) * Math.SQRT1_2;
            y = (x1 - y1) * Math.SQRT1_2;
          }
          var p = projectHemisphere.invert(x, y);
          if (!t) p[0] += x > 0 ? π : -π;
          return p;
        } : function(x, y) {
          var s = x > 0 ? -.5 : .5, location = projectHemisphere.invert(x + s * dx, y), λ = location[0] - s * π;
          if (λ < -π) λ += 2 * π; else if (λ > π) λ -= 2 * π;
          location[0] = λ;
          return location;
        };
        return forward;
      }
      projection.raw = projectAt;
      return projection;
    }
    function gringorten(λ, φ) {
      var sλ = sgn(λ), sφ = sgn(φ), cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(sφ * φ);
      λ = Math.abs(Math.atan2(y, z));
      φ = asin(x);
      if (Math.abs(λ - halfπ) > ε) λ %= halfπ;
      var point = gringortenHexadecant(λ > π / 4 ? halfπ - λ : λ, φ);
      if (λ > π / 4) z = point[0], point[0] = -point[1], point[1] = -z;
      return point[0] *= sλ, point[1] *= -sφ, point;
    }
    gringorten.invert = function(x, y) {
      var sx = sgn(x), sy = sgn(y), x0 = -sx * x, y0 = -sy * y, t = y0 / x0 < 1, p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0), λ = p[0], φ = p[1];
      if (t) λ = -halfπ - λ;
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ);
      return [sx * (Math.atan2(y, -z) + π), sy * asin(x)];
    };
    function gringortenHexadecant(λ, φ) {
      if (φ === halfπ) return [0, 0];
      var sinφ = Math.sin(φ), r = sinφ * sinφ, r2 = r * r, j = 1 + r2, k = 1 + 3 * r2, q = 1 - r2, z = asin(1 / Math.sqrt(j)), v = q + r * j * z, p2 = (1 - sinφ) / v, p = Math.sqrt(p2), a2 = p2 * j, a = Math.sqrt(a2), h = p * q;
      if (λ === 0) return [0, -(h + r * a)];
      var cosφ = Math.cos(φ), secφ = 1 / cosφ, drdφ = 2 * sinφ * cosφ, dvdφ = (-3 * r + z * k) * drdφ, dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v), dpdφ = .5 * dp2dφ / p, dhdφ = q * dpdφ - 2 * r * p * drdφ, dra2dφ = r * j * dp2dφ + p2 * k * drdφ, μ = -secφ * drdφ, ν = -secφ * dra2dφ, ζ = -2 * secφ * dhdφ, Λ = 4 * λ / π;
      if (λ > .222 * π || φ < π / 4 && λ > .175 * π) {
        var x = (h + r * asqrt(a2 * (1 + r2) - h * h)) / (1 + r2);
        if (λ > π / 4) return [x, x];
        var x1 = x, x0 = .5 * x, i = 50;
        x = .5 * (x0 + x1);
        do {
          var g = Math.sqrt(a2 - x * x), f = x * (ζ + μ * g) + ν * asin(x / a) - Λ;
          if (!f) break;
          if (f < 0) x0 = x; else x1 = x;
          x = .5 * (x0 + x1);
        } while (Math.abs(x1 - x0) > ε && --i > 0);
      } else {
        var x = ε, i = 25, δ;
        do {
          var x2 = x * x, g = asqrt(a2 - x2), ζμg = ζ + μ * g, f = x * ζμg + ν * asin(x / a) - Λ, df = ζμg + (ν - μ * x2) / g;
          x -= δ = g ? f / df : 0;
        } while (Math.abs(δ) > ε && --i > 0);
      }
      return [x, -h - r * asqrt(a2 - x * x)];
    }
    function gringortenHexadecantInvert(x, y) {
      var x0 = 0, x1 = 1, r = .5, i = 50;
      while (true) {
        var r2 = r * r, sinφ = Math.sqrt(r), z = Math.asin(1 / Math.sqrt(1 + r2)), v = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinφ) / v, p = Math.sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = Math.sqrt(g2), y0 = y + h + r * g;
        if (Math.abs(x1 - x0) < ε2 || --i === 0 || y0 === 0) break;
        if (y0 > 0) x0 = r; else x1 = r;
        r = .5 * (x0 + x1);
      }
      if (!i) return null;
      var φ = Math.asin(sinφ), cosφ = Math.cos(φ), secφ = 1 / cosφ, drdφ = 2 * sinφ * cosφ, dvdφ = (-3 * r + z * (1 + 3 * r2)) * drdφ, dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v), dpdφ = .5 * dp2dφ / p, dhdφ = (1 - r2) * dpdφ - 2 * r * p * drdφ, ζ = -2 * secφ * dhdφ, μ = -secφ * drdφ, ν = -secφ * (r * (1 + r2) * dp2dφ + p2 * (1 + 3 * r2) * drdφ);
      return [π / 4 * (x * (ζ + μ * g) + ν * Math.asin(x / Math.sqrt(a2))), φ];
    }
    d3.geoGringorten = quincuncialProjection(gringorten);
    function ellipticJi(u, v, m) {
      if (!u) {
        var b = ellipticJ(v, 1 - m);
        return [[0, b[0] / b[1]], [1 / b[1], 0], [b[2] / b[1], 0]];
      }
      var a = ellipticJ(u, m);
      if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
      var b = ellipticJ(v, 1 - m), denominator = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
      return [[a[0] * b[2] / denominator, a[1] * a[2] * b[0] * b[1] / denominator], [a[1] * b[1] / denominator, -a[0] * a[2] * b[0] * b[2] / denominator], [a[2] * b[1] * b[2] / denominator, -m * a[0] * a[1] * b[0] / denominator]];
    }
    function ellipticJ(u, m) {
      var ai, b, φ, t, twon;
      if (m < ε) {
        t = Math.sin(u);
        b = Math.cos(u);
        ai = .25 * m * (u - t * b);
        return [t - ai * b, b + ai * t, 1 - .5 * m * t * t, u - ai];
      }
      if (m >= 1 - ε) {
        ai = .25 * (1 - m);
        b = cosh(u);
        t = tanh(u);
        φ = 1 / b;
        twon = b * sinh(u);
        return [t + ai * (twon - u) / (b * b), φ - ai * t * φ * (twon - u), φ + ai * t * φ * (twon + u), 2 * Math.atan(Math.exp(u)) - halfπ + ai * (twon - u) / b];
      }
      var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [Math.sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
      b = Math.sqrt(1 - m);
      twon = 1;
      while (Math.abs(c[i] / a[i]) > ε && i < 8) {
        ai = a[i++];
        c[i] = .5 * (ai - b);
        a[i] = .5 * (ai + b);
        b = asqrt(ai * b);
        twon *= 2;
      }
      φ = twon * a[i] * u;
      do {
        t = c[i] * Math.sin(b = φ) / a[i];
        φ = .5 * (asin(t) + φ);
      } while (--i);
      return [Math.sin(φ), t = Math.cos(φ), t / Math.cos(φ - b), φ];
    }
    function ellipticFi(φ, ψ, m) {
      var r = Math.abs(φ), i = Math.abs(ψ), sinhψ = sinh(i);
      if (r) {
        var cscφ = 1 / Math.sin(r), cotφ2 = 1 / (Math.tan(r) * Math.tan(r)), b = -(cotφ2 + m * sinhψ * sinhψ * cscφ * cscφ - 1 + m), c = (m - 1) * cotφ2, cotλ2 = .5 * (-b + Math.sqrt(b * b - 4 * c));
        return [ellipticF(Math.atan(1 / Math.sqrt(cotλ2)), m) * sgn(φ), ellipticF(Math.atan(asqrt((cotλ2 / cotφ2 - 1) / m)), 1 - m) * sgn(ψ)];
      }
      return [0, ellipticF(Math.atan(sinhψ), 1 - m) * sgn(ψ)];
    }
    function ellipticF(φ, m) {
      if (!m) return φ;
      if (m === 1) return Math.log(Math.tan(φ / 2 + π / 4));
      var a = 1, b = Math.sqrt(1 - m), c = Math.sqrt(m);
      for (var i = 0; Math.abs(c) > ε; i++) {
        if (φ % π) {
          var dφ = Math.atan(b * Math.tan(φ) / a);
          if (dφ < 0) dφ += π;
          φ += dφ + ~~(φ / π) * π;
        } else φ += φ;
        c = (a + b) / 2;
        b = Math.sqrt(a * b);
        c = ((a = c) - b) / 2;
      }
      return φ / (Math.pow(2, i) * a);
    }
    function guyou(λ, φ) {
      var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1), k = Math.sqrt(1 - k_ * k_), K = ellipticF(halfπ, k * k), f = -1;
      var ψ = Math.log(Math.tan(π / 4 + Math.abs(φ) / 2)), r = Math.exp(f * ψ) / Math.sqrt(k_), at = guyouComplexAtan(r * Math.cos(f * λ), r * Math.sin(f * λ)), t = ellipticFi(at[0], at[1], k * k);
      return [-t[1], (φ >= 0 ? 1 : -1) * (.5 * K - t[0])];
    }
    function guyouComplexAtan(x, y) {
      var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;
      return [.5 * ((x >= 0 ? halfπ : -halfπ) - Math.atan2(t, 2 * x)), -.25 * Math.log(t * t + 4 * x2) + .5 * Math.log(y_1 * y_1 + x2)];
    }
    function guyouComplexDivide(a, b) {
      var denominator = b[0] * b[0] + b[1] * b[1];
      return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
    }
    guyou.invert = function(x, y) {
      var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1), k = Math.sqrt(1 - k_ * k_), K = ellipticF(halfπ, k * k), f = -1;
      var j = ellipticJi(.5 * K - y, -x, k * k), tn = guyouComplexDivide(j[0], j[1]), λ = Math.atan2(tn[1], tn[0]) / f;
      return [λ, 2 * Math.atan(Math.exp(.5 / f * Math.log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfπ];
    };
    d3.geoGuyou = quincuncialProjection(guyou);
    function hammerRetroazimuthal(φ0) {
      var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), rotate = hammerRetroazimuthalRotation(φ0);
      rotate.invert = hammerRetroazimuthalRotation(-φ0);
      function forward(λ, φ) {
        var p = rotate(λ, φ);
        λ = p[0], φ = p[1];
        var sinφ = Math.sin(φ), cosφ = Math.cos(φ), cosλ = Math.cos(λ), z = acos(sinφ0 * sinφ + cosφ0 * cosφ * cosλ), sinz = Math.sin(z), K = Math.abs(sinz) > ε ? z / sinz : 1;
        return [K * cosφ0 * Math.sin(λ), (Math.abs(λ) > halfπ ? K : -K) * (sinφ0 * cosφ - cosφ0 * sinφ * cosλ)];
      }
      forward.invert = function(x, y) {
        var ρ = Math.sqrt(x * x + y * y), sinz = -Math.sin(ρ), cosz = Math.cos(ρ), a = ρ * cosz, b = -y * sinz, c = ρ * sinφ0, d = asqrt(a * a + b * b - c * c), φ = Math.atan2(a * c + b * d, b * c - a * d), λ = (ρ > halfπ ? -1 : 1) * Math.atan2(x * sinz, ρ * Math.cos(φ) * cosz + y * Math.sin(φ) * sinz);
        return rotate.invert(λ, φ);
      };
      return forward;
    }
    function hammerRetroazimuthalRotation(φ0) {
      var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0);
      return function(λ, φ) {
        var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ);
        return [Math.atan2(y, x * cosφ0 - z * sinφ0), asin(z * cosφ0 + x * sinφ0)];
      };
    }
    function hammerRetroazimuthalProjection() {
      var φ0 = 0, m = projectionMutator(hammerRetroazimuthal), p = m(φ0), rotate_ = p.rotate, stream_ = p.stream, circle = d3.geoCircle();
      p.parallel = function(_) {
        if (!arguments.length) return φ0 / π * 180;
        var r = p.rotate();
        return m(φ0 = _ * π / 180).rotate(r);
      };
      p.rotate = function(_) {
        if (!arguments.length) return _ = rotate_.call(p), _[1] += φ0 / π * 180, _;
        rotate_.call(p, [_[0], _[1] - φ0 / π * 180]);
        circle.center([-_[0], -_[1]]);
        return p;
      };
      p.stream = function(stream) {
        stream = stream_(stream);
        stream.sphere = function() {
          stream.polygonStart();
          var ε = .01, ring = circle.radius(90 - ε)().coordinates[0], n = ring.length - 1, i = -1, p;
          stream.lineStart();
          while (++i < n) stream.point((p = ring[i])[0], p[1]);
          stream.lineEnd();
          ring = circle.radius(90 + ε)().coordinates[0];
          n = ring.length - 1;
          stream.lineStart();
          while (--i >= 0) stream.point((p = ring[i])[0], p[1]);
          stream.lineEnd();
          stream.polygonEnd();
        };
        return stream;
      };
      return p;
    }
    (d3.geoHammerRetroazimuthal = hammerRetroazimuthalProjection).raw = hammerRetroazimuthal;
    var hammerAzimuthalEqualArea = d3.geoAzimuthalEqualArea.raw;
    function hammer(A, B) {
      if (arguments.length < 2) B = A;
      if (B === 1) return hammerAzimuthalEqualArea;
      if (B === Infinity) return hammerQuarticAuthalic;
      function forward(λ, φ) {
        var coordinates = hammerAzimuthalEqualArea(λ / B, φ);
        coordinates[0] *= A;
        return coordinates;
      }
      forward.invert = function(x, y) {
        var coordinates = hammerAzimuthalEqualArea.invert(x / A, y);
        coordinates[0] *= B;
        return coordinates;
      };
      return forward;
    }
    function hammerProjection() {
      var B = 2, m = projectionMutator(hammer), p = m(B);
      p.coefficient = function(_) {
        if (!arguments.length) return B;
        return m(B = +_);
      };
      return p;
    }
    function hammerQuarticAuthalic(λ, φ) {
      return [λ * Math.cos(φ) / Math.cos(φ /= 2), 2 * Math.sin(φ)];
    }
    hammerQuarticAuthalic.invert = function(x, y) {
      var φ = 2 * asin(y / 2);
      return [x * Math.cos(φ / 2) / Math.cos(φ), φ];
    };
    (d3.geoHammer = hammerProjection).raw = hammer;
    function hatano(λ, φ) {
      var c = Math.sin(φ) * (φ < 0 ? 2.43763 : 2.67595);
      for (var i = 0, δ; i < 20; i++) {
        φ -= δ = (φ + Math.sin(φ) - c) / (1 + Math.cos(φ));
        if (Math.abs(δ) < ε) break;
      }
      return [.85 * λ * Math.cos(φ *= .5), Math.sin(φ) * (φ < 0 ? 1.93052 : 1.75859)];
    }
    hatano.invert = function(x, y) {
      var θ = Math.abs(θ = y * (y < 0 ? .5179951515653813 : .5686373742600607)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ);
      return [1.1764705882352942 * x / Math.cos(θ), Math.abs(θ = ((θ += θ) + Math.sin(θ)) * (y < 0 ? .4102345310814193 : .3736990601468637)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ)];
    };
    (d3.geoHatano = function() {
      return projection(hatano);
    }).raw = hatano;
    var healpixParallel = 41 + 48 / 36 + 37 / 3600;
    function healpix(h) {
      var lambert = d3.geoCylindricalEqualArea.raw(0), φ0 = healpixParallel * π / 180, dx0 = 2 * π, dx1 = d3.geoCollignon.raw(π, φ0)[0] - d3.geoCollignon.raw(-π, φ0)[0], y0 = lambert(0, φ0)[1], y1 = d3.geoCollignon.raw(0, φ0)[1], dy1 = d3.geoCollignon.raw(0, halfπ)[1] - y1, k = 2 * π / h;
      function forward(λ, φ) {
        var point, φ2 = Math.abs(φ);
        if (φ2 > φ0) {
          var i = Math.min(h - 1, Math.max(0, Math.floor((λ + π) / k)));
          λ += π * (h - 1) / h - i * k;
          point = d3.geoCollignon.raw(λ, φ2);
          point[0] = point[0] * dx0 / dx1 - dx0 * (h - 1) / (2 * h) + i * dx0 / h;
          point[1] = y0 + (point[1] - y1) * 4 * dy1 / dx0;
          if (φ < 0) point[1] = -point[1];
        } else {
          point = lambert(λ, φ);
        }
        point[0] /= 2;
        return point;
      }
      forward.invert = function(x, y) {
        x *= 2;
        var y2 = Math.abs(y);
        if (y2 > y0) {
          var i = Math.min(h - 1, Math.max(0, Math.floor((x + π) / k)));
          x = (x + π * (h - 1) / h - i * k) * dx1 / dx0;
          var point = d3.geoCollignon.raw.invert(x, .25 * (y2 - y0) * dx0 / dy1 + y1);
          point[0] -= π * (h - 1) / h - i * k;
          if (y < 0) point[1] = -point[1];
          return point;
        }
        return lambert.invert(x, y);
      };
      return forward;
    }
    function healpixProjection() {
      var n = 2, m = projectionMutator(healpix), p = m(n), stream_ = p.stream;
      p.lobes = function(_) {
        if (!arguments.length) return n;
        return m(n = +_);
      };
      p.stream = function(stream) {
        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]),
        stream_(stream));
        p.rotate(rotate);
        rotateStream.sphere = function() {
          d3.geoStream(sphere(), sphereStream);
        };
        return rotateStream;
      };
      function sphere() {
        var step = 180 / n;
        return {
          type: "Polygon",
          coordinates: [d3.range(-180, 180 + step / 2, step).map(function(x, i) {
            return [x, i & 1 ? 90 - 1e-6 : healpixParallel];
          }).concat(d3.range(180, -180 - step / 2, -step).map(function(x, i) {
            return [x, i & 1 ? -90 + 1e-6 : -healpixParallel];
          }))]
        };
      }
      return p;
    }
    (d3.geoHealpix = healpixProjection).raw = healpix;
    function hill(K) {
      var L = 1 + K, sinβ = Math.sin(1 / L), β = asin(sinβ), A = 2 * Math.sqrt(π / (B = π + 4 * β * L)), B, ρ0 = .5 * A * (L + Math.sqrt(K * (2 + K))), K2 = K * K, L2 = L * L;
      function forward(λ, φ) {
        var t = 1 - Math.sin(φ), ρ, ω;
        if (t && t < 2) {
          var θ = halfπ - φ, i = 25, δ;
          do {
            var sinθ = Math.sin(θ), cosθ = Math.cos(θ), β_β1 = β + Math.atan2(sinθ, L - cosθ), C = 1 + L2 - 2 * L * cosθ;
            θ -= δ = (θ - K2 * β - L * sinθ + C * β_β1 - .5 * t * B) / (2 * L * sinθ * β_β1);
          } while (Math.abs(δ) > ε2 && --i > 0);
          ρ = A * Math.sqrt(C);
          ω = λ * β_β1 / π;
        } else {
          ρ = A * (K + t);
          ω = λ * β / π;
        }
        return [ρ * Math.sin(ω), ρ0 - ρ * Math.cos(ω)];
      }
      forward.invert = function(x, y) {
        var ρ2 = x * x + (y -= ρ0) * y, cosθ = (1 + L2 - ρ2 / (A * A)) / (2 * L), θ = acos(cosθ), sinθ = Math.sin(θ), β_β1 = β + Math.atan2(sinθ, L - cosθ);
        return [asin(x / Math.sqrt(ρ2)) * π / β_β1, asin(1 - 2 * (θ - K2 * β - L * sinθ + (1 + L2 - 2 * L * cosθ) * β_β1) / B)];
      };
      return forward;
    }
    function hillProjection() {
      var K = 1, m = projectionMutator(hill), p = m(K);
      p.ratio = function(_) {
        if (!arguments.length) return K;
        return m(K = +_);
      };
      return p;
    }
    (d3.geoHill = hillProjection).raw = hill;
    var sinuMollweideφ = .7109889596207567, sinuMollweideY = .0528035274542;
    function sinuMollweide(λ, φ) {
      return φ > -sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] += sinuMollweideY, λ) : sinusoidal(λ, φ);
    }
    sinuMollweide.invert = function(x, y) {
      return y > -sinuMollweideφ ? mollweide.invert(x, y - sinuMollweideY) : sinusoidal.invert(x, y);
    };
    (d3.geoSinuMollweide = function() {
      return projection(sinuMollweide).rotate([-20, -55]);
    }).raw = sinuMollweide;
    function homolosine(λ, φ) {
      return Math.abs(φ) > sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] -= φ > 0 ? sinuMollweideY : -sinuMollweideY,
      λ) : sinusoidal(λ, φ);
    }
    homolosine.invert = function(x, y) {
      return Math.abs(y) > sinuMollweideφ ? mollweide.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidal.invert(x, y);
    };
    (d3.geoHomolosine = function() {
      return projection(homolosine);
    }).raw = homolosine;
    function kavrayskiy7(λ, φ) {
      return [3 * λ / (2 * π) * Math.sqrt(π * π / 3 - φ * φ), φ];
    }
    kavrayskiy7.invert = function(x, y) {
      return [2 / 3 * π * x / Math.sqrt(π * π / 3 - y * y), y];
    };
    (d3.geoKavrayskiy7 = function() {
      return projection(kavrayskiy7);
    }).raw = kavrayskiy7;
    function lagrange(n) {
      function forward(λ, φ) {
        if (Math.abs(Math.abs(φ) - halfπ) < ε) return [0, φ < 0 ? -2 : 2];
        var sinφ = Math.sin(φ), v = Math.pow((1 + sinφ) / (1 - sinφ), n / 2), c = .5 * (v + 1 / v) + Math.cos(λ *= n);
        return [2 * Math.sin(λ) / c, (v - 1 / v) / c];
      }
      forward.invert = function(x, y) {
        var y0 = Math.abs(y);
        if (Math.abs(y0 - 2) < ε) return x ? null : [0, sgn(y) * halfπ];
        if (y0 > 2) return null;
        x /= 2, y /= 2;
        var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2);
        t = Math.pow((1 + t) / (1 - t), 1 / n);
        return [Math.atan2(2 * x, 1 - x2 - y2) / n, asin((t - 1) / (t + 1))];
      };
      return forward;
    }
    function lagrangeProjection() {
      var n = .5, m = projectionMutator(lagrange), p = m(n);
      p.spacing = function(_) {
        if (!arguments.length) return n;
        return m(n = +_);
      };
      return p;
    }
    (d3.geoLagrange = lagrangeProjection).raw = lagrange;
    function larrivee(λ, φ) {
      return [λ * (1 + Math.sqrt(Math.cos(φ))) / 2, φ / (Math.cos(φ / 2) * Math.cos(λ / 6))];
    }
    larrivee.invert = function(x, y) {
      var x0 = Math.abs(x), y0 = Math.abs(y), π_sqrt2 = π / Math.SQRT2, λ = ε, φ = halfπ;
      if (y0 < π_sqrt2) φ *= y0 / π_sqrt2; else λ += 6 * acos(π_sqrt2 / y0);
      for (var i = 0; i < 25; i++) {
        var sinφ = Math.sin(φ), sqrtcosφ = asqrt(Math.cos(φ)), sinφ_2 = Math.sin(φ / 2), cosφ_2 = Math.cos(φ / 2), sinλ_6 = Math.sin(λ / 6), cosλ_6 = Math.cos(λ / 6), f0 = .5 * λ * (1 + sqrtcosφ) - x0, f1 = φ / (cosφ_2 * cosλ_6) - y0, df0dφ = sqrtcosφ ? -.25 * λ * sinφ / sqrtcosφ : 0, df0dλ = .5 * (1 + sqrtcosφ), df1dφ = (1 + .5 * φ * sinφ_2 / cosφ_2) / (cosφ_2 * cosλ_6), df1dλ = φ / cosφ_2 * (sinλ_6 / 6) / (cosλ_6 * cosλ_6), denom = df0dφ * df1dλ - df1dφ * df0dλ, dφ = (f0 * df1dλ - f1 * df0dλ) / denom, dλ = (f1 * df0dφ - f0 * df1dφ) / denom;
        φ -= dφ;
        λ -= dλ;
        if (Math.abs(dφ) < ε && Math.abs(dλ) < ε) break;
      }
      return [x < 0 ? -λ : λ, y < 0 ? -φ : φ];
    };
    (d3.geoLarrivee = function() {
      return projection(larrivee);
    }).raw = larrivee;
    function laskowski(λ, φ) {
      var λ2 = λ * λ, φ2 = φ * φ;
      return [λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)), φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032))];
    }
    laskowski.invert = function(x, y) {
      var λ = sgn(x) * π, φ = y / 2, i = 50;
      do {
        var λ2 = λ * λ, φ2 = φ * φ, λφ = λ * φ, fx = λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)) - x, fy = φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032)) - y, δxδλ = .975534 - φ2 * (.119161 + 3 * λ2 * .0143059 + φ2 * .0547009), δxδφ = -λφ * (2 * .119161 + 4 * .0547009 * φ2 + 2 * .0143059 * λ2), δyδλ = λφ * (2 * .0802894 + 4 * 199025e-9 * λ2 + 2 * -.02855 * φ2), δyδφ = 1.00384 + λ2 * (.0802894 + 199025e-9 * λ2) + φ2 * (3 * (.0998909 - .02855 * λ2) - 5 * .0491032 * φ2), denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ, φ -= δφ;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return i && [λ, φ];
    };
    (d3.geoLaskowski = function() {
      return projection(laskowski);
    }).raw = laskowski;
    function littrow(λ, φ) {
      return [Math.sin(λ) / Math.cos(φ), Math.tan(φ) * Math.cos(λ)];
    }
    littrow.invert = function(x, y) {
      var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, cosφ = x ? Math.SQRT1_2 * Math.sqrt((y2_1 - Math.sqrt(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1) : 1 / Math.sqrt(y2_1);
      return [asin(x * cosφ), sgn(y) * acos(cosφ)];
    };
    (d3.geoLittrow = function() {
      return projection(littrow);
    }).raw = littrow;
    function loximuthal(φ0) {
      var cosφ0 = Math.cos(φ0), tanφ0 = Math.tan(π / 4 + φ0 / 2);
      function forward(λ, φ) {
        var y = φ - φ0, x = Math.abs(y) < ε ? λ * cosφ0 : Math.abs(x = π / 4 + φ / 2) < ε || Math.abs(Math.abs(x) - halfπ) < ε ? 0 : λ * y / Math.log(Math.tan(x) / tanφ0);
        return [x, y];
      }
      forward.invert = function(x, y) {
        var λ, φ = y + φ0;
        return [Math.abs(y) < ε ? x / cosφ0 : Math.abs(λ = π / 4 + φ / 2) < ε || Math.abs(Math.abs(λ) - halfπ) < ε ? 0 : x * Math.log(Math.tan(λ) / tanφ0) / y, φ];
      };
      return forward;
    }
    (d3.geoLoximuthal = function() {
      return parallel1Projection(loximuthal).parallel(40);
    }).raw = loximuthal;
    function miller(λ, φ) {
      return [λ, 1.25 * Math.log(Math.tan(π / 4 + .4 * φ))];
    }
    miller.invert = function(x, y) {
      return [x, 2.5 * Math.atan(Math.exp(.8 * y)) - .625 * π];
    };
    (d3.geoMiller = function() {
      return projection(miller);
    }).raw = miller;
    function modifiedStereographic(C) {
      var m = C.length - 1;
      function forward(λ, φ) {
        var cosφ = Math.cos(φ), k = 2 / (1 + cosφ * Math.cos(λ)), zr = k * cosφ * Math.sin(λ), zi = k * Math.sin(φ), i = m, w = C[i], ar = w[0], ai = w[1], t;
        while (--i >= 0) {
          w = C[i];
          ar = w[0] + zr * (t = ar) - zi * ai;
          ai = w[1] + zr * ai + zi * t;
        }
        ar = zr * (t = ar) - zi * ai;
        ai = zr * ai + zi * t;
        return [ar, ai];
      }
      forward.invert = function(x, y) {
        var i = 20, zr = x, zi = y;
        do {
          var j = m, w = C[j], ar = w[0], ai = w[1], br = 0, bi = 0, t;
          while (--j >= 0) {
            w = C[j];
            br = ar + zr * (t = br) - zi * bi;
            bi = ai + zr * bi + zi * t;
            ar = w[0] + zr * (t = ar) - zi * ai;
            ai = w[1] + zr * ai + zi * t;
          }
          br = ar + zr * (t = br) - zi * bi;
          bi = ai + zr * bi + zi * t;
          ar = zr * (t = ar) - zi * ai - x;
          ai = zr * ai + zi * t - y;
          var denominator = br * br + bi * bi, δr, δi;
          zr -= δr = (ar * br + ai * bi) / denominator;
          zi -= δi = (ai * br - ar * bi) / denominator;
        } while (Math.abs(δr) + Math.abs(δi) > ε * ε && --i > 0);
        if (i) {
          var ρ = Math.sqrt(zr * zr + zi * zi), c = 2 * Math.atan(ρ * .5), sinc = Math.sin(c);
          return [Math.atan2(zr * sinc, ρ * Math.cos(c)), ρ ? asin(zi * sinc / ρ) : 0];
        }
      };
      return forward;
    }
    var modifiedStereographicCoefficients = {
      alaska: [[.9972523, 0], [.0052513, -.0041175], [.0074606, .0048125], [-.0153783, -.1968253], [.0636871, -.1408027], [.3660976, -.2937382]],
      gs48: [[.98879, 0], [0, 0], [-.050909, 0], [0, 0], [.075528, 0]],
      gs50: [[.984299, 0], [.0211642, .0037608], [-.1036018, -.0575102], [-.0329095, -.0320119], [.0499471, .1223335], [.026046, .0899805], [7388e-7, -.1435792], [.0075848, -.1334108], [-.0216473, .0776645], [-.0225161, .0853673]],
      miller: [[.9245, 0], [0, 0], [.01943, 0]],
      lee: [[.721316, 0], [0, 0], [-.00881625, -.00617325]]
    };
    function modifiedStereographicProjection() {
      var coefficients = modifiedStereographicCoefficients.miller, m = projectionMutator(modifiedStereographic), p = m(coefficients);
      p.coefficients = function(_) {
        if (!arguments.length) return coefficients;
        return m(coefficients = typeof _ === "string" ? modifiedStereographicCoefficients[_] : _);
      };
      return p;
    }
    (d3.geoModifiedStereographic = modifiedStereographicProjection).raw = modifiedStereographic;
    function mtFlatPolarParabolic(λ, φ) {
      var sqrt6 = Math.sqrt(6), sqrt7 = Math.sqrt(7), θ = Math.asin(7 * Math.sin(φ) / (3 * sqrt6));
      return [sqrt6 * λ * (2 * Math.cos(2 * θ / 3) - 1) / sqrt7, 9 * Math.sin(θ / 3) / sqrt7];
    }
    mtFlatPolarParabolic.invert = function(x, y) {
      var sqrt6 = Math.sqrt(6), sqrt7 = Math.sqrt(7), θ = 3 * asin(y * sqrt7 / 9);
      return [x * sqrt7 / (sqrt6 * (2 * Math.cos(2 * θ / 3) - 1)), asin(Math.sin(θ) * 3 * sqrt6 / 7)];
    };
    (d3.geoMtFlatPolarParabolic = function() {
      return projection(mtFlatPolarParabolic);
    }).raw = mtFlatPolarParabolic;
    function mtFlatPolarQuartic(λ, φ) {
      var k = (1 + Math.SQRT1_2) * Math.sin(φ), θ = φ;
      for (var i = 0, δ; i < 25; i++) {
        θ -= δ = (Math.sin(θ / 2) + Math.sin(θ) - k) / (.5 * Math.cos(θ / 2) + Math.cos(θ));
        if (Math.abs(δ) < ε) break;
      }
      return [λ * (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)) / (3 * Math.SQRT2), 2 * Math.sqrt(3) * Math.sin(θ / 2) / Math.sqrt(2 + Math.SQRT2)];
    }
    mtFlatPolarQuartic.invert = function(x, y) {
      var sinθ_2 = y * Math.sqrt(2 + Math.SQRT2) / (2 * Math.sqrt(3)), θ = 2 * asin(sinθ_2);
      return [3 * Math.SQRT2 * x / (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)), asin((sinθ_2 + Math.sin(θ)) / (1 + Math.SQRT1_2))];
    };
    (d3.geoMtFlatPolarQuartic = function() {
      return projection(mtFlatPolarQuartic);
    }).raw = mtFlatPolarQuartic;
    function mtFlatPolarSinusoidal(λ, φ) {
      var A = Math.sqrt(6 / (4 + π)), k = (1 + π / 4) * Math.sin(φ), θ = φ / 2;
      for (var i = 0, δ; i < 25; i++) {
        θ -= δ = (θ / 2 + Math.sin(θ) - k) / (.5 + Math.cos(θ));
        if (Math.abs(δ) < ε) break;
      }
      return [A * (.5 + Math.cos(θ)) * λ / 1.5, A * θ];
    }
    mtFlatPolarSinusoidal.invert = function(x, y) {
      var A = Math.sqrt(6 / (4 + π)), θ = y / A;
      if (Math.abs(Math.abs(θ) - halfπ) < ε) θ = θ < 0 ? -halfπ : halfπ;
      return [1.5 * x / (A * (.5 + Math.cos(θ))), asin((θ / 2 + Math.sin(θ)) / (1 + π / 4))];
    };
    (d3.geoMtFlatPolarSinusoidal = function() {
      return projection(mtFlatPolarSinusoidal);
    }).raw = mtFlatPolarSinusoidal;
    function naturalEarth(λ, φ) {
      var φ2 = φ * φ, φ4 = φ2 * φ2;
      return [λ * (.8707 - .131979 * φ2 + φ4 * (-.013791 + φ4 * (.003971 * φ2 - .001529 * φ4))), φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4)))];
    }
    naturalEarth.invert = function(x, y) {
      var φ = y, i = 25, δ;
      do {
        var φ2 = φ * φ, φ4 = φ2 * φ2;
        φ -= δ = (φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4))) - y) / (1.007226 + φ2 * (.015085 * 3 + φ4 * (-.044475 * 7 + .028874 * 9 * φ2 - .005916 * 11 * φ4)));
      } while (Math.abs(δ) > ε && --i > 0);
      return [x / (.8707 + (φ2 = φ * φ) * (-.131979 + φ2 * (-.013791 + φ2 * φ2 * φ2 * (.003971 - .001529 * φ2)))), φ];
    };
    (d3.geoNaturalEarth = function() {
      return projection(naturalEarth);
    }).raw = naturalEarth;
    function nellHammer(λ, φ) {
      return [λ * (1 + Math.cos(φ)) / 2, 2 * (φ - Math.tan(φ / 2))];
    }
    nellHammer.invert = function(x, y) {
      var p = y / 2;
      for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
        var c = Math.cos(y / 2);
        y -= δ = (y - Math.tan(y / 2) - p) / (1 - .5 / (c * c));
      }
      return [2 * x / (1 + Math.cos(y)), y];
    };
    (d3.geoNellHammer = function() {
      return projection(nellHammer);
    }).raw = nellHammer;
    var pattersonK1 = 1.0148, pattersonK2 = .23185, pattersonK3 = -.14499, pattersonK4 = .02406, pattersonC1 = pattersonK1, pattersonC2 = 5 * pattersonK2, pattersonC3 = 7 * pattersonK3, pattersonC4 = 9 * pattersonK4, pattersonYmax = 1.790857183;
    function patterson(λ, φ) {
      var φ2 = φ * φ;
      return [λ, φ * (pattersonK1 + φ2 * φ2 * (pattersonK2 + φ2 * (pattersonK3 + pattersonK4 * φ2)))];
    }
    patterson.invert = function(x, y) {
      if (y > pattersonYmax) y = pattersonYmax; else if (y < -pattersonYmax) y = -pattersonYmax;
      var yc = y, δ;
      do {
        var y2 = yc * yc;
        yc -= δ = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
      } while (Math.abs(δ) > ε);
      return [x, yc];
    };
    (d3.geoPatterson = function() {
      return projection(patterson);
    }).raw = patterson;
    var peirceQuincuncialProjection = quincuncialProjection(guyou);
    (d3.geoPeirceQuincuncial = function() {
      return peirceQuincuncialProjection().quincuncial(true).rotate([-90, -90, 45]).clipAngle(180 - 1e-6);
    }).raw = peirceQuincuncialProjection.raw;
    function polyconic(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var tanφ = Math.tan(φ), k = λ * Math.sin(φ);
      return [Math.sin(k) / tanφ, φ + (1 - Math.cos(k)) / tanφ];
    }
    polyconic.invert = function(x, y) {
      if (Math.abs(y) < ε) return [x, 0];
      var k = x * x + y * y, φ = y * .5, i = 10, δ;
      do {
        var tanφ = Math.tan(φ), secφ = 1 / Math.cos(φ), j = k - 2 * y * φ + φ * φ;
        φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
      } while (Math.abs(δ) > ε && --i > 0);
      tanφ = Math.tan(φ);
      return [(Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(x * tanφ) : sgn(x) * (acos(Math.abs(x * tanφ)) + halfπ)) / Math.sin(φ), φ];
    };
    (d3.geoPolyconic = function() {
      return projection(polyconic);
    }).raw = polyconic;
    function rectangularPolyconic(φ0) {
      var sinφ0 = Math.sin(φ0);
      function forward(λ, φ) {
        var A = sinφ0 ? Math.tan(λ * sinφ0 / 2) / sinφ0 : λ / 2;
        if (!φ) return [2 * A, -φ0];
        var E = 2 * Math.atan(A * Math.sin(φ)), cotφ = 1 / Math.tan(φ);
        return [Math.sin(E) * cotφ, φ + (1 - Math.cos(E)) * cotφ - φ0];
      }
      forward.invert = function(x, y) {
        if (Math.abs(y += φ0) < ε) return [sinφ0 ? 2 * Math.atan(sinφ0 * x / 2) / sinφ0 : x, 0];
        var k = x * x + y * y, φ = 0, i = 10, δ;
        do {
          var tanφ = Math.tan(φ), secφ = 1 / Math.cos(φ), j = k - 2 * y * φ + φ * φ;
          φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
        } while (Math.abs(δ) > ε && --i > 0);
        var E = x * (tanφ = Math.tan(φ)), A = Math.tan(Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(E) * .5 : acos(E) * .5 + π / 4) / Math.sin(φ);
        return [sinφ0 ? 2 * Math.atan(sinφ0 * A) / sinφ0 : 2 * A, φ];
      };
      return forward;
    }
    (d3.geoRectangularPolyconic = function() {
      return parallel1Projection(rectangularPolyconic);
    }).raw = rectangularPolyconic;
    var robinsonConstants = [[.9986, -.062], [1, 0], [.9986, .062], [.9954, .124], [.99, .186], [.9822, .248], [.973, .31], [.96, .372], [.9427, .434], [.9216, .4958], [.8962, .5571], [.8679, .6176], [.835, .6769], [.7986, .7346], [.7597, .7903], [.7186, .8435], [.6732, .8936], [.6213, .9394], [.5722, .9761], [.5322, 1]];
    robinsonConstants.forEach(function(d) {
      d[1] *= 1.0144;
    });
    function robinson(λ, φ) {
      var i = Math.min(18, Math.abs(φ) * 36 / π), i0 = Math.floor(i), di = i - i0, ax = (k = robinsonConstants[i0])[0], ay = k[1], bx = (k = robinsonConstants[++i0])[0], by = k[1], cx = (k = robinsonConstants[Math.min(19, ++i0)])[0], cy = k[1], k;
      return [λ * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (φ > 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)];
    }
    robinson.invert = function(x, y) {
      var yy = y / halfπ, φ = yy * 90, i = Math.min(18, Math.abs(φ / 5)), i0 = Math.max(0, Math.floor(i));
      do {
        var ay = robinsonConstants[i0][1], by = robinsonConstants[i0 + 1][1], cy = robinsonConstants[Math.min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (Math.abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));
        if (di >= 0 || i0 === 1) {
          φ = (y >= 0 ? 5 : -5) * (di + i);
          var j = 50, δ;
          do {
            i = Math.min(18, Math.abs(φ) / 5);
            i0 = Math.floor(i);
            di = i - i0;
            ay = robinsonConstants[i0][1];
            by = robinsonConstants[i0 + 1][1];
            cy = robinsonConstants[Math.min(19, i0 + 2)][1];
            φ -= (δ = (y >= 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;
          } while (Math.abs(δ) > ε2 && --j > 0);
          break;
        }
      } while (--i0 >= 0);
      var ax = robinsonConstants[i0][0], bx = robinsonConstants[i0 + 1][0], cx = robinsonConstants[Math.min(19, i0 + 2)][0];
      return [x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), φ * radians];
    };
    (d3.geoRobinson = function() {
      return projection(robinson);
    }).raw = robinson;
    function satelliteVertical(P) {
      function forward(λ, φ) {
        var cosφ = Math.cos(φ), k = (P - 1) / (P - cosφ * Math.cos(λ));
        return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
      }
      forward.invert = function(x, y) {
        var ρ2 = x * x + y * y, ρ = Math.sqrt(ρ2), sinc = (P - Math.sqrt(1 - ρ2 * (P + 1) / (P - 1))) / ((P - 1) / ρ + ρ / (P - 1));
        return [Math.atan2(x * sinc, ρ * Math.sqrt(1 - sinc * sinc)), ρ ? asin(y * sinc / ρ) : 0];
      };
      return forward;
    }
    function satellite(P, ω) {
      var vertical = satelliteVertical(P);
      if (!ω) return vertical;
      var cosω = Math.cos(ω), sinω = Math.sin(ω);
      function forward(λ, φ) {
        var coordinates = vertical(λ, φ), y = coordinates[1], A = y * sinω / (P - 1) + cosω;
        return [coordinates[0] * cosω / A, y / A];
      }
      forward.invert = function(x, y) {
        var k = (P - 1) / (P - 1 - y * sinω);
        return vertical.invert(k * x, k * y * cosω);
      };
      return forward;
    }
    function satelliteProjection() {
      var P = 1.4, ω = 0, m = projectionMutator(satellite), p = m(P, ω);
      p.distance = function(_) {
        if (!arguments.length) return P;
        return m(P = +_, ω);
      };
      p.tilt = function(_) {
        if (!arguments.length) return ω * 180 / π;
        return m(P, ω = _ * π / 180);
      };
      return p;
    }
    (d3.geoSatellite = satelliteProjection).raw = satellite;
    function times(λ, φ) {
      var t = Math.tan(φ / 2), s = Math.sin(π / 4 * t);
      return [λ * (.74482 - .34588 * s * s), 1.70711 * t];
    }
    times.invert = function(x, y) {
      var t = y / 1.70711, s = Math.sin(π / 4 * t);
      return [x / (.74482 - .34588 * s * s), 2 * Math.atan(t)];
    };
    (d3.geoTimes = function() {
      return projection(times);
    }).raw = times;
    function twoPointEquidistant(z0) {
      if (!z0) return d3.geoAzimuthalEquidistant.raw;
      var λa = -z0 / 2, λb = -λa, z02 = z0 * z0, tanλ0 = Math.tan(λb), S = .5 / Math.sin(λb);
      function forward(λ, φ) {
        var za = acos(Math.cos(φ) * Math.cos(λ - λa)), zb = acos(Math.cos(φ) * Math.cos(λ - λb)), ys = φ < 0 ? -1 : 1;
        za *= za, zb *= zb;
        return [(za - zb) / (2 * z0), ys * asqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)];
      }
      forward.invert = function(x, y) {
        var y2 = y * y, cosza = Math.cos(Math.sqrt(y2 + (t = x + λa) * t)), coszb = Math.cos(Math.sqrt(y2 + (t = x + λb) * t)), t, d;
        return [Math.atan2(d = cosza - coszb, t = (cosza + coszb) * tanλ0), (y < 0 ? -1 : 1) * acos(Math.sqrt(t * t + d * d) * S)];
      };
      return forward;
    }
    function twoPointEquidistantProjection() {
      var points = [[0, 0], [0, 0]], m = projectionMutator(twoPointEquidistant), p = m(0), rotate = p.rotate;
      delete p.rotate;
      p.points = function(_) {
        if (!arguments.length) return points;
        points = _;
        var interpolate = d3.geoInterpolate(_[0], _[1]), origin = interpolate(.5), p = d3.geoRotation([-origin[0], -origin[1]])(_[0]), b = interpolate.distance * .5, γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
        if (p[0] > 0) γ = π - γ;
        rotate.call(p, [-origin[0], -origin[1], -γ * degrees]);
        return m(b * 2);
      };
      return p;
    }
    (d3.geoTwoPointEquidistant = twoPointEquidistantProjection).raw = twoPointEquidistant;
    function twoPointAzimuthal(d) {
      var cosd = Math.cos(d);
      function forward(λ, φ) {
        var coordinates = d3.geoGnomonic.raw(λ, φ);
        coordinates[0] *= cosd;
        return coordinates;
      }
      forward.invert = function(x, y) {
        return d3.geoGnomonic.raw.invert(x / cosd, y);
      };
      return forward;
    }
    function twoPointAzimuthalProjection() {
      var points = [[0, 0], [0, 0]], m = projectionMutator(twoPointAzimuthal), p = m(0), rotate = p.rotate;
      delete p.rotate;
      p.points = function(_) {
        if (!arguments.length) return points;
        points = _;
        var interpolate = d3.geoInterpolate(_[0], _[1]), origin = interpolate(.5), p = d3.geoRotation([-origin[0], -origin[1]])(_[0]), b = interpolate.distance * .5, γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
        if (p[0] > 0) γ = π - γ;
        rotate.call(p, [-origin[0], -origin[1], -γ * degrees]);
        return m(b);
      };
      return p;
    }
    (d3.geoTwoPointAzimuthal = twoPointAzimuthalProjection).raw = twoPointAzimuthal;
    function vanDerGrinten(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var sinθ = Math.abs(φ / halfπ), θ = asin(sinθ);
      if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, sgn(φ) * π * Math.tan(θ / 2)];
      var cosθ = Math.cos(θ), A = Math.abs(π / λ - λ / π) / 2, A2 = A * A, G = cosθ / (sinθ + cosθ - 1), P = G * (2 / sinθ - 1), P2 = P * P, P2_A2 = P2 + A2, G_P2 = G - P2, Q = A2 + G;
      return [sgn(λ) * π * (A * G_P2 + Math.sqrt(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2, sgn(φ) * π * (P * Q - A * Math.sqrt((A2 + 1) * P2_A2 - Q * Q)) / P2_A2];
    }
    vanDerGrinten.invert = function(x, y) {
      if (Math.abs(y) < ε) return [x, 0];
      if (Math.abs(x) < ε) return [0, halfπ * Math.sin(2 * Math.atan(y / π))];
      var x2 = (x /= π) * x, y2 = (y /= π) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -Math.abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * Math.sqrt(-a1 / 3), θ1 = acos(3 * d / (a1 * m1)) / 3;
      return [π * (x2_y2 - 1 + Math.sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x), sgn(y) * π * (-m1 * Math.cos(θ1 + π / 3) - c2 / (3 * c3))];
    };
    (d3.geoVanDerGrinten = function() {
      return projection(vanDerGrinten);
    }).raw = vanDerGrinten;
    function vanDerGrinten2(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var sinθ = Math.abs(φ / halfπ), θ = asin(sinθ);
      if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, sgn(φ) * π * Math.tan(θ / 2)];
      var cosθ = Math.cos(θ), A = Math.abs(π / λ - λ / π) / 2, A2 = A * A, x1 = cosθ * (Math.sqrt(1 + A2) - A * cosθ) / (1 + A2 * sinθ * sinθ);
      return [sgn(λ) * π * x1, sgn(φ) * π * asqrt(1 - x1 * (2 * A + x1))];
    }
    vanDerGrinten2.invert = function(x, y) {
      if (!x) return [0, halfπ * Math.sin(2 * Math.atan(y / π))];
      var x1 = Math.abs(x / π), A = (1 - x1 * x1 - (y /= π) * y) / (2 * x1), A2 = A * A, B = Math.sqrt(A2 + 1);
      return [sgn(x) * π * (B - A), sgn(y) * halfπ * Math.sin(2 * Math.atan2(Math.sqrt((1 - 2 * A * x1) * (A + B) - x1), Math.sqrt(B + A + x1)))];
    };
    (d3.geoVanDerGrinten2 = function() {
      return projection(vanDerGrinten2);
    }).raw = vanDerGrinten2;
    function vanDerGrinten3(λ, φ) {
      if (Math.abs(φ) < ε) return [λ, 0];
      var sinθ = φ / halfπ, θ = asin(sinθ);
      if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, π * Math.tan(θ / 2)];
      var A = (π / λ - λ / π) / 2, y1 = sinθ / (1 + Math.cos(θ));
      return [π * (sgn(λ) * asqrt(A * A + 1 - y1 * y1) - A), π * y1];
    }
    vanDerGrinten3.invert = function(x, y) {
      if (!y) return [x, 0];
      var y1 = y / π, A = (π * π * (1 - y1 * y1) - x * x) / (2 * π * x);
      return [x ? π * (sgn(x) * Math.sqrt(A * A + 1) - A) : 0, halfπ * Math.sin(2 * Math.atan(y1))];
    };
    (d3.geoVanDerGrinten3 = function() {
      return projection(vanDerGrinten3);
    }).raw = vanDerGrinten3;
    function vanDerGrinten4(λ, φ) {
      if (!φ) return [λ, 0];
      var φ0 = Math.abs(φ);
      if (!λ || φ0 === halfπ) return [0, φ];
      var B = φ0 / halfπ, B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C2 = C * C, BC = B * C, B_C2 = B2 + C2 + 2 * BC, B_3C = B + 3 * C, λ0 = λ / halfπ, λ1 = λ0 + 1 / λ0, D = sgn(Math.abs(λ) - halfπ) * Math.sqrt(λ1 * λ1 - 4), D2 = D * D, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x1 = (D * (B_C2 + C2 - 1) + 2 * asqrt(F)) / (4 * B_C2 + D2);
      return [sgn(λ) * halfπ * x1, sgn(φ) * halfπ * asqrt(1 + D * Math.abs(x1) - x1 * x1)];
    }
    vanDerGrinten4.invert = function(x, y) {
      if (!x || !y) return [x, y];
      y /= π;
      var x1 = sgn(x) * x / halfπ, D = (x1 * x1 - 1 + 4 * y * y) / Math.abs(x1), D2 = D * D, B = 2 * y, i = 50;
      do {
        var B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C_ = (3 * B - B2 * B - 10) / (2 * B2 * B), C2 = C * C, BC = B * C, B_C = B + C, B_C2 = B_C * B_C, B_3C = B + 3 * C, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)), sqrtF = Math.sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
        B -= δ = f / f_;
      } while (δ > ε && --i > 0);
      return [sgn(x) * (Math.sqrt(D * D + 4) + D) * π / 4, halfπ * B];
    };
    (d3.geoVanDerGrinten4 = function() {
      return projection(vanDerGrinten4);
    }).raw = vanDerGrinten4;
    var wagner4 = function() {
      var A = 4 * π + 3 * Math.sqrt(3), B = 2 * Math.sqrt(2 * π * Math.sqrt(3) / A);
      return mollweideBromley(B * Math.sqrt(3) / π, B, A / 6);
    }();
    (d3.geoWagner4 = function() {
      return projection(wagner4);
    }).raw = wagner4;
    function wagner6(λ, φ) {
      return [λ * Math.sqrt(1 - 3 * φ * φ / (π * π)), φ];
    }
    wagner6.invert = function(x, y) {
      return [x / Math.sqrt(1 - 3 * y * y / (π * π)), y];
    };
    (d3.geoWagner6 = function() {
      return projection(wagner6);
    }).raw = wagner6;
    function wagner7(λ, φ) {
      var s = .90631 * Math.sin(φ), c0 = Math.sqrt(1 - s * s), c1 = Math.sqrt(2 / (1 + c0 * Math.cos(λ /= 3)));
      return [2.66723 * c0 * c1 * Math.sin(λ), 1.24104 * s * c1];
    }
    wagner7.invert = function(x, y) {
      var t1 = x / 2.66723, t2 = y / 1.24104, p = Math.sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);
      return [3 * Math.atan2(x * Math.tan(c), 2.66723 * p), p && asin(y * Math.sin(c) / (1.24104 * .90631 * p))];
    };
    (d3.geoWagner7 = function() {
      return projection(wagner7);
    }).raw = wagner7;
    function wiechel(λ, φ) {
      var cosφ = Math.cos(φ), sinφ = Math.cos(λ) * cosφ, sin1_φ = 1 - sinφ, cosλ = Math.cos(λ = Math.atan2(Math.sin(λ) * cosφ, -Math.sin(φ))), sinλ = Math.sin(λ);
      cosφ = asqrt(1 - sinφ * sinφ);
      return [sinλ * cosφ - cosλ * sin1_φ, -cosλ * cosφ - sinλ * sin1_φ];
    }
    wiechel.invert = function(x, y) {
      var w = -.5 * (x * x + y * y), k = Math.sqrt(-w * (2 + w)), b = y * w + x * k, a = x * w - y * k, D = Math.sqrt(a * a + b * b);
      return [Math.atan2(k * b, D * (1 + w)), D ? -asin(k * a / D) : 0];
    };
    (d3.geoWiechel = function() {
      return projection(wiechel);
    }).raw = wiechel;
    function winkel3(λ, φ) {
      var coordinates = aitoff(λ, φ);
      return [(coordinates[0] + λ / halfπ) / 2, (coordinates[1] + φ) / 2];
    }
    winkel3.invert = function(x, y) {
      var λ = x, φ = y, i = 25;
      do {
        var cosφ = Math.cos(φ), sinφ = Math.sin(φ), sin_2φ = Math.sin(2 * φ), sin2φ = sinφ * sinφ, cos2φ = cosφ * cosφ, sinλ = Math.sin(λ), cosλ_2 = Math.cos(λ / 2), sinλ_2 = Math.sin(λ / 2), sin2λ_2 = sinλ_2 * sinλ_2, C = 1 - cos2φ * cosλ_2 * cosλ_2, E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = .5 * (2 * E * cosφ * sinλ_2 + λ / halfπ) - x, fy = .5 * (E * sinφ + φ) - y, δxδλ = .5 * F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ) + .5 / halfπ, δxδφ = F * (sinλ * sin_2φ / 4 - E * sinφ * sinλ_2), δyδλ = .125 * F * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ), δyδφ = .5 * F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ) + .5, denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ, φ -= δφ;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return [λ, φ];
    };
    (d3.geoWinkel3 = function() {
      return projection(winkel3);
    }).raw = winkel3;
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var Google = createCommonjsModule(function (module, exports) {
  (function(root, factory) {

  	if (root === null) {
  		throw new Error('Google-maps package can be used only in browser');
  	}

  	{
  		module.exports = factory();
  	}

  })(typeof window !== 'undefined' ? window : null, function() {


  	var googleVersion = '3.31';

  	var script = null;

  	var google = null;

  	var loading = false;

  	var callbacks = [];

  	var onLoadEvents = [];

  	var originalCreateLoaderMethod = null;


  	var GoogleMapsLoader = {};


  	GoogleMapsLoader.URL = 'https://maps.googleapis.com/maps/api/js';

  	GoogleMapsLoader.KEY = null;

  	GoogleMapsLoader.LIBRARIES = [];

  	GoogleMapsLoader.CLIENT = null;

  	GoogleMapsLoader.CHANNEL = null;

  	GoogleMapsLoader.LANGUAGE = null;

  	GoogleMapsLoader.REGION = null;

  	GoogleMapsLoader.VERSION = googleVersion;

  	GoogleMapsLoader.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';


  	GoogleMapsLoader._googleMockApiObject = {};


  	GoogleMapsLoader.load = function(fn) {
  		if (google === null) {
  			if (loading === true) {
  				if (fn) {
  					callbacks.push(fn);
  				}
  			} else {
  				loading = true;

  				window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] = function() {
  					ready(fn);
  				};

  				GoogleMapsLoader.createLoader();
  			}
  		} else if (fn) {
  			fn(google);
  		}
  	};


  	GoogleMapsLoader.createLoader = function() {
  		script = document.createElement('script');
  		script.type = 'text/javascript';
  		script.src = GoogleMapsLoader.createUrl();

  		document.body.appendChild(script);
  	};


  	GoogleMapsLoader.isLoaded = function() {
  		return google !== null;
  	};


  	GoogleMapsLoader.createUrl = function() {
  		var url = GoogleMapsLoader.URL;

  		url += '?callback=' + GoogleMapsLoader.WINDOW_CALLBACK_NAME;

  		if (GoogleMapsLoader.KEY) {
  			url += '&key=' + GoogleMapsLoader.KEY;
  		}

  		if (GoogleMapsLoader.LIBRARIES.length > 0) {
  			url += '&libraries=' + GoogleMapsLoader.LIBRARIES.join(',');
  		}

  		if (GoogleMapsLoader.CLIENT) {
  			url += '&client=' + GoogleMapsLoader.CLIENT;
  		}

  		if (GoogleMapsLoader.CHANNEL) {
  			url += '&channel=' + GoogleMapsLoader.CHANNEL;
  		}

  		if (GoogleMapsLoader.LANGUAGE) {
  			url += '&language=' + GoogleMapsLoader.LANGUAGE;
  		}

  		if (GoogleMapsLoader.REGION) {
  			url += '&region=' + GoogleMapsLoader.REGION;
  		}

  		if (GoogleMapsLoader.VERSION) {
  			url += '&v=' + GoogleMapsLoader.VERSION;
  		}

  		return url;
  	};


  	GoogleMapsLoader.release = function(fn) {
  		var release = function() {
  			GoogleMapsLoader.KEY = null;
  			GoogleMapsLoader.LIBRARIES = [];
  			GoogleMapsLoader.CLIENT = null;
  			GoogleMapsLoader.CHANNEL = null;
  			GoogleMapsLoader.LANGUAGE = null;
  			GoogleMapsLoader.REGION = null;
  			GoogleMapsLoader.VERSION = googleVersion;

  			google = null;
  			loading = false;
  			callbacks = [];
  			onLoadEvents = [];

  			if (typeof window.google !== 'undefined') {
  				delete window.google;
  			}

  			if (typeof window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] !== 'undefined') {
  				delete window[GoogleMapsLoader.WINDOW_CALLBACK_NAME];
  			}

  			if (originalCreateLoaderMethod !== null) {
  				GoogleMapsLoader.createLoader = originalCreateLoaderMethod;
  				originalCreateLoaderMethod = null;
  			}

  			if (script !== null) {
  				script.parentElement.removeChild(script);
  				script = null;
  			}

  			if (fn) {
  				fn();
  			}
  		};

  		if (loading) {
  			GoogleMapsLoader.load(function() {
  				release();
  			});
  		} else {
  			release();
  		}
  	};


  	GoogleMapsLoader.onLoad = function(fn) {
  		onLoadEvents.push(fn);
  	};


  	GoogleMapsLoader.makeMock = function() {
  		originalCreateLoaderMethod = GoogleMapsLoader.createLoader;

  		GoogleMapsLoader.createLoader = function() {
  			window.google = GoogleMapsLoader._googleMockApiObject;
  			window[GoogleMapsLoader.WINDOW_CALLBACK_NAME]();
  		};
  	};


  	var ready = function(fn) {
  		var i;

  		loading = false;

  		if (google === null) {
  			google = window.google;
  		}

  		for (i = 0; i < onLoadEvents.length; i++) {
  			onLoadEvents[i](google);
  		}

  		if (fn) {
  			fn(google);
  		}

  		for (i = 0; i < callbacks.length; i++) {
  			callbacks[i](google);
  		}

  		callbacks = [];
  	};


  	return GoogleMapsLoader;

  });
  });

  var mapboxGl = createCommonjsModule(function (module, exports) {
  /* Mapbox GL JS is Copyright © 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */
  (function (global, factory) {
  module.exports = factory() ;
  })(commonjsGlobal, (function () {
  /* eslint-disable */

  var shared, worker, mapboxgl;
  // define gets called three times: one for each chunk. we rely on the order
  // they're imported to know which is which
  function define(_, chunk) {
  if (!shared) {
      shared = chunk;
  } else if (!worker) {
      worker = chunk;
  } else {
      var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";

      var sharedChunk = {};
      shared(sharedChunk);
      mapboxgl = chunk(sharedChunk);
      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
          mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
      }
  }
  }


  define(["exports"],(function(t){var e="undefined"!=typeof self?self:{},r="2.15.0";let n;const i={API_URL:"https://api.mapbox.com",get API_URL_REGEX(){if(null==n){const t=/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;try{n=null!=process.env.API_URL_REGEX?new RegExp(process.env.API_URL_REGEX):t;}catch(e){n=t;}}return n},get API_TILEJSON_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i},get API_SPRITE_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i},get API_FONTS_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i},get API_STYLE_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i},get API_CDN_URL_REGEX(){return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i},get EVENTS_URL(){if(!i.API_URL)return null;try{const t=new URL(i.API_URL);return "api.mapbox.cn"===t.hostname?"https://events.mapbox.cn/events/v2":"api.mapbox.com"===t.hostname?"https://events.mapbox.com/events/v2":null}catch(t){return null}},SESSION_PATH:"/map-sessions/v1",FEEDBACK_URL:"https://apps.mapbox.com/feedback",TILE_URL_VERSION:"v4",RASTER_URL_PREFIX:"raster/v1",REQUIRE_ACCESS_TOKEN:!0,ACCESS_TOKEN:null,MAX_PARALLEL_IMAGE_REQUESTS:16},s={supported:!1,testSupport:function(t){!l&&o&&(u?c(t):a=t);}};let a,o,l=!1,u=!1;function c(t){const e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);try{if(t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,o),t.isContextLost())return;s.supported=!0;}catch(t){}t.deleteTexture(e),l=!0;}e.document&&(o=e.document.createElement("img"),o.onload=function(){a&&c(a),a=null,u=!0;},o.onerror=function(){l=!0,a=null;},o.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");const h="01";function p(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var d=f;function f(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=e,this.p2x=r,this.p2y=n;}f.prototype={sampleCurveX:function(t){return ((this.ax*t+this.bx)*t+this.cx)*t},sampleCurveY:function(t){return ((this.ay*t+this.by)*t+this.cy)*t},sampleCurveDerivativeX:function(t){return (3*this.ax*t+2*this.bx)*t+this.cx},solveCurveX:function(t,e){if(void 0===e&&(e=1e-6),t<0)return 0;if(t>1)return 1;for(var r=t,n=0;n<8;n++){var i=this.sampleCurveX(r)-t;if(Math.abs(i)<e)return r;var s=this.sampleCurveDerivativeX(r);if(Math.abs(s)<1e-6)break;r-=i/s;}var a=0,o=1;for(r=t,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-t)<e));n++)t>i?a=r:o=r,r=.5*(o-a)+a;return r},solve:function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))}};var y=p(d),m=g;function g(t,e){this.x=t,this.y=e;}g.prototype={clone:function(){return new g(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[2]*this.x+t[3]*this.y;return this.x=t[0]*this.x+t[1]*this.y,this.y=e,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=r*this.x+e*this.y;return this.x=e*this.x-r*this.y,this.y=n,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),i=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=e.x+r*(this.x-e.x)-n*(this.y-e.y),this.y=i,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},g.convert=function(t){return t instanceof g?t:Array.isArray(t)?new g(t[0],t[1]):t};var x=p(m);const v=Math.PI/180,b=180/Math.PI;function w(t){return t*v}function _(t){return t*b}const A=[[0,0],[1,0],[1,1],[0,1]];function S(t){if(t<=0)return 0;if(t>=1)return 1;const e=t*t,r=e*t;return 4*(t<.5?r:3*(t-e)+r-.75)}function k(t,e,r,n){const i=new y(t,e,r,n);return function(t){return i.solve(t)}}const I=k(.25,.1,.25,1);function M(t,e,r){return Math.min(r,Math.max(e,t))}function T(t,e,r){return (r=M((r-t)/(e-t),0,1))*r*(3-2*r)}function z(t,e,r){const n=r-e,i=((t-e)%n+n)%n+e;return i===e?r:i}function B(t,e,r){if(!t.length)return r(null,[]);let n=t.length;const i=new Array(t.length);let s=null;t.forEach(((t,a)=>{e(t,((t,e)=>{t&&(s=t),i[a]=e,0==--n&&r(s,i);}));}));}function E(t){const e=[];for(const r in t)e.push(t[r]);return e}function C(t,...e){for(const r of e)for(const e in r)t[e]=r[e];return t}let P=1;function D(){return P++}function V(){return function t(e){return e?(e^Math.random()*(16>>e/4)).toString(16):([1e7]+-[1e3]+-4e3+-8e3+-1e11).replace(/[018]/g,t)}()}function L(t){return t<=1?1:Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function F(t){return !!t&&/^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)}function R(t,e){t.forEach((t=>{e[t]&&(e[t]=e[t].bind(e));}));}function U(t,e){return -1!==t.indexOf(e,t.length-e.length)}function $(t,e,r){const n={};for(const i in t)n[i]=e.call(r||this,t[i],i,t);return n}function j(t,e,r){const n={};for(const i in t)e.call(r||this,t[i],i,t)&&(n[i]=t[i]);return n}function O(t){return Array.isArray(t)?t.map(O):"object"==typeof t&&t?$(t,O):t}const q={};function N(t){q[t]||("undefined"!=typeof console&&console.warn(t),q[t]=!0);}function G(t,e,r){return (r.y-t.y)*(e.x-t.x)>(e.y-t.y)*(r.x-t.x)}function Z(t){let e=0;for(let r,n,i=0,s=t.length,a=s-1;i<s;a=i++)r=t[i],n=t[a],e+=(n.x-r.x)*(r.y+n.y);return e}function K(){return "undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope}function X(t){const e={};if(t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,((t,r,n,i)=>{const s=n||i;return e[r]=!s||s.toLowerCase(),""})),e["max-age"]){const t=parseInt(e["max-age"],10);isNaN(t)?delete e["max-age"]:e["max-age"]=t;}return e}let J=null;function H(t){if(null==J){const e=t.navigator?t.navigator.userAgent:null;J=!!t.safari||!(!e||!(/\b(iPad|iPhone|iPod)\b/.test(e)||e.match("Safari")&&!e.match("Chrome")));}return J}function Y(t){try{const r=e[t];return r.setItem("_mapbox_test_",1),r.removeItem("_mapbox_test_"),!0}catch(t){return !1}}function W(t,e){return [t[4*e],t[4*e+1],t[4*e+2],t[4*e+3]]}const Q="mapbox-tiles";let tt=500,et=50;let rt,nt;function it(){try{return e.caches}catch(t){}}function st(){it()&&!rt&&(rt=e.caches.open(Q));}function at(t){const e=t.indexOf("?");if(e<0)return t;const r=function(t){const e=t.indexOf("?");return e>0?t.slice(e+1).split("&"):[]}(t),n=r.filter((t=>{const e=t.split("=");return "language"===e[0]||"worldview"===e[0]}));return n.length?`${t.slice(0,e)}?${n.join("&")}`:t.slice(0,e)}let ot=1/0;const lt={Unknown:"Unknown",Style:"Style",Source:"Source",Tile:"Tile",Glyphs:"Glyphs",SpriteImage:"SpriteImage",SpriteJSON:"SpriteJSON",Image:"Image"};"function"==typeof Object.freeze&&Object.freeze(lt);class ut extends Error{constructor(t,e,r){401===e&&bt(r)&&(t+=": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),super(t),this.status=e,this.url=r;}toString(){return `${this.name}: ${this.message} (${this.status}): ${this.url}`}}const ct=K()?()=>self.worker&&self.worker.referrer:()=>("blob:"===e.location.protocol?e.parent:e).location.href;const ht=function(t,r){if(!(/^file:/.test(n=t.url)||/^file:/.test(ct())&&!/^\w+:/.test(n))){if(e.fetch&&e.Request&&e.AbortController&&e.Request.prototype.hasOwnProperty("signal"))return function(t,r){const n=new e.AbortController,i=new e.Request(t.url,{method:t.method||"GET",body:t.body,credentials:t.credentials,headers:t.headers,referrer:ct(),referrerPolicy:t.referrerPolicy,signal:n.signal});let s=!1,a=!1;const o=(l=i.url).indexOf("sku=")>0&&bt(l);var l;"json"===t.type&&i.headers.set("Accept","application/json");const u=(n,s,l)=>{if(a)return;if(n&&"SecurityError"!==n.message&&N(n.toString()),s&&l)return c(s);const u=Date.now();e.fetch(i).then((e=>{if(e.ok){const t=o?e.clone():null;return c(e,t,u)}return r(new ut(e.statusText,e.status,t.url))})).catch((e=>{"AbortError"!==e.name&&r(new Error(`${e.message} ${t.url}`));}));},c=(n,o,l)=>{("arrayBuffer"===t.type?n.arrayBuffer():"json"===t.type?n.json():n.text()).then((t=>{a||(o&&l&&function(t,r,n){if(st(),!rt)return;const i={status:r.status,statusText:r.statusText,headers:new e.Headers};r.headers.forEach(((t,e)=>i.headers.set(e,t)));const s=X(r.headers.get("Cache-Control")||"");if(s["no-store"])return;s["max-age"]&&i.headers.set("Expires",new Date(n+1e3*s["max-age"]).toUTCString());const a=i.headers.get("Expires");a&&(new Date(a).getTime()-n<42e4||function(t,e){if(void 0===nt)try{new Response(new ReadableStream),nt=!0;}catch(t){nt=!1;}nt?e(t.body):t.blob().then(e);}(r,(r=>{const n=new e.Response(r,i);st(),rt&&rt.then((e=>e.put(at(t.url),n))).catch((t=>N(t.message)));})));}(i,o,l),s=!0,r(null,t,n.headers.get("Cache-Control"),n.headers.get("Expires")));})).catch((t=>{a||r(new Error(t.message));}));};return o?function(t,e){if(st(),!rt)return e(null);const r=at(t.url);rt.then((t=>{t.match(r).then((n=>{const i=function(t){if(!t)return !1;const e=new Date(t.headers.get("Expires")||0),r=X(t.headers.get("Cache-Control")||"");return e>Date.now()&&!r["no-cache"]}(n);t.delete(r),i&&t.put(r,n.clone()),e(null,n,i);})).catch(e);})).catch(e);}(i,u):u(null,null),{cancel:()=>{a=!0,s||n.abort();}}}(t,r);if(K()&&self.worker&&self.worker.actor)return self.worker.actor.send("getResource",t,r,void 0,!0)}var n;return function(t,r){const n=new e.XMLHttpRequest;n.open(t.method||"GET",t.url,!0),"arrayBuffer"===t.type&&(n.responseType="arraybuffer");for(const e in t.headers)n.setRequestHeader(e,t.headers[e]);return "json"===t.type&&(n.responseType="text",n.setRequestHeader("Accept","application/json")),n.withCredentials="include"===t.credentials,n.onerror=()=>{r(new Error(n.statusText));},n.onload=()=>{if((n.status>=200&&n.status<300||0===n.status)&&null!==n.response){let e=n.response;if("json"===t.type)try{e=JSON.parse(n.response);}catch(t){return r(t)}r(null,e,n.getResponseHeader("Cache-Control"),n.getResponseHeader("Expires"));}else r(new ut(n.statusText,n.status,t.url));},n.send(t.body),{cancel:()=>n.abort()}}(t,r)},pt=function(t,e){return ht(C(t,{type:"arrayBuffer"}),e)};function dt(t){const r=e.document.createElement("a");return r.href=t,r.protocol===e.document.location.protocol&&r.host===e.document.location.host}const ft="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";let yt,mt;yt=[],mt=0;const gt=function(t,r){if(s.supported&&(t.headers||(t.headers={}),t.headers.accept="image/webp,*/*"),mt>=i.MAX_PARALLEL_IMAGE_REQUESTS){const e={requestParameters:t,callback:r,cancelled:!1,cancel(){this.cancelled=!0;}};return yt.push(e),e}mt++;let n=!1;const a=()=>{if(!n)for(n=!0,mt--;yt.length&&mt<i.MAX_PARALLEL_IMAGE_REQUESTS;){const t=yt.shift(),{requestParameters:e,callback:r,cancelled:n}=t;n||(t.cancel=gt(e,r).cancel);}},o=pt(t,((t,n,i,s)=>{a(),t?r(t):n&&(e.createImageBitmap?function(t,r){const n=new e.Blob([new Uint8Array(t)],{type:"image/png"});e.createImageBitmap(n).then((t=>{r(null,t);})).catch((t=>{r(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));}));}(n,((t,e)=>r(t,e,i,s))):function(t,r){const n=new e.Image,i=e.URL;n.onload=()=>{r(null,n),i.revokeObjectURL(n.src),n.onload=null,e.requestAnimationFrame((()=>{n.src=ft;}));},n.onerror=()=>r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));const s=new e.Blob([new Uint8Array(t)],{type:"image/png"});n.src=t.byteLength?i.createObjectURL(s):ft;}(n,((t,e)=>r(t,e,i,s))));}));return {cancel:()=>{o.cancel(),a();}}},xt="NO_ACCESS_TOKEN";function vt(t){return 0===t.indexOf("mapbox:")}function bt(t){return i.API_URL_REGEX.test(t)}function wt(t){return i.API_CDN_URL_REGEX.test(t)}function _t(t){return i.API_STYLE_REGEX.test(t)&&!At(t)}function At(t){return i.API_SPRITE_REGEX.test(t)}const St=/^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;function kt(t){const e=t.match(St);if(!e)throw new Error("Unable to parse URL object");return {protocol:e[1],authority:e[2],path:e[3]||"/",params:e[4]?e[4].split("&"):[]}}function It(t){const e=t.params.length?`?${t.params.join("&")}`:"";return `${t.protocol}://${t.authority}${t.path}${e}`}const Mt="mapbox.eventData";function Tt(t){if(!t)return null;const r=t.split(".");if(!r||3!==r.length)return null;try{return JSON.parse(decodeURIComponent(e.atob(r[1]).split("").map((t=>"%"+("00"+t.charCodeAt(0).toString(16)).slice(-2))).join("")))}catch(t){return null}}class zt{constructor(t){this.type=t,this.anonId=null,this.eventData={},this.queue=[],this.pendingRequest=null;}getStorageKey(t){const r=Tt(i.ACCESS_TOKEN);let n="";return n=r&&r.u?e.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g,((t,e)=>String.fromCharCode(Number("0x"+e))))):i.ACCESS_TOKEN||"",t?`${Mt}.${t}:${n}`:`${Mt}:${n}`}fetchEventData(){const t=Y("localStorage"),r=this.getStorageKey(),n=this.getStorageKey("uuid");if(t)try{const t=e.localStorage.getItem(r);t&&(this.eventData=JSON.parse(t));const i=e.localStorage.getItem(n);i&&(this.anonId=i);}catch(t){N("Unable to read from LocalStorage");}}saveEventData(){const t=Y("localStorage"),r=this.getStorageKey(),n=this.getStorageKey("uuid");if(t)try{e.localStorage.setItem(n,this.anonId),Object.keys(this.eventData).length>=1&&e.localStorage.setItem(r,JSON.stringify(this.eventData));}catch(t){N("Unable to write to LocalStorage");}}processRequests(t){}postEvent(t,e,r,n){if(!i.EVENTS_URL)return;const s=kt(i.EVENTS_URL);s.params.push(`access_token=${n||i.ACCESS_TOKEN||""}`);const a={event:this.type,created:new Date(t).toISOString()},o=e?C(a,e):a,l={url:It(s),headers:{"Content-Type":"text/plain"},body:JSON.stringify([o])};this.pendingRequest=function(t,e){return ht(C(t,{method:"POST"}),e)}(l,(t=>{this.pendingRequest=null,r(t),this.saveEventData(),this.processRequests(n);}));}queueRequest(t,e){this.queue.push(t),this.processRequests(e);}}const Bt=new class extends zt{constructor(t){super("appUserTurnstile"),this._customAccessToken=t;}postTurnstileEvent(t,e){i.EVENTS_URL&&i.ACCESS_TOKEN&&Array.isArray(t)&&t.some((t=>vt(t)||bt(t)))&&this.queueRequest(Date.now(),e);}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;this.anonId&&this.eventData.lastSuccess&&this.eventData.tokenU||this.fetchEventData();const e=Tt(i.ACCESS_TOKEN),n=e?e.u:i.ACCESS_TOKEN;let s=n!==this.eventData.tokenU;F(this.anonId)||(this.anonId=V(),s=!0);const a=this.queue.shift();if(this.eventData.lastSuccess){const t=new Date(this.eventData.lastSuccess),e=new Date(a),r=(a-this.eventData.lastSuccess)/864e5;s=s||r>=1||r<-1||t.getDate()!==e.getDate();}else s=!0;s?this.postEvent(a,{sdkIdentifier:"mapbox-gl-js",sdkVersion:r,skuId:h,"enabled.telemetry":!1,userId:this.anonId},(t=>{t||(this.eventData.lastSuccess=a,this.eventData.tokenU=n);}),t):this.processRequests();}},Et=Bt.postTurnstileEvent.bind(Bt),Ct=new class extends zt{constructor(){super("map.load"),this.success={},this.skuToken="";}postMapLoadEvent(t,e,r,n){this.skuToken=e,this.errorCb=n,i.EVENTS_URL&&(r||i.ACCESS_TOKEN?this.queueRequest({id:t,timestamp:Date.now()},r):this.errorCb(new Error(xt)));}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;const{id:e,timestamp:n}=this.queue.shift();e&&this.success[e]||(this.anonId||this.fetchEventData(),F(this.anonId)||(this.anonId=V()),this.postEvent(n,{sdkIdentifier:"mapbox-gl-js",sdkVersion:r,skuId:h,skuToken:this.skuToken,userId:this.anonId},(t=>{t?this.errorCb(t):e&&(this.success[e]=!0);}),t));}},Pt=Ct.postMapLoadEvent.bind(Ct),Dt=new class extends zt{constructor(){super("gljs.performance");}postPerformanceEvent(t,e){i.EVENTS_URL&&(t||i.ACCESS_TOKEN)&&this.queueRequest({timestamp:Date.now(),performanceData:e},t);}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;const{timestamp:n,performanceData:i}=this.queue.shift(),s=function(t){const n=e.performance.getEntriesByType("resource"),i=e.performance.getEntriesByType("mark"),s=function(t){const e={};if(t)for(const r in t)if("other"!==r)for(const n of t[r]){const t=`${r}ResolveRangeMin`,i=`${r}ResolveRangeMax`,s=`${r}RequestCount`,a=`${r}RequestCachedCount`;e[t]=Math.min(e[t]||1/0,n.startTime),e[i]=Math.max(e[i]||-1/0,n.responseEnd);const o=t=>{void 0===e[t]&&(e[t]=0),++e[t];};void 0!==n.transferSize&&0===n.transferSize&&o(a),o(s);}return e}(function(t,e){const r={};if(t)for(const n of t){const t=e(n);void 0===r[t]&&(r[t]=[]),r[t].push(n);}return r}(n,jt)),a=e.devicePixelRatio,o=e.navigator.connection||e.navigator.mozConnection||e.navigator.webkitConnection,l={counters:[],metadata:[],attributes:[]},u=(t,e,r)=>{null!=r&&t.push({name:e,value:r.toString()});};for(const t in s)u(l.counters,t,s[t]);if(t.interactionRange[0]!==1/0&&t.interactionRange[1]!==-1/0&&(u(l.counters,"interactionRangeMin",t.interactionRange[0]),u(l.counters,"interactionRangeMax",t.interactionRange[1])),i)for(const t of Object.keys(Ut)){const e=Ut[t],r=i.find((t=>t.name===e));r&&u(l.counters,e,r.startTime);}return u(l.counters,"visibilityHidden",t.visibilityHidden),u(l.attributes,"style",function(t){if(t)for(const e of t){const t=e.name.split("?")[0];if(_t(t)){const e=t.split("/").slice(-2);if(2===e.length)return `mapbox://styles/${e[0]}/${e[1]}`}}}(n)),u(l.attributes,"terrainEnabled",t.terrainEnabled?"true":"false"),u(l.attributes,"fogEnabled",t.fogEnabled?"true":"false"),u(l.attributes,"projection",t.projection),u(l.attributes,"zoom",t.zoom),u(l.metadata,"devicePixelRatio",a),u(l.metadata,"connectionEffectiveType",o?o.effectiveType:void 0),u(l.metadata,"navigatorUserAgent",e.navigator.userAgent),u(l.metadata,"screenWidth",e.screen.width),u(l.metadata,"screenHeight",e.screen.height),u(l.metadata,"windowWidth",e.innerWidth),u(l.metadata,"windowHeight",e.innerHeight),u(l.metadata,"mapWidth",t.width/a),u(l.metadata,"mapHeight",t.height/a),u(l.metadata,"webglRenderer",t.renderer),u(l.metadata,"webglVendor",t.vendor),u(l.metadata,"sdkVersion",r),u(l.metadata,"sdkIdentifier","mapbox-gl-js"),l}(i);for(const t of s.metadata);for(const t of s.counters);for(const t of s.attributes);this.postEvent(n,s,(()=>{}),t);}},Vt=Dt.postPerformanceEvent.bind(Dt),Lt=new class extends zt{constructor(){super("map.auth"),this.success={},this.skuToken="";}getSession(t,e,r,n){if(!i.API_URL||!i.SESSION_PATH)return;const s=kt(i.API_URL+i.SESSION_PATH);s.params.push(`sku=${e||""}`),s.params.push(`access_token=${n||i.ACCESS_TOKEN||""}`);const a={url:It(s),headers:{"Content-Type":"text/plain"}};this.pendingRequest=function(t,e){return ht(C(t,{method:"GET"}),e)}(a,(t=>{this.pendingRequest=null,r(t),this.saveEventData(),this.processRequests(n);}));}getSessionAPI(t,e,r,n){this.skuToken=e,this.errorCb=n,i.SESSION_PATH&&i.API_URL&&(r||i.ACCESS_TOKEN?this.queueRequest({id:t,timestamp:Date.now()},r):this.errorCb(new Error(xt)));}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;const{id:e,timestamp:r}=this.queue.shift();e&&this.success[e]||this.getSession(r,this.skuToken,(t=>{t?this.errorCb(t):e&&(this.success[e]=!0);}),t);}},Ft=Lt.getSessionAPI.bind(Lt),Rt=new Set,Ut={create:"create",load:"load",fullLoad:"fullLoad"},$t={mark(t){e.performance.mark(t);},measure(t,r,n){e.performance.measure(t,r,n);}};function jt(t){const e=t.name.split("?")[0];return wt(e)&&e.includes("mapbox-gl.js")?"javascript":wt(e)&&e.includes("mapbox-gl.css")?"css":function(t){return i.API_FONTS_REGEX.test(t)}(e)?"fontRange":At(e)?"sprite":_t(e)?"style":function(t){return i.API_TILEJSON_REGEX.test(t)}(e)?"tilejson":"other"}const Ot=e.performance;function qt(t){const e=t?t.url.toString():void 0;return Ot.getEntriesByName(e)}let Nt,Gt,Zt,Kt;const Xt={now:()=>void 0!==Zt?Zt:e.performance.now(),setNow(t){Zt=t;},restoreNow(){Zt=void 0;},frame(t){const r=e.requestAnimationFrame(t);return {cancel:()=>e.cancelAnimationFrame(r)}},getImageData(t,r=0){const{width:n,height:i}=t;Kt||(Kt=e.document.createElement("canvas"));const s=Kt.getContext("2d",{willReadFrequently:!0});if(!s)throw new Error("failed to create canvas 2d context");return (n>Kt.width||i>Kt.height)&&(Kt.width=n,Kt.height=i),s.clearRect(-r,-r,n+2*r,i+2*r),s.drawImage(t,0,0,n,i),s.getImageData(-r,-r,n+2*r,i+2*r)},resolveURL:t=>(Nt||(Nt=e.document.createElement("a")),Nt.href=t,Nt.href),get devicePixelRatio(){return e.devicePixelRatio},get prefersReducedMotion(){return !!e.matchMedia&&(null==Gt&&(Gt=e.matchMedia("(prefers-reduced-motion: reduce)")),Gt.matches)}};function Jt(t,e,r){r[t]&&-1!==r[t].indexOf(e)||(r[t]=r[t]||[],r[t].push(e));}function Ht(t,e,r){if(r&&r[t]){const n=r[t].indexOf(e);-1!==n&&r[t].splice(n,1);}}class Yt{constructor(t,e={}){C(this,e),this.type=t;}}class Wt extends Yt{constructor(t,e={}){super("error",C({error:t},e));}}class Qt{on(t,e){return this._listeners=this._listeners||{},Jt(t,e,this._listeners),this}off(t,e){return Ht(t,e,this._listeners),Ht(t,e,this._oneTimeListeners),this}once(t,e){return e?(this._oneTimeListeners=this._oneTimeListeners||{},Jt(t,e,this._oneTimeListeners),this):new Promise((e=>this.once(t,e)))}fire(t,e){"string"==typeof t&&(t=new Yt(t,e||{}));const r=t.type;if(this.listens(r)){t.target=this;const e=this._listeners&&this._listeners[r]?this._listeners[r].slice():[];for(const r of e)r.call(this,t);const n=this._oneTimeListeners&&this._oneTimeListeners[r]?this._oneTimeListeners[r].slice():[];for(const e of n)Ht(r,e,this._oneTimeListeners),e.call(this,t);const i=this._eventedParent;i&&(C(t,"function"==typeof this._eventedParentData?this._eventedParentData():this._eventedParentData),i.fire(t));}else t instanceof Wt&&console.error(t.error);return this}listens(t){return !!(this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t))}setEventedParent(t,e){return this._eventedParent=t,this._eventedParentData=e,this}}var te=JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');function ee(t,...e){for(const r of e)for(const e in r)t[e]=r[e];return t}function re(t){return t instanceof Number||t instanceof String||t instanceof Boolean?t.valueOf():t}function ne(t){if(Array.isArray(t))return t.map(ne);if(t instanceof Object&&!(t instanceof Number||t instanceof String||t instanceof Boolean)){const e={};for(const r in t)e[r]=ne(t[r]);return e}return re(t)}class ie extends Error{constructor(t,e){super(e),this.message=e,this.key=t;}}var se=ie;class ae{constructor(t,e=[]){this.parent=t,this.bindings={};for(const[t,r]of e)this.bindings[t]=r;}concat(t){return new ae(this,t)}get(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error(`${t} not found in scope.`)}has(t){return !!this.bindings[t]||!!this.parent&&this.parent.has(t)}}var oe=ae;const le={kind:"null"},ue={kind:"number"},ce={kind:"string"},he={kind:"boolean"},pe={kind:"color"},de={kind:"object"},fe={kind:"value"},ye={kind:"collator"},me={kind:"formatted"},ge={kind:"resolvedImage"};function xe(t,e){return {kind:"array",itemType:t,N:e}}function ve(t){if("array"===t.kind){const e=ve(t.itemType);return "number"==typeof t.N?`array<${e}, ${t.N}>`:"value"===t.itemType.kind?"array":`array<${e}>`}return t.kind}const be=[le,ue,ce,he,pe,me,de,xe(fe),ge];function we(t,e){if("error"===e.kind)return null;if("array"===t.kind){if("array"===e.kind&&(0===e.N&&"value"===e.itemType.kind||!we(t.itemType,e.itemType))&&("number"!=typeof t.N||t.N===e.N))return null}else {if(t.kind===e.kind)return null;if("value"===t.kind)for(const t of be)if(!we(t,e))return null}return `Expected ${ve(t)} but found ${ve(e)} instead.`}function _e(t,e){return e.some((e=>e.kind===t.kind))}function Ae(t,e){return e.some((e=>"null"===e?null===t:"array"===e?Array.isArray(t):"object"===e?t&&!Array.isArray(t)&&"object"==typeof t:e===typeof t))}var Se,ke={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function Ie(t){return (t=Math.round(t))<0?0:t>255?255:t}function Me(t){return Ie("%"===t[t.length-1]?parseFloat(t)/100*255:parseInt(t))}function Te(t){return (e="%"===t[t.length-1]?parseFloat(t)/100:parseFloat(t))<0?0:e>1?1:e;var e;}function ze(t,e,r){return r<0?r+=1:r>1&&(r-=1),6*r<1?t+(e-t)*r*6:2*r<1?e:3*r<2?t+(e-t)*(2/3-r)*6:t}try{Se={}.parseCSSColor=function(t){var e,r=t.replace(/ /g,"").toLowerCase();if(r in ke)return ke[r].slice();if("#"===r[0])return 4===r.length?(e=parseInt(r.substr(1),16))>=0&&e<=4095?[(3840&e)>>4|(3840&e)>>8,240&e|(240&e)>>4,15&e|(15&e)<<4,1]:null:7===r.length&&(e=parseInt(r.substr(1),16))>=0&&e<=16777215?[(16711680&e)>>16,(65280&e)>>8,255&e,1]:null;var n=r.indexOf("("),i=r.indexOf(")");if(-1!==n&&i+1===r.length){var s=r.substr(0,n),a=r.substr(n+1,i-(n+1)).split(","),o=1;switch(s){case"rgba":if(4!==a.length)return null;o=Te(a.pop());case"rgb":return 3!==a.length?null:[Me(a[0]),Me(a[1]),Me(a[2]),o];case"hsla":if(4!==a.length)return null;o=Te(a.pop());case"hsl":if(3!==a.length)return null;var l=(parseFloat(a[0])%360+360)%360/360,u=Te(a[1]),c=Te(a[2]),h=c<=.5?c*(u+1):c+u-c*u,p=2*c-h;return [Ie(255*ze(p,h,l+1/3)),Ie(255*ze(p,h,l)),Ie(255*ze(p,h,l-1/3)),o];default:return null}}return null};}catch(t){}class Be{constructor(t,e,r,n=1){this.r=t,this.g=e,this.b=r,this.a=n;}static parse(t){if(!t)return;if(t instanceof Be)return t;if("string"!=typeof t)return;const e=Se(t);return e?new Be(e[0]/255*e[3],e[1]/255*e[3],e[2]/255*e[3],e[3]):void 0}toString(){const[t,e,r,n]=this.toArray();return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`}toArray(){const{r:t,g:e,b:r,a:n}=this;return 0===n?[0,0,0,0]:[255*t/n,255*e/n,255*r/n,n]}toArray01(){const{r:t,g:e,b:r,a:n}=this;return 0===n?[0,0,0,0]:[t/n,e/n,r/n,n]}toArray01PremultipliedAlpha(){const{r:t,g:e,b:r,a:n}=this;return [t,e,r,n]}}Be.black=new Be(0,0,0,1),Be.white=new Be(1,1,1,1),Be.transparent=new Be(0,0,0,0),Be.red=new Be(1,0,0,1),Be.blue=new Be(0,0,1,1);var Ee=Be;class Ce{constructor(t,e,r){this.sensitivity=t?e?"variant":"case":e?"accent":"base",this.locale=r,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"});}compare(t,e){return this.collator.compare(t,e)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}}class Pe{constructor(t,e,r,n,i){this.text=t.normalize?t.normalize():t,this.image=e,this.scale=r,this.fontStack=n,this.textColor=i;}}class De{constructor(t){this.sections=t;}static fromString(t){return new De([new Pe(t,null,null,null,null)])}isEmpty(){return 0===this.sections.length||!this.sections.some((t=>0!==t.text.length||t.image&&0!==t.image.name.length))}static factory(t){return t instanceof De?t:De.fromString(t)}toString(){return 0===this.sections.length?"":this.sections.map((t=>t.text)).join("")}serialize(){const t=["format"];for(const e of this.sections){if(e.image){t.push(["image",e.image.name]);continue}t.push(e.text);const r={};e.fontStack&&(r["text-font"]=["literal",e.fontStack.split(",")]),e.scale&&(r["font-scale"]=e.scale),e.textColor&&(r["text-color"]=["rgba"].concat(e.textColor.toArray())),t.push(r);}return t}}class Ve{constructor(t){this.name=t.name,this.available=t.available;}toString(){return this.name}static fromString(t){return t?new Ve({name:t,available:!1}):null}serialize(){return ["image",this.name]}}function Le(t,e,r,n){return "number"==typeof t&&t>=0&&t<=255&&"number"==typeof e&&e>=0&&e<=255&&"number"==typeof r&&r>=0&&r<=255?void 0===n||"number"==typeof n&&n>=0&&n<=1?null:`Invalid rgba value [${[t,e,r,n].join(", ")}]: 'a' must be between 0 and 1.`:`Invalid rgba value [${("number"==typeof n?[t,e,r,n]:[t,e,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`}function Fe(t){if(null===t)return !0;if("string"==typeof t)return !0;if("boolean"==typeof t)return !0;if("number"==typeof t)return !0;if(t instanceof Ee)return !0;if(t instanceof Ce)return !0;if(t instanceof De)return !0;if(t instanceof Ve)return !0;if(Array.isArray(t)){for(const e of t)if(!Fe(e))return !1;return !0}if("object"==typeof t){for(const e in t)if(!Fe(t[e]))return !1;return !0}return !1}function Re(t){if(null===t)return le;if("string"==typeof t)return ce;if("boolean"==typeof t)return he;if("number"==typeof t)return ue;if(t instanceof Ee)return pe;if(t instanceof Ce)return ye;if(t instanceof De)return me;if(t instanceof Ve)return ge;if(Array.isArray(t)){const e=t.length;let r;for(const e of t){const t=Re(e);if(r){if(r===t)continue;r=fe;break}r=t;}return xe(r||fe,e)}return de}function Ue(t){const e=typeof t;return null===t?"":"string"===e||"number"===e||"boolean"===e?String(t):t instanceof Ee||t instanceof De||t instanceof Ve?t.toString():JSON.stringify(t)}class $e{constructor(t,e){this.type=t,this.value=e;}static parse(t,e){if(2!==t.length)return e.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);if(!Fe(t[1]))return e.error("invalid value");const r=t[1];let n=Re(r);const i=e.expectedType;return "array"!==n.kind||0!==n.N||!i||"array"!==i.kind||"number"==typeof i.N&&0!==i.N||(n=i),new $e(n,r)}evaluate(){return this.value}eachChild(){}outputDefined(){return !0}serialize(){return "array"===this.type.kind||"object"===this.type.kind?["literal",this.value]:this.value instanceof Ee?["rgba"].concat(this.value.toArray()):this.value instanceof De?this.value.serialize():this.value}}var je=$e,Oe=class{constructor(t){this.name="ExpressionEvaluationError",this.message=t;}toJSON(){return this.message}};const qe={string:ce,number:ue,boolean:he,object:de};class Ne{constructor(t,e){this.type=t,this.args=e;}static parse(t,e){if(t.length<2)return e.error("Expected at least one argument.");let r,n=1;const i=t[0];if("array"===i){let i,s;if(t.length>2){const r=t[1];if("string"!=typeof r||!(r in qe)||"object"===r)return e.error('The item type argument of "array" must be one of string, number, boolean',1);i=qe[r],n++;}else i=fe;if(t.length>3){if(null!==t[2]&&("number"!=typeof t[2]||t[2]<0||t[2]!==Math.floor(t[2])))return e.error('The length argument to "array" must be a positive integer literal',2);s=t[2],n++;}r=xe(i,s);}else r=qe[i];const s=[];for(;n<t.length;n++){const r=e.parse(t[n],n,fe);if(!r)return null;s.push(r);}return new Ne(r,s)}evaluate(t){for(let e=0;e<this.args.length;e++){const r=this.args[e].evaluate(t);if(!we(this.type,Re(r)))return r;if(e===this.args.length-1)throw new Oe(`Expected value to be of type ${ve(this.type)}, but found ${ve(Re(r))} instead.`)}return null}eachChild(t){this.args.forEach(t);}outputDefined(){return this.args.every((t=>t.outputDefined()))}serialize(){const t=this.type,e=[t.kind];if("array"===t.kind){const r=t.itemType;if("string"===r.kind||"number"===r.kind||"boolean"===r.kind){e.push(r.kind);const n=t.N;("number"==typeof n||this.args.length>1)&&e.push(n);}}return e.concat(this.args.map((t=>t.serialize())))}}var Ge=Ne;class Ze{constructor(t){this.type=me,this.sections=t;}static parse(t,e){if(t.length<2)return e.error("Expected at least one argument.");const r=t[1];if(!Array.isArray(r)&&"object"==typeof r)return e.error("First argument must be an image or text section.");const n=[];let i=!1;for(let r=1;r<=t.length-1;++r){const s=t[r];if(i&&"object"==typeof s&&!Array.isArray(s)){i=!1;let t=null;if(s["font-scale"]&&(t=e.parse(s["font-scale"],1,ue),!t))return null;let r=null;if(s["text-font"]&&(r=e.parse(s["text-font"],1,xe(ce)),!r))return null;let a=null;if(s["text-color"]&&(a=e.parse(s["text-color"],1,pe),!a))return null;const o=n[n.length-1];o.scale=t,o.font=r,o.textColor=a;}else {const s=e.parse(t[r],1,fe);if(!s)return null;const a=s.type.kind;if("string"!==a&&"value"!==a&&"null"!==a&&"resolvedImage"!==a)return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");i=!0,n.push({content:s,scale:null,font:null,textColor:null});}}return new Ze(n)}evaluate(t){return new De(this.sections.map((e=>{const r=e.content.evaluate(t);return Re(r)===ge?new Pe("",r,null,null,null):new Pe(Ue(r),null,e.scale?e.scale.evaluate(t):null,e.font?e.font.evaluate(t).join(","):null,e.textColor?e.textColor.evaluate(t):null)})))}eachChild(t){for(const e of this.sections)t(e.content),e.scale&&t(e.scale),e.font&&t(e.font),e.textColor&&t(e.textColor);}outputDefined(){return !1}serialize(){const t=["format"];for(const e of this.sections){t.push(e.content.serialize());const r={};e.scale&&(r["font-scale"]=e.scale.serialize()),e.font&&(r["text-font"]=e.font.serialize()),e.textColor&&(r["text-color"]=e.textColor.serialize()),t.push(r);}return t}}class Ke{constructor(t){this.type=ge,this.input=t;}static parse(t,e){if(2!==t.length)return e.error("Expected two arguments.");const r=e.parse(t[1],1,ce);return r?new Ke(r):e.error("No image name provided.")}evaluate(t){const e=this.input.evaluate(t),r=Ve.fromString(e);return r&&t.availableImages&&(r.available=t.availableImages.indexOf(e)>-1),r}eachChild(t){t(this.input);}outputDefined(){return !1}serialize(){return ["image",this.input.serialize()]}}const Xe={"to-boolean":he,"to-color":pe,"to-number":ue,"to-string":ce};class Je{constructor(t,e){this.type=t,this.args=e;}static parse(t,e){if(t.length<2)return e.error("Expected at least one argument.");const r=t[0];if(("to-boolean"===r||"to-string"===r)&&2!==t.length)return e.error("Expected one argument.");const n=Xe[r],i=[];for(let r=1;r<t.length;r++){const n=e.parse(t[r],r,fe);if(!n)return null;i.push(n);}return new Je(n,i)}evaluate(t){if("boolean"===this.type.kind)return Boolean(this.args[0].evaluate(t));if("color"===this.type.kind){let e,r;for(const n of this.args){if(e=n.evaluate(t),r=null,e instanceof Ee)return e;if("string"==typeof e){const r=t.parseColor(e);if(r)return r}else if(Array.isArray(e)&&(r=e.length<3||e.length>4?`Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.`:Le(e[0],e[1],e[2],e[3]),!r))return new Ee(e[0]/255,e[1]/255,e[2]/255,e[3])}throw new Oe(r||`Could not parse color from value '${"string"==typeof e?e:String(JSON.stringify(e))}'`)}if("number"===this.type.kind){let e=null;for(const r of this.args){if(e=r.evaluate(t),null===e)return 0;const n=Number(e);if(!isNaN(n))return n}throw new Oe(`Could not convert ${JSON.stringify(e)} to number.`)}return "formatted"===this.type.kind?De.fromString(Ue(this.args[0].evaluate(t))):"resolvedImage"===this.type.kind?Ve.fromString(Ue(this.args[0].evaluate(t))):Ue(this.args[0].evaluate(t))}eachChild(t){this.args.forEach(t);}outputDefined(){return this.args.every((t=>t.outputDefined()))}serialize(){if("formatted"===this.type.kind)return new Ze([{content:this.args[0],scale:null,font:null,textColor:null}]).serialize();if("resolvedImage"===this.type.kind)return new Ke(this.args[0]).serialize();const t=[`to-${this.type.kind}`];return this.eachChild((e=>{t.push(e.serialize());})),t}}var He=Je;const Ye=["Unknown","Point","LineString","Polygon"];var We=class{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null,this.featureTileCoord=null,this.featureDistanceData=null;}id(){return this.feature&&void 0!==this.feature.id?this.feature.id:null}geometryType(){return this.feature?"number"==typeof this.feature.type?Ye[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}distanceFromCenter(){if(this.featureTileCoord&&this.featureDistanceData){const t=this.featureDistanceData.center,e=this.featureDistanceData.scale,{x:r,y:n}=this.featureTileCoord;return this.featureDistanceData.bearing[0]*(r*e-t[0])+this.featureDistanceData.bearing[1]*(n*e-t[1])}return 0}parseColor(t){let e=this._parseColorCache[t];return e||(e=this._parseColorCache[t]=Ee.parse(t)),e}};class Qe{constructor(t,e,r,n){this.name=t,this.type=e,this._evaluate=r,this.args=n;}evaluate(t){return this._evaluate(t,this.args)}eachChild(t){this.args.forEach(t);}outputDefined(){return !1}serialize(){return [this.name].concat(this.args.map((t=>t.serialize())))}static parse(t,e){const r=t[0],n=Qe.definitions[r];if(!n)return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`,0);const i=Array.isArray(n)?n[0]:n.type,s=Array.isArray(n)?[[n[1],n[2]]]:n.overloads,a=s.filter((([e])=>!Array.isArray(e)||e.length===t.length-1));let o=null;for(const[n,s]of a){o=new Ir(e.registry,e.path,null,e.scope);const a=[];let l=!1;for(let e=1;e<t.length;e++){const r=t[e],i=Array.isArray(n)?n[e-1]:n.type,s=o.parse(r,1+a.length,i);if(!s){l=!0;break}a.push(s);}if(!l)if(Array.isArray(n)&&n.length!==a.length)o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {for(let t=0;t<a.length;t++){const e=Array.isArray(n)?n[t]:n.type,r=a[t];o.concat(t+1).checkSubtype(e,r.type);}if(0===o.errors.length)return new Qe(r,i,s,a)}}if(1===a.length)e.errors.push(...o.errors);else {const r=(a.length?a:s).map((([t])=>{return e=t,Array.isArray(e)?`(${e.map(ve).join(", ")})`:`(${ve(e.type)}...)`;var e;})).join(" | "),n=[];for(let r=1;r<t.length;r++){const i=e.parse(t[r],1+n.length);if(!i)return null;n.push(ve(i.type));}e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);}return null}static register(t,e){Qe.definitions=e;for(const r in e)t[r]=Qe;}}var tr=Qe;class er{constructor(t,e,r){this.type=ye,this.locale=r,this.caseSensitive=t,this.diacriticSensitive=e;}static parse(t,e){if(2!==t.length)return e.error("Expected one argument.");const r=t[1];if("object"!=typeof r||Array.isArray(r))return e.error("Collator options argument must be an object.");const n=e.parse(void 0!==r["case-sensitive"]&&r["case-sensitive"],1,he);if(!n)return null;const i=e.parse(void 0!==r["diacritic-sensitive"]&&r["diacritic-sensitive"],1,he);if(!i)return null;let s=null;return r.locale&&(s=e.parse(r.locale,1,ce),!s)?null:new er(n,i,s)}evaluate(t){return new Ce(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)}eachChild(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale);}outputDefined(){return !1}serialize(){const t={};return t["case-sensitive"]=this.caseSensitive.serialize(),t["diacritic-sensitive"]=this.diacriticSensitive.serialize(),this.locale&&(t.locale=this.locale.serialize()),["collator",t]}}const rr=8192;function nr(t,e){t[0]=Math.min(t[0],e[0]),t[1]=Math.min(t[1],e[1]),t[2]=Math.max(t[2],e[0]),t[3]=Math.max(t[3],e[1]);}function ir(t,e){return !(t[0]<=e[0]||t[2]>=e[2]||t[1]<=e[1]||t[3]>=e[3])}function sr(t,e){const r=(180+t[0])/360,n=(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t[1]*Math.PI/360)))/360,i=Math.pow(2,e.z);return [Math.round(r*i*rr),Math.round(n*i*rr)]}function ar(t,e,r){const n=t[0]-e[0],i=t[1]-e[1],s=t[0]-r[0],a=t[1]-r[1];return n*a-s*i==0&&n*s<=0&&i*a<=0}function or(t,e){let r=!1;for(let a=0,o=e.length;a<o;a++){const o=e[a];for(let e=0,a=o.length;e<a-1;e++){if(ar(t,o[e],o[e+1]))return !1;(i=o[e])[1]>(n=t)[1]!=(s=o[e+1])[1]>n[1]&&n[0]<(s[0]-i[0])*(n[1]-i[1])/(s[1]-i[1])+i[0]&&(r=!r);}}var n,i,s;return r}function lr(t,e){for(let r=0;r<e.length;r++)if(or(t,e[r]))return !0;return !1}function ur(t,e,r,n){const i=n[0]-r[0],s=n[1]-r[1],a=(t[0]-r[0])*s-i*(t[1]-r[1]),o=(e[0]-r[0])*s-i*(e[1]-r[1]);return a>0&&o<0||a<0&&o>0}function cr(t,e,r){for(const u of r)for(let r=0;r<u.length-1;++r)if(0!=(o=[(a=u[r+1])[0]-(s=u[r])[0],a[1]-s[1]])[0]*(l=[(i=e)[0]-(n=t)[0],i[1]-n[1]])[1]-o[1]*l[0]&&ur(n,i,s,a)&&ur(s,a,n,i))return !0;var n,i,s,a,o,l;return !1}function hr(t,e){for(let r=0;r<t.length;++r)if(!or(t[r],e))return !1;for(let r=0;r<t.length-1;++r)if(cr(t[r],t[r+1],e))return !1;return !0}function pr(t,e){for(let r=0;r<e.length;r++)if(hr(t,e[r]))return !0;return !1}function dr(t,e,r){const n=[];for(let i=0;i<t.length;i++){const s=[];for(let n=0;n<t[i].length;n++){const a=sr(t[i][n],r);nr(e,a),s.push(a);}n.push(s);}return n}function fr(t,e,r){const n=[];for(let i=0;i<t.length;i++){const s=dr(t[i],e,r);n.push(s);}return n}function yr(t,e,r,n){if(t[0]<r[0]||t[0]>r[2]){const e=.5*n;let i=t[0]-r[0]>e?-n:r[0]-t[0]>e?n:0;0===i&&(i=t[0]-r[2]>e?-n:r[2]-t[0]>e?n:0),t[0]+=i;}nr(e,t);}function mr(t,e,r,n){const i=Math.pow(2,n.z)*rr,s=[n.x*rr,n.y*rr],a=[];if(!t)return a;for(const n of t)for(const t of n){const n=[t.x+s[0],t.y+s[1]];yr(n,e,r,i),a.push(n);}return a}function gr(t,e,r,n){const i=Math.pow(2,n.z)*rr,s=[n.x*rr,n.y*rr],a=[];if(!t)return a;for(const r of t){const t=[];for(const n of r){const r=[n.x+s[0],n.y+s[1]];nr(e,r),t.push(r);}a.push(t);}if(e[2]-e[0]<=i/2){(o=e)[0]=o[1]=1/0,o[2]=o[3]=-1/0;for(const t of a)for(const n of t)yr(n,e,r,i);}var o;return a}class xr{constructor(t,e){this.type=he,this.geojson=t,this.geometries=e;}static parse(t,e){if(2!==t.length)return e.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);if(Fe(t[1])){const e=t[1];if("FeatureCollection"===e.type)for(let t=0;t<e.features.length;++t){const r=e.features[t].geometry.type;if("Polygon"===r||"MultiPolygon"===r)return new xr(e,e.features[t].geometry)}else if("Feature"===e.type){const t=e.geometry.type;if("Polygon"===t||"MultiPolygon"===t)return new xr(e,e.geometry)}else if("Polygon"===e.type||"MultiPolygon"===e.type)return new xr(e,e)}return e.error("'within' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(null!=t.geometry()&&null!=t.canonicalID()){if("Point"===t.geometryType())return function(t,e){const r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(!i)return !1;if("Polygon"===e.type){const s=dr(e.coordinates,n,i),a=mr(t.geometry(),r,n,i);if(!ir(r,n))return !1;for(const t of a)if(!or(t,s))return !1}if("MultiPolygon"===e.type){const s=fr(e.coordinates,n,i),a=mr(t.geometry(),r,n,i);if(!ir(r,n))return !1;for(const t of a)if(!lr(t,s))return !1}return !0}(t,this.geometries);if("LineString"===t.geometryType())return function(t,e){const r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(!i)return !1;if("Polygon"===e.type){const s=dr(e.coordinates,n,i),a=gr(t.geometry(),r,n,i);if(!ir(r,n))return !1;for(const t of a)if(!hr(t,s))return !1}if("MultiPolygon"===e.type){const s=fr(e.coordinates,n,i),a=gr(t.geometry(),r,n,i);if(!ir(r,n))return !1;for(const t of a)if(!pr(t,s))return !1}return !0}(t,this.geometries)}return !1}eachChild(){}outputDefined(){return !0}serialize(){return ["within",this.geojson]}}var vr=xr;function br(t){if(t instanceof tr){if("get"===t.name&&1===t.args.length)return !1;if("feature-state"===t.name)return !1;if("has"===t.name&&1===t.args.length)return !1;if("properties"===t.name||"geometry-type"===t.name||"id"===t.name)return !1;if(/^filter-/.test(t.name))return !1}if(t instanceof vr)return !1;let e=!0;return t.eachChild((t=>{e&&!br(t)&&(e=!1);})),e}function wr(t){if(t instanceof tr&&"feature-state"===t.name)return !1;let e=!0;return t.eachChild((t=>{e&&!wr(t)&&(e=!1);})),e}function _r(t,e){if(t instanceof tr&&e.indexOf(t.name)>=0)return !1;let r=!0;return t.eachChild((t=>{r&&!_r(t,e)&&(r=!1);})),r}class Ar{constructor(t,e){this.type=e.type,this.name=t,this.boundExpression=e;}static parse(t,e){if(2!==t.length||"string"!=typeof t[1])return e.error("'var' expression requires exactly one string literal argument.");const r=t[1];return e.scope.has(r)?new Ar(r,e.scope.get(r)):e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`,1)}evaluate(t){return this.boundExpression.evaluate(t)}eachChild(){}outputDefined(){return !1}serialize(){return ["var",this.name]}}var Sr=Ar;class kr{constructor(t,e=[],r,n=new oe,i=[]){this.registry=t,this.path=e,this.key=e.map((t=>`[${t}]`)).join(""),this.scope=n,this.errors=i,this.expectedType=r;}parse(t,e,r,n,i={}){return e?this.concat(e,r,n)._parse(t,i):this._parse(t,i)}_parse(t,e){function r(t,e,r){return "assert"===r?new Ge(e,[t]):"coerce"===r?new He(e,[t]):t}if(null!==t&&"string"!=typeof t&&"boolean"!=typeof t&&"number"!=typeof t||(t=["literal",t]),Array.isArray(t)){if(0===t.length)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');const n=t[0];if("string"!=typeof n)return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`,0),null;const i=this.registry[n];if(i){let n=i.parse(t,this);if(!n)return null;if(this.expectedType){const t=this.expectedType,i=n.type;if("string"!==t.kind&&"number"!==t.kind&&"boolean"!==t.kind&&"object"!==t.kind&&"array"!==t.kind||"value"!==i.kind)if("color"!==t.kind&&"formatted"!==t.kind&&"resolvedImage"!==t.kind||"value"!==i.kind&&"string"!==i.kind){if(this.checkSubtype(t,i))return null}else n=r(n,t,e.typeAnnotation||"coerce");else n=r(n,t,e.typeAnnotation||"assert");}if(!(n instanceof je)&&"resolvedImage"!==n.type.kind&&Mr(n)){const t=new We;try{n=new je(n.type,n.evaluate(t));}catch(t){return this.error(t.message),null}}return n}return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`,0)}return this.error(void 0===t?"'undefined' value invalid. Use null instead.":"object"==typeof t?'Bare objects invalid. Use ["literal", {...}] instead.':`Expected an array, but found ${typeof t} instead.`)}concat(t,e,r){const n="number"==typeof t?this.path.concat(t):this.path,i=r?this.scope.concat(r):this.scope;return new kr(this.registry,n,e||null,i,this.errors)}error(t,...e){const r=`${this.key}${e.map((t=>`[${t}]`)).join("")}`;this.errors.push(new se(r,t));}checkSubtype(t,e){const r=we(t,e);return r&&this.error(r),r}}var Ir=kr;function Mr(t){if(t instanceof Sr)return Mr(t.boundExpression);if(t instanceof tr&&"error"===t.name)return !1;if(t instanceof er)return !1;if(t instanceof vr)return !1;const e=t instanceof He||t instanceof Ge;let r=!0;return t.eachChild((t=>{r=e?r&&Mr(t):r&&t instanceof je;})),!!r&&br(t)&&_r(t,["zoom","heatmap-density","line-progress","sky-radial-progress","accumulated","is-supported-script","pitch","distance-from-center"])}function Tr(t,e){const r=t.length-1;let n,i,s=0,a=r,o=0;for(;s<=a;)if(o=Math.floor((s+a)/2),n=t[o],i=t[o+1],n<=e){if(o===r||e<i)return o;s=o+1;}else {if(!(n>e))throw new Oe("Input is not a number.");a=o-1;}return 0}class zr{constructor(t,e,r){this.type=t,this.input=e,this.labels=[],this.outputs=[];for(const[t,e]of r)this.labels.push(t),this.outputs.push(e);}static parse(t,e){if(t.length-1<4)return e.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");const r=e.parse(t[1],1,ue);if(!r)return null;const n=[];let i=null;e.expectedType&&"value"!==e.expectedType.kind&&(i=e.expectedType);for(let r=1;r<t.length;r+=2){const s=1===r?-1/0:t[r],a=t[r+1],o=r,l=r+1;if("number"!=typeof s)return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',o);if(n.length&&n[n.length-1][0]>=s)return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',o);const u=e.parse(a,l,i);if(!u)return null;i=i||u.type,n.push([s,u]);}return new zr(i,r,n)}evaluate(t){const e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);const n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);const i=e.length;return n>=e[i-1]?r[i-1].evaluate(t):r[Tr(e,n)].evaluate(t)}eachChild(t){t(this.input);for(const e of this.outputs)t(e);}outputDefined(){return this.outputs.every((t=>t.outputDefined()))}serialize(){const t=["step",this.input.serialize()];for(let e=0;e<this.labels.length;e++)e>0&&t.push(this.labels[e]),t.push(this.outputs[e].serialize());return t}}var Br=zr;function Er(t,e,r){return t*(1-r)+e*r}var Cr=Object.freeze({__proto__:null,array:function(t,e,r){return t.map(((t,n)=>Er(t,e[n],r)))},color:function(t,e,r){return new Ee(Er(t.r,e.r,r),Er(t.g,e.g,r),Er(t.b,e.b,r),Er(t.a,e.a,r))},number:Er});const Pr=.95047,Dr=1.08883,Vr=4/29,Lr=6/29,Fr=3*Lr*Lr,Rr=Lr*Lr*Lr,Ur=Math.PI/180,$r=180/Math.PI;function jr(t){return t>Rr?Math.pow(t,1/3):t/Fr+Vr}function Or(t){return t>Lr?t*t*t:Fr*(t-Vr)}function qr(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function Nr(t){return (t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function Gr(t){const e=Nr(t.r),r=Nr(t.g),n=Nr(t.b),i=jr((.4124564*e+.3575761*r+.1804375*n)/Pr),s=jr((.2126729*e+.7151522*r+.072175*n)/1);return {l:116*s-16,a:500*(i-s),b:200*(s-jr((.0193339*e+.119192*r+.9503041*n)/Dr)),alpha:t.a}}function Zr(t){let e=(t.l+16)/116,r=isNaN(t.a)?e:e+t.a/500,n=isNaN(t.b)?e:e-t.b/200;return e=1*Or(e),r=Pr*Or(r),n=Dr*Or(n),new Ee(qr(3.2404542*r-1.5371385*e-.4985314*n),qr(-.969266*r+1.8760108*e+.041556*n),qr(.0556434*r-.2040259*e+1.0572252*n),t.alpha)}function Kr(t,e,r){const n=e-t;return t+r*(n>180||n<-180?n-360*Math.round(n/360):n)}const Xr={forward:Gr,reverse:Zr,interpolate:function(t,e,r){return {l:Er(t.l,e.l,r),a:Er(t.a,e.a,r),b:Er(t.b,e.b,r),alpha:Er(t.alpha,e.alpha,r)}}},Jr={forward:function(t){const{l:e,a:r,b:n}=Gr(t),i=Math.atan2(n,r)*$r;return {h:i<0?i+360:i,c:Math.sqrt(r*r+n*n),l:e,alpha:t.a}},reverse:function(t){const e=t.h*Ur,r=t.c;return Zr({l:t.l,a:Math.cos(e)*r,b:Math.sin(e)*r,alpha:t.alpha})},interpolate:function(t,e,r){return {h:Kr(t.h,e.h,r),c:Er(t.c,e.c,r),l:Er(t.l,e.l,r),alpha:Er(t.alpha,e.alpha,r)}}};var Hr=Object.freeze({__proto__:null,hcl:Jr,lab:Xr});class Yr{constructor(t,e,r,n,i){this.type=t,this.operator=e,this.interpolation=r,this.input=n,this.labels=[],this.outputs=[];for(const[t,e]of i)this.labels.push(t),this.outputs.push(e);}static interpolationFactor(t,e,r,n){let i=0;if("exponential"===t.name)i=Wr(e,t.base,r,n);else if("linear"===t.name)i=Wr(e,1,r,n);else if("cubic-bezier"===t.name){const s=t.controlPoints;i=new y(s[0],s[1],s[2],s[3]).solve(Wr(e,1,r,n));}return i}static parse(t,e){let[r,n,i,...s]=t;if(!Array.isArray(n)||0===n.length)return e.error("Expected an interpolation type expression.",1);if("linear"===n[0])n={name:"linear"};else if("exponential"===n[0]){const t=n[1];if("number"!=typeof t)return e.error("Exponential interpolation requires a numeric base.",1,1);n={name:"exponential",base:t};}else {if("cubic-bezier"!==n[0])return e.error(`Unknown interpolation type ${String(n[0])}`,1,0);{const t=n.slice(1);if(4!==t.length||t.some((t=>"number"!=typeof t||t<0||t>1)))return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);n={name:"cubic-bezier",controlPoints:t};}}if(t.length-1<4)return e.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");if(i=e.parse(i,2,ue),!i)return null;const a=[];let o=null;"interpolate-hcl"===r||"interpolate-lab"===r?o=pe:e.expectedType&&"value"!==e.expectedType.kind&&(o=e.expectedType);for(let t=0;t<s.length;t+=2){const r=s[t],n=s[t+1],i=t+3,l=t+4;if("number"!=typeof r)return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',i);if(a.length&&a[a.length-1][0]>=r)return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',i);const u=e.parse(n,l,o);if(!u)return null;o=o||u.type,a.push([r,u]);}return "number"===o.kind||"color"===o.kind||"array"===o.kind&&"number"===o.itemType.kind&&"number"==typeof o.N?new Yr(o,r,n,i,a):e.error(`Type ${ve(o)} is not interpolatable.`)}evaluate(t){const e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);const n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);const i=e.length;if(n>=e[i-1])return r[i-1].evaluate(t);const s=Tr(e,n),a=Yr.interpolationFactor(this.interpolation,n,e[s],e[s+1]),o=r[s].evaluate(t),l=r[s+1].evaluate(t);return "interpolate"===this.operator?Cr[this.type.kind.toLowerCase()](o,l,a):"interpolate-hcl"===this.operator?Jr.reverse(Jr.interpolate(Jr.forward(o),Jr.forward(l),a)):Xr.reverse(Xr.interpolate(Xr.forward(o),Xr.forward(l),a))}eachChild(t){t(this.input);for(const e of this.outputs)t(e);}outputDefined(){return this.outputs.every((t=>t.outputDefined()))}serialize(){let t;t="linear"===this.interpolation.name?["linear"]:"exponential"===this.interpolation.name?1===this.interpolation.base?["linear"]:["exponential",this.interpolation.base]:["cubic-bezier"].concat(this.interpolation.controlPoints);const e=[this.operator,t,this.input.serialize()];for(let t=0;t<this.labels.length;t++)e.push(this.labels[t],this.outputs[t].serialize());return e}}function Wr(t,e,r,n){const i=n-r,s=t-r;return 0===i?0:1===e?s/i:(Math.pow(e,s)-1)/(Math.pow(e,i)-1)}var Qr=Yr;class tn{constructor(t,e){this.type=t,this.args=e;}static parse(t,e){if(t.length<2)return e.error("Expectected at least one argument.");let r=null;const n=e.expectedType;n&&"value"!==n.kind&&(r=n);const i=[];for(const n of t.slice(1)){const t=e.parse(n,1+i.length,r,void 0,{typeAnnotation:"omit"});if(!t)return null;r=r||t.type,i.push(t);}const s=n&&i.some((t=>we(n,t.type)));return new tn(s?fe:r,i)}evaluate(t){let e,r=null,n=0;for(const i of this.args){if(n++,r=i.evaluate(t),r&&r instanceof Ve&&!r.available&&(e||(e=r),r=null,n===this.args.length))return e;if(null!==r)break}return r}eachChild(t){this.args.forEach(t);}outputDefined(){return this.args.every((t=>t.outputDefined()))}serialize(){const t=["coalesce"];return this.eachChild((e=>{t.push(e.serialize());})),t}}var en=tn;class rn{constructor(t,e){this.type=e.type,this.bindings=[].concat(t),this.result=e;}evaluate(t){return this.result.evaluate(t)}eachChild(t){for(const e of this.bindings)t(e[1]);t(this.result);}static parse(t,e){if(t.length<4)return e.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);const r=[];for(let n=1;n<t.length-1;n+=2){const i=t[n];if("string"!=typeof i)return e.error(`Expected string, but found ${typeof i} instead.`,n);if(/[^a-zA-Z0-9_]/.test(i))return e.error("Variable names must contain only alphanumeric characters or '_'.",n);const s=e.parse(t[n+1],n+1);if(!s)return null;r.push([i,s]);}const n=e.parse(t[t.length-1],t.length-1,e.expectedType,r);return n?new rn(r,n):null}outputDefined(){return this.result.outputDefined()}serialize(){const t=["let"];for(const[e,r]of this.bindings)t.push(e,r.serialize());return t.push(this.result.serialize()),t}}var nn=rn;class sn{constructor(t,e,r){this.type=t,this.index=e,this.input=r;}static parse(t,e){if(3!==t.length)return e.error(`Expected 2 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,ue),n=e.parse(t[2],2,xe(e.expectedType||fe));return r&&n?new sn(n.type.itemType,r,n):null}evaluate(t){const e=this.index.evaluate(t),r=this.input.evaluate(t);if(e<0)throw new Oe(`Array index out of bounds: ${e} < 0.`);if(e>=r.length)throw new Oe(`Array index out of bounds: ${e} > ${r.length-1}.`);if(e!==Math.floor(e))throw new Oe(`Array index must be an integer, but found ${e} instead.`);return r[e]}eachChild(t){t(this.index),t(this.input);}outputDefined(){return !1}serialize(){return ["at",this.index.serialize(),this.input.serialize()]}}var an=sn;class on{constructor(t,e){this.type=he,this.needle=t,this.haystack=e;}static parse(t,e){if(3!==t.length)return e.error(`Expected 2 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,fe),n=e.parse(t[2],2,fe);return r&&n?_e(r.type,[he,ce,ue,le,fe])?new on(r,n):e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r.type)} instead`):null}evaluate(t){const e=this.needle.evaluate(t),r=this.haystack.evaluate(t);if(null==r)return !1;if(!Ae(e,["boolean","string","number","null"]))throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e))} instead.`);if(!Ae(r,["string","array"]))throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r))} instead.`);return r.indexOf(e)>=0}eachChild(t){t(this.needle),t(this.haystack);}outputDefined(){return !0}serialize(){return ["in",this.needle.serialize(),this.haystack.serialize()]}}var ln=on;class un{constructor(t,e,r){this.type=ue,this.needle=t,this.haystack=e,this.fromIndex=r;}static parse(t,e){if(t.length<=2||t.length>=5)return e.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,fe),n=e.parse(t[2],2,fe);if(!r||!n)return null;if(!_e(r.type,[he,ce,ue,le,fe]))return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r.type)} instead`);if(4===t.length){const i=e.parse(t[3],3,ue);return i?new un(r,n,i):null}return new un(r,n)}evaluate(t){const e=this.needle.evaluate(t),r=this.haystack.evaluate(t);if(!Ae(e,["boolean","string","number","null"]))throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e))} instead.`);if(!Ae(r,["string","array"]))throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r))} instead.`);if(this.fromIndex){const n=this.fromIndex.evaluate(t);return r.indexOf(e,n)}return r.indexOf(e)}eachChild(t){t(this.needle),t(this.haystack),this.fromIndex&&t(this.fromIndex);}outputDefined(){return !1}serialize(){if(null!=this.fromIndex&&void 0!==this.fromIndex){const t=this.fromIndex.serialize();return ["index-of",this.needle.serialize(),this.haystack.serialize(),t]}return ["index-of",this.needle.serialize(),this.haystack.serialize()]}}var cn=un;class hn{constructor(t,e,r,n,i,s){this.inputType=t,this.type=e,this.input=r,this.cases=n,this.outputs=i,this.otherwise=s;}static parse(t,e){if(t.length<5)return e.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if(t.length%2!=1)return e.error("Expected an even number of arguments.");let r,n;e.expectedType&&"value"!==e.expectedType.kind&&(n=e.expectedType);const i={},s=[];for(let a=2;a<t.length-1;a+=2){let o=t[a];const l=t[a+1];Array.isArray(o)||(o=[o]);const u=e.concat(a);if(0===o.length)return u.error("Expected at least one branch label.");for(const t of o){if("number"!=typeof t&&"string"!=typeof t)return u.error("Branch labels must be numbers or strings.");if("number"==typeof t&&Math.abs(t)>Number.MAX_SAFE_INTEGER)return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if("number"==typeof t&&Math.floor(t)!==t)return u.error("Numeric branch labels must be integer values.");if(r){if(u.checkSubtype(r,Re(t)))return null}else r=Re(t);if(void 0!==i[String(t)])return u.error("Branch labels must be unique.");i[String(t)]=s.length;}const c=e.parse(l,a,n);if(!c)return null;n=n||c.type,s.push(c);}const a=e.parse(t[1],1,fe);if(!a)return null;const o=e.parse(t[t.length-1],t.length-1,n);return o?"value"!==a.type.kind&&e.concat(1).checkSubtype(r,a.type)?null:new hn(r,n,a,i,s,o):null}evaluate(t){const e=this.input.evaluate(t);return (Re(e)===this.inputType&&this.outputs[this.cases[e]]||this.otherwise).evaluate(t)}eachChild(t){t(this.input),this.outputs.forEach(t),t(this.otherwise);}outputDefined(){return this.outputs.every((t=>t.outputDefined()))&&this.otherwise.outputDefined()}serialize(){const t=["match",this.input.serialize()],e=Object.keys(this.cases).sort(),r=[],n={};for(const t of e){const e=n[this.cases[t]];void 0===e?(n[this.cases[t]]=r.length,r.push([this.cases[t],[t]])):r[e][1].push(t);}const i=t=>"number"===this.inputType.kind?Number(t):t;for(const[e,n]of r)t.push(1===n.length?i(n[0]):n.map(i)),t.push(this.outputs[e].serialize());return t.push(this.otherwise.serialize()),t}}var pn=hn;class dn{constructor(t,e,r){this.type=t,this.branches=e,this.otherwise=r;}static parse(t,e){if(t.length<4)return e.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);if(t.length%2!=0)return e.error("Expected an odd number of arguments.");let r;e.expectedType&&"value"!==e.expectedType.kind&&(r=e.expectedType);const n=[];for(let i=1;i<t.length-1;i+=2){const s=e.parse(t[i],i,he);if(!s)return null;const a=e.parse(t[i+1],i+1,r);if(!a)return null;n.push([s,a]),r=r||a.type;}const i=e.parse(t[t.length-1],t.length-1,r);return i?new dn(r,n,i):null}evaluate(t){for(const[e,r]of this.branches)if(e.evaluate(t))return r.evaluate(t);return this.otherwise.evaluate(t)}eachChild(t){for(const[e,r]of this.branches)t(e),t(r);t(this.otherwise);}outputDefined(){return this.branches.every((([t,e])=>e.outputDefined()))&&this.otherwise.outputDefined()}serialize(){const t=["case"];return this.eachChild((e=>{t.push(e.serialize());})),t}}var fn=dn;class yn{constructor(t,e,r,n){this.type=t,this.input=e,this.beginIndex=r,this.endIndex=n;}static parse(t,e){if(t.length<=2||t.length>=5)return e.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,fe),n=e.parse(t[2],2,ue);if(!r||!n)return null;if(!_e(r.type,[xe(fe),ce,fe]))return e.error(`Expected first argument to be of type array or string, but found ${ve(r.type)} instead`);if(4===t.length){const i=e.parse(t[3],3,ue);return i?new yn(r.type,r,n,i):null}return new yn(r.type,r,n)}evaluate(t){const e=this.input.evaluate(t),r=this.beginIndex.evaluate(t);if(!Ae(e,["string","array"]))throw new Oe(`Expected first argument to be of type array or string, but found ${ve(Re(e))} instead.`);if(this.endIndex){const n=this.endIndex.evaluate(t);return e.slice(r,n)}return e.slice(r)}eachChild(t){t(this.input),t(this.beginIndex),this.endIndex&&t(this.endIndex);}outputDefined(){return !1}serialize(){if(null!=this.endIndex&&void 0!==this.endIndex){const t=this.endIndex.serialize();return ["slice",this.input.serialize(),this.beginIndex.serialize(),t]}return ["slice",this.input.serialize(),this.beginIndex.serialize()]}}var mn=yn;function gn(t,e){return "=="===t||"!="===t?"boolean"===e.kind||"string"===e.kind||"number"===e.kind||"null"===e.kind||"value"===e.kind:"string"===e.kind||"number"===e.kind||"value"===e.kind}function xn(t,e,r,n){return 0===n.compare(e,r)}function vn(t,e,r){const n="=="!==t&&"!="!==t;return class i{constructor(t,e,r){this.type=he,this.lhs=t,this.rhs=e,this.collator=r,this.hasUntypedArgument="value"===t.type.kind||"value"===e.type.kind;}static parse(t,e){if(3!==t.length&&4!==t.length)return e.error("Expected two or three arguments.");const r=t[0];let s=e.parse(t[1],1,fe);if(!s)return null;if(!gn(r,s.type))return e.concat(1).error(`"${r}" comparisons are not supported for type '${ve(s.type)}'.`);let a=e.parse(t[2],2,fe);if(!a)return null;if(!gn(r,a.type))return e.concat(2).error(`"${r}" comparisons are not supported for type '${ve(a.type)}'.`);if(s.type.kind!==a.type.kind&&"value"!==s.type.kind&&"value"!==a.type.kind)return e.error(`Cannot compare types '${ve(s.type)}' and '${ve(a.type)}'.`);n&&("value"===s.type.kind&&"value"!==a.type.kind?s=new Ge(a.type,[s]):"value"!==s.type.kind&&"value"===a.type.kind&&(a=new Ge(s.type,[a])));let o=null;if(4===t.length){if("string"!==s.type.kind&&"string"!==a.type.kind&&"value"!==s.type.kind&&"value"!==a.type.kind)return e.error("Cannot use collator to compare non-string types.");if(o=e.parse(t[3],3,ye),!o)return null}return new i(s,a,o)}evaluate(i){const s=this.lhs.evaluate(i),a=this.rhs.evaluate(i);if(n&&this.hasUntypedArgument){const e=Re(s),r=Re(a);if(e.kind!==r.kind||"string"!==e.kind&&"number"!==e.kind)throw new Oe(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`)}if(this.collator&&!n&&this.hasUntypedArgument){const t=Re(s),r=Re(a);if("string"!==t.kind||"string"!==r.kind)return e(i,s,a)}return this.collator?r(i,s,a,this.collator.evaluate(i)):e(i,s,a)}eachChild(t){t(this.lhs),t(this.rhs),this.collator&&t(this.collator);}outputDefined(){return !0}serialize(){const e=[t];return this.eachChild((t=>{e.push(t.serialize());})),e}}}const bn=vn("==",(function(t,e,r){return e===r}),xn),wn=vn("!=",(function(t,e,r){return e!==r}),(function(t,e,r,n){return !xn(0,e,r,n)})),_n=vn("<",(function(t,e,r){return e<r}),(function(t,e,r,n){return n.compare(e,r)<0})),An=vn(">",(function(t,e,r){return e>r}),(function(t,e,r,n){return n.compare(e,r)>0})),Sn=vn("<=",(function(t,e,r){return e<=r}),(function(t,e,r,n){return n.compare(e,r)<=0})),kn=vn(">=",(function(t,e,r){return e>=r}),(function(t,e,r,n){return n.compare(e,r)>=0}));class In{constructor(t,e,r,n,i,s){this.type=ce,this.number=t,this.locale=e,this.currency=r,this.unit=n,this.minFractionDigits=i,this.maxFractionDigits=s;}static parse(t,e){if(3!==t.length)return e.error("Expected two arguments.");const r=e.parse(t[1],1,ue);if(!r)return null;const n=t[2];if("object"!=typeof n||Array.isArray(n))return e.error("NumberFormat options argument must be an object.");let i=null;if(n.locale&&(i=e.parse(n.locale,1,ce),!i))return null;let s=null;if(n.currency&&(s=e.parse(n.currency,1,ce),!s))return null;let a=null;if(n.unit&&(a=e.parse(n.unit,1,ce),!a))return null;let o=null;if(n["min-fraction-digits"]&&(o=e.parse(n["min-fraction-digits"],1,ue),!o))return null;let l=null;return n["max-fraction-digits"]&&(l=e.parse(n["max-fraction-digits"],1,ue),!l)?null:new In(r,i,s,a,o,l)}evaluate(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:(this.currency?"currency":this.unit&&"unit")||"decimal",currency:this.currency?this.currency.evaluate(t):void 0,unit:this.unit?this.unit.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))}eachChild(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.unit&&t(this.unit),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits);}outputDefined(){return !1}serialize(){const t={};return this.locale&&(t.locale=this.locale.serialize()),this.currency&&(t.currency=this.currency.serialize()),this.unit&&(t.unit=this.unit.serialize()),this.minFractionDigits&&(t["min-fraction-digits"]=this.minFractionDigits.serialize()),this.maxFractionDigits&&(t["max-fraction-digits"]=this.maxFractionDigits.serialize()),["number-format",this.number.serialize(),t]}}class Mn{constructor(t){this.type=ue,this.input=t;}static parse(t,e){if(2!==t.length)return e.error(`Expected 1 argument, but found ${t.length-1} instead.`);const r=e.parse(t[1],1);return r?"array"!==r.type.kind&&"string"!==r.type.kind&&"value"!==r.type.kind?e.error(`Expected argument of type string or array, but found ${ve(r.type)} instead.`):new Mn(r):null}evaluate(t){const e=this.input.evaluate(t);if("string"==typeof e)return e.length;if(Array.isArray(e))return e.length;throw new Oe(`Expected value to be of type string or array, but found ${ve(Re(e))} instead.`)}eachChild(t){t(this.input);}outputDefined(){return !1}serialize(){const t=["length"];return this.eachChild((e=>{t.push(e.serialize());})),t}}const Tn={"==":bn,"!=":wn,">":An,"<":_n,">=":kn,"<=":Sn,array:Ge,at:an,boolean:Ge,case:fn,coalesce:en,collator:er,format:Ze,image:Ke,in:ln,"index-of":cn,interpolate:Qr,"interpolate-hcl":Qr,"interpolate-lab":Qr,length:Mn,let:nn,literal:je,match:pn,number:Ge,"number-format":In,object:Ge,slice:mn,step:Br,string:Ge,"to-boolean":He,"to-color":He,"to-number":He,"to-string":He,var:Sr,within:vr};function zn(t,[e,r,n,i]){e=e.evaluate(t),r=r.evaluate(t),n=n.evaluate(t);const s=i?i.evaluate(t):1,a=Le(e,r,n,s);if(a)throw new Oe(a);return new Ee(e/255*s,r/255*s,n/255*s,s)}function Bn(t,e){return t in e}function En(t,e){const r=e[t];return void 0===r?null:r}function Cn(t){return {type:t}}tr.register(Tn,{error:[{kind:"error"},[ce],(t,[e])=>{throw new Oe(e.evaluate(t))}],typeof:[ce,[fe],(t,[e])=>ve(Re(e.evaluate(t)))],"to-rgba":[xe(ue,4),[pe],(t,[e])=>e.evaluate(t).toArray()],rgb:[pe,[ue,ue,ue],zn],rgba:[pe,[ue,ue,ue,ue],zn],has:{type:he,overloads:[[[ce],(t,[e])=>Bn(e.evaluate(t),t.properties())],[[ce,de],(t,[e,r])=>Bn(e.evaluate(t),r.evaluate(t))]]},get:{type:fe,overloads:[[[ce],(t,[e])=>En(e.evaluate(t),t.properties())],[[ce,de],(t,[e,r])=>En(e.evaluate(t),r.evaluate(t))]]},"feature-state":[fe,[ce],(t,[e])=>En(e.evaluate(t),t.featureState||{})],properties:[de,[],t=>t.properties()],"geometry-type":[ce,[],t=>t.geometryType()],id:[fe,[],t=>t.id()],zoom:[ue,[],t=>t.globals.zoom],pitch:[ue,[],t=>t.globals.pitch||0],"distance-from-center":[ue,[],t=>t.distanceFromCenter()],"heatmap-density":[ue,[],t=>t.globals.heatmapDensity||0],"line-progress":[ue,[],t=>t.globals.lineProgress||0],"sky-radial-progress":[ue,[],t=>t.globals.skyRadialProgress||0],accumulated:[fe,[],t=>void 0===t.globals.accumulated?null:t.globals.accumulated],"+":[ue,Cn(ue),(t,e)=>{let r=0;for(const n of e)r+=n.evaluate(t);return r}],"*":[ue,Cn(ue),(t,e)=>{let r=1;for(const n of e)r*=n.evaluate(t);return r}],"-":{type:ue,overloads:[[[ue,ue],(t,[e,r])=>e.evaluate(t)-r.evaluate(t)],[[ue],(t,[e])=>-e.evaluate(t)]]},"/":[ue,[ue,ue],(t,[e,r])=>e.evaluate(t)/r.evaluate(t)],"%":[ue,[ue,ue],(t,[e,r])=>e.evaluate(t)%r.evaluate(t)],ln2:[ue,[],()=>Math.LN2],pi:[ue,[],()=>Math.PI],e:[ue,[],()=>Math.E],"^":[ue,[ue,ue],(t,[e,r])=>Math.pow(e.evaluate(t),r.evaluate(t))],sqrt:[ue,[ue],(t,[e])=>Math.sqrt(e.evaluate(t))],log10:[ue,[ue],(t,[e])=>Math.log(e.evaluate(t))/Math.LN10],ln:[ue,[ue],(t,[e])=>Math.log(e.evaluate(t))],log2:[ue,[ue],(t,[e])=>Math.log(e.evaluate(t))/Math.LN2],sin:[ue,[ue],(t,[e])=>Math.sin(e.evaluate(t))],cos:[ue,[ue],(t,[e])=>Math.cos(e.evaluate(t))],tan:[ue,[ue],(t,[e])=>Math.tan(e.evaluate(t))],asin:[ue,[ue],(t,[e])=>Math.asin(e.evaluate(t))],acos:[ue,[ue],(t,[e])=>Math.acos(e.evaluate(t))],atan:[ue,[ue],(t,[e])=>Math.atan(e.evaluate(t))],min:[ue,Cn(ue),(t,e)=>Math.min(...e.map((e=>e.evaluate(t))))],max:[ue,Cn(ue),(t,e)=>Math.max(...e.map((e=>e.evaluate(t))))],abs:[ue,[ue],(t,[e])=>Math.abs(e.evaluate(t))],round:[ue,[ue],(t,[e])=>{const r=e.evaluate(t);return r<0?-Math.round(-r):Math.round(r)}],floor:[ue,[ue],(t,[e])=>Math.floor(e.evaluate(t))],ceil:[ue,[ue],(t,[e])=>Math.ceil(e.evaluate(t))],"filter-==":[he,[ce,fe],(t,[e,r])=>t.properties()[e.value]===r.value],"filter-id-==":[he,[fe],(t,[e])=>t.id()===e.value],"filter-type-==":[he,[ce],(t,[e])=>t.geometryType()===e.value],"filter-<":[he,[ce,fe],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<i}],"filter-id-<":[he,[fe],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r<n}],"filter->":[he,[ce,fe],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>i}],"filter-id->":[he,[fe],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r>n}],"filter-<=":[he,[ce,fe],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<=i}],"filter-id-<=":[he,[fe],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r<=n}],"filter->=":[he,[ce,fe],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>=i}],"filter-id->=":[he,[fe],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r>=n}],"filter-has":[he,[fe],(t,[e])=>e.value in t.properties()],"filter-has-id":[he,[],t=>null!==t.id()&&void 0!==t.id()],"filter-type-in":[he,[xe(ce)],(t,[e])=>e.value.indexOf(t.geometryType())>=0],"filter-id-in":[he,[xe(fe)],(t,[e])=>e.value.indexOf(t.id())>=0],"filter-in-small":[he,[ce,xe(fe)],(t,[e,r])=>r.value.indexOf(t.properties()[e.value])>=0],"filter-in-large":[he,[ce,xe(fe)],(t,[e,r])=>function(t,e,r,n){for(;r<=n;){const i=r+n>>1;if(e[i]===t)return !0;e[i]>t?n=i-1:r=i+1;}return !1}(t.properties()[e.value],r.value,0,r.value.length-1)],all:{type:he,overloads:[[[he,he],(t,[e,r])=>e.evaluate(t)&&r.evaluate(t)],[Cn(he),(t,e)=>{for(const r of e)if(!r.evaluate(t))return !1;return !0}]]},any:{type:he,overloads:[[[he,he],(t,[e,r])=>e.evaluate(t)||r.evaluate(t)],[Cn(he),(t,e)=>{for(const r of e)if(r.evaluate(t))return !0;return !1}]]},"!":[he,[he],(t,[e])=>!e.evaluate(t)],"is-supported-script":[he,[ce],(t,[e])=>{const r=t.globals&&t.globals.isSupportedScript;return !r||r(e.evaluate(t))}],upcase:[ce,[ce],(t,[e])=>e.evaluate(t).toUpperCase()],downcase:[ce,[ce],(t,[e])=>e.evaluate(t).toLowerCase()],concat:[ce,Cn(fe),(t,e)=>e.map((e=>Ue(e.evaluate(t)))).join("")],"resolved-locale":[ce,[ye],(t,[e])=>e.evaluate(t).resolvedLocale()]});var Pn=Tn;function Dn(t){return {result:"success",value:t}}function Vn(t){return {result:"error",value:t}}function Ln(t){return "data-driven"===t["property-type"]}function Fn(t){return !!t.expression&&t.expression.parameters.indexOf("zoom")>-1}function Rn(t){return !!t.expression&&t.expression.interpolated}function Un(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":null===t?"null":typeof t}function $n(t){return "object"==typeof t&&null!==t&&!Array.isArray(t)}function jn(t){return t}function On(t,e){const r="color"===e.type,n=t.stops&&"object"==typeof t.stops[0][0],i=n||!(n||void 0!==t.property),s=t.type||(Rn(e)?"exponential":"interval");if(r&&((t=ee({},t)).stops&&(t.stops=t.stops.map((t=>[t[0],Ee.parse(t[1])]))),t.default=Ee.parse(t.default?t.default:e.default)),t.colorSpace&&"rgb"!==t.colorSpace&&!Hr[t.colorSpace])throw new Error(`Unknown color space: ${t.colorSpace}`);let a,o,l;if("exponential"===s)a=Zn;else if("interval"===s)a=Gn;else if("categorical"===s){a=Nn,o=Object.create(null);for(const e of t.stops)o[e[0]]=e[1];l=typeof t.stops[0][0];}else {if("identity"!==s)throw new Error(`Unknown function type "${s}"`);a=Kn;}if(n){const r={},n=[];for(let e=0;e<t.stops.length;e++){const i=t.stops[e],s=i[0].zoom;void 0===r[s]&&(r[s]={zoom:s,type:t.type,property:t.property,default:t.default,stops:[]},n.push(s)),r[s].stops.push([i[0].value,i[1]]);}const i=[];for(const t of n)i.push([r[t].zoom,On(r[t],e)]);const s={name:"linear"};return {kind:"composite",interpolationType:s,interpolationFactor:Qr.interpolationFactor.bind(void 0,s),zoomStops:i.map((t=>t[0])),evaluate:({zoom:r},n)=>Zn({stops:i,base:t.base},e,r).evaluate(r,n)}}if(i){const r="exponential"===s?{name:"exponential",base:void 0!==t.base?t.base:1}:null;return {kind:"camera",interpolationType:r,interpolationFactor:Qr.interpolationFactor.bind(void 0,r),zoomStops:t.stops.map((t=>t[0])),evaluate:({zoom:r})=>a(t,e,r,o,l)}}return {kind:"source",evaluate(r,n){const i=n&&n.properties?n.properties[t.property]:void 0;return void 0===i?qn(t.default,e.default):a(t,e,i,o,l)}}}function qn(t,e,r){return void 0!==t?t:void 0!==e?e:void 0!==r?r:void 0}function Nn(t,e,r,n,i){return qn(typeof r===i?n[r]:void 0,t.default,e.default)}function Gn(t,e,r){if("number"!==Un(r))return qn(t.default,e.default);const n=t.stops.length;if(1===n)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[n-1][0])return t.stops[n-1][1];const i=Tr(t.stops.map((t=>t[0])),r);return t.stops[i][1]}function Zn(t,e,r){const n=void 0!==t.base?t.base:1;if("number"!==Un(r))return qn(t.default,e.default);const i=t.stops.length;if(1===i)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[i-1][0])return t.stops[i-1][1];const s=Tr(t.stops.map((t=>t[0])),r),a=function(t,e,r,n){const i=n-r,s=t-r;return 0===i?0:1===e?s/i:(Math.pow(e,s)-1)/(Math.pow(e,i)-1)}(r,n,t.stops[s][0],t.stops[s+1][0]),o=t.stops[s][1],l=t.stops[s+1][1];let u=Cr[e.type]||jn;if(t.colorSpace&&"rgb"!==t.colorSpace){const e=Hr[t.colorSpace];u=(t,r)=>e.reverse(e.interpolate(e.forward(t),e.forward(r),a));}return "function"==typeof o.evaluate?{evaluate(...t){const e=o.evaluate.apply(void 0,t),r=l.evaluate.apply(void 0,t);if(void 0!==e&&void 0!==r)return u(e,r,a)}}:u(o,l,a)}function Kn(t,e,r){return "color"===e.type?r=Ee.parse(r):"formatted"===e.type?r=De.fromString(r.toString()):"resolvedImage"===e.type?r=Ve.fromString(r.toString()):Un(r)===e.type||"enum"===e.type&&e.values[r]||(r=void 0),qn(r,t.default,e.default)}class Xn{constructor(t,e){this.expression=t,this._warningHistory={},this._evaluator=new We,this._defaultValue=e?function(t){return "color"===t.type&&($n(t.default)||Array.isArray(t.default))?new Ee(0,0,0,0):"color"===t.type?Ee.parse(t.default)||null:void 0===t.default?null:t.default}(e):null,this._enumValues=e&&"enum"===e.type?e.values:null;}evaluateWithoutErrorHandling(t,e,r,n,i,s,a,o){return this._evaluator.globals=t,this._evaluator.feature=e,this._evaluator.featureState=r,this._evaluator.canonical=n||null,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=s,this._evaluator.featureTileCoord=a||null,this._evaluator.featureDistanceData=o||null,this.expression.evaluate(this._evaluator)}evaluate(t,e,r,n,i,s,a,o){this._evaluator.globals=t,this._evaluator.feature=e||null,this._evaluator.featureState=r||null,this._evaluator.canonical=n||null,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=s||null,this._evaluator.featureTileCoord=a||null,this._evaluator.featureDistanceData=o||null;try{const t=this.expression.evaluate(this._evaluator);if(null==t||"number"==typeof t&&t!=t)return this._defaultValue;if(this._enumValues&&!(t in this._enumValues))throw new Oe(`Expected value to be one of ${Object.keys(this._enumValues).map((t=>JSON.stringify(t))).join(", ")}, but found ${JSON.stringify(t)} instead.`);return t}catch(t){return this._warningHistory[t.message]||(this._warningHistory[t.message]=!0,"undefined"!=typeof console&&console.warn(t.message)),this._defaultValue}}}function Jn(t){return Array.isArray(t)&&t.length>0&&"string"==typeof t[0]&&t[0]in Pn}function Hn(t,e){const r=new Ir(Pn,[],e?function(t){const e={color:pe,string:ce,number:ue,enum:ce,boolean:he,formatted:me,resolvedImage:ge};return "array"===t.type?xe(e[t.value]||fe,t.length):e[t.type]}(e):void 0),n=r.parse(t,void 0,void 0,void 0,e&&"string"===e.type?{typeAnnotation:"coerce"}:void 0);return n?Dn(new Xn(n,e)):Vn(r.errors)}class Yn{constructor(t,e){this.kind=t,this._styleExpression=e,this.isStateDependent="constant"!==t&&!wr(e.expression);}evaluateWithoutErrorHandling(t,e,r,n,i,s){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,s)}evaluate(t,e,r,n,i,s){return this._styleExpression.evaluate(t,e,r,n,i,s)}}class Wn{constructor(t,e,r,n){this.kind=t,this.zoomStops=r,this._styleExpression=e,this.isStateDependent="camera"!==t&&!wr(e.expression),this.interpolationType=n;}evaluateWithoutErrorHandling(t,e,r,n,i,s){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,s)}evaluate(t,e,r,n,i,s){return this._styleExpression.evaluate(t,e,r,n,i,s)}interpolationFactor(t,e,r){return this.interpolationType?Qr.interpolationFactor(this.interpolationType,t,e,r):0}}function Qn(t,e){if("error"===(t=Hn(t,e)).result)return t;const r=t.value.expression,n=br(r);if(!n&&!Ln(e))return Vn([new se("","data expressions not supported")]);const i=_r(r,["zoom","pitch","distance-from-center"]);if(!i&&!Fn(e))return Vn([new se("","zoom expressions not supported")]);const s=ei(r);return s||i?s instanceof se?Vn([s]):s instanceof Qr&&!Rn(e)?Vn([new se("",'"interpolate" expressions cannot be used with this property')]):Dn(s?new Wn(n?"camera":"composite",t.value,s.labels,s instanceof Qr?s.interpolation:void 0):new Yn(n?"constant":"source",t.value)):Vn([new se("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])}class ti{constructor(t,e){this._parameters=t,this._specification=e,ee(this,On(this._parameters,this._specification));}static deserialize(t){return new ti(t._parameters,t._specification)}static serialize(t){return {_parameters:t._parameters,_specification:t._specification}}}function ei(t){let e=null;if(t instanceof nn)e=ei(t.result);else if(t instanceof en){for(const r of t.args)if(e=ei(r),e)break}else (t instanceof Br||t instanceof Qr)&&t.input instanceof tr&&"zoom"===t.input.name&&(e=t);return e instanceof se||t.eachChild((t=>{const r=ei(t);r instanceof se?e=r:!e&&r?e=new se("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'):e&&r&&e!==r&&(e=new se("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));})),e}class ri{constructor(t,e,r,n){this.message=(t?`${t}: `:"")+r,n&&(this.identifier=n),null!=e&&e.__line__&&(this.line=e.__line__);}}function ni(t){const e=t.key,r=t.value,n=t.valueSpec||{},i=t.objectElementValidators||{},s=t.style,a=t.styleSpec;let o=[];const l=Un(r);if("object"!==l)return [new ri(e,r,`object expected, ${l} found`)];for(const t in r){const l=t.split(".")[0];let u;i[l]?u=i[l]:n[l]?u=Fi:i["*"]?u=i["*"]:n["*"]&&(u=Fi),u?o=o.concat(u({key:(e?`${e}.`:e)+t,value:r[t],valueSpec:n[l]||n["*"],style:s,styleSpec:a,object:r,objectKey:t},r)):o.push(new ri(e,r[t],`unknown property "${t}"`));}for(const t in n)i[t]||n[t].required&&void 0===n[t].default&&void 0===r[t]&&o.push(new ri(e,r,`missing required property "${t}"`));return o}function ii(t){const e=t.value,r=t.valueSpec,n=t.style,i=t.styleSpec,s=t.key,a=t.arrayElementValidator||Fi;if("array"!==Un(e))return [new ri(s,e,`array expected, ${Un(e)} found`)];if(r.length&&e.length!==r.length)return [new ri(s,e,`array length ${r.length} expected, length ${e.length} found`)];if(r["min-length"]&&e.length<r["min-length"])return [new ri(s,e,`array length at least ${r["min-length"]} expected, length ${e.length} found`)];let o={type:r.value,values:r.values,minimum:r.minimum,maximum:r.maximum,function:void 0};i.$version<7&&(o.function=r.function),"object"===Un(r.value)&&(o=r.value);let l=[];for(let t=0;t<e.length;t++)l=l.concat(a({array:e,arrayIndex:t,value:e[t],valueSpec:o,style:n,styleSpec:i,key:`${s}[${t}]`}));return l}function si(t){const e=t.key,r=t.value,n=t.valueSpec;let i=Un(r);if("number"===i&&r!=r&&(i="NaN"),"number"!==i)return [new ri(e,r,`number expected, ${i} found`)];if("minimum"in n){let i=n.minimum;if("array"===Un(n.minimum)&&(i=n.minimum[t.arrayIndex]),r<i)return [new ri(e,r,`${r} is less than the minimum value ${i}`)]}if("maximum"in n){let i=n.maximum;if("array"===Un(n.maximum)&&(i=n.maximum[t.arrayIndex]),r>i)return [new ri(e,r,`${r} is greater than the maximum value ${i}`)]}return []}function ai(t){const e=t.valueSpec,r=re(t.value.type);let n,i,s,a={};const o="categorical"!==r&&void 0===t.value.property,l=!o,u="array"===Un(t.value.stops)&&"array"===Un(t.value.stops[0])&&"object"===Un(t.value.stops[0][0]),c=ni({key:t.key,value:t.value,valueSpec:t.styleSpec.function,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{stops:function(t){if("identity"===r)return [new ri(t.key,t.value,'identity function may not have a "stops" property')];let e=[];const n=t.value;return e=e.concat(ii({key:t.key,value:n,valueSpec:t.valueSpec,style:t.style,styleSpec:t.styleSpec,arrayElementValidator:h})),"array"===Un(n)&&0===n.length&&e.push(new ri(t.key,n,"array must have at least one stop")),e},default:function(t){return Fi({key:t.key,value:t.value,valueSpec:e,style:t.style,styleSpec:t.styleSpec})}}});return "identity"===r&&o&&c.push(new ri(t.key,t.value,'missing required property "property"')),"identity"===r||t.value.stops||c.push(new ri(t.key,t.value,'missing required property "stops"')),"exponential"===r&&t.valueSpec.expression&&!Rn(t.valueSpec)&&c.push(new ri(t.key,t.value,"exponential functions not supported")),t.styleSpec.$version>=8&&(l&&!Ln(t.valueSpec)?c.push(new ri(t.key,t.value,"property functions not supported")):o&&!Fn(t.valueSpec)&&c.push(new ri(t.key,t.value,"zoom functions not supported"))),"categorical"!==r&&!u||void 0!==t.value.property||c.push(new ri(t.key,t.value,'"property" property is required')),c;function h(t){let r=[];const n=t.value,o=t.key;if("array"!==Un(n))return [new ri(o,n,`array expected, ${Un(n)} found`)];if(2!==n.length)return [new ri(o,n,`array length 2 expected, length ${n.length} found`)];if(u){if("object"!==Un(n[0]))return [new ri(o,n,`object expected, ${Un(n[0])} found`)];if(void 0===n[0].zoom)return [new ri(o,n,"object stop key must have zoom")];if(void 0===n[0].value)return [new ri(o,n,"object stop key must have value")];const e=re(n[0].zoom);if("number"!=typeof e)return [new ri(o,n[0].zoom,"stop zoom values must be numbers")];if(s&&s>e)return [new ri(o,n[0].zoom,"stop zoom values must appear in ascending order")];e!==s&&(s=e,i=void 0,a={}),r=r.concat(ni({key:`${o}[0]`,value:n[0],valueSpec:{zoom:{}},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{zoom:si,value:p}}));}else r=r.concat(p({key:`${o}[0]`,value:n[0],valueSpec:{},style:t.style,styleSpec:t.styleSpec},n));return Jn(ne(n[1]))?r.concat([new ri(`${o}[1]`,n[1],"expressions are not allowed in function stops.")]):r.concat(Fi({key:`${o}[1]`,value:n[1],valueSpec:e,style:t.style,styleSpec:t.styleSpec}))}function p(t,s){const o=Un(t.value),l=re(t.value),u=null!==t.value?t.value:s;if(n){if(o!==n)return [new ri(t.key,u,`${o} stop domain type must match previous stop domain type ${n}`)]}else n=o;if("number"!==o&&"string"!==o&&"boolean"!==o&&"number"!=typeof l&&"string"!=typeof l&&"boolean"!=typeof l)return [new ri(t.key,u,"stop domain value must be a number, string, or boolean")];if("number"!==o&&"categorical"!==r){let n=`number expected, ${o} found`;return Ln(e)&&void 0===r&&(n+='\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),[new ri(t.key,u,n)]}return "categorical"!==r||"number"!==o||"number"==typeof l&&isFinite(l)&&Math.floor(l)===l?"categorical"!==r&&"number"===o&&"number"==typeof l&&"number"==typeof i&&void 0!==i&&l<i?[new ri(t.key,u,"stop domain values must appear in ascending order")]:(i=l,"categorical"===r&&l in a?[new ri(t.key,u,"stop domain values must be unique")]:(a[l]=!0,[])):[new ri(t.key,u,`integer expected, found ${String(l)}`)]}}function oi(t){const e=("property"===t.expressionContext?Qn:Hn)(ne(t.value),t.valueSpec);if("error"===e.result)return e.value.map((e=>new ri(`${t.key}${e.key}`,t.value,e.message)));const r=e.value.expression||e.value._styleExpression.expression;if("property"===t.expressionContext&&"text-font"===t.propertyKey&&!r.outputDefined())return [new ri(t.key,t.value,`Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];if("property"===t.expressionContext&&"layout"===t.propertyType&&!wr(r))return [new ri(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];if("filter"===t.expressionContext)return li(r,t);if(t.expressionContext&&0===t.expressionContext.indexOf("cluster")){if(!_r(r,["zoom","feature-state"]))return [new ri(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if("cluster-initial"===t.expressionContext&&!br(r))return [new ri(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return []}function li(t,e){const r=new Set(["zoom","feature-state","pitch","distance-from-center"]);if(e.valueSpec&&e.valueSpec.expression)for(const t of e.valueSpec.expression.parameters)r.delete(t);if(0===r.size)return [];const n=[];return t instanceof tr&&r.has(t.name)?[new ri(e.key,e.value,`["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)]:(t.eachChild((t=>{n.push(...li(t,e));})),n)}function ui(t){const e=t.key,r=t.value,n=t.valueSpec,i=[];return Array.isArray(n.values)?-1===n.values.indexOf(re(r))&&i.push(new ri(e,r,`expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)):-1===Object.keys(n.values).indexOf(re(r))&&i.push(new ri(e,r,`expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)),i}function ci(t){if(!0===t||!1===t)return !0;if(!Array.isArray(t)||0===t.length)return !1;switch(t[0]){case"has":return t.length>=2&&"$id"!==t[1]&&"$type"!==t[1];case"in":return t.length>=3&&("string"!=typeof t[1]||Array.isArray(t[2]));case"!in":case"!has":case"none":return !1;case"==":case"!=":case">":case">=":case"<":case"<=":return 3!==t.length||Array.isArray(t[1])||Array.isArray(t[2]);case"any":case"all":for(const e of t.slice(1))if(!ci(e)&&"boolean"!=typeof e)return !1;return !0;default:return !0}}function hi(t,e="fill"){if(null==t)return {filter:()=>!0,needGeometry:!1,needFeature:!1};ci(t)||(t=xi(t));const r=t;let n=!0;try{n=function(t){if(!fi(t))return t;let e=ne(t);return di(e),e=pi(e),e}(r);}catch(t){console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r,null,2)}\n        `);}const i=te[`filter_${e}`],s=Hn(n,i);let a=null;if("error"===s.result)throw new Error(s.value.map((t=>`${t.key}: ${t.message}`)).join(", "));a=(t,e,r)=>s.value.evaluate(t,e,{},r);let o=null,l=null;if(n!==r){const t=Hn(r,i);if("error"===t.result)throw new Error(t.value.map((t=>`${t.key}: ${t.message}`)).join(", "));o=(e,r,n,i,s)=>t.value.evaluate(e,r,{},n,void 0,void 0,i,s),l=!br(t.value.expression);}return {filter:a,dynamicFilter:o||void 0,needGeometry:gi(n),needFeature:!!l}}function pi(t){if(!Array.isArray(t))return t;const e=function(t){if(yi.has(t[0]))for(let e=1;e<t.length;e++)if(fi(t[e]))return !0;return t}(t);return !0===e?e:e.map((t=>pi(t)))}function di(t){let e=!1;const r=[];if("case"===t[0]){for(let n=1;n<t.length-1;n+=2)e=e||fi(t[n]),r.push(t[n+1]);r.push(t[t.length-1]);}else if("match"===t[0]){e=e||fi(t[1]);for(let e=2;e<t.length-1;e+=2)r.push(t[e+1]);r.push(t[t.length-1]);}else if("step"===t[0]){e=e||fi(t[1]);for(let e=1;e<t.length-1;e+=2)r.push(t[e+1]);}e&&(t.length=0,t.push("any",...r));for(let e=1;e<t.length;e++)di(t[e]);}function fi(t){if(!Array.isArray(t))return !1;if("pitch"===(e=t[0])||"distance-from-center"===e)return !0;var e;for(let e=1;e<t.length;e++)if(fi(t[e]))return !0;return !1}const yi=new Set(["in","==","!=",">",">=","<","<=","to-boolean"]);function mi(t,e){return t<e?-1:t>e?1:0}function gi(t){if(!Array.isArray(t))return !1;if("within"===t[0])return !0;for(let e=1;e<t.length;e++)if(gi(t[e]))return !0;return !1}function xi(t){if(!t)return !0;const e=t[0];return t.length<=1?"any"!==e:"=="===e?vi(t[1],t[2],"=="):"!="===e?_i(vi(t[1],t[2],"==")):"<"===e||">"===e||"<="===e||">="===e?vi(t[1],t[2],e):"any"===e?(r=t.slice(1),["any"].concat(r.map(xi))):"all"===e?["all"].concat(t.slice(1).map(xi)):"none"===e?["all"].concat(t.slice(1).map(xi).map(_i)):"in"===e?bi(t[1],t.slice(2)):"!in"===e?_i(bi(t[1],t.slice(2))):"has"===e?wi(t[1]):"!has"===e?_i(wi(t[1])):"within"!==e||t;var r;}function vi(t,e,r){switch(t){case"$type":return [`filter-type-${r}`,e];case"$id":return [`filter-id-${r}`,e];default:return [`filter-${r}`,t,e]}}function bi(t,e){if(0===e.length)return !1;switch(t){case"$type":return ["filter-type-in",["literal",e]];case"$id":return ["filter-id-in",["literal",e]];default:return e.length>200&&!e.some((t=>typeof t!=typeof e[0]))?["filter-in-large",t,["literal",e.sort(mi)]]:["filter-in-small",t,["literal",e]]}}function wi(t){switch(t){case"$type":return !0;case"$id":return ["filter-has-id"];default:return ["filter-has",t]}}function _i(t){return ["!",t]}function Ai(t){return ci(ne(t.value))?oi(ee({},t,{expressionContext:"filter",valueSpec:t.styleSpec[`filter_${t.layerType||"fill"}`]})):Si(t)}function Si(t){const e=t.value,r=t.key;if("array"!==Un(e))return [new ri(r,e,`array expected, ${Un(e)} found`)];const n=t.styleSpec;let i,s=[];if(e.length<1)return [new ri(r,e,"filter array must have at least 1 element")];switch(s=s.concat(ui({key:`${r}[0]`,value:e[0],valueSpec:n.filter_operator,style:t.style,styleSpec:t.styleSpec})),re(e[0])){case"<":case"<=":case">":case">=":e.length>=2&&"$type"===re(e[1])&&s.push(new ri(r,e,`"$type" cannot be use with operator "${e[0]}"`));case"==":case"!=":3!==e.length&&s.push(new ri(r,e,`filter array for operator "${e[0]}" must have 3 elements`));case"in":case"!in":e.length>=2&&(i=Un(e[1]),"string"!==i&&s.push(new ri(`${r}[1]`,e[1],`string expected, ${i} found`)));for(let a=2;a<e.length;a++)i=Un(e[a]),"$type"===re(e[1])?s=s.concat(ui({key:`${r}[${a}]`,value:e[a],valueSpec:n.geometry_type,style:t.style,styleSpec:t.styleSpec})):"string"!==i&&"number"!==i&&"boolean"!==i&&s.push(new ri(`${r}[${a}]`,e[a],`string, number, or boolean expected, ${i} found`));break;case"any":case"all":case"none":for(let n=1;n<e.length;n++)s=s.concat(Si({key:`${r}[${n}]`,value:e[n],style:t.style,styleSpec:t.styleSpec}));break;case"has":case"!has":i=Un(e[1]),2!==e.length?s.push(new ri(r,e,`filter array for "${e[0]}" operator must have 2 elements`)):"string"!==i&&s.push(new ri(`${r}[1]`,e[1],`string expected, ${i} found`));break;case"within":i=Un(e[1]),2!==e.length?s.push(new ri(r,e,`filter array for "${e[0]}" operator must have 2 elements`)):"object"!==i&&s.push(new ri(`${r}[1]`,e[1],`object expected, ${i} found`));}return s}function ki(t,e){const r=t.key,n=t.style,i=t.styleSpec,s=t.value,a=t.objectKey,o=i[`${e}_${t.layerType}`];if(!o)return [];const l=a.match(/^(.*)-transition$/);if("paint"===e&&l&&o[l[1]]&&o[l[1]].transition)return Fi({key:r,value:s,valueSpec:i.transition,style:n,styleSpec:i});const u=t.valueSpec||o[a];if(!u)return [new ri(r,s,`unknown property "${a}"`)];let c;if("string"===Un(s)&&Ln(u)&&!u.tokens&&(c=/^{([^}]+)}$/.exec(s))){const t=`\`{ "type": "identity", "property": ${c?JSON.stringify(c[1]):'"_"'} }\``;return [new ri(r,s,`"${a}" does not support interpolation syntax\nUse an identity property function instead: ${t}.`)]}const h=[];return "symbol"===t.layerType&&("text-field"===a&&n&&!n.glyphs&&h.push(new ri(r,s,'use of "text-field" requires a style "glyphs" property')),"text-font"===a&&$n(ne(s))&&"identity"===re(s.type)&&h.push(new ri(r,s,'"text-font" does not support identity functions'))),h.concat(Fi({key:t.key,value:s,valueSpec:u,style:n,styleSpec:i,expressionContext:"property",propertyType:e,propertyKey:a}))}function Ii(t){return ki(t,"paint")}function Mi(t){return ki(t,"layout")}function Ti(t){let e=[];const r=t.value,n=t.key,i=t.style,s=t.styleSpec;r.type||r.ref||e.push(new ri(n,r,'either "type" or "ref" is required'));let a=re(r.type);const o=re(r.ref);if(r.id){const s=re(r.id);for(let a=0;a<t.arrayIndex;a++){const t=i.layers[a];re(t.id)===s&&e.push(new ri(n,r.id,`duplicate layer id "${r.id}", previously used at line ${t.id.__line__}`));}}if("ref"in r){let t;["type","source","source-layer","filter","layout"].forEach((t=>{t in r&&e.push(new ri(n,r[t],`"${t}" is prohibited for ref layers`));})),i.layers.forEach((e=>{re(e.id)===o&&(t=e);})),t?t.ref?e.push(new ri(n,r.ref,"ref cannot reference another ref layer")):a=re(t.type):"string"==typeof o&&e.push(new ri(n,r.ref,`ref layer "${o}" not found`));}else if("background"!==a&&"sky"!==a)if(r.source){const t=i.sources&&i.sources[r.source],s=t&&re(t.type);t?"vector"===s&&"raster"===a?e.push(new ri(n,r.source,`layer "${r.id}" requires a raster source`)):"raster"===s&&"raster"!==a?e.push(new ri(n,r.source,`layer "${r.id}" requires a vector source`)):"vector"!==s||r["source-layer"]?"raster-dem"===s&&"hillshade"!==a?e.push(new ri(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")):"line"!==a||!r.paint||!r.paint["line-gradient"]&&!r.paint["line-trim-offset"]||"geojson"===s&&t.lineMetrics||e.push(new ri(n,r,`layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)):e.push(new ri(n,r,`layer "${r.id}" must specify a "source-layer"`)):e.push(new ri(n,r.source,`source "${r.source}" not found`));}else e.push(new ri(n,r,'missing required property "source"'));return e=e.concat(ni({key:n,value:r,valueSpec:s.layer,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":()=>[],type:()=>Fi({key:`${n}.type`,value:r.type,valueSpec:s.layer.type,style:t.style,styleSpec:t.styleSpec,object:r,objectKey:"type"}),filter:t=>Ai(ee({layerType:a},t)),layout:t=>ni({layer:r,key:t.key,value:t.value,valueSpec:{},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":t=>Mi(ee({layerType:a},t))}}),paint:t=>ni({layer:r,key:t.key,value:t.value,valueSpec:{},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":t=>Ii(ee({layerType:a},t))}})}})),e}function zi(t){const e=t.value,r=t.key,n=Un(e);return "string"!==n?[new ri(r,e,`string expected, ${n} found`)]:[]}const Bi={promoteId:function({key:t,value:e}){if("string"===Un(e))return zi({key:t,value:e});{const r=[];for(const n in e)r.push(...zi({key:`${t}.${n}`,value:e[n]}));return r}}};function Ei(t){const e=t.value,r=t.key,n=t.styleSpec,i=t.style;if(!e.type)return [new ri(r,e,'"type" is required')];const s=re(e.type);let a;switch(s){case"vector":case"raster":case"raster-dem":return a=ni({key:r,value:e,valueSpec:n[`source_${s.replace("-","_")}`],style:t.style,styleSpec:n,objectElementValidators:Bi}),a;case"geojson":if(a=ni({key:r,value:e,valueSpec:n.source_geojson,style:i,styleSpec:n,objectElementValidators:Bi}),e.cluster)for(const t in e.clusterProperties){const[n,i]=e.clusterProperties[t],s="string"==typeof n?[n,["accumulated"],["get",t]]:n;a.push(...oi({key:`${r}.${t}.map`,value:i,expressionContext:"cluster-map"})),a.push(...oi({key:`${r}.${t}.reduce`,value:s,expressionContext:"cluster-reduce"}));}return a;case"video":return ni({key:r,value:e,valueSpec:n.source_video,style:i,styleSpec:n});case"image":return ni({key:r,value:e,valueSpec:n.source_image,style:i,styleSpec:n});case"canvas":return [new ri(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return ui({key:`${r}.type`,value:e.type,valueSpec:{values:Ci(n)},style:i,styleSpec:n})}}function Ci(t){return t.source.reduce(((e,r)=>{const n=t[r];return "enum"===n.type.type&&(e=e.concat(Object.keys(n.type.values))),e}),[])}function Pi(t){const e=t.value,r=t.styleSpec,n=r.light,i=t.style;let s=[];const a=Un(e);if(void 0===e)return s;if("object"!==a)return s=s.concat([new ri("light",e,`object expected, ${a} found`)]),s;for(const t in e){const a=t.match(/^(.*)-transition$/);s=s.concat(a&&n[a[1]]&&n[a[1]].transition?Fi({key:t,value:e[t],valueSpec:r.transition,style:i,styleSpec:r}):n[t]?Fi({key:t,value:e[t],valueSpec:n[t],style:i,styleSpec:r}):[new ri(t,e[t],`unknown property "${t}"`)]);}return s}function Di(t){const e=t.value,r=t.key,n=t.style,i=t.styleSpec,s=i.terrain;let a=[];const o=Un(e);if(void 0===e)return a;if("object"!==o)return a=a.concat([new ri("terrain",e,`object expected, ${o} found`)]),a;for(const t in e){const r=t.match(/^(.*)-transition$/);a=a.concat(r&&s[r[1]]&&s[r[1]].transition?Fi({key:t,value:e[t],valueSpec:i.transition,style:n,styleSpec:i}):s[t]?Fi({key:t,value:e[t],valueSpec:s[t],style:n,styleSpec:i}):[new ri(t,e[t],`unknown property "${t}"`)]);}if(e.source){const t=n.sources&&n.sources[e.source],i=t&&re(t.type);t?"raster-dem"!==i&&a.push(new ri(r,e.source,`terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)):a.push(new ri(r,e.source,`source "${e.source}" not found`));}else a.push(new ri(r,e,'terrain is missing required property "source"'));return a}function Vi(t){const e=t.value,r=t.style,n=t.styleSpec,i=n.fog;let s=[];const a=Un(e);if(void 0===e)return s;if("object"!==a)return s=s.concat([new ri("fog",e,`object expected, ${a} found`)]),s;for(const t in e){const a=t.match(/^(.*)-transition$/);s=s.concat(a&&i[a[1]]&&i[a[1]].transition?Fi({key:t,value:e[t],valueSpec:n.transition,style:r,styleSpec:n}):i[t]?Fi({key:t,value:e[t],valueSpec:i[t],style:r,styleSpec:n}):[new ri(t,e[t],`unknown property "${t}"`)]);}return s}const Li={"*":()=>[],array:ii,boolean:function(t){const e=t.value,r=t.key,n=Un(e);return "boolean"!==n?[new ri(r,e,`boolean expected, ${n} found`)]:[]},number:si,color:function(t){const e=t.key,r=t.value,n=Un(r);return "string"!==n?[new ri(e,r,`color expected, ${n} found`)]:null===Se(r)?[new ri(e,r,`color expected, "${r}" found`)]:[]},enum:ui,filter:Ai,function:ai,layer:Ti,object:ni,source:Ei,light:Pi,terrain:Di,fog:Vi,string:zi,formatted:function(t){return 0===zi(t).length?[]:oi(t)},resolvedImage:function(t){return 0===zi(t).length?[]:oi(t)},projection:function(t){const e=t.value,r=t.styleSpec,n=r.projection,i=t.style;let s=[];const a=Un(e);if("object"===a)for(const t in e)s=s.concat(Fi({key:t,value:e[t],valueSpec:n[t],style:i,styleSpec:r}));else "string"!==a&&(s=s.concat([new ri("projection",e,`object or string expected, ${a} found`)]));return s}};function Fi(t){const e=t.value,r=t.valueSpec,n=t.styleSpec;return r.expression&&$n(re(e))?ai(t):r.expression&&Jn(ne(e))?oi(t):r.type&&Li[r.type]?Li[r.type](t):ni(ee({},t,{valueSpec:r.type?n[r.type]:r}))}function Ri(t){const e=t.value,r=t.key,n=zi(t);return n.length||(-1===e.indexOf("{fontstack}")&&n.push(new ri(r,e,'"glyphs" url must include a "{fontstack}" token')),-1===e.indexOf("{range}")&&n.push(new ri(r,e,'"glyphs" url must include a "{range}" token'))),n}function Ui(t,e=te){return Oi(Fi({key:"",value:t,valueSpec:e.$root,styleSpec:e,style:t,objectElementValidators:{glyphs:Ri,"*":()=>[]}}))}const $i=t=>Oi(Ii(t)),ji=t=>Oi(Mi(t));function Oi(t){return t.slice().sort(((t,e)=>t.line&&e.line?t.line-e.line:0))}function qi(t,e){let r=!1;if(e&&e.length)for(const n of e)t.fire(new Wt(new Error(n.message))),r=!0;return r}var Ni=Zi,Gi=3;function Zi(t,e,r){var n=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;var i=new Int32Array(this.arrayBuffer);t=i[0],this.d=(e=i[1])+2*(r=i[2]);for(var s=0;s<this.d*this.d;s++){var a=i[Gi+s],o=i[Gi+s+1];n.push(a===o?null:i.subarray(a,o));}var l=i[Gi+n.length+1];this.keys=i.subarray(i[Gi+n.length],l),this.bboxes=i.subarray(l),this.insert=this._insertReadonly;}else {this.d=e+2*r;for(var u=0;u<this.d*this.d;u++)n.push([]);this.keys=[],this.bboxes=[];}this.n=e,this.extent=t,this.padding=r,this.scale=e/t,this.uid=0;var c=r/e*t;this.min=-c,this.max=t+c;}Zi.prototype.insert=function(t,e,r,n,i){this._forEachCell(e,r,n,i,this._insertCell,this.uid++),this.keys.push(t),this.bboxes.push(e),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i);},Zi.prototype._insertReadonly=function(){throw "Cannot insert into a GridIndex created from an ArrayBuffer."},Zi.prototype._insertCell=function(t,e,r,n,i,s){this.cells[i].push(s);},Zi.prototype.query=function(t,e,r,n,i){var s=this.min,a=this.max;if(t<=s&&e<=s&&a<=r&&a<=n&&!i)return Array.prototype.slice.call(this.keys);var o=[];return this._forEachCell(t,e,r,n,this._queryCell,o,{},i),o},Zi.prototype._queryCell=function(t,e,r,n,i,s,a,o){var l=this.cells[i];if(null!==l)for(var u=this.keys,c=this.bboxes,h=0;h<l.length;h++){var p=l[h];if(void 0===a[p]){var d=4*p;(o?o(c[d+0],c[d+1],c[d+2],c[d+3]):t<=c[d+2]&&e<=c[d+3]&&r>=c[d+0]&&n>=c[d+1])?(a[p]=!0,s.push(u[p])):a[p]=!1;}}},Zi.prototype._forEachCell=function(t,e,r,n,i,s,a,o){for(var l=this._convertToCellCoord(t),u=this._convertToCellCoord(e),c=this._convertToCellCoord(r),h=this._convertToCellCoord(n),p=l;p<=c;p++)for(var d=u;d<=h;d++){var f=this.d*d+p;if((!o||o(this._convertFromCellCoord(p),this._convertFromCellCoord(d),this._convertFromCellCoord(p+1),this._convertFromCellCoord(d+1)))&&i.call(this,t,e,r,n,f,s,a,o))return}},Zi.prototype._convertFromCellCoord=function(t){return (t-this.padding)/this.scale},Zi.prototype._convertToCellCoord=function(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))},Zi.prototype.toArrayBuffer=function(){if(this.arrayBuffer)return this.arrayBuffer;for(var t=this.cells,e=Gi+this.cells.length+1+1,r=0,n=0;n<this.cells.length;n++)r+=this.cells[n].length;var i=new Int32Array(e+r+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;for(var s=e,a=0;a<t.length;a++){var o=t[a];i[Gi+a]=s,i.set(o,s),s+=o.length;}return i[Gi+t.length]=s,i.set(this.keys,s),i[Gi+t.length+1]=s+=this.keys.length,i.set(this.bboxes,s),s+=this.bboxes.length,i.buffer};var Ki=p(Ni);const Xi={};function Ji(t,e,r={}){Object.defineProperty(t,"_classRegistryKey",{value:e,writeable:!1}),Xi[e]={klass:t,omit:r.omit||[]};}Ji(Object,"Object"),Ki.serialize=function(t,e){const r=t.toArrayBuffer();return e&&e.push(r),{buffer:r}},Ki.deserialize=function(t){return new Ki(t.buffer)},Object.defineProperty(Ki,"name",{value:"Grid"}),Ji(Ki,"Grid"),Ji(Ee,"Color"),Ji(Error,"Error"),Ji(ut,"AJAXError"),Ji(Ve,"ResolvedImage"),Ji(ti,"StylePropertyFunction"),Ji(Xn,"StyleExpression",{omit:["_evaluator"]}),Ji(Wn,"ZoomDependentExpression"),Ji(Yn,"ZoomConstantExpression"),Ji(tr,"CompoundExpression",{omit:["_evaluate"]});for(const t in Pn)Xi[Pn[t]._classRegistryKey]||Ji(Pn[t],`Expression${t}`);function Hi(t){return t&&"undefined"!=typeof ArrayBuffer&&(t instanceof ArrayBuffer||t.constructor&&"ArrayBuffer"===t.constructor.name)}function Yi(t){return e.ImageBitmap&&t instanceof e.ImageBitmap}function Wi(t,r){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp)return t;if(Hi(t)||Yi(t))return r&&r.push(t),t;if(ArrayBuffer.isView(t)){const e=t;return r&&r.push(e.buffer),e}if(t instanceof e.ImageData)return r&&r.push(t.data.buffer),t;if(Array.isArray(t)){const e=[];for(const n of t)e.push(Wi(n,r));return e}if("object"==typeof t){const e=t.constructor,n=e._classRegistryKey;if(!n)throw new Error(`can't serialize object of unregistered class ${n}`);const i=e.serialize?e.serialize(t,r):{};if(!e.serialize){for(const e in t)t.hasOwnProperty(e)&&(Xi[n].omit.indexOf(e)>=0||(i[e]=Wi(t[e],r)));t instanceof Error&&(i.message=t.message);}if(i.$name)throw new Error("$name property is reserved for worker serialization logic.");return "Object"!==n&&(i.$name=n),i}throw new Error("can't serialize object of type "+typeof t)}function Qi(t){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||Hi(t)||Yi(t)||ArrayBuffer.isView(t)||t instanceof e.ImageData)return t;if(Array.isArray(t))return t.map(Qi);if("object"==typeof t){const e=t.$name||"Object",{klass:r}=Xi[e];if(!r)throw new Error(`can't deserialize unregistered class ${e}`);if(r.deserialize)return r.deserialize(t);const n=Object.create(r.prototype);for(const e of Object.keys(t))"$name"!==e&&(n[e]=Qi(t[e]));return n}throw new Error("can't deserialize object of type "+typeof t)}const ts={"Latin-1 Supplement":t=>t>=128&&t<=255,Arabic:t=>t>=1536&&t<=1791,"Arabic Supplement":t=>t>=1872&&t<=1919,"Arabic Extended-A":t=>t>=2208&&t<=2303,"Hangul Jamo":t=>t>=4352&&t<=4607,"Unified Canadian Aboriginal Syllabics":t=>t>=5120&&t<=5759,Khmer:t=>t>=6016&&t<=6143,"Unified Canadian Aboriginal Syllabics Extended":t=>t>=6320&&t<=6399,"General Punctuation":t=>t>=8192&&t<=8303,"Letterlike Symbols":t=>t>=8448&&t<=8527,"Number Forms":t=>t>=8528&&t<=8591,"Miscellaneous Technical":t=>t>=8960&&t<=9215,"Control Pictures":t=>t>=9216&&t<=9279,"Optical Character Recognition":t=>t>=9280&&t<=9311,"Enclosed Alphanumerics":t=>t>=9312&&t<=9471,"Geometric Shapes":t=>t>=9632&&t<=9727,"Miscellaneous Symbols":t=>t>=9728&&t<=9983,"Miscellaneous Symbols and Arrows":t=>t>=11008&&t<=11263,"CJK Radicals Supplement":t=>t>=11904&&t<=12031,"Kangxi Radicals":t=>t>=12032&&t<=12255,"Ideographic Description Characters":t=>t>=12272&&t<=12287,"CJK Symbols and Punctuation":t=>t>=12288&&t<=12351,Hiragana:t=>t>=12352&&t<=12447,Katakana:t=>t>=12448&&t<=12543,Bopomofo:t=>t>=12544&&t<=12591,"Hangul Compatibility Jamo":t=>t>=12592&&t<=12687,Kanbun:t=>t>=12688&&t<=12703,"Bopomofo Extended":t=>t>=12704&&t<=12735,"CJK Strokes":t=>t>=12736&&t<=12783,"Katakana Phonetic Extensions":t=>t>=12784&&t<=12799,"Enclosed CJK Letters and Months":t=>t>=12800&&t<=13055,"CJK Compatibility":t=>t>=13056&&t<=13311,"CJK Unified Ideographs Extension A":t=>t>=13312&&t<=19903,"Yijing Hexagram Symbols":t=>t>=19904&&t<=19967,"CJK Unified Ideographs":t=>t>=19968&&t<=40959,"Yi Syllables":t=>t>=40960&&t<=42127,"Yi Radicals":t=>t>=42128&&t<=42191,"Hangul Jamo Extended-A":t=>t>=43360&&t<=43391,"Hangul Syllables":t=>t>=44032&&t<=55215,"Hangul Jamo Extended-B":t=>t>=55216&&t<=55295,"Private Use Area":t=>t>=57344&&t<=63743,"CJK Compatibility Ideographs":t=>t>=63744&&t<=64255,"Arabic Presentation Forms-A":t=>t>=64336&&t<=65023,"Vertical Forms":t=>t>=65040&&t<=65055,"CJK Compatibility Forms":t=>t>=65072&&t<=65103,"Small Form Variants":t=>t>=65104&&t<=65135,"Arabic Presentation Forms-B":t=>t>=65136&&t<=65279,"Halfwidth and Fullwidth Forms":t=>t>=65280&&t<=65519};function es(t){for(const e of t)if(is(e.charCodeAt(0)))return !0;return !1}function rs(t){for(const e of t)if(!ns(e.charCodeAt(0)))return !1;return !0}function ns(t){return !(ts.Arabic(t)||ts["Arabic Supplement"](t)||ts["Arabic Extended-A"](t)||ts["Arabic Presentation Forms-A"](t)||ts["Arabic Presentation Forms-B"](t))}function is(t){return !(746!==t&&747!==t&&(t<4352||!(ts["Bopomofo Extended"](t)||ts.Bopomofo(t)||ts["CJK Compatibility Forms"](t)&&!(t>=65097&&t<=65103)||ts["CJK Compatibility Ideographs"](t)||ts["CJK Compatibility"](t)||ts["CJK Radicals Supplement"](t)||ts["CJK Strokes"](t)||!(!ts["CJK Symbols and Punctuation"](t)||t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||ts["CJK Unified Ideographs Extension A"](t)||ts["CJK Unified Ideographs"](t)||ts["Enclosed CJK Letters and Months"](t)||ts["Hangul Compatibility Jamo"](t)||ts["Hangul Jamo Extended-A"](t)||ts["Hangul Jamo Extended-B"](t)||ts["Hangul Jamo"](t)||ts["Hangul Syllables"](t)||ts.Hiragana(t)||ts["Ideographic Description Characters"](t)||ts.Kanbun(t)||ts["Kangxi Radicals"](t)||ts["Katakana Phonetic Extensions"](t)||ts.Katakana(t)&&12540!==t||!(!ts["Halfwidth and Fullwidth Forms"](t)||65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||!(!ts["Small Form Variants"](t)||t>=65112&&t<=65118||t>=65123&&t<=65126)||ts["Unified Canadian Aboriginal Syllabics"](t)||ts["Unified Canadian Aboriginal Syllabics Extended"](t)||ts["Vertical Forms"](t)||ts["Yijing Hexagram Symbols"](t)||ts["Yi Syllables"](t)||ts["Yi Radicals"](t))))}function ss(t){return !(is(t)||function(t){return !!(ts["Latin-1 Supplement"](t)&&(167===t||169===t||174===t||177===t||188===t||189===t||190===t||215===t||247===t)||ts["General Punctuation"](t)&&(8214===t||8224===t||8225===t||8240===t||8241===t||8251===t||8252===t||8258===t||8263===t||8264===t||8265===t||8273===t)||ts["Letterlike Symbols"](t)||ts["Number Forms"](t)||ts["Miscellaneous Technical"](t)&&(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||9003===t||t>=9085&&t<=9114||t>=9150&&t<=9165||9167===t||t>=9169&&t<=9179||t>=9186&&t<=9215)||ts["Control Pictures"](t)&&9251!==t||ts["Optical Character Recognition"](t)||ts["Enclosed Alphanumerics"](t)||ts["Geometric Shapes"](t)||ts["Miscellaneous Symbols"](t)&&!(t>=9754&&t<=9759)||ts["Miscellaneous Symbols and Arrows"](t)&&(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243)||ts["CJK Symbols and Punctuation"](t)||ts.Katakana(t)||ts["Private Use Area"](t)||ts["CJK Compatibility Forms"](t)||ts["Small Form Variants"](t)||ts["Halfwidth and Fullwidth Forms"](t)||8734===t||8756===t||8757===t||t>=9984&&t<=10087||t>=10102&&t<=10131||65532===t||65533===t)}(t))}function as(t){return t>=1424&&t<=2303||ts["Arabic Presentation Forms-A"](t)||ts["Arabic Presentation Forms-B"](t)}function os(t,e){return !(!e&&as(t)||t>=2304&&t<=3583||t>=3840&&t<=4255||ts.Khmer(t))}function ls(t){for(const e of t)if(as(e.charCodeAt(0)))return !0;return !1}const us="deferred",cs="loading",hs="loaded";let ps=null,ds="unavailable",fs=null;const ys=function(t){t&&"string"==typeof t&&t.indexOf("NetworkError")>-1&&(ds="error"),ps&&ps(t);};function ms(){gs.fire(new Yt("pluginStateChange",{pluginStatus:ds,pluginURL:fs}));}const gs=new Qt,xs=function(){return ds},vs=function(){if(ds!==us||!fs)throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");ds=cs,ms(),fs&&pt({url:fs},(t=>{t?ys(t):(ds=hs,ms());}));},bs={applyArabicShaping:null,processBidirectionalText:null,processStyledBidirectionalText:null,isLoaded:()=>ds===hs||null!=bs.applyArabicShaping,isLoading:()=>ds===cs,setState(t){ds=t.pluginStatus,fs=t.pluginURL;},isParsed:()=>null!=bs.applyArabicShaping&&null!=bs.processBidirectionalText&&null!=bs.processStyledBidirectionalText,getPluginURL:()=>fs};class ws{constructor(t,e){this.zoom=t,e?(this.now=e.now,this.fadeDuration=e.fadeDuration,this.transition=e.transition,this.pitch=e.pitch):(this.now=0,this.fadeDuration=0,this.transition={},this.pitch=0);}isSupportedScript(t){return function(t,e){for(const r of t)if(!os(r.charCodeAt(0),e))return !1;return !0}(t,bs.isLoaded())}}class _s{constructor(t,e){this.property=t,this.value=e,this.expression=function(t,e){if($n(t))return new ti(t,e);if(Jn(t)){const r=Qn(t,e);if("error"===r.result)throw new Error(r.value.map((t=>`${t.key}: ${t.message}`)).join(", "));return r.value}{let r=t;return "string"==typeof t&&"color"===e.type&&(r=Ee.parse(t)),{kind:"constant",evaluate:()=>r}}}(void 0===e?t.specification.default:e,t.specification);}isDataDriven(){return "source"===this.expression.kind||"composite"===this.expression.kind}possiblyEvaluate(t,e,r){return this.property.possiblyEvaluate(this,t,e,r)}}class As{constructor(t){this.property=t,this.value=new _s(t,void 0);}transitioned(t,e){return new ks(this.property,this.value,e,C({},t.transition,this.transition),t.now)}untransitioned(){return new ks(this.property,this.value,null,{},0)}}class Ss{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues);}getValue(t){return O(this._values[t].value.value)}setValue(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new As(this._values[t].property)),this._values[t].value=new _s(this._values[t].property,null===e?void 0:O(e));}getTransition(t){return O(this._values[t].transition)}setTransition(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new As(this._values[t].property)),this._values[t].transition=O(e)||void 0;}serialize(){const t={};for(const e of Object.keys(this._values)){const r=this.getValue(e);void 0!==r&&(t[e]=r);const n=this.getTransition(e);void 0!==n&&(t[`${e}-transition`]=n);}return t}transitioned(t,e){const r=new Is(this._properties);for(const n of Object.keys(this._values))r._values[n]=this._values[n].transitioned(t,e._values[n]);return r}untransitioned(){const t=new Is(this._properties);for(const e of Object.keys(this._values))t._values[e]=this._values[e].untransitioned();return t}}class ks{constructor(t,e,r,n,i){const s=n.delay||0,a=n.duration||0;i=i||0,this.property=t,this.value=e,this.begin=i+s,this.end=this.begin+a,t.specification.transition&&(n.delay||n.duration)&&(this.prior=r);}possiblyEvaluate(t,e,r){const n=t.now||0,i=this.value.possiblyEvaluate(t,e,r),s=this.prior;if(s){if(n>this.end)return this.prior=null,i;if(this.value.isDataDriven())return this.prior=null,i;if(n<this.begin)return s.possiblyEvaluate(t,e,r);{const a=(n-this.begin)/(this.end-this.begin);return this.property.interpolate(s.possiblyEvaluate(t,e,r),i,S(a))}}return i}}class Is{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues);}possiblyEvaluate(t,e,r){const n=new zs(this._properties);for(const i of Object.keys(this._values))n._values[i]=this._values[i].possiblyEvaluate(t,e,r);return n}hasTransition(){for(const t of Object.keys(this._values))if(this._values[t].prior)return !0;return !1}}class Ms{constructor(t){this._properties=t,this._values=Object.create(t.defaultPropertyValues);}getValue(t){return O(this._values[t].value)}setValue(t,e){this._values[t]=new _s(this._values[t].property,null===e?void 0:O(e));}serialize(){const t={};for(const e of Object.keys(this._values)){const r=this.getValue(e);void 0!==r&&(t[e]=r);}return t}possiblyEvaluate(t,e,r){const n=new zs(this._properties);for(const i of Object.keys(this._values))n._values[i]=this._values[i].possiblyEvaluate(t,e,r);return n}}class Ts{constructor(t,e,r){this.property=t,this.value=e,this.parameters=r;}isConstant(){return "constant"===this.value.kind}constantOr(t){return "constant"===this.value.kind?this.value.value:t}evaluate(t,e,r,n){return this.property.evaluate(this.value,this.parameters,t,e,r,n)}}class zs{constructor(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues);}get(t){return this._values[t]}}class Bs{constructor(t){this.specification=t;}possiblyEvaluate(t,e){return t.expression.evaluate(e)}interpolate(t,e,r){const n=Cr[this.specification.type];return n?n(t,e,r):t}}class Es{constructor(t,e){this.specification=t,this.overrides=e;}possiblyEvaluate(t,e,r,n){return new Ts(this,"constant"===t.expression.kind||"camera"===t.expression.kind?{kind:"constant",value:t.expression.evaluate(e,null,{},r,n)}:t.expression,e)}interpolate(t,e,r){if("constant"!==t.value.kind||"constant"!==e.value.kind)return t;if(void 0===t.value.value||void 0===e.value.value)return new Ts(this,{kind:"constant",value:void 0},t.parameters);const n=Cr[this.specification.type];return n?new Ts(this,{kind:"constant",value:n(t.value.value,e.value.value,r)},t.parameters):t}evaluate(t,e,r,n,i,s){return "constant"===t.kind?t.value:t.evaluate(e,r,n,i,s)}}class Cs{constructor(t){this.specification=t;}possiblyEvaluate(t,e,r,n){return !!t.expression.evaluate(e,null,{},r,n)}interpolate(){return !1}}class Ps{constructor(t){this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[];const e=new ws(0,{});for(const r in t){const n=t[r];n.specification.overridable&&this.overridableProperties.push(r);const i=this.defaultPropertyValues[r]=new _s(n,void 0),s=this.defaultTransitionablePropertyValues[r]=new As(n);this.defaultTransitioningPropertyValues[r]=s.untransitioned(),this.defaultPossiblyEvaluatedValues[r]=i.possiblyEvaluate(e);}}}function Ds(t,e){return 256*(t=M(Math.floor(t),0,255))+M(Math.floor(e),0,255)}Ji(Es,"DataDrivenProperty"),Ji(Bs,"DataConstantProperty"),Ji(Cs,"ColorRampProperty");const Vs={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array};class Ls{constructor(t,e){this._structArray=t,this._pos1=e*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8;}}class Fs{constructor(){this.isTransferred=!1,this.capacity=-1,this.resize(0);}static serialize(t,e){return t._trim(),e&&(t.isTransferred=!0,e.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}}static deserialize(t){const e=Object.create(this.prototype);return e.arrayBuffer=t.arrayBuffer,e.length=t.length,e.capacity=t.arrayBuffer.byteLength/e.bytesPerElement,e._refreshViews(),e}_trim(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews());}clear(){this.length=0;}resize(t){this.reserve(t),this.length=t;}reserve(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(5*this.capacity),128),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);const e=this.uint8;this._refreshViews(),e&&this.uint8.set(e);}}_refreshViews(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")}destroy(){this.int8=this.uint8=this.int16=this.uint16=this.int32=this.uint32=this.float32=null,this.arrayBuffer=null;}}function Rs(t,e=1){let r=0,n=0;return {members:t.map((t=>{const i=Vs[t.type].BYTES_PER_ELEMENT,s=r=Us(r,Math.max(e,i)),a=t.components||1;return n=Math.max(n,i),r+=i*a,{name:t.name,type:t.type,components:a,offset:s}})),size:Us(r,Math.max(n,e)),alignment:e}}function Us(t,e){return Math.ceil(t/e)*e}class $s extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e){const r=this.length;return this.resize(r+1),this.emplace(r,t,e)}emplace(t,e,r){const n=2*t;return this.int16[n+0]=e,this.int16[n+1]=r,t}}$s.prototype.bytesPerElement=4,Ji($s,"StructArrayLayout2i4");class js extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r){const n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)}emplace(t,e,r,n){const i=3*t;return this.int16[i+0]=e,this.int16[i+1]=r,this.int16[i+2]=n,t}}js.prototype.bytesPerElement=6,Ji(js,"StructArrayLayout3i6");class Os extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const s=4*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,t}}Os.prototype.bytesPerElement=8,Ji(Os,"StructArrayLayout4i8");class qs extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s,a){const o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,s,a)}emplace(t,e,r,n,i,s,a,o){const l=6*t,u=12*t,c=3*t;return this.int16[l+0]=e,this.int16[l+1]=r,this.uint8[u+4]=n,this.uint8[u+5]=i,this.uint8[u+6]=s,this.uint8[u+7]=a,this.float32[c+2]=o,t}}qs.prototype.bytesPerElement=12,Ji(qs,"StructArrayLayout2i4ub1f12");class Ns extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const s=4*t;return this.float32[s+0]=e,this.float32[s+1]=r,this.float32[s+2]=n,this.float32[s+3]=i,t}}Ns.prototype.bytesPerElement=16,Ji(Ns,"StructArrayLayout4f16");class Gs extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i){const s=this.length;return this.resize(s+1),this.emplace(s,t,e,r,n,i)}emplace(t,e,r,n,i,s){const a=6*t,o=3*t;return this.uint16[a+0]=e,this.uint16[a+1]=r,this.uint16[a+2]=n,this.uint16[a+3]=i,this.float32[o+2]=s,t}}Gs.prototype.bytesPerElement=12,Ji(Gs,"StructArrayLayout4ui1f12");class Zs extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const s=4*t;return this.uint16[s+0]=e,this.uint16[s+1]=r,this.uint16[s+2]=n,this.uint16[s+3]=i,t}}Zs.prototype.bytesPerElement=8,Ji(Zs,"StructArrayLayout4ui8");class Ks extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s){const a=this.length;return this.resize(a+1),this.emplace(a,t,e,r,n,i,s)}emplace(t,e,r,n,i,s,a){const o=6*t;return this.int16[o+0]=e,this.int16[o+1]=r,this.int16[o+2]=n,this.int16[o+3]=i,this.int16[o+4]=s,this.int16[o+5]=a,t}}Ks.prototype.bytesPerElement=12,Ji(Ks,"StructArrayLayout6i12");class Xs extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s,a,o,l,u,c,h){const p=this.length;return this.resize(p+1),this.emplace(p,t,e,r,n,i,s,a,o,l,u,c,h)}emplace(t,e,r,n,i,s,a,o,l,u,c,h,p){const d=12*t;return this.int16[d+0]=e,this.int16[d+1]=r,this.int16[d+2]=n,this.int16[d+3]=i,this.uint16[d+4]=s,this.uint16[d+5]=a,this.uint16[d+6]=o,this.uint16[d+7]=l,this.int16[d+8]=u,this.int16[d+9]=c,this.int16[d+10]=h,this.int16[d+11]=p,t}}Xs.prototype.bytesPerElement=24,Ji(Xs,"StructArrayLayout4i4ui4i24");class Js extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s){const a=this.length;return this.resize(a+1),this.emplace(a,t,e,r,n,i,s)}emplace(t,e,r,n,i,s,a){const o=10*t,l=5*t;return this.int16[o+0]=e,this.int16[o+1]=r,this.int16[o+2]=n,this.float32[l+2]=i,this.float32[l+3]=s,this.float32[l+4]=a,t}}Js.prototype.bytesPerElement=20,Ji(Js,"StructArrayLayout3i3f20");class Hs extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);}emplaceBack(t){const e=this.length;return this.resize(e+1),this.emplace(e,t)}emplace(t,e){return this.uint32[1*t+0]=e,t}}Hs.prototype.bytesPerElement=4,Ji(Hs,"StructArrayLayout1ul4");class Ys extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s,a,o,l,u,c,h,p){const d=this.length;return this.resize(d+1),this.emplace(d,t,e,r,n,i,s,a,o,l,u,c,h,p)}emplace(t,e,r,n,i,s,a,o,l,u,c,h,p,d){const f=20*t,y=10*t;return this.int16[f+0]=e,this.int16[f+1]=r,this.int16[f+2]=n,this.int16[f+3]=i,this.int16[f+4]=s,this.float32[y+3]=a,this.float32[y+4]=o,this.float32[y+5]=l,this.float32[y+6]=u,this.int16[f+14]=c,this.uint32[y+8]=h,this.uint16[f+18]=p,this.uint16[f+19]=d,t}}Ys.prototype.bytesPerElement=40,Ji(Ys,"StructArrayLayout5i4f1i1ul2ui40");class Ws extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s,a){const o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,s,a)}emplace(t,e,r,n,i,s,a,o){const l=8*t;return this.int16[l+0]=e,this.int16[l+1]=r,this.int16[l+2]=n,this.int16[l+4]=i,this.int16[l+5]=s,this.int16[l+6]=a,this.int16[l+7]=o,t}}Ws.prototype.bytesPerElement=16,Ji(Ws,"StructArrayLayout3i2i2i16");class Qs extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i){const s=this.length;return this.resize(s+1),this.emplace(s,t,e,r,n,i)}emplace(t,e,r,n,i,s){const a=4*t,o=8*t;return this.float32[a+0]=e,this.float32[a+1]=r,this.float32[a+2]=n,this.int16[o+6]=i,this.int16[o+7]=s,t}}Qs.prototype.bytesPerElement=16,Ji(Qs,"StructArrayLayout2f1f2i16");class ta extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const s=12*t,a=3*t;return this.uint8[s+0]=e,this.uint8[s+1]=r,this.float32[a+1]=n,this.float32[a+2]=i,t}}ta.prototype.bytesPerElement=12,Ji(ta,"StructArrayLayout2ub2f12");class ea extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r){const n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)}emplace(t,e,r,n){const i=3*t;return this.float32[i+0]=e,this.float32[i+1]=r,this.float32[i+2]=n,t}}ea.prototype.bytesPerElement=12,Ji(ea,"StructArrayLayout3f12");class ra extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r){const n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)}emplace(t,e,r,n){const i=3*t;return this.uint16[i+0]=e,this.uint16[i+1]=r,this.uint16[i+2]=n,t}}ra.prototype.bytesPerElement=6,Ji(ra,"StructArrayLayout3ui6");class na extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m,g,x,v,b){const w=this.length;return this.resize(w+1),this.emplace(w,t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m,g,x,v,b)}emplace(t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m,g,x,v,b,w){const _=30*t,A=15*t,S=60*t;return this.int16[_+0]=e,this.int16[_+1]=r,this.int16[_+2]=n,this.float32[A+2]=i,this.float32[A+3]=s,this.uint16[_+8]=a,this.uint16[_+9]=o,this.uint32[A+5]=l,this.uint32[A+6]=u,this.uint32[A+7]=c,this.uint16[_+16]=h,this.uint16[_+17]=p,this.uint16[_+18]=d,this.float32[A+10]=f,this.float32[A+11]=y,this.uint8[S+48]=m,this.uint8[S+49]=g,this.uint8[S+50]=x,this.uint32[A+13]=v,this.int16[_+28]=b,this.uint8[S+58]=w,t}}na.prototype.bytesPerElement=60,Ji(na,"StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");class ia extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m,g,x,v,b,w,_,A,S,k,I,M,T,z){const B=this.length;return this.resize(B+1),this.emplace(B,t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m,g,x,v,b,w,_,A,S,k,I,M,T,z)}emplace(t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m,g,x,v,b,w,_,A,S,k,I,M,T,z,B){const E=38*t,C=19*t;return this.int16[E+0]=e,this.int16[E+1]=r,this.int16[E+2]=n,this.float32[C+2]=i,this.float32[C+3]=s,this.int16[E+8]=a,this.int16[E+9]=o,this.int16[E+10]=l,this.int16[E+11]=u,this.int16[E+12]=c,this.int16[E+13]=h,this.uint16[E+14]=p,this.uint16[E+15]=d,this.uint16[E+16]=f,this.uint16[E+17]=y,this.uint16[E+18]=m,this.uint16[E+19]=g,this.uint16[E+20]=x,this.uint16[E+21]=v,this.uint16[E+22]=b,this.uint16[E+23]=w,this.uint16[E+24]=_,this.uint16[E+25]=A,this.uint16[E+26]=S,this.uint16[E+27]=k,this.uint16[E+28]=I,this.uint32[C+15]=M,this.float32[C+16]=T,this.float32[C+17]=z,this.float32[C+18]=B,t}}ia.prototype.bytesPerElement=76,Ji(ia,"StructArrayLayout3i2f6i15ui1ul3f76");class sa extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t){const e=this.length;return this.resize(e+1),this.emplace(e,t)}emplace(t,e){return this.float32[1*t+0]=e,t}}sa.prototype.bytesPerElement=4,Ji(sa,"StructArrayLayout1f4");class aa extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i){const s=this.length;return this.resize(s+1),this.emplace(s,t,e,r,n,i)}emplace(t,e,r,n,i,s){const a=5*t;return this.float32[a+0]=e,this.float32[a+1]=r,this.float32[a+2]=n,this.float32[a+3]=i,this.float32[a+4]=s,t}}aa.prototype.bytesPerElement=20,Ji(aa,"StructArrayLayout5f20");class oa extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const s=6*t;return this.uint32[3*t+0]=e,this.uint16[s+2]=r,this.uint16[s+3]=n,this.uint16[s+4]=i,t}}oa.prototype.bytesPerElement=12,Ji(oa,"StructArrayLayout1ul3ui12");class la extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e){const r=this.length;return this.resize(r+1),this.emplace(r,t,e)}emplace(t,e,r){const n=2*t;return this.uint16[n+0]=e,this.uint16[n+1]=r,t}}la.prototype.bytesPerElement=4,Ji(la,"StructArrayLayout2ui4");class ua extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t){const e=this.length;return this.resize(e+1),this.emplace(e,t)}emplace(t,e){return this.uint16[1*t+0]=e,t}}ua.prototype.bytesPerElement=2,Ji(ua,"StructArrayLayout1ui2");class ca extends Fs{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e){const r=this.length;return this.resize(r+1),this.emplace(r,t,e)}emplace(t,e,r){const n=2*t;return this.float32[n+0]=e,this.float32[n+1]=r,t}}ca.prototype.bytesPerElement=8,Ji(ca,"StructArrayLayout2f8");class ha extends Ls{get projectedAnchorX(){return this._structArray.int16[this._pos2+0]}get projectedAnchorY(){return this._structArray.int16[this._pos2+1]}get projectedAnchorZ(){return this._structArray.int16[this._pos2+2]}get tileAnchorX(){return this._structArray.int16[this._pos2+3]}get tileAnchorY(){return this._structArray.int16[this._pos2+4]}get x1(){return this._structArray.float32[this._pos4+3]}get y1(){return this._structArray.float32[this._pos4+4]}get x2(){return this._structArray.float32[this._pos4+5]}get y2(){return this._structArray.float32[this._pos4+6]}get padding(){return this._structArray.int16[this._pos2+14]}get featureIndex(){return this._structArray.uint32[this._pos4+8]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+18]}get bucketIndex(){return this._structArray.uint16[this._pos2+19]}}ha.prototype.size=40;class pa extends Ys{get(t){return new ha(this,t)}}Ji(pa,"CollisionBoxArray");class da extends Ls{get projectedAnchorX(){return this._structArray.int16[this._pos2+0]}get projectedAnchorY(){return this._structArray.int16[this._pos2+1]}get projectedAnchorZ(){return this._structArray.int16[this._pos2+2]}get tileAnchorX(){return this._structArray.float32[this._pos4+2]}get tileAnchorY(){return this._structArray.float32[this._pos4+3]}get glyphStartIndex(){return this._structArray.uint16[this._pos2+8]}get numGlyphs(){return this._structArray.uint16[this._pos2+9]}get vertexStartIndex(){return this._structArray.uint32[this._pos4+5]}get lineStartIndex(){return this._structArray.uint32[this._pos4+6]}get lineLength(){return this._structArray.uint32[this._pos4+7]}get segment(){return this._structArray.uint16[this._pos2+16]}get lowerSize(){return this._structArray.uint16[this._pos2+17]}get upperSize(){return this._structArray.uint16[this._pos2+18]}get lineOffsetX(){return this._structArray.float32[this._pos4+10]}get lineOffsetY(){return this._structArray.float32[this._pos4+11]}get writingMode(){return this._structArray.uint8[this._pos1+48]}get placedOrientation(){return this._structArray.uint8[this._pos1+49]}set placedOrientation(t){this._structArray.uint8[this._pos1+49]=t;}get hidden(){return this._structArray.uint8[this._pos1+50]}set hidden(t){this._structArray.uint8[this._pos1+50]=t;}get crossTileID(){return this._structArray.uint32[this._pos4+13]}set crossTileID(t){this._structArray.uint32[this._pos4+13]=t;}get associatedIconIndex(){return this._structArray.int16[this._pos2+28]}get flipState(){return this._structArray.uint8[this._pos1+58]}set flipState(t){this._structArray.uint8[this._pos1+58]=t;}}da.prototype.size=60;class fa extends na{get(t){return new da(this,t)}}Ji(fa,"PlacedSymbolArray");class ya extends Ls{get projectedAnchorX(){return this._structArray.int16[this._pos2+0]}get projectedAnchorY(){return this._structArray.int16[this._pos2+1]}get projectedAnchorZ(){return this._structArray.int16[this._pos2+2]}get tileAnchorX(){return this._structArray.float32[this._pos4+2]}get tileAnchorY(){return this._structArray.float32[this._pos4+3]}get rightJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+8]}get centerJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+9]}get leftJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+10]}get verticalPlacedTextSymbolIndex(){return this._structArray.int16[this._pos2+11]}get placedIconSymbolIndex(){return this._structArray.int16[this._pos2+12]}get verticalPlacedIconSymbolIndex(){return this._structArray.int16[this._pos2+13]}get key(){return this._structArray.uint16[this._pos2+14]}get textBoxStartIndex(){return this._structArray.uint16[this._pos2+15]}get textBoxEndIndex(){return this._structArray.uint16[this._pos2+16]}get verticalTextBoxStartIndex(){return this._structArray.uint16[this._pos2+17]}get verticalTextBoxEndIndex(){return this._structArray.uint16[this._pos2+18]}get iconBoxStartIndex(){return this._structArray.uint16[this._pos2+19]}get iconBoxEndIndex(){return this._structArray.uint16[this._pos2+20]}get verticalIconBoxStartIndex(){return this._structArray.uint16[this._pos2+21]}get verticalIconBoxEndIndex(){return this._structArray.uint16[this._pos2+22]}get featureIndex(){return this._structArray.uint16[this._pos2+23]}get numHorizontalGlyphVertices(){return this._structArray.uint16[this._pos2+24]}get numVerticalGlyphVertices(){return this._structArray.uint16[this._pos2+25]}get numIconVertices(){return this._structArray.uint16[this._pos2+26]}get numVerticalIconVertices(){return this._structArray.uint16[this._pos2+27]}get useRuntimeCollisionCircles(){return this._structArray.uint16[this._pos2+28]}get crossTileID(){return this._structArray.uint32[this._pos4+15]}set crossTileID(t){this._structArray.uint32[this._pos4+15]=t;}get textOffset0(){return this._structArray.float32[this._pos4+16]}get textOffset1(){return this._structArray.float32[this._pos4+17]}get collisionCircleDiameter(){return this._structArray.float32[this._pos4+18]}}ya.prototype.size=76;class ma extends ia{get(t){return new ya(this,t)}}Ji(ma,"SymbolInstanceArray");class ga extends sa{getoffsetX(t){return this.float32[1*t+0]}}Ji(ga,"GlyphOffsetArray");class xa extends $s{getx(t){return this.int16[2*t+0]}gety(t){return this.int16[2*t+1]}}Ji(xa,"SymbolLineVertexArray");class va extends Ls{get featureIndex(){return this._structArray.uint32[this._pos4+0]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+2]}get bucketIndex(){return this._structArray.uint16[this._pos2+3]}get layoutVertexArrayOffset(){return this._structArray.uint16[this._pos2+4]}}va.prototype.size=12;class ba extends oa{get(t){return new va(this,t)}}Ji(ba,"FeatureIndexArray");class wa extends la{geta_centroid_pos0(t){return this.uint16[2*t+0]}geta_centroid_pos1(t){return this.uint16[2*t+1]}}Ji(wa,"FillExtrusionCentroidArray");const _a=Rs([{name:"a_pattern",components:4,type:"Uint16"},{name:"a_pixel_ratio",components:1,type:"Float32"}]),Aa=Rs([{name:"a_dash",components:4,type:"Uint16"}]);var Sa={exports:{}},ka={exports:{}};ka.exports=function(t,e){var r,n,i,s,a,o,l,u;for(n=t.length-(r=3&t.length),i=e,a=3432918353,o=461845907,u=0;u<n;)l=255&t.charCodeAt(u)|(255&t.charCodeAt(++u))<<8|(255&t.charCodeAt(++u))<<16|(255&t.charCodeAt(++u))<<24,++u,i=27492+(65535&(s=5*(65535&(i=(i^=l=(65535&(l=(l=(65535&l)*a+(((l>>>16)*a&65535)<<16)&4294967295)<<15|l>>>17))*o+(((l>>>16)*o&65535)<<16)&4294967295)<<13|i>>>19))+((5*(i>>>16)&65535)<<16)&4294967295))+((58964+(s>>>16)&65535)<<16);switch(l=0,r){case 3:l^=(255&t.charCodeAt(u+2))<<16;case 2:l^=(255&t.charCodeAt(u+1))<<8;case 1:i^=l=(65535&(l=(l=(65535&(l^=255&t.charCodeAt(u)))*a+(((l>>>16)*a&65535)<<16)&4294967295)<<15|l>>>17))*o+(((l>>>16)*o&65535)<<16)&4294967295;}return i^=t.length,i=2246822507*(65535&(i^=i>>>16))+((2246822507*(i>>>16)&65535)<<16)&4294967295,i=3266489909*(65535&(i^=i>>>13))+((3266489909*(i>>>16)&65535)<<16)&4294967295,(i^=i>>>16)>>>0};var Ia=ka.exports,Ma={exports:{}};Ma.exports=function(t,e){for(var r,n=t.length,i=e^n,s=0;n>=4;)r=1540483477*(65535&(r=255&t.charCodeAt(s)|(255&t.charCodeAt(++s))<<8|(255&t.charCodeAt(++s))<<16|(255&t.charCodeAt(++s))<<24))+((1540483477*(r>>>16)&65535)<<16),i=1540483477*(65535&i)+((1540483477*(i>>>16)&65535)<<16)^(r=1540483477*(65535&(r^=r>>>24))+((1540483477*(r>>>16)&65535)<<16)),n-=4,++s;switch(n){case 3:i^=(255&t.charCodeAt(s+2))<<16;case 2:i^=(255&t.charCodeAt(s+1))<<8;case 1:i=1540483477*(65535&(i^=255&t.charCodeAt(s)))+((1540483477*(i>>>16)&65535)<<16);}return i=1540483477*(65535&(i^=i>>>13))+((1540483477*(i>>>16)&65535)<<16),(i^=i>>>15)>>>0};var Ta=Ia,za=Ma.exports;Sa.exports=Ta,Sa.exports.murmur3=Ta,Sa.exports.murmur2=za;var Ba=p(Sa.exports);class Ea{constructor(){this.ids=[],this.positions=[],this.indexed=!1;}add(t,e,r,n){this.ids.push(Ca(t)),this.positions.push(e,r,n);}getPositions(t){const e=Ca(t);let r=0,n=this.ids.length-1;for(;r<n;){const t=r+n>>1;this.ids[t]>=e?n=t:r=t+1;}const i=[];for(;this.ids[r]===e;)i.push({index:this.positions[3*r],start:this.positions[3*r+1],end:this.positions[3*r+2]}),r++;return i}static serialize(t,e){const r=new Float64Array(t.ids),n=new Uint32Array(t.positions);return Pa(r,n,0,r.length-1),e&&e.push(r.buffer,n.buffer),{ids:r,positions:n}}static deserialize(t){const e=new Ea;return e.ids=t.ids,e.positions=t.positions,e.indexed=!0,e}}function Ca(t){const e=+t;return !isNaN(e)&&Number.MIN_SAFE_INTEGER<=e&&e<=Number.MAX_SAFE_INTEGER?e:Ba(String(t))}function Pa(t,e,r,n){for(;r<n;){const i=t[r+n>>1];let s=r-1,a=n+1;for(;;){do{s++;}while(t[s]<i);do{a--;}while(t[a]>i);if(s>=a)break;Da(t,s,a),Da(e,3*s,3*a),Da(e,3*s+1,3*a+1),Da(e,3*s+2,3*a+2);}a-r<n-a?(Pa(t,e,r,a),r=a+1):(Pa(t,e,a+1,n),n=a);}}function Da(t,e,r){const n=t[e];t[e]=t[r],t[r]=n;}Ji(Ea,"FeaturePositionMap");class Va{constructor(t){this.gl=t.gl,this.initialized=!1;}fetchUniformLocation(t,e){return this.location||this.initialized||(this.location=this.gl.getUniformLocation(t,e),this.initialized=!0),!!this.location}}class La extends Va{constructor(t){super(t),this.current=0;}set(t,e,r){this.fetchUniformLocation(t,e)&&this.current!==r&&(this.current=r,this.gl.uniform1f(this.location,r));}}class Fa extends Va{constructor(t){super(t),this.current=[0,0,0,0];}set(t,e,r){this.fetchUniformLocation(t,e)&&(r[0]===this.current[0]&&r[1]===this.current[1]&&r[2]===this.current[2]&&r[3]===this.current[3]||(this.current=r,this.gl.uniform4f(this.location,r[0],r[1],r[2],r[3])));}}class Ra extends Va{constructor(t){super(t),this.current=Ee.transparent;}set(t,e,r){this.fetchUniformLocation(t,e)&&(r.r===this.current.r&&r.g===this.current.g&&r.b===this.current.b&&r.a===this.current.a||(this.current=r,this.gl.uniform4f(this.location,r.r,r.g,r.b,r.a)));}}const Ua=new Float32Array(16),$a=new Float32Array(9),ja=new Float32Array(4);function Oa(t){return [Ds(255*t.r,255*t.g),Ds(255*t.b,255*t.a)]}class qa{constructor(t,e,r){this.value=t,this.uniformNames=e.map((t=>`u_${t}`)),this.type=r;}setUniform(t,e,r,n,i){e.set(t,i,n.constantOr(this.value));}getBinding(t,e){return "color"===this.type?new Ra(t):new La(t)}}class Na{constructor(t,e){this.uniformNames=e.map((t=>`u_${t}`)),this.pattern=null,this.pixelRatio=1;}setConstantPatternPositions(t){this.pixelRatio=t.pixelRatio||1,this.pattern=t.tl.concat(t.br);}setUniform(t,e,r,n,i){const s="u_pattern"===i||"u_dash"===i?this.pattern:"u_pixel_ratio"===i?this.pixelRatio:null;s&&e.set(t,i,s);}getBinding(t,e){return "u_pattern"===e||"u_dash"===e?new Fa(t):new La(t)}}class Ga{constructor(t,e,r,n){this.expression=t,this.type=r,this.maxValue=0,this.paintVertexAttributes=e.map((t=>({name:`a_${t}`,type:"Float32",components:"color"===r?2:1,offset:0}))),this.paintVertexArray=new n;}populatePaintArray(t,e,r,n,i,s){const a=this.paintVertexArray.length,o=this.expression.evaluate(new ws(0),e,{},i,n,s);this.paintVertexArray.resize(t),this._setPaintValue(a,t,o);}updatePaintArray(t,e,r,n,i){const s=this.expression.evaluate({zoom:0},r,n,void 0,i);this._setPaintValue(t,e,s);}_setPaintValue(t,e,r){if("color"===this.type){const n=Oa(r);for(let r=t;r<e;r++)this.paintVertexArray.emplace(r,n[0],n[1]);}else {for(let n=t;n<e;n++)this.paintVertexArray.emplace(n,r);this.maxValue=Math.max(this.maxValue,Math.abs(r));}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();}}class Za{constructor(t,e,r,n,i,s){this.expression=t,this.uniformNames=e.map((t=>`u_${t}_t`)),this.type=r,this.useIntegerZoom=n,this.zoom=i,this.maxValue=0,this.paintVertexAttributes=e.map((t=>({name:`a_${t}`,type:"Float32",components:"color"===r?4:2,offset:0}))),this.paintVertexArray=new s;}populatePaintArray(t,e,r,n,i,s){const a=this.expression.evaluate(new ws(this.zoom),e,{},i,n,s),o=this.expression.evaluate(new ws(this.zoom+1),e,{},i,n,s),l=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValue(l,t,a,o);}updatePaintArray(t,e,r,n,i){const s=this.expression.evaluate({zoom:this.zoom},r,n,void 0,i),a=this.expression.evaluate({zoom:this.zoom+1},r,n,void 0,i);this._setPaintValue(t,e,s,a);}_setPaintValue(t,e,r,n){if("color"===this.type){const i=Oa(r),s=Oa(n);for(let r=t;r<e;r++)this.paintVertexArray.emplace(r,i[0],i[1],s[0],s[1]);}else {for(let i=t;i<e;i++)this.paintVertexArray.emplace(i,r,n);this.maxValue=Math.max(this.maxValue,Math.abs(r),Math.abs(n));}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();}setUniform(t,e,r,n,i){const s=this.useIntegerZoom?Math.floor(r.zoom):r.zoom,a=M(this.expression.interpolationFactor(s,this.zoom,this.zoom+1),0,1);e.set(t,i,a);}getBinding(t,e){return new La(t)}}class Ka{constructor(t,e,r,n,i){this.expression=t,this.layerId=i,this.paintVertexAttributes=("array"===r?Aa:_a).members;for(let t=0;t<e.length;++t);this.paintVertexArray=new n;}populatePaintArray(t,e,r){const n=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValues(n,t,e.patterns&&e.patterns[this.layerId],r);}updatePaintArray(t,e,r,n,i,s){this._setPaintValues(t,e,r.patterns&&r.patterns[this.layerId],s);}_setPaintValues(t,e,r,n){if(!n||!r)return;const i=n[r];if(!i)return;const{tl:s,br:a,pixelRatio:o}=i;for(let r=t;r<e;r++)this.paintVertexArray.emplace(r,s[0],s[1],a[0],a[1],o);}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();}}class Xa{constructor(t,e,r=(()=>!0)){this.binders={},this._buffers=[];const n=[];for(const i in t.paint._values){if(!r(i))continue;const s=t.paint.get(i);if(!(s instanceof Ts&&Ln(s.property.specification)))continue;const a=Ya(i,t.type),o=s.value,l=s.property.specification.type,u=!!s.property.useIntegerZoom,c="line-dasharray"===i||i.endsWith("pattern"),h="line-dasharray"===i&&"constant"!==t.layout.get("line-cap").value.kind;if("constant"!==o.kind||h)if("source"===o.kind||h||c){const e=to(i,l,"source");this.binders[i]=c?new Ka(o,a,l,e,t.id):new Ga(o,a,l,e),n.push(`/a_${i}`);}else {const t=to(i,l,"composite");this.binders[i]=new Za(o,a,l,u,e,t),n.push(`/z_${i}`);}else this.binders[i]=c?new Na(o.value,a):new qa(o.value,a,l),n.push(`/u_${i}`);}this.cacheKey=n.sort().join("");}getMaxValue(t){const e=this.binders[t];return e instanceof Ga||e instanceof Za?e.maxValue:0}populatePaintArrays(t,e,r,n,i,s){for(const a in this.binders){const o=this.binders[a];(o instanceof Ga||o instanceof Za||o instanceof Ka)&&o.populatePaintArray(t,e,r,n,i,s);}}setConstantPatternPositions(t){for(const e in this.binders){const r=this.binders[e];r instanceof Na&&r.setConstantPatternPositions(t);}}updatePaintArrays(t,e,r,n,i,s){let a=!1;for(const o in t){const l=e.getPositions(o);for(const e of l){const l=r.feature(e.index);for(const r in this.binders){const u=this.binders[r];if((u instanceof Ga||u instanceof Za||u instanceof Ka)&&!0===u.expression.isStateDependent){const c=n.paint.get(r);u.expression=c.value,u.updatePaintArray(e.start,e.end,l,t[o],i,s),a=!0;}}}}return a}defines(){const t=[];for(const e in this.binders){const r=this.binders[e];(r instanceof qa||r instanceof Na)&&t.push(...r.uniformNames.map((t=>`#define HAS_UNIFORM_${t}`)));}return t}getBinderAttributes(){const t=[];for(const e in this.binders){const r=this.binders[e];if(r instanceof Ga||r instanceof Za||r instanceof Ka)for(let e=0;e<r.paintVertexAttributes.length;e++)t.push(r.paintVertexAttributes[e].name);}return t}getBinderUniforms(){const t=[];for(const e in this.binders){const r=this.binders[e];if(r instanceof qa||r instanceof Na||r instanceof Za)for(const e of r.uniformNames)t.push(e);}return t}getPaintVertexBuffers(){return this._buffers}getUniforms(t){const e=[];for(const r in this.binders){const n=this.binders[r];if(n instanceof qa||n instanceof Na||n instanceof Za)for(const i of n.uniformNames)e.push({name:i,property:r,binding:n.getBinding(t,i)});}return e}setUniforms(t,e,r,n,i){for(const{name:e,property:s,binding:a}of r)this.binders[s].setUniform(t,a,i,n.get(s),e);}updatePaintBuffers(){this._buffers=[];for(const t in this.binders){const e=this.binders[t];(e instanceof Ga||e instanceof Za||e instanceof Ka)&&e.paintVertexBuffer&&this._buffers.push(e.paintVertexBuffer);}}upload(t){for(const e in this.binders){const r=this.binders[e];(r instanceof Ga||r instanceof Za||r instanceof Ka)&&r.upload(t);}this.updatePaintBuffers();}destroy(){for(const t in this.binders){const e=this.binders[t];(e instanceof Ga||e instanceof Za||e instanceof Ka)&&e.destroy();}}}class Ja{constructor(t,e,r=(()=>!0)){this.programConfigurations={};for(const n of t)this.programConfigurations[n.id]=new Xa(n,e,r);this.needsUpload=!1,this._featureMap=new Ea,this._bufferOffset=0;}populatePaintArrays(t,e,r,n,i,s,a){for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t,e,n,i,s,a);void 0!==e.id&&this._featureMap.add(e.id,r,this._bufferOffset,t),this._bufferOffset=t,this.needsUpload=!0;}updatePaintArrays(t,e,r,n,i){for(const s of r)this.needsUpload=this.programConfigurations[s.id].updatePaintArrays(t,this._featureMap,e,s,n,i)||this.needsUpload;}get(t){return this.programConfigurations[t]}upload(t){if(this.needsUpload){for(const e in this.programConfigurations)this.programConfigurations[e].upload(t);this.needsUpload=!1;}}destroy(){for(const t in this.programConfigurations)this.programConfigurations[t].destroy();}}const Ha={"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern","pixel_ratio"],"fill-pattern":["pattern","pixel_ratio"],"fill-extrusion-pattern":["pattern","pixel_ratio"],"line-dasharray":["dash"]};function Ya(t,e){return Ha[t]||[t.replace(`${e}-`,"").replace(/-/g,"_")]}const Wa={"line-pattern":{source:Gs,composite:Gs},"fill-pattern":{source:Gs,composite:Gs},"fill-extrusion-pattern":{source:Gs,composite:Gs},"line-dasharray":{source:Zs,composite:Zs}},Qa={color:{source:ca,composite:Ns},number:{source:sa,composite:ca}};function to(t,e,r){const n=Wa[t];return n&&n[r]||Qa[e][r]}Ji(qa,"ConstantBinder"),Ji(Na,"PatternConstantBinder"),Ji(Ga,"SourceExpressionBinder"),Ji(Ka,"PatternCompositeBinder"),Ji(Za,"CompositeExpressionBinder"),Ji(Xa,"ProgramConfiguration",{omit:["_buffers"]}),Ji(Ja,"ProgramConfigurationSet");const eo="-transition";class ro extends Qt{constructor(t,e){if(super(),this.id=t.id,this.type=t.type,this._featureFilter={filter:()=>!0,needGeometry:!1,needFeature:!1},this._filterCompiled=!1,"custom"!==t.type&&(this.metadata=t.metadata,this.minzoom=t.minzoom,this.maxzoom=t.maxzoom,"background"!==t.type&&"sky"!==t.type&&(this.source=t.source,this.sourceLayer=t["source-layer"],this.filter=t.filter),e.layout&&(this._unevaluatedLayout=new Ms(e.layout)),e.paint)){this._transitionablePaint=new Ss(e.paint);for(const e in t.paint)this.setPaintProperty(e,t.paint[e],{validate:!1});for(const e in t.layout)this.setLayoutProperty(e,t.layout[e],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new zs(e.paint);}}getLayoutProperty(t){return "visibility"===t?this.visibility:this._unevaluatedLayout.getValue(t)}setLayoutProperty(t,e,r={}){null!=e&&this._validate(ji,`layers.${this.id}.layout.${t}`,t,e,r)||("visibility"!==t?this._unevaluatedLayout.setValue(t,e):this.visibility=e);}getPaintProperty(t){return U(t,eo)?this._transitionablePaint.getTransition(t.slice(0,-11)):this._transitionablePaint.getValue(t)}setPaintProperty(t,e,r={}){if(null!=e&&this._validate($i,`layers.${this.id}.paint.${t}`,t,e,r))return !1;if(U(t,eo))return this._transitionablePaint.setTransition(t.slice(0,-11),e||void 0),!1;{const r=this._transitionablePaint._values[t],n=r.value.isDataDriven(),i=r.value;this._transitionablePaint.setValue(t,e),this._handleSpecialPaintPropertyUpdate(t);const s=this._transitionablePaint._values[t].value,a=s.isDataDriven(),o=U(t,"pattern")||"line-dasharray"===t;return a||n||o||this._handleOverridablePaintPropertyUpdate(t,i,s)}}_handleSpecialPaintPropertyUpdate(t){}getProgramIds(){return null}getProgramConfiguration(t){return null}_handleOverridablePaintPropertyUpdate(t,e,r){return !1}isHidden(t){return !!(this.minzoom&&t<this.minzoom)||!!(this.maxzoom&&t>=this.maxzoom)||"none"===this.visibility}updateTransitions(t){this._transitioningPaint=this._transitionablePaint.transitioned(t,this._transitioningPaint);}hasTransition(){return this._transitioningPaint.hasTransition()}recalculate(t,e){this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(t,void 0,e)),this.paint=this._transitioningPaint.possiblyEvaluate(t,void 0,e);}serialize(){const t={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(t.layout=t.layout||{},t.layout.visibility=this.visibility),j(t,((t,e)=>!(void 0===t||"layout"===e&&!Object.keys(t).length||"paint"===e&&!Object.keys(t).length)))}_validate(t,e,r,n,i={}){return (!i||!1!==i.validate)&&qi(this,t.call(Ui,{key:e,layerType:this.type,objectKey:r,value:n,styleSpec:te,style:{glyphs:!0,sprite:!0}}))}is3D(){return !1}isSky(){return !1}isTileClipped(){return !1}hasOffscreenPass(){return !1}resize(){}isStateDependent(){for(const t in this.paint._values){const e=this.paint.get(t);if(e instanceof Ts&&Ln(e.property.specification)&&("source"===e.value.kind||"composite"===e.value.kind)&&e.value.isStateDependent)return !0}return !1}compileFilter(){this._filterCompiled||(this._featureFilter=hi(this.filter),this._filterCompiled=!0);}invalidateCompiledFilter(){this._filterCompiled=!1;}dynamicFilter(){return this._featureFilter.dynamicFilter}dynamicFilterNeedsFeature(){return this._featureFilter.needFeature}}const no=Rs([{name:"a_pos",components:2,type:"Int16"}],4),io=Rs([{name:"a_pos_3",components:3,type:"Int16"},{name:"a_pos_normal_3",components:3,type:"Int16"}]);class so{constructor(t=[]){this.segments=t;}prepareSegment(t,e,r,n){let i=this.segments[this.segments.length-1];return t>so.MAX_VERTEX_ARRAY_LENGTH&&N(`Max vertices per segment is ${so.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`),(!i||i.vertexLength+t>so.MAX_VERTEX_ARRAY_LENGTH||i.sortKey!==n)&&(i={vertexOffset:e.length,primitiveOffset:r.length,vertexLength:0,primitiveLength:0},void 0!==n&&(i.sortKey=n),this.segments.push(i)),i}get(){return this.segments}destroy(){for(const t of this.segments)for(const e in t.vaos)t.vaos[e].destroy();}static simpleSegment(t,e,r,n){return new so([{vertexOffset:t,primitiveOffset:e,vertexLength:r,primitiveLength:n,vaos:{},sortKey:0}])}}so.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1,Ji(so,"SegmentVector");var ao=8192;class oo{constructor(t,e){t&&(e?this.setSouthWest(t).setNorthEast(e):4===t.length?this.setSouthWest([t[0],t[1]]).setNorthEast([t[2],t[3]]):this.setSouthWest(t[0]).setNorthEast(t[1]));}setNorthEast(t){return this._ne=t instanceof Ol?new Ol(t.lng,t.lat):Ol.convert(t),this}setSouthWest(t){return this._sw=t instanceof Ol?new Ol(t.lng,t.lat):Ol.convert(t),this}extend(t){const e=this._sw,r=this._ne;let n,i;if(t instanceof Ol)n=t,i=t;else {if(!(t instanceof oo))return Array.isArray(t)?4===t.length||t.every(Array.isArray)?this.extend(oo.convert(t)):this.extend(Ol.convert(t)):"object"==typeof t&&null!==t&&t.hasOwnProperty("lat")&&(t.hasOwnProperty("lon")||t.hasOwnProperty("lng"))?this.extend(Ol.convert(t)):this;if(n=t._sw,i=t._ne,!n||!i)return this}return e||r?(e.lng=Math.min(n.lng,e.lng),e.lat=Math.min(n.lat,e.lat),r.lng=Math.max(i.lng,r.lng),r.lat=Math.max(i.lat,r.lat)):(this._sw=new Ol(n.lng,n.lat),this._ne=new Ol(i.lng,i.lat)),this}getCenter(){return new Ol((this._sw.lng+this._ne.lng)/2,(this._sw.lat+this._ne.lat)/2)}getSouthWest(){return this._sw}getNorthEast(){return this._ne}getNorthWest(){return new Ol(this.getWest(),this.getNorth())}getSouthEast(){return new Ol(this.getEast(),this.getSouth())}getWest(){return this._sw.lng}getSouth(){return this._sw.lat}getEast(){return this._ne.lng}getNorth(){return this._ne.lat}toArray(){return [this._sw.toArray(),this._ne.toArray()]}toString(){return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`}isEmpty(){return !(this._sw&&this._ne)}contains(t){const{lng:e,lat:r}=Ol.convert(t);let n=this._sw.lng<=e&&e<=this._ne.lng;return this._sw.lng>this._ne.lng&&(n=this._sw.lng>=e&&e>=this._ne.lng),this._sw.lat<=r&&r<=this._ne.lat&&n}static convert(t){return !t||t instanceof oo?t:new oo(t)}}var lo=1e-6,uo="undefined"!=typeof Float32Array?Float32Array:Array;function co(){var t=new uo(9);return uo!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function ho(t,e,r){var n=e[0],i=e[1],s=e[2],a=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=r[0],d=r[1],f=r[2],y=r[3],m=r[4],g=r[5],x=r[6],v=r[7],b=r[8];return t[0]=p*n+d*a+f*u,t[1]=p*i+d*o+f*c,t[2]=p*s+d*l+f*h,t[3]=y*n+m*a+g*u,t[4]=y*i+m*o+g*c,t[5]=y*s+m*l+g*h,t[6]=x*n+v*a+b*u,t[7]=x*i+v*o+b*c,t[8]=x*s+v*l+b*h,t}function po(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fo(t,e){var r=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8],h=e[9],p=e[10],d=e[11],f=e[12],y=e[13],m=e[14],g=e[15],x=r*o-n*a,v=r*l-i*a,b=r*u-s*a,w=n*l-i*o,_=n*u-s*o,A=i*u-s*l,S=c*y-h*f,k=c*m-p*f,I=c*g-d*f,M=h*m-p*y,T=h*g-d*y,z=p*g-d*m,B=x*z-v*T+b*M+w*I-_*k+A*S;return B?(t[0]=(o*z-l*T+u*M)*(B=1/B),t[1]=(i*T-n*z-s*M)*B,t[2]=(y*A-m*_+g*w)*B,t[3]=(p*_-h*A-d*w)*B,t[4]=(l*I-a*z-u*k)*B,t[5]=(r*z-i*I+s*k)*B,t[6]=(m*b-f*A-g*v)*B,t[7]=(c*A-p*b+d*v)*B,t[8]=(a*T-o*I+u*S)*B,t[9]=(n*I-r*T-s*S)*B,t[10]=(f*_-y*b+g*x)*B,t[11]=(h*b-c*_-d*x)*B,t[12]=(o*k-a*M-l*S)*B,t[13]=(r*M-n*k+i*S)*B,t[14]=(y*v-f*w-m*x)*B,t[15]=(c*w-h*v+p*x)*B,t):null}function yo(t,e,r){var n=e[0],i=e[1],s=e[2],a=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=e[9],d=e[10],f=e[11],y=e[12],m=e[13],g=e[14],x=e[15],v=r[0],b=r[1],w=r[2],_=r[3];return t[0]=v*n+b*o+w*h+_*y,t[1]=v*i+b*l+w*p+_*m,t[2]=v*s+b*u+w*d+_*g,t[3]=v*a+b*c+w*f+_*x,t[4]=(v=r[4])*n+(b=r[5])*o+(w=r[6])*h+(_=r[7])*y,t[5]=v*i+b*l+w*p+_*m,t[6]=v*s+b*u+w*d+_*g,t[7]=v*a+b*c+w*f+_*x,t[8]=(v=r[8])*n+(b=r[9])*o+(w=r[10])*h+(_=r[11])*y,t[9]=v*i+b*l+w*p+_*m,t[10]=v*s+b*u+w*d+_*g,t[11]=v*a+b*c+w*f+_*x,t[12]=(v=r[12])*n+(b=r[13])*o+(w=r[14])*h+(_=r[15])*y,t[13]=v*i+b*l+w*p+_*m,t[14]=v*s+b*u+w*d+_*g,t[15]=v*a+b*c+w*f+_*x,t}function mo(t,e,r){var n,i,s,a,o,l,u,c,h,p,d,f,y=r[0],m=r[1],g=r[2];return e===t?(t[12]=e[0]*y+e[4]*m+e[8]*g+e[12],t[13]=e[1]*y+e[5]*m+e[9]*g+e[13],t[14]=e[2]*y+e[6]*m+e[10]*g+e[14],t[15]=e[3]*y+e[7]*m+e[11]*g+e[15]):(i=e[1],s=e[2],a=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=e[9],d=e[10],f=e[11],t[0]=n=e[0],t[1]=i,t[2]=s,t[3]=a,t[4]=o,t[5]=l,t[6]=u,t[7]=c,t[8]=h,t[9]=p,t[10]=d,t[11]=f,t[12]=n*y+o*m+h*g+e[12],t[13]=i*y+l*m+p*g+e[13],t[14]=s*y+u*m+d*g+e[14],t[15]=a*y+c*m+f*g+e[15]),t}function go(t,e,r){var n=r[0],i=r[1],s=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*s,t[9]=e[9]*s,t[10]=e[10]*s,t[11]=e[11]*s,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function xo(t,e,r){var n=Math.sin(r),i=Math.cos(r),s=e[4],a=e[5],o=e[6],l=e[7],u=e[8],c=e[9],h=e[10],p=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=s*i+u*n,t[5]=a*i+c*n,t[6]=o*i+h*n,t[7]=l*i+p*n,t[8]=u*i-s*n,t[9]=c*i-a*n,t[10]=h*i-o*n,t[11]=p*i-l*n,t}function vo(t,e,r){var n=Math.sin(r),i=Math.cos(r),s=e[0],a=e[1],o=e[2],l=e[3],u=e[8],c=e[9],h=e[10],p=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*i-u*n,t[1]=a*i-c*n,t[2]=o*i-h*n,t[3]=l*i-p*n,t[8]=s*n+u*i,t[9]=a*n+c*i,t[10]=o*n+h*i,t[11]=l*n+p*i,t}function bo(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function wo(t,e,r){var n,i,s,a=r[0],o=r[1],l=r[2],u=Math.hypot(a,o,l);return u<lo?null:(a*=u=1/u,o*=u,l*=u,n=Math.sin(e),i=Math.cos(e),t[0]=a*a*(s=1-i)+i,t[1]=o*a*s+l*n,t[2]=l*a*s-o*n,t[3]=0,t[4]=a*o*s-l*n,t[5]=o*o*s+i,t[6]=l*o*s+a*n,t[7]=0,t[8]=a*l*s+o*n,t[9]=o*l*s-a*n,t[10]=l*l*s+i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var _o=yo;function Ao(){var t=new uo(3);return uo!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function So(t){var e=new uo(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function ko(t){return Math.hypot(t[0],t[1],t[2])}function Io(t,e,r){var n=new uo(3);return n[0]=t,n[1]=e,n[2]=r,n}function Mo(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t}function To(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t}function zo(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t}function Bo(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t}function Eo(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t}function Co(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t}function Po(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t}function Do(t,e){var r=e[0],n=e[1],i=e[2],s=r*r+n*n+i*i;return s>0&&(s=1/Math.sqrt(s)),t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t}function Vo(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function Lo(t,e,r){var n=e[0],i=e[1],s=e[2],a=r[0],o=r[1],l=r[2];return t[0]=i*l-s*o,t[1]=s*a-n*l,t[2]=n*o-i*a,t}function Fo(t,e,r){var n=e[0],i=e[1],s=e[2],a=r[3]*n+r[7]*i+r[11]*s+r[15];return t[0]=(r[0]*n+r[4]*i+r[8]*s+r[12])/(a=a||1),t[1]=(r[1]*n+r[5]*i+r[9]*s+r[13])/a,t[2]=(r[2]*n+r[6]*i+r[10]*s+r[14])/a,t}function Ro(t,e,r){var n=r[0],i=r[1],s=r[2],a=e[0],o=e[1],l=e[2],u=i*l-s*o,c=s*a-n*l,h=n*o-i*a,p=i*h-s*c,d=s*u-n*h,f=n*c-i*u,y=2*r[3];return c*=y,h*=y,d*=2,f*=2,t[0]=a+(u*=y)+(p*=2),t[1]=o+c+d,t[2]=l+h+f,t}var Uo,$o=To,jo=zo,Oo=ko;function qo(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function No(t,e){var r=e[0],n=e[1],i=e[2],s=e[3],a=r*r+n*n+i*i+s*s;return a>0&&(a=1/Math.sqrt(a)),t[0]=r*a,t[1]=n*a,t[2]=i*a,t[3]=s*a,t}function Go(t,e,r){var n=e[0],i=e[1],s=e[2],a=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*s+r[12]*a,t[1]=r[1]*n+r[5]*i+r[9]*s+r[13]*a,t[2]=r[2]*n+r[6]*i+r[10]*s+r[14]*a,t[3]=r[3]*n+r[7]*i+r[11]*s+r[15]*a,t}function Zo(){var t=new uo(4);return uo!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function Ko(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function Xo(t,e,r){r*=.5;var n=e[0],i=e[1],s=e[2],a=e[3],o=Math.sin(r),l=Math.cos(r);return t[0]=n*l+a*o,t[1]=i*l+s*o,t[2]=s*l-i*o,t[3]=a*l-n*o,t}function Jo(t,e,r){r*=.5;var n=e[0],i=e[1],s=e[2],a=e[3],o=Math.sin(r),l=Math.cos(r);return t[0]=n*l-s*o,t[1]=i*l+a*o,t[2]=s*l+n*o,t[3]=a*l-i*o,t}Ao(),Uo=new uo(4),uo!=Float32Array&&(Uo[0]=0,Uo[1]=0,Uo[2]=0,Uo[3]=0);var Ho=No;Ao(),Io(1,0,0),Io(0,1,0),Zo(),Zo(),co();const Yo=Rs([{type:"Float32",name:"a_globe_pos",components:3},{type:"Float32",name:"a_uv",components:2}]),{members:Wo}=Yo,Qo=Rs([{name:"a_pos_3",components:3,type:"Int16"}]);var tl=Rs([{name:"a_pos",type:"Int16",components:2}]);class el{constructor(t,e){this.pos=t,this.dir=e;}intersectsPlane(t,e,r){const n=Vo(e,this.dir);if(Math.abs(n)<1e-6)return !1;const i=((t[0]-this.pos[0])*e[0]+(t[1]-this.pos[1])*e[1]+(t[2]-this.pos[2])*e[2])/n;return r[0]=this.pos[0]+this.dir[0]*i,r[1]=this.pos[1]+this.dir[1]*i,r[2]=this.pos[2]+this.dir[2]*i,!0}closestPointOnSphere(t,e,r){if(function(t,e){var r=t[0],n=t[1],i=t[2],s=e[0],a=e[1],o=e[2];return Math.abs(r-s)<=lo*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(n-a)<=lo*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(i-o)<=lo*Math.max(1,Math.abs(i),Math.abs(o))}(this.pos,t)||0===e)return r[0]=r[1]=r[2]=0,!1;const[n,i,s]=this.dir,a=this.pos[0]-t[0],o=this.pos[1]-t[1],l=this.pos[2]-t[2],u=n*n+i*i+s*s,c=2*(a*n+o*i+l*s),h=c*c-4*u*(a*a+o*o+l*l-e*e);if(h<0){const t=Math.max(-c/2,0),u=a+n*t,h=o+i*t,p=l+s*t,d=Math.hypot(u,h,p);return r[0]=u*e/d,r[1]=h*e/d,r[2]=p*e/d,!1}{const t=(-c-Math.sqrt(h))/(2*u);if(t<0){const t=Math.hypot(a,o,l);return r[0]=a*e/t,r[1]=o*e/t,r[2]=l*e/t,!1}return r[0]=a+n*t,r[1]=o+i*t,r[2]=l+s*t,!0}}}class rl{constructor(t,e,r,n,i){this.TL=t,this.TR=e,this.BR=r,this.BL=n,this.horizon=i;}static fromInvProjectionMatrix(t,e,r){const n=[-1,1,1],i=[1,1,1],s=[1,-1,1],a=[-1,-1,1],o=Fo(n,n,t),l=Fo(i,i,t),u=Fo(s,s,t),c=Fo(a,a,t);return new rl(o,l,u,c,e/r)}}class nl{constructor(t,e){this.points=t,this.planes=e;}static fromInvProjectionMatrix(t,e,r,n){const i=Math.pow(2,r),s=[[-1,1,-1,1],[1,1,-1,1],[1,-1,-1,1],[-1,-1,-1,1],[-1,1,1,1],[1,1,1,1],[1,-1,1,1],[-1,-1,1,1]].map((r=>{const s=Go([],r,t),a=1/s[3]/e*i;return function(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t[3]=e[3]*r[3],t}(s,s,[a,a,n?1/s[3]:a,a])})),a=[[0,1,2],[6,5,4],[0,3,7],[2,1,5],[3,2,6],[0,4,5]].map((t=>{const e=Do([],Lo([],$o([],s[t[0]],s[t[1]]),$o([],s[t[2]],s[t[1]]))),r=-Vo(e,s[t[1]]);return e.concat(r)}));return new nl(s,a)}}class il{static fromPoints(t){const e=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0];for(const n of t)Bo(e,e,n),Eo(r,r,n);return new il(e,r)}static applyTransform(t,e){const r=t.getCorners();for(let t=0;t<r.length;++t)Fo(r[t],r[t],e);return il.fromPoints(r)}constructor(t,e){this.min=t,this.max=e,this.center=Co([],Mo([],this.min,this.max),.5);}quadrant(t){const e=[t%2==0,t<2],r=So(this.min),n=So(this.max);for(let t=0;t<e.length;t++)r[t]=e[t]?this.min[t]:this.center[t],n[t]=e[t]?this.center[t]:this.max[t];return n[2]=this.max[2],new il(r,n)}distanceX(t){return Math.max(Math.min(this.max[0],t[0]),this.min[0])-t[0]}distanceY(t){return Math.max(Math.min(this.max[1],t[1]),this.min[1])-t[1]}distanceZ(t){return Math.max(Math.min(this.max[2],t[2]),this.min[2])-t[2]}getCorners(){const t=this.min,e=this.max;return [[t[0],t[1],t[2]],[e[0],t[1],t[2]],[e[0],e[1],t[2]],[t[0],e[1],t[2]],[t[0],t[1],e[2]],[e[0],t[1],e[2]],[e[0],e[1],e[2]],[t[0],e[1],e[2]]]}intersects(t){const e=this.getCorners();let r=!0;for(let n=0;n<t.planes.length;n++){const i=t.planes[n];let s=0;for(let t=0;t<e.length;t++)s+=Vo(i,e[t])+i[3]>=0;if(0===s)return 0;s!==e.length&&(r=!1);}if(r)return 2;for(let e=0;e<3;e++){let r=Number.MAX_VALUE,n=-Number.MAX_VALUE;for(let i=0;i<t.points.length;i++){const s=t.points[i][e]-this.min[e];r=Math.min(r,s),n=Math.max(n,s);}if(n<0||r>this.max[e]-this.min[e])return 0}return 1}}const sl=5,al=6,ol=ao/Math.PI/2,ll=16383,ul=64,cl=[ul,32,16],hl=-ol,pl=ol,dl=[new il([hl,hl,hl],[pl,pl,pl]),new il([hl,hl,hl],[0,0,pl]),new il([0,hl,hl],[pl,0,pl]),new il([hl,0,hl],[0,pl,pl]),new il([0,0,hl],[pl,pl,pl])];function fl(t){return t*ol/Ul}function yl(t,e,r,n=!0){const i=Co([],t._camera.position,t.worldSize),s=[e,r,1,1];Go(s,s,t.pixelMatrixInverse),qo(s,s,1/s[3]);const a=Do([],$o([],s,i)),o=t.globeMatrix,l=[o[12],o[13],o[14]],u=$o([],l,i),c=ko(u),h=Do([],u),p=t.worldSize/(2*Math.PI),d=Vo(h,a),f=Math.asin(p/c);if(f<Math.acos(d)){if(!n)return null;const t=[],e=[];Co(t,a,c/d),Do(e,$o(e,t,u)),Do(a,Mo(a,u,Co(a,e,Math.tan(f)*c)));}const y=[];new el(i,a).closestPointOnSphere(l,p,y);const m=Do([],W(o,0)),g=Do([],W(o,1)),x=Do([],W(o,2)),v=Vo(m,y),b=Vo(g,y),w=Vo(x,y),A=_(Math.asin(-b/p));let S=_(Math.atan2(v,w));S=t.center.lng+function(t,e){const r=(e-t+180)%360-180;return r<-180?r+360:r}(t.center.lng,S);const k=Nl(S),I=M(Gl(A),0,1);return new Wl(k,I)}class ml{constructor(t,e,r){this.a=$o([],t,r),this.b=$o([],e,r),this.center=r;const n=Do([],this.a),i=Do([],this.b);this.angle=Math.acos(Vo(n,i));}}function gl(t,e){if(0===t.angle)return null;let r;return r=0===t.a[e]?1/t.angle*.5*Math.PI:1/t.angle*Math.atan(t.b[e]/t.a[e]/Math.sin(t.angle)-1/Math.tan(t.angle)),r<0||r>1?null:function(t,e,r,n){const i=Math.sin(r);return t*(Math.sin((1-n)*r)/i)+e*(Math.sin(n*r)/i)}(t.a[e],t.b[e],t.angle,M(r,0,1))+t.center[e]}function xl(t){if(t.z<=1)return dl[t.z+2*t.y+t.x];const e=Sl(Al(t));return il.fromPoints(e)}function vl(t,e,r){return Co(t,t,1-r),Po(t,t,e,r)}function bl(t,e){const r=Pl(e.zoom);if(0===r)return xl(t);const n=Al(t),i=Sl(n),s=Nl(n.getWest())*e.worldSize,a=Nl(n.getEast())*e.worldSize,o=Gl(n.getNorth())*e.worldSize,l=Gl(n.getSouth())*e.worldSize,u=[s,o,0],c=[a,o,0],h=[s,l,0],p=[a,l,0],d=fo([],e.globeMatrix);return Fo(u,u,d),Fo(c,c,d),Fo(h,h,d),Fo(p,p,d),i[0]=vl(i[0],h,r),i[1]=vl(i[1],p,r),i[2]=vl(i[2],c,r),i[3]=vl(i[3],u,r),il.fromPoints(i)}function wl(t,e,r){for(const n of t)Fo(n,n,e),Co(n,n,r);}function _l(t,e,r){const n=e/t.worldSize,i=t.globeMatrix;if(r.z<=1){const t=xl(r).getCorners();return wl(t,i,n),il.fromPoints(t)}const s=Al(r),a=Sl(s);wl(a,i,n);const o=Number.MAX_VALUE,l=[-o,-o,-o],u=[o,o,o];if(s.contains(t.center)){for(const t of a)Bo(u,u,t),Eo(l,l,t);l[2]=0;const e=t.point,r=[e.x*n,e.y*n,0];return Bo(u,u,r),Eo(l,l,r),new il(u,l)}const c=[i[12]*n,i[13]*n,i[14]*n],h=s.getCenter(),p=M(t.center.lat,-Hl,Hl),d=M(h.lat,-Hl,Hl),f=Nl(t.center.lng),y=Gl(p);let m=f-Nl(h.lng);const g=y-Gl(d);m>.5?m-=1:m<-.5&&(m+=1);let x=0;Math.abs(m)>Math.abs(g)?x=m>=0?1:3:(x=g>=0?0:2,Po(c,c,[i[4]*n,i[5]*n,i[6]*n],-Math.sin(w(g>=0?s.getSouth():s.getNorth()))*ol));const v=a[x],b=a[(x+1)%4],_=new ml(v,b,c),A=[gl(_,0)||v[0],gl(_,1)||v[1],gl(_,2)||v[2]],S=Pl(t.zoom);if(S>0){const n=function({x:t,y:e,z:r},n,i,s,a){const o=1/(1<<r);let l=t*o,u=l+o,c=e*o,h=c+o,p=0;const d=(l+u)/2-s;return d>.5?p=-1:d<-.5&&(p=1),l=((l+p)*n-(s*=n))*i+s,u=((u+p)*n-s)*i+s,c=(c*n-(a*=n))*i+a,h=(h*n-a)*i+a,[[l,h,0],[u,h,0],[u,c,0],[l,c,0]]}(r,e,t._pixelsPerMercatorPixel,f,y);for(let t=0;t<a.length;t++)vl(a[t],n[t],S);const i=Mo([],n[x],n[(x+1)%4]);Co(i,i,.5),vl(A,i,S);}for(const t of a)Bo(u,u,t),Eo(l,l,t);return u[2]=Math.min(v[2],b[2]),Bo(u,u,A),Eo(l,l,A),new il(u,l)}function Al({x:t,y:e,z:r}){const n=1/(1<<r),i=new Ol(Kl(t*n),Xl((e+1)*n)),s=new Ol(Kl((t+1)*n),Xl(e*n));return new oo(i,s)}function Sl(t){const e=w(t.getNorth()),r=w(t.getSouth()),n=Math.cos(e),i=Math.cos(r),s=Math.sin(e),a=Math.sin(r),o=t.getWest(),l=t.getEast();return [kl(i,a,o),kl(i,a,l),kl(n,s,l),kl(n,s,o)]}function kl(t,e,r,n=ol){return r=w(r),[t*Math.sin(r)*n,-e*n,t*Math.cos(r)*n]}function Il(t,e,r){return kl(Math.cos(w(t)),Math.sin(w(t)),e,r)}function Ml(t,e,r,n){const i=1<<r.z,s=(t/ao+r.x)/i;return Il(Xl((e/ao+r.y)/i),Kl(s),n)}function Tl({min:t,max:e}){return ll/Math.max(e[0]-t[0],e[1]-t[1],e[2]-t[2])}const zl=new Float64Array(16);function Bl(t){const e=Tl(t),r=bo(zl,[e,e,e]);return mo(r,r,((n=[])[0]=-(i=t.min)[0],n[1]=-i[1],n[2]=-i[2],n));var n,i;}function El(t){const e=(n=t.min,(r=zl)[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=n[0],r[13]=n[1],r[14]=n[2],r[15]=1,r);var r,n;const i=1/Tl(t);return go(e,e,[i,i,i])}function Cl(t,e,r,n,i){const s=function(t){const e=ao/(2*Math.PI);return t/(2*Math.PI)/e}(r),a=[t,e,-r/(2*Math.PI)],o=po(new Float64Array(16));return mo(o,o,a),go(o,o,[s,s,s]),xo(o,o,w(-i)),vo(o,o,w(-n)),o}function Pl(t){return T(sl,al,t)}function Dl(t,e){const r=Il(e.lat,e.lng),n=function(t){const e=Il(t._center.lat,t._center.lng);let r=Lo([],Io(0,1,0),e);const n=wo([],-t.angle,e);r=Fo(r,r,n),wo(n,-t._pitch,r);const i=Do([],e);return Co(i,i,fl(t.cameraToCenterDistance/t.pixelsPerMeter)),Fo(i,i,n),Mo([],e,i)}(t);return a=(i=To([],n,r))[0],o=i[1],l=i[2],u=(s=r)[0],c=s[1],h=s[2],d=(p=Math.sqrt(a*a+o*o+l*l)*Math.sqrt(u*u+c*c+h*h))&&Vo(i,s)/p,Math.acos(Math.min(Math.max(d,-1),1));var i,s,a,o,l,u,c,h,p,d;}function Vl(t,e){return Dl(t,e)>Math.PI/2*1.01}const Ll=w(85),Fl=Math.cos(Ll),Rl=Math.sin(Ll),Ul=6371008.8,$l=2*Math.PI*Ul;class jl{constructor(t,e){if(isNaN(t)||isNaN(e))throw new Error(`Invalid LngLat object: (${t}, ${e})`);if(this.lng=+t,this.lat=+e,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")}wrap(){return new jl(z(this.lng,-180,180),this.lat)}toArray(){return [this.lng,this.lat]}toString(){return `LngLat(${this.lng}, ${this.lat})`}distanceTo(t){const e=Math.PI/180,r=this.lat*e,n=t.lat*e,i=Math.sin(r)*Math.sin(n)+Math.cos(r)*Math.cos(n)*Math.cos((t.lng-this.lng)*e);return Ul*Math.acos(Math.min(i,1))}toBounds(t=0){const e=360*t/40075017,r=e/Math.cos(Math.PI/180*this.lat);return new oo(new jl(this.lng-r,this.lat-e),new jl(this.lng+r,this.lat+e))}toEcef(t){const e=fl(t);return Il(this.lat,this.lng,ol+e)}static convert(t){if(t instanceof jl)return t;if(Array.isArray(t)&&(2===t.length||3===t.length))return new jl(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&"object"==typeof t&&null!==t)return new jl(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")}}var Ol=jl;function ql(t){return $l*Math.cos(t*Math.PI/180)}function Nl(t){return (180+t)/360}function Gl(t){return (180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function Zl(t,e){return t/ql(e)}function Kl(t){return 360*t-180}function Xl(t){return 360/Math.PI*Math.atan(Math.exp((180-360*t)*Math.PI/180))-90}function Jl(t,e){return t*ql(Xl(e))}const Hl=85.051129;function Yl(t){return 1/Math.cos(t*Math.PI/180)}class Wl{constructor(t,e,r=0){this.x=+t,this.y=+e,this.z=+r;}static fromLngLat(t,e=0){const r=Ol.convert(t);return new Wl(Nl(r.lng),Gl(r.lat),Zl(e,r.lat))}toLngLat(){return new Ol(Kl(this.x),Xl(this.y))}toAltitude(){return Jl(this.z,this.y)}meterInMercatorCoordinateUnits(){return 1/$l*Yl(Xl(this.y))}}function Ql(t,e,r,n,i,s,a,o,l){const u=(e+n)/2,c=(r+i)/2,h=new x(u,c);o(h),function(t,e,r,n,i,s){const a=r-i,o=n-s;return Math.abs((n-e)*a-(r-t)*o)/Math.hypot(a,o)}(h.x,h.y,s.x,s.y,a.x,a.y)>=l?(Ql(t,e,r,u,c,s,h,o,l),Ql(t,u,c,n,i,h,a,o,l)):t.push(a);}function tu(t,e,r){let n=t[0],i=n.x,s=n.y;e(n);const a=[n];for(let o=1;o<t.length;o++){const l=t[o],{x:u,y:c}=l;e(l),Ql(a,i,s,u,c,n,l,e,r),i=u,s=c,n=l;}return a}function eu(t,e,r,n){if(n(e,r)){const i=e.add(r)._mult(.5);eu(t,e,i,n),eu(t,i,r,n);}else t.push(r);}function ru(t,e){let r=t[0];const n=[r];for(let i=1;i<t.length;i++){const s=t[i];eu(n,r,s,e),r=s;}return n}const nu=Math.pow(2,14)-1,iu=-nu-1;function su(t,e){const r=Math.round(t.x*e),n=Math.round(t.y*e);return t.x=M(r,iu,nu),t.y=M(n,iu,nu),(r<t.x||r>t.x+1||n<t.y||n>t.y+1)&&N("Geometry exceeds allowed extent, reduce your vector tile buffer size"),t}function au(t,e,r){const n=t.loadGeometry(),i=t.extent,s=ao/i;if(e&&r&&r.projection.isReprojectedInTileSpace){const s=1<<e.z,{scale:a,x:o,y:l,projection:u}=r,c=t=>{const r=Kl((e.x+t.x/i)/s),n=Xl((e.y+t.y/i)/s),c=u.project(r,n);t.x=(c.x*a-o)*i,t.y=(c.y*a-l)*i;};for(let e=0;e<n.length;e++)if(1!==t.type)n[e]=tu(n[e],c,1);else {const t=[];for(const r of n[e])r.x<0||r.x>=i||r.y<0||r.y>=i||(c(r),t.push(r));n[e]=t;}}for(const t of n)for(const e of t)su(e,s);return n}function ou(t,e){return {type:t.type,id:t.id,properties:t.properties,geometry:e?au(t):[]}}function lu(t,e,r,n,i){t.emplaceBack(2*e+(n+1)/2,2*r+(i+1)/2);}function uu(t,e,r){const n=16384;t.emplaceBack(e.x,e.y,e.z,r[0]*n,r[1]*n,r[2]*n);}class cu{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.id)),this.index=t.index,this.hasPattern=!1,this.projection=t.projection,this.layoutVertexArray=new $s,this.indexArray=new ra,this.segments=new so,this.programConfigurations=new Ja(t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id));}populate(t,e,r,n){const i=this.layers[0],s=[];let a=null;"circle"===i.type&&(a=i.layout.get("circle-sort-key"));for(const{feature:e,id:i,index:o,sourceLayerIndex:l}of t){const t=this.layers[0]._featureFilter.needGeometry,u=ou(e,t);if(!this.layers[0]._featureFilter.filter(new ws(this.zoom),u,r))continue;const c=a?a.evaluate(u,{},r):void 0,h={id:i,properties:e.properties,type:e.type,sourceLayerIndex:l,index:o,geometry:t?u.geometry:au(e,r,n),patterns:{},sortKey:c};s.push(h);}a&&s.sort(((t,e)=>t.sortKey-e.sortKey));let o=null;"globe"===n.projection.name&&(this.globeExtVertexArray=new Ks,o=n.projection);for(const n of s){const{geometry:i,index:s,sourceLayerIndex:a}=n,l=t[s].feature;this.addFeature(n,i,s,e.availableImages,r,o),e.featureIndex.insert(l,i,s,a,this.index);}}update(t,e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r,n);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,no.members),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.globeExtVertexArray&&(this.globeExtVertexBuffer=t.createVertexBuffer(this.globeExtVertexArray,io.members))),this.programConfigurations.upload(t),this.uploaded=!0;}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.globeExtVertexBuffer&&this.globeExtVertexBuffer.destroy());}addFeature(t,e,r,n,i,s){for(const r of e)for(const e of r){const r=e.x,n=e.y;if(r<0||r>=ao||n<0||n>=ao)continue;if(s){const t=s.projectTilePoint(r,n,i),e=s.upVector(i,r,n),a=this.globeExtVertexArray;uu(a,t,e),uu(a,t,e),uu(a,t,e),uu(a,t,e);}const a=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),o=a.vertexLength;lu(this.layoutVertexArray,r,n,-1,-1),lu(this.layoutVertexArray,r,n,1,-1),lu(this.layoutVertexArray,r,n,1,1),lu(this.layoutVertexArray,r,n,-1,1),this.indexArray.emplaceBack(o,o+1,o+2),this.indexArray.emplaceBack(o,o+2,o+3),a.vertexLength+=4,a.primitiveLength+=2;}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,{},n,i);}}function hu(t,e){for(let r=0;r<t.length;r++)if(bu(e,t[r]))return !0;for(let r=0;r<e.length;r++)if(bu(t,e[r]))return !0;return !!yu(t,e)}function pu(t,e,r){return !!bu(t,e)||!!gu(e,t,r)}function du(t,e){if(1===t.length)return vu(e,t[0]);for(let r=0;r<e.length;r++){const n=e[r];for(let e=0;e<n.length;e++)if(bu(t,n[e]))return !0}for(let r=0;r<t.length;r++)if(vu(e,t[r]))return !0;for(let r=0;r<e.length;r++)if(yu(t,e[r]))return !0;return !1}function fu(t,e,r){if(t.length>1){if(yu(t,e))return !0;for(let n=0;n<e.length;n++)if(gu(e[n],t,r))return !0}for(let n=0;n<t.length;n++)if(gu(t[n],e,r))return !0;return !1}function yu(t,e){if(0===t.length||0===e.length)return !1;for(let r=0;r<t.length-1;r++){const n=t[r],i=t[r+1];for(let t=0;t<e.length-1;t++)if(mu(n,i,e[t],e[t+1]))return !0}return !1}function mu(t,e,r,n){return G(t,r,n)!==G(e,r,n)&&G(t,e,r)!==G(t,e,n)}function gu(t,e,r){const n=r*r;if(1===e.length)return t.distSqr(e[0])<n;for(let r=1;r<e.length;r++)if(xu(t,e[r-1],e[r])<n)return !0;return !1}function xu(t,e,r){const n=e.distSqr(r);if(0===n)return t.distSqr(e);const i=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y))/n;return t.distSqr(i<0?e:i>1?r:r.sub(e)._mult(i)._add(e))}function vu(t,e){let r,n,i,s=!1;for(let a=0;a<t.length;a++){r=t[a];for(let t=0,a=r.length-1;t<r.length;a=t++)n=r[t],i=r[a],n.y>e.y!=i.y>e.y&&e.x<(i.x-n.x)*(e.y-n.y)/(i.y-n.y)+n.x&&(s=!s);}return s}function bu(t,e){let r=!1;for(let n=0,i=t.length-1;n<t.length;i=n++){const s=t[n],a=t[i];s.y>e.y!=a.y>e.y&&e.x<(a.x-s.x)*(e.y-s.y)/(a.y-s.y)+s.x&&(r=!r);}return r}function wu(t,e,r,n,i){for(const s of t)if(e<=s.x&&r<=s.y&&n>=s.x&&i>=s.y)return !0;const s=[new x(e,r),new x(e,i),new x(n,i),new x(n,r)];if(t.length>2)for(const e of s)if(bu(t,e))return !0;for(let e=0;e<t.length-1;e++)if(_u(t[e],t[e+1],s))return !0;return !1}function _u(t,e,r){const n=r[0],i=r[2];if(t.x<n.x&&e.x<n.x||t.x>i.x&&e.x>i.x||t.y<n.y&&e.y<n.y||t.y>i.y&&e.y>i.y)return !1;const s=G(t,e,r[0]);return s!==G(t,e,r[1])||s!==G(t,e,r[2])||s!==G(t,e,r[3])}function Au(t,e,r){const n=e.paint.get(t).value;return "constant"===n.kind?n.value:r.programConfigurations.get(e.id).getMaxValue(t)}function Su(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function ku(t,e,r,n,i){if(!e[0]&&!e[1])return t;const s=x.convert(e)._mult(i);"viewport"===r&&s._rotate(-n);const a=[];for(let e=0;e<t.length;e++)a.push(t[e].sub(s));return a}function Iu(t,e,r,n){const i=x.convert(t)._mult(n);return "viewport"===e&&i._rotate(-r),i}Ji(cu,"CircleBucket",{omit:["layers"]});const Mu=new Ps({"circle-sort-key":new Es(te.layout_circle["circle-sort-key"])});var Tu={paint:new Ps({"circle-radius":new Es(te.paint_circle["circle-radius"]),"circle-color":new Es(te.paint_circle["circle-color"]),"circle-blur":new Es(te.paint_circle["circle-blur"]),"circle-opacity":new Es(te.paint_circle["circle-opacity"]),"circle-translate":new Bs(te.paint_circle["circle-translate"]),"circle-translate-anchor":new Bs(te.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new Bs(te.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new Bs(te.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new Es(te.paint_circle["circle-stroke-width"]),"circle-stroke-color":new Es(te.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new Es(te.paint_circle["circle-stroke-opacity"])}),layout:Mu};function zu(t,e,r,n,i,s,a,o,l){if(s&&t.queryGeometry.isAboveHorizon)return !1;s&&(l*=t.pixelToTileUnitsFactor);const u=t.tileID.canonical,c=r.projection.upVectorScale(u,r.center.lat,r.worldSize).metersToTile;for(const h of e)for(const e of h){const h=e.add(o),p=i&&r.elevation?r.elevation.exaggeration()*i.getElevationAt(h.x,h.y,!0):0,d=r.projection.projectTilePoint(h.x,h.y,u);if(p>0){const t=r.projection.upVector(u,h.x,h.y);d.x+=t[0]*c*p,d.y+=t[1]*c*p,d.z+=t[2]*c*p;}const f=s?h:Bu(d.x,d.y,d.z,n),y=s?t.tilespaceRays.map((t=>Pu(t,p))):t.queryGeometry.screenGeometry,m=Go([],[d.x,d.y,d.z,1],n);if(!a&&s?l*=m[3]/r.cameraToCenterDistance:a&&!s&&(l*=r.cameraToCenterDistance/m[3]),s){const t=Xl((e.y/ao+u.y)/(1<<u.z));l/=r.projection.pixelsPerMeter(t,1)/Zl(1,t);}if(pu(y,f,l))return !0}return !1}function Bu(t,e,r,n){const i=Go([],[t,e,r,1],n);return new x(i[0]/i[3],i[1]/i[3])}const Eu=Io(0,0,0),Cu=Io(0,0,1);function Pu(t,e){const r=Ao();return Eu[2]=e,t.intersectsPlane(Eu,Cu,r),new x(r[0],r[1])}class Du extends cu{}function Vu(t,{width:e,height:r},n,i){if(i){if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==e*r*n)throw new RangeError("mismatched image size")}else i=new Uint8Array(e*r*n);return t.width=e,t.height=r,t.data=i,t}function Lu(t,e,r){const{width:n,height:i}=e;n===t.width&&i===t.height||(Fu(t,e,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,n),height:Math.min(t.height,i)},r),t.width=n,t.height=i,t.data=e.data);}function Fu(t,e,r,n,i,s){if(0===i.width||0===i.height)return e;if(i.width>t.width||i.height>t.height||r.x>t.width-i.width||r.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>e.width||i.height>e.height||n.x>e.width-i.width||n.y>e.height-i.height)throw new RangeError("out of range destination coordinates for image copy");const a=t.data,o=e.data;for(let l=0;l<i.height;l++){const u=((r.y+l)*t.width+r.x)*s,c=((n.y+l)*e.width+n.x)*s;for(let t=0;t<i.width*s;t++)o[c+t]=a[u+t];}return e}Ji(Du,"HeatmapBucket",{omit:["layers"]});class Ru{constructor(t,e){Vu(this,t,1,e);}resize(t){Lu(this,new Ru(t),1);}clone(){return new Ru({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,e,r,n,i){Fu(t,e,r,n,i,1);}}class Uu{constructor(t,e){Vu(this,t,4,e);}resize(t){Lu(this,new Uu(t),4);}replace(t,e){e?this.data.set(t):this.data=t instanceof Uint8ClampedArray?new Uint8Array(t.buffer):t;}clone(){return new Uu({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,e,r,n,i){Fu(t,e,r,n,i,4);}}Ji(Ru,"AlphaImage"),Ji(Uu,"RGBAImage");var $u={paint:new Ps({"heatmap-radius":new Es(te.paint_heatmap["heatmap-radius"]),"heatmap-weight":new Es(te.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new Bs(te.paint_heatmap["heatmap-intensity"]),"heatmap-color":new Cs(te.paint_heatmap["heatmap-color"]),"heatmap-opacity":new Bs(te.paint_heatmap["heatmap-opacity"])})};function ju(t){const e={},r=t.resolution||256,n=t.clips?t.clips.length:1,i=t.image||new Uu({width:r,height:n}),s=(r,n,s)=>{e[t.evaluationKey]=s;const a=t.expression.evaluate(e);i.data[r+n+0]=Math.floor(255*a.r/a.a),i.data[r+n+1]=Math.floor(255*a.g/a.a),i.data[r+n+2]=Math.floor(255*a.b/a.a),i.data[r+n+3]=Math.floor(255*a.a);};if(t.clips)for(let e=0,i=0;e<n;++e,i+=4*r)for(let n=0,a=0;n<r;n++,a+=4){const o=n/(r-1),{start:l,end:u}=t.clips[e];s(i,a,l*(1-o)+u*o);}else for(let t=0,e=0;t<r;t++,e+=4)s(0,e,t/(r-1));return i}var Ou={paint:new Ps({"hillshade-illumination-direction":new Bs(te.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new Bs(te.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new Bs(te.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new Bs(te.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new Bs(te.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new Bs(te.paint_hillshade["hillshade-accent-color"])})};const qu=Rs([{name:"a_pos",components:2,type:"Int16"}],4),{members:Nu}=qu;var Gu={exports:{}};function Zu(t,e,r){r=r||2;var n,i,s,a,o,l,u,c=e&&e.length,h=c?e[0]*r:t.length,p=Ku(t,0,h,r,!0),d=[];if(!p||p.next===p.prev)return d;if(c&&(p=function(t,e,r,n){var i,s,a,o=[];for(i=0,s=e.length;i<s;i++)(a=Ku(t,e[i]*n,i<s-1?e[i+1]*n:t.length,n,!1))===a.next&&(a.steiner=!0),o.push(ic(a));for(o.sort(tc),i=0;i<o.length;i++)r=ec(o[i],r);return r}(t,e,p,r)),t.length>80*r){n=s=t[0],i=a=t[1];for(var f=r;f<h;f+=r)(o=t[f])<n&&(n=o),(l=t[f+1])<i&&(i=l),o>s&&(s=o),l>a&&(a=l);u=0!==(u=Math.max(s-n,a-i))?32767/u:0;}return Ju(p,d,r,n,i,u,0),d}function Ku(t,e,r,n,i){var s,a;if(i===gc(t,e,r,n)>0)for(s=e;s<r;s+=n)a=fc(s,t[s],t[s+1],a);else for(s=r-n;s>=e;s-=n)a=fc(s,t[s],t[s+1],a);return a&&lc(a,a.next)&&(yc(a),a=a.next),a}function Xu(t,e){if(!t)return t;e||(e=t);var r,n=t;do{if(r=!1,n.steiner||!lc(n,n.next)&&0!==oc(n.prev,n,n.next))n=n.next;else {if(yc(n),(n=e=n.prev)===n.next)break;r=!0;}}while(r||n!==e);return e}function Ju(t,e,r,n,i,s,a){if(t){!a&&s&&function(t,e,r,n){var i=t;do{0===i.z&&(i.z=nc(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){var e,r,n,i,s,a,o,l,u=1;do{for(r=t,t=null,s=null,a=0;r;){for(a++,n=r,o=0,e=0;e<u&&(o++,n=n.nextZ);e++);for(l=u;o>0||l>0&&n;)0!==o&&(0===l||!n||r.z<=n.z)?(i=r,r=r.nextZ,o--):(i=n,n=n.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;r=n;}s.nextZ=null,u*=2;}while(a>1)}(i);}(t,n,i,s);for(var o,l,u=t;t.prev!==t.next;)if(o=t.prev,l=t.next,s?Yu(t,n,i,s):Hu(t))e.push(o.i/r|0),e.push(t.i/r|0),e.push(l.i/r|0),yc(t),t=l.next,u=l.next;else if((t=l)===u){a?1===a?Ju(t=Wu(Xu(t),e,r),e,r,n,i,s,2):2===a&&Qu(t,e,r,n,i,s):Ju(Xu(t),e,r,n,i,s,1);break}}}function Hu(t){var e=t.prev,r=t,n=t.next;if(oc(e,r,n)>=0)return !1;for(var i=e.x,s=r.x,a=n.x,o=e.y,l=r.y,u=n.y,c=i<s?i<a?i:a:s<a?s:a,h=o<l?o<u?o:u:l<u?l:u,p=i>s?i>a?i:a:s>a?s:a,d=o>l?o>u?o:u:l>u?l:u,f=n.next;f!==e;){if(f.x>=c&&f.x<=p&&f.y>=h&&f.y<=d&&sc(i,o,s,l,a,u,f.x,f.y)&&oc(f.prev,f,f.next)>=0)return !1;f=f.next;}return !0}function Yu(t,e,r,n){var i=t.prev,s=t,a=t.next;if(oc(i,s,a)>=0)return !1;for(var o=i.x,l=s.x,u=a.x,c=i.y,h=s.y,p=a.y,d=o<l?o<u?o:u:l<u?l:u,f=c<h?c<p?c:p:h<p?h:p,y=o>l?o>u?o:u:l>u?l:u,m=c>h?c>p?c:p:h>p?h:p,g=nc(d,f,e,r,n),x=nc(y,m,e,r,n),v=t.prevZ,b=t.nextZ;v&&v.z>=g&&b&&b.z<=x;){if(v.x>=d&&v.x<=y&&v.y>=f&&v.y<=m&&v!==i&&v!==a&&sc(o,c,l,h,u,p,v.x,v.y)&&oc(v.prev,v,v.next)>=0)return !1;if(v=v.prevZ,b.x>=d&&b.x<=y&&b.y>=f&&b.y<=m&&b!==i&&b!==a&&sc(o,c,l,h,u,p,b.x,b.y)&&oc(b.prev,b,b.next)>=0)return !1;b=b.nextZ;}for(;v&&v.z>=g;){if(v.x>=d&&v.x<=y&&v.y>=f&&v.y<=m&&v!==i&&v!==a&&sc(o,c,l,h,u,p,v.x,v.y)&&oc(v.prev,v,v.next)>=0)return !1;v=v.prevZ;}for(;b&&b.z<=x;){if(b.x>=d&&b.x<=y&&b.y>=f&&b.y<=m&&b!==i&&b!==a&&sc(o,c,l,h,u,p,b.x,b.y)&&oc(b.prev,b,b.next)>=0)return !1;b=b.nextZ;}return !0}function Wu(t,e,r){var n=t;do{var i=n.prev,s=n.next.next;!lc(i,s)&&uc(i,n,n.next,s)&&pc(i,s)&&pc(s,i)&&(e.push(i.i/r|0),e.push(n.i/r|0),e.push(s.i/r|0),yc(n),yc(n.next),n=t=s),n=n.next;}while(n!==t);return Xu(n)}function Qu(t,e,r,n,i,s){var a=t;do{for(var o=a.next.next;o!==a.prev;){if(a.i!==o.i&&ac(a,o)){var l=dc(a,o);return a=Xu(a,a.next),l=Xu(l,l.next),Ju(a,e,r,n,i,s,0),void Ju(l,e,r,n,i,s,0)}o=o.next;}a=a.next;}while(a!==t)}function tc(t,e){return t.x-e.x}function ec(t,e){var r=function(t,e){var r,n=e,i=t.x,s=t.y,a=-1/0;do{if(s<=n.y&&s>=n.next.y&&n.next.y!==n.y){var o=n.x+(s-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(o<=i&&o>a&&(a=o,r=n.x<n.next.x?n:n.next,o===i))return r}n=n.next;}while(n!==e);if(!r)return null;var l,u=r,c=r.x,h=r.y,p=1/0;n=r;do{i>=n.x&&n.x>=c&&i!==n.x&&sc(s<h?i:a,s,c,h,s<h?a:i,s,n.x,n.y)&&(l=Math.abs(s-n.y)/(i-n.x),pc(n,t)&&(l<p||l===p&&(n.x>r.x||n.x===r.x&&rc(r,n)))&&(r=n,p=l)),n=n.next;}while(n!==u);return r}(t,e);if(!r)return e;var n=dc(r,t);return Xu(n,n.next),Xu(r,r.next)}function rc(t,e){return oc(t.prev,t,e.prev)<0&&oc(e.next,t,t.next)<0}function nc(t,e,r,n,i){return (t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function ic(t){var e=t,r=t;do{(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;}while(e!==t);return r}function sc(t,e,r,n,i,s,a,o){return (i-a)*(e-o)>=(t-a)*(s-o)&&(t-a)*(n-o)>=(r-a)*(e-o)&&(r-a)*(s-o)>=(i-a)*(n-o)}function ac(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&uc(r,r.next,t,e))return !0;r=r.next;}while(r!==t);return !1}(t,e)&&(pc(t,e)&&pc(e,t)&&function(t,e){var r=t,n=!1,i=(t.x+e.x)/2,s=(t.y+e.y)/2;do{r.y>s!=r.next.y>s&&r.next.y!==r.y&&i<(r.next.x-r.x)*(s-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;}while(r!==t);return n}(t,e)&&(oc(t.prev,t,e.prev)||oc(t,e.prev,e))||lc(t,e)&&oc(t.prev,t,t.next)>0&&oc(e.prev,e,e.next)>0)}function oc(t,e,r){return (e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function lc(t,e){return t.x===e.x&&t.y===e.y}function uc(t,e,r,n){var i=hc(oc(t,e,r)),s=hc(oc(t,e,n)),a=hc(oc(r,n,t)),o=hc(oc(r,n,e));return i!==s&&a!==o||!(0!==i||!cc(t,r,e))||!(0!==s||!cc(t,n,e))||!(0!==a||!cc(r,t,n))||!(0!==o||!cc(r,e,n))}function cc(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function hc(t){return t>0?1:t<0?-1:0}function pc(t,e){return oc(t.prev,t,t.next)<0?oc(t,e,t.next)>=0&&oc(t,t.prev,e)>=0:oc(t,e,t.prev)<0||oc(t,t.next,e)<0}function dc(t,e){var r=new mc(t.i,t.x,t.y),n=new mc(e.i,e.x,e.y),i=t.next,s=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,s.next=n,n.prev=s,n}function fc(t,e,r,n){var i=new mc(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function yc(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ);}function mc(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1;}function gc(t,e,r,n){for(var i=0,s=e,a=r-n;s<r;s+=n)i+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return i}Gu.exports=Zu,Gu.exports.default=Zu,Zu.deviation=function(t,e,r,n){var i=e&&e.length,s=Math.abs(gc(t,0,i?e[0]*r:t.length,r));if(i)for(var a=0,o=e.length;a<o;a++)s-=Math.abs(gc(t,e[a]*r,a<o-1?e[a+1]*r:t.length,r));var l=0;for(a=0;a<n.length;a+=3){var u=n[a]*r,c=n[a+1]*r,h=n[a+2]*r;l+=Math.abs((t[u]-t[h])*(t[c+1]-t[u+1])-(t[u]-t[c])*(t[h+1]-t[u+1]));}return 0===s&&0===l?0:Math.abs((l-s)/s)},Zu.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var s=0;s<t[i].length;s++)for(var a=0;a<e;a++)r.vertices.push(t[i][s][a]);i>0&&r.holes.push(n+=t[i-1].length);}return r};var xc=p(Gu.exports);function vc(t,e,r,n,i){bc(t,e,r||0,n||t.length-1,i||_c);}function bc(t,e,r,n,i){for(;n>r;){if(n-r>600){var s=n-r+1,a=e-r+1,o=Math.log(s),l=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*l*(s-l)/s)*(a-s/2<0?-1:1);bc(t,e,Math.max(r,Math.floor(e-a*l/s+u)),Math.min(n,Math.floor(e+(s-a)*l/s+u)),i);}var c=t[e],h=r,p=n;for(wc(t,r,e),i(t[n],c)>0&&wc(t,r,n);h<p;){for(wc(t,h,p),h++,p--;i(t[h],c)<0;)h++;for(;i(t[p],c)>0;)p--;}0===i(t[r],c)?wc(t,r,p):wc(t,++p,n),p<=e&&(r=p+1),e<=p&&(n=p-1);}}function wc(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}function _c(t,e){return t<e?-1:t>e?1:0}function Ac(t,e){const r=t.length;if(r<=1)return [t];const n=[];let i,s;for(let e=0;e<r;e++){const r=Z(t[e]);0!==r&&(t[e].area=Math.abs(r),void 0===s&&(s=r<0),s===r<0?(i&&n.push(i),i=[t[e]]):i.push(t[e]));}if(i&&n.push(i),e>1)for(let t=0;t<n.length;t++)n[t].length<=e||(vc(n[t],e,1,n[t].length-1,Sc),n[t]=n[t].slice(0,e));return n}function Sc(t,e){return e.area-t.area}function kc(t,e,r){const n=r.patternDependencies;let i=!1;for(const r of e){const e=r.paint.get(`${t}-pattern`);e.isConstant()||(i=!0);const s=e.constantOr(null);s&&(i=!0,n[s]=!0);}return i}function Ic(t,e,r,n,i){const s=i.patternDependencies;for(const a of e){const e=a.paint.get(`${t}-pattern`).value;if("constant"!==e.kind){let t=e.evaluate({zoom:n},r,{},i.availableImages);t=t&&t.name?t.name:t,s[t]=!0,r.patterns[a.id]=t;}}return r}class Mc{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.id)),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new $s,this.indexArray=new ra,this.indexArray2=new la,this.programConfigurations=new Ja(t.layers,t.zoom),this.segments=new so,this.segments2=new so,this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),this.projection=t.projection;}populate(t,e,r,n){this.hasPattern=kc("fill",this.layers,e);const i=this.layers[0].layout.get("fill-sort-key"),s=[];for(const{feature:a,id:o,index:l,sourceLayerIndex:u}of t){const t=this.layers[0]._featureFilter.needGeometry,c=ou(a,t);if(!this.layers[0]._featureFilter.filter(new ws(this.zoom),c,r))continue;const h=i?i.evaluate(c,{},r,e.availableImages):void 0,p={id:o,properties:a.properties,type:a.type,sourceLayerIndex:u,index:l,geometry:t?c.geometry:au(a,r,n),patterns:{},sortKey:h};s.push(p);}i&&s.sort(((t,e)=>t.sortKey-e.sortKey));for(const n of s){const{geometry:i,index:s,sourceLayerIndex:a}=n;if(this.hasPattern){const t=Ic("fill",this.layers,n,this.zoom,e);this.patternFeatures.push(t);}else this.addFeature(n,i,s,r,{},e.availableImages);e.featureIndex.insert(t[s].feature,i,s,a,this.index);}}update(t,e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r,n);}addFeatures(t,e,r,n,i){for(const t of this.patternFeatures)this.addFeature(t,t.geometry,t.index,e,r,n);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Nu),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0;}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy());}addFeature(t,e,r,n,i,s=[]){for(const t of Ac(e,500)){let e=0;for(const r of t)e+=r.length;const r=this.segments.prepareSegment(e,this.layoutVertexArray,this.indexArray),n=r.vertexLength,i=[],s=[];for(const e of t){if(0===e.length)continue;e!==t[0]&&s.push(i.length/2);const r=this.segments2.prepareSegment(e.length,this.layoutVertexArray,this.indexArray2),n=r.vertexLength;this.layoutVertexArray.emplaceBack(e[0].x,e[0].y),this.indexArray2.emplaceBack(n+e.length-1,n),i.push(e[0].x),i.push(e[0].y);for(let t=1;t<e.length;t++)this.layoutVertexArray.emplaceBack(e[t].x,e[t].y),this.indexArray2.emplaceBack(n+t-1,n+t),i.push(e[t].x),i.push(e[t].y);r.vertexLength+=e.length,r.primitiveLength+=e.length;}const a=xc(i,s);for(let t=0;t<a.length;t+=3)this.indexArray.emplaceBack(n+a[t],n+a[t+1],n+a[t+2]);r.vertexLength+=e,r.primitiveLength+=a.length/3;}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,s,n);}}Ji(Mc,"FillBucket",{omit:["layers","patternFeatures"]});const Tc=new Ps({"fill-sort-key":new Es(te.layout_fill["fill-sort-key"])});var zc={paint:new Ps({"fill-antialias":new Bs(te.paint_fill["fill-antialias"]),"fill-opacity":new Es(te.paint_fill["fill-opacity"]),"fill-color":new Es(te.paint_fill["fill-color"]),"fill-outline-color":new Es(te.paint_fill["fill-outline-color"]),"fill-translate":new Bs(te.paint_fill["fill-translate"]),"fill-translate-anchor":new Bs(te.paint_fill["fill-translate-anchor"]),"fill-pattern":new Es(te.paint_fill["fill-pattern"])}),layout:Tc};const Bc=Rs([{name:"a_pos_normal_ed",components:4,type:"Int16"}]),Ec=Rs([{name:"a_centroid_pos",components:2,type:"Uint16"}]),Cc=Rs([{name:"a_pos_3",components:3,type:"Int16"},{name:"a_pos_normal_3",components:3,type:"Int16"}]),{members:Pc}=Bc;var Dc={},Vc=m,Lc=Fc;function Fc(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=i,t.readFields(Rc,this,e);}function Rc(t,e,r){1==t?e.id=r.readVarint():2==t?function(t,e){for(var r=t.readVarint()+t.pos;t.pos<r;){var n=e._keys[t.readVarint()],i=e._values[t.readVarint()];e.properties[n]=i;}}(r,e):3==t?e.type=r.readVarint():4==t&&(e._geometry=r.pos);}function Uc(t){for(var e,r,n=0,i=0,s=t.length,a=s-1;i<s;a=i++)n+=((r=t[a]).x-(e=t[i]).x)*(e.y+r.y);return n}Fc.types=["Unknown","Point","LineString","Polygon"],Fc.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e,r=t.readVarint()+t.pos,n=1,i=0,s=0,a=0,o=[];t.pos<r;){if(i<=0){var l=t.readVarint();n=7&l,i=l>>3;}if(i--,1===n||2===n)s+=t.readSVarint(),a+=t.readSVarint(),1===n&&(e&&o.push(e),e=[]),e.push(new Vc(s,a));else {if(7!==n)throw new Error("unknown command "+n);e&&e.push(e[0].clone());}}return e&&o.push(e),o},Fc.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,s=0,a=1/0,o=-1/0,l=1/0,u=-1/0;t.pos<e;){if(n<=0){var c=t.readVarint();r=7&c,n=c>>3;}if(n--,1===r||2===r)(i+=t.readSVarint())<a&&(a=i),i>o&&(o=i),(s+=t.readSVarint())<l&&(l=s),s>u&&(u=s);else if(7!==r)throw new Error("unknown command "+r)}return [a,l,o,u]},Fc.prototype.toGeoJSON=function(t,e,r){var n,i,s=this.extent*Math.pow(2,r),a=this.extent*t,o=this.extent*e,l=this.loadGeometry(),u=Fc.types[this.type];function c(t){for(var e=0;e<t.length;e++){var r=t[e];t[e]=[360*(r.x+a)/s-180,360/Math.PI*Math.atan(Math.exp((180-360*(r.y+o)/s)*Math.PI/180))-90];}}switch(this.type){case 1:var h=[];for(n=0;n<l.length;n++)h[n]=l[n][0];c(l=h);break;case 2:for(n=0;n<l.length;n++)c(l[n]);break;case 3:for(l=function(t){var e=t.length;if(e<=1)return [t];for(var r,n,i=[],s=0;s<e;s++){var a=Uc(t[s]);0!==a&&(void 0===n&&(n=a<0),n===a<0?(r&&i.push(r),r=[t[s]]):r.push(t[s]));}return r&&i.push(r),i}(l),n=0;n<l.length;n++)for(i=0;i<l[n].length;i++)c(l[n][i]);}1===l.length?l=l[0]:u="Multi"+u;var p={type:"Feature",geometry:{type:u,coordinates:l},properties:this.properties};return "id"in this&&(p.id=this.id),p};var $c=Lc,jc=Oc;function Oc(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(qc,this,e),this.length=this._features.length;}function qc(t,e,r){15===t?e.version=r.readVarint():1===t?e.name=r.readString():5===t?e.extent=r.readVarint():2===t?e._features.push(r.pos):3===t?e._keys.push(r.readString()):4===t&&e._values.push(function(t){for(var e=null,r=t.readVarint()+t.pos;t.pos<r;){var n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null;}return e}(r));}Oc.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new $c(this._pbf,e,this.extent,this._keys,this._values)};var Nc=jc;function Gc(t,e,r){if(3===t){var n=new Nc(r,r.readVarint()+r.pos);n.length&&(e[n.name]=n);}}var Zc=Dc.VectorTile=function(t,e){this.layers=t.readFields(Gc,{},e);},Kc=Dc.VectorTileFeature=Lc;function Xc(t,e,r,n){const i=[],s=0===n?(t,e,r,n,i,s)=>{t.push(new x(s,r+(s-e)/(n-e)*(i-r)));}:(t,e,r,n,i,s)=>{t.push(new x(e+(s-r)/(i-r)*(n-e),s));};for(const a of t){const t=[];for(const i of a){if(i.length<=2)continue;const a=[];for(let t=0;t<i.length-1;t++){const o=i[t].x,l=i[t].y,u=i[t+1].x,c=i[t+1].y,h=0===n?o:l,p=0===n?u:c;h<e?p>e&&s(a,o,l,u,c,e):h>r?p<r&&s(a,o,l,u,c,r):a.push(i[t]),p<e&&h>=e&&s(a,o,l,u,c,e),p>r&&h<=r&&s(a,o,l,u,c,r);}let o=i[i.length-1];const l=0===n?o.x:o.y;l>=e&&l<=r&&a.push(o),a.length&&(o=a[a.length-1],a[0].x===o.x&&a[0].y===o.y||a.push(a[0]),t.push(a));}t.length&&i.push(t);}return i}Dc.VectorTileLayer=jc;const Jc=Kc.types,Hc=Math.pow(2,13);function Yc(t,e,r,n,i,s,a,o){t.emplaceBack((e<<1)+a,(r<<1)+s,(Math.floor(n*Hc)<<1)+i,Math.round(o));}function Wc(t,e,r){const n=16384;t.emplaceBack(e.x,e.y,e.z,r[0]*n,r[1]*n,r[2]*n);}class Qc{constructor(){this.acc=new x(0,0),this.polyCount=[];}startRing(t){this.currentPolyCount={edges:0,top:0},this.polyCount.push(this.currentPolyCount),this.min||(this.min=new x(t.x,t.y),this.max=new x(t.x,t.y));}append(t,e){this.currentPolyCount.edges++,this.acc._add(t);const r=this.min,n=this.max;t.x<r.x?r.x=t.x:t.x>n.x&&(n.x=t.x),t.y<r.y?r.y=t.y:t.y>n.y&&(n.y=t.y),((0===t.x||t.x===ao)&&t.x===e.x)!=((0===t.y||t.y===ao)&&t.y===e.y)&&this.processBorderOverlap(t,e),e.x<0!=t.x<0&&this.addBorderIntersection(0,Er(e.y,t.y,(0-e.x)/(t.x-e.x))),e.x>ao!=t.x>ao&&this.addBorderIntersection(1,Er(e.y,t.y,(ao-e.x)/(t.x-e.x))),e.y<0!=t.y<0&&this.addBorderIntersection(2,Er(e.x,t.x,(0-e.y)/(t.y-e.y))),e.y>ao!=t.y>ao&&this.addBorderIntersection(3,Er(e.x,t.x,(ao-e.y)/(t.y-e.y)));}addBorderIntersection(t,e){this.borders||(this.borders=[[Number.MAX_VALUE,-Number.MAX_VALUE],[Number.MAX_VALUE,-Number.MAX_VALUE],[Number.MAX_VALUE,-Number.MAX_VALUE],[Number.MAX_VALUE,-Number.MAX_VALUE]]);const r=this.borders[t];e<r[0]&&(r[0]=e),e>r[1]&&(r[1]=e);}processBorderOverlap(t,e){if(t.x===e.x){if(t.y===e.y)return;const r=0===t.x?0:1;this.addBorderIntersection(r,e.y),this.addBorderIntersection(r,t.y);}else {const r=0===t.y?2:3;this.addBorderIntersection(r,e.x),this.addBorderIntersection(r,t.x);}}centroid(){const t=this.polyCount.reduce(((t,e)=>t+e.edges),0);return 0!==t?this.acc.div(t)._round():new x(0,0)}span(){return new x(this.max.x-this.min.x,this.max.y-this.min.y)}intersectsCount(){return this.borders.reduce(((t,e)=>t+ +(e[0]!==Number.MAX_VALUE)),0)}}class th{constructor(t){this.zoom=t.zoom,this.canonical=t.canonical,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.id)),this.index=t.index,this.hasPattern=!1,this.edgeRadius=0,this.projection=t.projection,this.layoutVertexArray=new Os,this.centroidVertexArray=new wa,this.indexArray=new ra,this.programConfigurations=new Ja(t.layers,t.zoom),this.segments=new so,this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),this.enableTerrain=t.enableTerrain;}populate(t,e,r,n){this.features=[],this.hasPattern=kc("fill-extrusion",this.layers,e),this.featuresOnBorder=[],this.borders=[[],[],[],[]],this.borderDoneWithNeighborZ=[-1,-1,-1,-1],this.tileToMeter=function(t){const e=Math.exp(Math.PI*(1-t.y/(1<<t.z)*2));return 80150034*e/(e*e+1)/ao/(1<<t.z)}(r),this.edgeRadius=this.layers[0].layout.get("fill-extrusion-edge-radius")/this.tileToMeter;for(const{feature:i,id:s,index:a,sourceLayerIndex:o}of t){const t=this.layers[0]._featureFilter.needGeometry,l=ou(i,t);if(!this.layers[0]._featureFilter.filter(new ws(this.zoom),l,r))continue;const u={id:s,sourceLayerIndex:o,index:a,geometry:t?l.geometry:au(i,r,n),properties:i.properties,type:i.type,patterns:{}},c=this.layoutVertexArray.length;this.hasPattern?this.features.push(Ic("fill-extrusion",this.layers,u,this.zoom,e)):this.addFeature(u,u.geometry,a,r,{},e.availableImages,n),e.featureIndex.insert(i,u.geometry,a,o,this.index,c);}this.sortBorders();}addFeatures(t,e,r,n,i){for(const t of this.features){const{geometry:s}=t;this.addFeature(t,s,t.index,e,r,n,i);}this.sortBorders();}update(t,e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r,n);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Pc),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.layoutVertexExtArray&&(this.layoutVertexExtBuffer=t.createVertexBuffer(this.layoutVertexExtArray,Cc.members,!0))),this.programConfigurations.upload(t),this.uploaded=!0;}uploadCentroid(t){0!==this.centroidVertexArray.length&&(this.centroidVertexBuffer?this.needsCentroidUpdate&&this.centroidVertexBuffer.updateData(this.centroidVertexArray):this.centroidVertexBuffer=t.createVertexBuffer(this.centroidVertexArray,Ec.members,!0),this.needsCentroidUpdate=!1);}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.centroidVertexBuffer&&this.centroidVertexBuffer.destroy(),this.layoutVertexExtBuffer&&this.layoutVertexExtBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());}addFeature(t,e,r,n,i,s,a){const o=[new x(0,0),new x(ao,ao)],l=a.projection,u="globe"===l.name,c=this.enableTerrain&&!u?new Qc:null,h="Polygon"===Jc[t.type];u&&!this.layoutVertexExtArray&&(this.layoutVertexExtArray=new Ks);const p=Ac(e,500);for(let t=p.length-1;t>=0;t--){const e=p[t];(0===e.length||(d=e[0]).every((t=>t.x<=0))||d.every((t=>t.x>=ao))||d.every((t=>t.y<=0))||d.every((t=>t.y>=ao)))&&p.splice(t,1);}var d;let f;if(u)f=lh(p,o,n);else {f=[];for(const t of p)f.push({polygon:t,bounds:o});}const y=h?this.edgeRadius:0;for(const{polygon:t,bounds:e}of f){let r=0,i=0;for(const e of t)h&&!e[0].equals(e[e.length-1])&&e.push(e[0]),i+=h?e.length-1:e.length;const s=this.segments.prepareSegment((h?5:4)*i,this.layoutVertexArray,this.indexArray);if(h){const e=[],i=[];r=s.vertexLength;for(const r of t){let a,o;r.length&&r!==t[0]&&i.push(e.length/2),a=r[1].sub(r[0])._perp()._unit();for(let t=1;t<r.length;t++){const i=r[t],c=r[t===r.length-1?1:t+1];let{x:h,y:p}=i;if(y){o=c.sub(i)._perp()._unit();const t=a.add(o)._unit(),e=y*Math.min(4,1/(a.x*t.x+a.y*t.y));h+=e*t.x,p+=e*t.y,a=o;}Yc(this.layoutVertexArray,h,p,0,0,1,1,0),s.vertexLength++,e.push(i.x,i.y),u&&Wc(this.layoutVertexExtArray,l.projectTilePoint(h,p,n),l.upVector(n,h,p));}}const a=xc(e,i);for(let t=0;t<a.length;t+=3)this.indexArray.emplaceBack(r+a[t],r+a[t+2],r+a[t+1]),s.primitiveLength++;}for(const i of t){c&&i.length&&c.startRing(i[0]);let t,a,o,p=i.length>4&&sh(i[i.length-2],i[0],i[1]),d=y?rh(i[i.length-2],i[0],i[1],y):0;a=i[1].sub(i[0])._perp()._unit();let f=!0;for(let m=1,g=0;m<i.length;m++){let x=i[m-1],v=i[m];const b=i[m===i.length-1?1:m+1];if(c&&h&&c.currentPolyCount.top++,ih(v,x,e)){y&&(a=b.sub(v)._perp()._unit(),f=!f);continue}c&&c.append(v,x);const w=v.sub(x)._perp(),_=w.x/(Math.abs(w.x)+Math.abs(w.y)),A=w.y>0?1:0,S=x.dist(v);if(g+S>32768&&(g=0),y){o=b.sub(v)._perp()._unit();let t=nh(x,v,b,eh(a,o),y);isNaN(t)&&(t=0);const e=v.sub(x)._unit();x=x.add(e.mult(d))._round(),v=v.add(e.mult(-t))._round(),d=t,a=o;}const k=s.vertexLength,I=i.length>4&&sh(x,v,b);let M=ah(g,p,f);if(Yc(this.layoutVertexArray,x.x,x.y,_,A,0,0,M),Yc(this.layoutVertexArray,x.x,x.y,_,A,0,1,M),g+=S,M=ah(g,I,!f),p=I,Yc(this.layoutVertexArray,v.x,v.y,_,A,0,0,M),Yc(this.layoutVertexArray,v.x,v.y,_,A,0,1,M),s.vertexLength+=4,this.indexArray.emplaceBack(k+0,k+1,k+2),this.indexArray.emplaceBack(k+1,k+3,k+2),s.primitiveLength+=2,y){const n=r+(1===m?i.length-2:m-2),a=1===m?r:n+1;if(this.indexArray.emplaceBack(k+1,n,k+3),this.indexArray.emplaceBack(n,a,k+3),s.primitiveLength+=2,void 0===t&&(t=k),!ih(b,i[m],e)){const e=m===i.length-1?t:s.vertexLength;this.indexArray.emplaceBack(k+2,k+3,e),this.indexArray.emplaceBack(k+3,e+1,e),this.indexArray.emplaceBack(k+3,a,e+1),s.primitiveLength+=3;}f=!f;}if(u){const t=this.layoutVertexExtArray,e=l.projectTilePoint(x.x,x.y,n),r=l.projectTilePoint(v.x,v.y,n),i=l.upVector(n,x.x,x.y),s=l.upVector(n,v.x,v.y);Wc(t,e,i),Wc(t,e,i),Wc(t,r,s),Wc(t,r,s);}}h&&(r+=i.length-1);}}if(c&&c.polyCount.length>0){if(c.borders){c.vertexArrayOffset=this.centroidVertexArray.length;const t=c.borders,e=this.featuresOnBorder.push(c)-1;for(let r=0;r<4;r++)t[r][0]!==Number.MAX_VALUE&&this.borders[r].push(e);}this.encodeCentroid(c.borders?void 0:c.centroid(),c);}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,s,n);}sortBorders(){for(let t=0;t<4;t++)this.borders[t].sort(((e,r)=>this.featuresOnBorder[e].borders[t][0]-this.featuresOnBorder[r].borders[t][0]));}encodeCentroid(t,e,r=!0){let n,i;if(t)if(0!==t.y){const r=e.span()._mult(this.tileToMeter);n=(Math.max(t.x,1)<<3)+Math.min(7,Math.round(r.x/10)),i=(Math.max(t.y,1)<<3)+Math.min(7,Math.round(r.y/10));}else n=Math.ceil(7*(t.x+450)),i=0;else n=0,i=+r;let s=r?this.centroidVertexArray.length:e.vertexArrayOffset;for(const t of e.polyCount){r&&this.centroidVertexArray.resize(this.centroidVertexArray.length+4*t.edges+t.top);for(let e=0;e<t.top;e++)this.centroidVertexArray.emplace(s++,n,i);for(let e=0;e<2*t.edges;e++)this.centroidVertexArray.emplace(s++,0,i),this.centroidVertexArray.emplace(s++,n,i);}}}function eh(t,e){const r=t.add(e)._unit();return t.x*r.x+t.y*r.y}function rh(t,e,r,n){const i=e.sub(t)._perp()._unit(),s=r.sub(e)._perp()._unit();return nh(t,e,r,eh(i,s),n)}function nh(t,e,r,n,i){const s=Math.sqrt(1-n*n);return Math.min(t.dist(e)/3,e.dist(r)/3,i*s/n)}function ih(t,e,r){return t.x<r[0].x&&e.x<r[0].x||t.x>r[1].x&&e.x>r[1].x||t.y<r[0].y&&e.y<r[0].y||t.y>r[1].y&&e.y>r[1].y}function sh(t,e,r){if(t.x<0||t.x>=ao||e.x<0||e.x>=ao||r.x<0||r.x>=ao)return !1;const n=r.sub(e),i=n.perp(),s=t.sub(e);return (n.x*s.x+n.y*s.y)/Math.sqrt((n.x*n.x+n.y*n.y)*(s.x*s.x+s.y*s.y))>-.866&&i.x*s.x+i.y*s.y<0}function ah(t,e,r){const n=e?2|t:-3&t;return r?1|n:-2&n}function oh(){const t=Math.PI/32,e=Math.tan(t),r=Ul;return r*Math.sqrt(1+2*e*e)-r}function lh(t,e,r){const n=1<<r.z,i=Kl(r.x/n),s=Kl((r.x+1)/n),a=Xl(r.y/n),o=Xl((r.y+1)/n);return function(t,e,r,n,i=0,s){const a=[];if(!t.length||!r||!n)return a;const o=(t,e)=>{for(const r of t)a.push({polygon:r,bounds:e});},l=Math.ceil(Math.log2(r)),u=Math.ceil(Math.log2(n)),c=l-u,h=[];for(let t=0;t<Math.abs(c);t++)h.push(c>0?0:1);for(let t=0;t<Math.min(l,u);t++)h.push(0),h.push(1);let p=t;if(p=Xc(p,e[0].y-i,e[1].y+i,1),p=Xc(p,e[0].x-i,e[1].x+i,0),!p.length)return a;const d=[];for(h.length?d.push({polygons:p,bounds:e,depth:0}):o(p,e);d.length;){const t=d.pop(),e=t.depth,r=h[e],n=t.bounds[0],a=t.bounds[1],l=0===r?n.x:n.y,u=0===r?a.x:a.y,c=s?s(r,l,u):.5*(l+u),p=Xc(t.polygons,l-i,c+i,r),f=Xc(t.polygons,c-i,u+i,r);if(p.length){const t=[n,new x(0===r?c:a.x,1===r?c:a.y)];h.length>e+1?d.push({polygons:p,bounds:t,depth:e+1}):o(p,t);}if(f.length){const t=[new x(0===r?c:n.x,1===r?c:n.y),a];h.length>e+1?d.push({polygons:f,bounds:t,depth:e+1}):o(f,t);}}return a}(t,e,Math.ceil((s-i)/11.25),Math.ceil((a-o)/11.25),1,((t,e,i)=>{if(0===t)return .5*(e+i);{const t=Xl((r.y+e/ao)/n);return (Gl(.5*(Xl((r.y+i/ao)/n)+t))*n-r.y)*ao}}))}Ji(th,"FillExtrusionBucket",{omit:["layers","features"]}),Ji(Qc,"PartMetadata");const uh=new Ps({"fill-extrusion-edge-radius":new Bs(te["layout_fill-extrusion"]["fill-extrusion-edge-radius"])});var ch={paint:new Ps({"fill-extrusion-opacity":new Bs(te["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new Es(te["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new Es(te["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new Es(te["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new Es(te["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new Bs(te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),"fill-extrusion-ambient-occlusion-intensity":new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),"fill-extrusion-ambient-occlusion-radius":new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),"fill-extrusion-rounded-roof":new Bs(te["paint_fill-extrusion"]["fill-extrusion-rounded-roof"])}),layout:uh};function hh(t,e,r){var n=2*Math.PI*6378137/256/Math.pow(2,r);return [t*n-2*Math.PI*6378137/2,e*n-2*Math.PI*6378137/2]}class ph{constructor(t,e,r){this.z=t,this.x=e,this.y=r,this.key=yh(0,t,t,e,r);}equals(t){return this.z===t.z&&this.x===t.x&&this.y===t.y}url(t,e){const r=function(t,e,r){var n=hh(256*t,256*(e=Math.pow(2,r)-e-1),r),i=hh(256*(t+1),256*(e+1),r);return n[0]+","+n[1]+","+i[0]+","+i[1]}(this.x,this.y,this.z),n=function(t,e,r){let n,i="";for(let s=t;s>0;s--)n=1<<s-1,i+=(e&n?1:0)+(r&n?2:0);return i}(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace("{prefix}",(this.x%16).toString(16)+(this.y%16).toString(16)).replace(/{z}/g,String(this.z)).replace(/{x}/g,String(this.x)).replace(/{y}/g,String("tms"===e?Math.pow(2,this.z)-this.y-1:this.y)).replace("{quadkey}",n).replace("{bbox-epsg-3857}",r)}toString(){return `${this.z}/${this.x}/${this.y}`}}class dh{constructor(t,e){this.wrap=t,this.canonical=e,this.key=yh(t,e.z,e.z,e.x,e.y);}}class fh{constructor(t,e,r,n,i){this.overscaledZ=t,this.wrap=e,this.canonical=new ph(r,+n,+i),this.key=0===e&&t===r?this.canonical.key:yh(e,t,r,n,i);}equals(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)}scaledTo(t){const e=this.canonical.z-t;return t>this.canonical.z?new fh(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new fh(t,this.wrap,t,this.canonical.x>>e,this.canonical.y>>e)}calculateScaledKey(t,e=!0){if(this.overscaledZ===t&&e)return this.key;if(t>this.canonical.z)return yh(this.wrap*+e,t,this.canonical.z,this.canonical.x,this.canonical.y);{const r=this.canonical.z-t;return yh(this.wrap*+e,t,t,this.canonical.x>>r,this.canonical.y>>r)}}isChildOf(t){if(t.wrap!==this.wrap)return !1;const e=this.canonical.z-t.canonical.z;return 0===t.overscaledZ||t.overscaledZ<this.overscaledZ&&t.canonical.x===this.canonical.x>>e&&t.canonical.y===this.canonical.y>>e}children(t){if(this.overscaledZ>=t)return [new fh(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];const e=this.canonical.z+1,r=2*this.canonical.x,n=2*this.canonical.y;return [new fh(e,this.wrap,e,r,n),new fh(e,this.wrap,e,r+1,n),new fh(e,this.wrap,e,r,n+1),new fh(e,this.wrap,e,r+1,n+1)]}isLessThan(t){return this.wrap<t.wrap||!(this.wrap>t.wrap)&&(this.overscaledZ<t.overscaledZ||!(this.overscaledZ>t.overscaledZ)&&(this.canonical.x<t.canonical.x||!(this.canonical.x>t.canonical.x)&&this.canonical.y<t.canonical.y))}wrapped(){return new fh(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)}unwrapTo(t){return new fh(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)}overscaleFactor(){return Math.pow(2,this.overscaledZ-this.canonical.z)}toUnwrapped(){return new dh(this.wrap,this.canonical)}toString(){return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`}}function yh(t,e,r,n,i){const s=1<<Math.min(r,22);let a=s*(i%s)+n%s;return t&&r<22&&(a+=s*s*((t<0?-2*t-1:2*t)%(1<<2*(22-r)))),16*(32*a+r)+(e-r)}Ji(ph,"CanonicalTileID"),Ji(fh,"OverscaledTileID",{omit:["projMatrix"]});class mh extends x{constructor(t,e,r){super(t,e),this.z=r;}}function gh(t,e){return t.x*e.x+t.y*e.y}function xh(t,e){if(1===t.length){let r=0;const n=e[r++];let i;for(;!i||n.equals(i);)if(i=e[r++],!i)return 1/0;for(;r<e.length;r++){const s=e[r],a=t[0],o=i.sub(n),l=s.sub(n),u=a.sub(n),c=gh(o,o),h=gh(o,l),p=gh(l,l),d=gh(u,o),f=gh(u,l),y=c*p-h*h,m=(p*d-h*f)/y,g=(c*f-h*d)/y,x=n.z*(1-m-g)+i.z*m+s.z*g;if(isFinite(x))return x}return 1/0}{let t=1/0;for(const r of e)t=Math.min(t,r.z);return t}}function vh(t,e,r,n,i,s,a,o){const l=a*i.getElevationAt(t,e,!0,!0),u=0!==s[0],c=u?0===s[1]?a*(s[0]/7-450):a*function(t,e,r){const n=Math.floor(e[0]/8),i=Math.floor(e[1]/8),s=10*(e[0]-8*n),a=10*(e[1]-8*i),o=t.getElevationAt(n,i,!0,!0),l=t.getMeterToDEM(r),u=Math.floor(.5*(s*l-1)),c=Math.floor(.5*(a*l-1)),h=t.tileCoordToPixel(n,i),p=2*u+1,d=2*c+1,f=function(t,e,r,n,i){return [t.getElevationAtPixel(e,r,!0),t.getElevationAtPixel(e+i,r,!0),t.getElevationAtPixel(e,r+i,!0),t.getElevationAtPixel(e+n,r+i,!0)]}(t,h.x-u,h.y-c,p,d),y=Math.abs(f[0]-f[1]),m=Math.abs(f[2]-f[3]),g=Math.abs(f[0]-f[2])+Math.abs(f[1]-f[3]),x=Math.min(.25,.5*l*(y+m)/p),v=Math.min(.25,.5*l*g/d);return o+Math.max(x*s,v*a)}(i,s,o):l;return {base:l+(0===r)?-1:r,top:u?Math.max(c+n,l+r+2):l+n}}const bh=Rs([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"},{name:"a_linesofar",components:1,type:"Float32"}],4),{members:wh}=bh,_h=Rs([{name:"a_packed",components:4,type:"Float32"}]),{members:Ah}=_h,Sh=Kc.types,kh=Math.cos(Math.PI/180*37.5);class Ih{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.id)),this.index=t.index,this.projection=t.projection,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach((t=>{this.gradients[t.id]={};})),this.layoutVertexArray=new qs,this.layoutVertexArray2=new Ns,this.indexArray=new ra,this.programConfigurations=new Ja(t.layers,t.zoom),this.segments=new so,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id));}populate(t,e,r,n){this.hasPattern=kc("line",this.layers,e);const i=this.layers[0].layout.get("line-sort-key"),s=[];for(const{feature:e,id:a,index:o,sourceLayerIndex:l}of t){const t=this.layers[0]._featureFilter.needGeometry,u=ou(e,t);if(!this.layers[0]._featureFilter.filter(new ws(this.zoom),u,r))continue;const c=i?i.evaluate(u,{},r):void 0,h={id:a,properties:e.properties,type:e.type,sourceLayerIndex:l,index:o,geometry:t?u.geometry:au(e,r,n),patterns:{},sortKey:c};s.push(h);}i&&s.sort(((t,e)=>t.sortKey-e.sortKey));const{lineAtlas:a,featureIndex:o}=e,l=this.addConstantDashes(a);for(const n of s){const{geometry:i,index:s,sourceLayerIndex:u}=n;if(l&&this.addFeatureDashes(n,a),this.hasPattern){const t=Ic("line",this.layers,n,this.zoom,e);this.patternFeatures.push(t);}else this.addFeature(n,i,s,r,a.positions,e.availableImages);o.insert(t[s].feature,i,s,u,this.index);}}addConstantDashes(t){let e=!1;for(const r of this.layers){const n=r.paint.get("line-dasharray").value,i=r.layout.get("line-cap").value;if("constant"!==n.kind||"constant"!==i.kind)e=!0;else {const e=i.value,r=n.value;if(!r)continue;t.addDash(r,e);}}return e}addFeatureDashes(t,e){const r=this.zoom;for(const n of this.layers){const i=n.paint.get("line-dasharray").value,s=n.layout.get("line-cap").value;if("constant"===i.kind&&"constant"===s.kind)continue;let a,o;if("constant"===i.kind){if(a=i.value,!a)continue}else a=i.evaluate({zoom:r},t);o="constant"===s.kind?s.value:s.evaluate({zoom:r},t),e.addDash(a,o),t.patterns[n.id]=e.getKey(a,o);}}update(t,e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r,n);}addFeatures(t,e,r,n,i){for(const t of this.patternFeatures)this.addFeature(t,t.geometry,t.index,e,r,n);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(0!==this.layoutVertexArray2.length&&(this.layoutVertexBuffer2=t.createVertexBuffer(this.layoutVertexArray2,Ah)),this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,wh),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());}lineFeatureClips(t){if(t.properties&&t.properties.hasOwnProperty("mapbox_clip_start")&&t.properties.hasOwnProperty("mapbox_clip_end"))return {start:+t.properties.mapbox_clip_start,end:+t.properties.mapbox_clip_end}}addFeature(t,e,r,n,i,s){const a=this.layers[0].layout,o=a.get("line-join").evaluate(t,{}),l=a.get("line-cap").evaluate(t,{}),u=a.get("line-miter-limit"),c=a.get("line-round-limit");this.lineClips=this.lineFeatureClips(t);for(const r of e)this.addLine(r,t,o,l,u,c);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,s,n);}addLine(t,e,r,n,i,s){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.lineSoFar=0,this.lineClips){this.lineClipsArray.push(this.lineClips);for(let e=0;e<t.length-1;e++)this.totalDistance+=t[e].dist(t[e+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance);}const a="Polygon"===Sh[e.type];let o=t.length;for(;o>=2&&t[o-1].equals(t[o-2]);)o--;let l=0;for(;l<o-1&&t[l].equals(t[l+1]);)l++;if(o<(a?3:2))return;"bevel"===r&&(i=1.05);const u=this.overscaling<=16?15*ao/(512*this.overscaling):0,c=this.segments.prepareSegment(10*o,this.layoutVertexArray,this.indexArray);let h,p,d,f,y;this.e1=this.e2=-1,a&&(h=t[o-2],y=t[l].sub(h)._unit()._perp());for(let e=l;e<o;e++){if(d=e===o-1?a?t[l+1]:void 0:t[e+1],d&&t[e].equals(d))continue;y&&(f=y),h&&(p=h),h=t[e],y=d?d.sub(h)._unit()._perp():f,f=f||y;let m=f.add(y);0===m.x&&0===m.y||m._unit();const g=f.x*y.x+f.y*y.y,x=m.x*y.x+m.y*y.y,v=0!==x?1/x:1/0,b=2*Math.sqrt(2-2*x),w=x<kh&&p&&d,_=f.x*y.y-f.y*y.x>0;if(w&&e>l){const t=h.dist(p);if(t>2*u){const e=h.sub(h.sub(p)._mult(u/t)._round());this.updateDistance(p,e),this.addCurrentVertex(e,f,0,0,c),p=e;}}const A=p&&d;let S=A?r:a?"butt":n;if(A&&"round"===S&&(v<s?S="miter":v<=2&&(S="fakeround")),"miter"===S&&v>i&&(S="bevel"),"bevel"===S&&(v>2&&(S="flipbevel"),v<i&&(S="miter")),p&&this.updateDistance(p,h),"miter"===S)m._mult(v),this.addCurrentVertex(h,m,0,0,c);else if("flipbevel"===S){if(v>100)m=y.mult(-1);else {const t=v*f.add(y).mag()/f.sub(y).mag();m._perp()._mult(t*(_?-1:1));}this.addCurrentVertex(h,m,0,0,c),this.addCurrentVertex(h,m.mult(-1),0,0,c);}else if("bevel"===S||"fakeround"===S){const t=-Math.sqrt(v*v-1),e=_?t:0,r=_?0:t;if(p&&this.addCurrentVertex(h,f,e,r,c),"fakeround"===S){const t=Math.round(180*b/Math.PI/20);for(let e=1;e<t;e++){let r=e/t;if(.5!==r){const t=r-.5;r+=r*t*(r-1)*((1.0904+g*(g*(3.55645-1.43519*g)-3.2452))*t*t+(.848013+g*(.215638*g-1.06021)));}const n=y.sub(f)._mult(r)._add(f)._unit()._mult(_?-1:1);this.addHalfVertex(h,n.x,n.y,!1,_,0,c);}}d&&this.addCurrentVertex(h,y,-e,-r,c);}else if("butt"===S)this.addCurrentVertex(h,m,0,0,c);else if("square"===S){const t=p?1:-1;p||this.addCurrentVertex(h,m,t,t,c),this.addCurrentVertex(h,m,0,0,c),p&&this.addCurrentVertex(h,m,t,t,c);}else "round"===S&&(p&&(this.addCurrentVertex(h,f,0,0,c),this.addCurrentVertex(h,f,1,1,c,!0)),d&&(this.addCurrentVertex(h,y,-1,-1,c,!0),this.addCurrentVertex(h,y,0,0,c)));if(w&&e<o-1){const t=h.dist(d);if(t>2*u){const e=h.add(d.sub(h)._mult(u/t)._round());this.updateDistance(h,e),this.addCurrentVertex(e,y,0,0,c),h=e;}}}}addCurrentVertex(t,e,r,n,i,s=!1){const a=e.y*n-e.x,o=-e.y-e.x*n;this.addHalfVertex(t,e.x+e.y*r,e.y-e.x*r,s,!1,r,i),this.addHalfVertex(t,a,o,s,!0,-n,i);}addHalfVertex({x:t,y:e},r,n,i,s,a,o){this.layoutVertexArray.emplaceBack((t<<1)+(i?1:0),(e<<1)+(s?1:0),Math.round(63*r)+128,Math.round(63*n)+128,1+(0===a?0:a<0?-1:1),0,this.lineSoFar),this.lineClips&&this.layoutVertexArray2.emplaceBack(this.scaledDistance,this.lineClipsArray.length,this.lineClips.start,this.lineClips.end);const l=o.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,l),o.primitiveLength++),s?this.e2=l:this.e1=l;}updateScaledDistance(){if(this.lineClips){const t=this.totalDistance/(this.lineClips.end-this.lineClips.start);this.scaledDistance=this.distance/this.totalDistance,this.lineSoFar=t*this.lineClips.start+this.distance;}else this.lineSoFar=this.distance;}updateDistance(t,e){this.distance+=t.dist(e),this.updateScaledDistance();}}Ji(Ih,"LineBucket",{omit:["layers","patternFeatures"]});const Mh=new Ps({"line-cap":new Es(te.layout_line["line-cap"]),"line-join":new Es(te.layout_line["line-join"]),"line-miter-limit":new Bs(te.layout_line["line-miter-limit"]),"line-round-limit":new Bs(te.layout_line["line-round-limit"]),"line-sort-key":new Es(te.layout_line["line-sort-key"])});var Th={paint:new Ps({"line-opacity":new Es(te.paint_line["line-opacity"]),"line-color":new Es(te.paint_line["line-color"]),"line-translate":new Bs(te.paint_line["line-translate"]),"line-translate-anchor":new Bs(te.paint_line["line-translate-anchor"]),"line-width":new Es(te.paint_line["line-width"]),"line-gap-width":new Es(te.paint_line["line-gap-width"]),"line-offset":new Es(te.paint_line["line-offset"]),"line-blur":new Es(te.paint_line["line-blur"]),"line-dasharray":new Es(te.paint_line["line-dasharray"]),"line-pattern":new Es(te.paint_line["line-pattern"]),"line-gradient":new Cs(te.paint_line["line-gradient"]),"line-trim-offset":new Bs(te.paint_line["line-trim-offset"])}),layout:Mh};const zh=new class extends Es{possiblyEvaluate(t,e){return e=new ws(Math.floor(e.zoom),{now:e.now,fadeDuration:e.fadeDuration,transition:e.transition}),super.possiblyEvaluate(t,e)}evaluate(t,e,r,n){return e=C({},e,{zoom:Math.floor(e.zoom)}),super.evaluate(t,e,r,n)}}(Th.paint.properties["line-width"].specification);function Bh(t,e){return e>0?e+2*t:t}zh.useIntegerZoom=!0;const Eh=Rs([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_tex_size",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),Ch=Rs([{name:"a_globe_anchor",components:3,type:"Int16"},{name:"a_globe_normal",components:3,type:"Float32"}],4),Ph=Rs([{name:"a_projected_pos",components:4,type:"Float32"}],4);Rs([{name:"a_fade_opacity",components:1,type:"Uint32"}],4);const Dh=Rs([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}]),Vh=Rs([{name:"a_size_scale",components:1,type:"Float32"},{name:"a_padding",components:2,type:"Float32"}]);Rs([{type:"Int16",name:"projectedAnchorX"},{type:"Int16",name:"projectedAnchorY"},{type:"Int16",name:"projectedAnchorZ"},{type:"Int16",name:"tileAnchorX"},{type:"Int16",name:"tileAnchorY"},{type:"Float32",name:"x1"},{type:"Float32",name:"y1"},{type:"Float32",name:"x2"},{type:"Float32",name:"y2"},{type:"Int16",name:"padding"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]);const Lh=Rs([{name:"a_pos",components:3,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4),Fh=Rs([{name:"a_pos_2f",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4);Rs([{name:"triangle",components:3,type:"Uint16"}]),Rs([{type:"Int16",name:"projectedAnchorX"},{type:"Int16",name:"projectedAnchorY"},{type:"Int16",name:"projectedAnchorZ"},{type:"Float32",name:"tileAnchorX"},{type:"Float32",name:"tileAnchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"},{type:"Uint8",name:"flipState"}]),Rs([{type:"Int16",name:"projectedAnchorX"},{type:"Int16",name:"projectedAnchorY"},{type:"Int16",name:"projectedAnchorZ"},{type:"Float32",name:"tileAnchorX"},{type:"Float32",name:"tileAnchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",components:2,name:"textOffset"},{type:"Float32",name:"collisionCircleDiameter"}]),Rs([{type:"Float32",name:"offsetX"}]),Rs([{type:"Int16",name:"x"},{type:"Int16",name:"y"}]);var Rh=24;const Uh=128;function $h(t,e){const{expression:r}=e;if("constant"===r.kind)return {kind:"constant",layoutSize:r.evaluate(new ws(t+1))};if("source"===r.kind)return {kind:"source"};{const{zoomStops:e,interpolationType:n}=r;let i=0;for(;i<e.length&&e[i]<=t;)i++;i=Math.max(0,i-1);let s=i;for(;s<e.length&&e[s]<t+1;)s++;s=Math.min(e.length-1,s);const a=e[i],o=e[s];return "composite"===r.kind?{kind:"composite",minZoom:a,maxZoom:o,interpolationType:n}:{kind:"camera",minZoom:a,maxZoom:o,minSize:r.evaluate(new ws(a)),maxSize:r.evaluate(new ws(o)),interpolationType:n}}}function jh(t,{uSize:e,uSizeT:r},{lowerSize:n,upperSize:i}){return "source"===t.kind?n/Uh:"composite"===t.kind?Er(n/Uh,i/Uh,r):e}function Oh(t,e){let r=0,n=0;if("constant"===t.kind)n=t.layoutSize;else if("source"!==t.kind){const{interpolationType:i,minZoom:s,maxZoom:a}=t,o=i?M(Qr.interpolationFactor(i,e,s,a),0,1):0;"camera"===t.kind?n=Er(t.minSize,t.maxSize,o):r=o;}return {uSizeT:r,uSize:n}}var qh=Object.freeze({__proto__:null,SIZE_PACK_FACTOR:Uh,evaluateSizeForFeature:jh,evaluateSizeForZoom:Oh,getSizeData:$h});function Nh(t,e,r){return t.sections.forEach((t=>{t.text=function(t,e,r){const n=e.layout.get("text-transform").evaluate(r,{});return "uppercase"===n?t=t.toLocaleUpperCase():"lowercase"===n&&(t=t.toLocaleLowerCase()),bs.applyArabicShaping&&(t=bs.applyArabicShaping(t)),t}(t.text,e,r);})),t}const Gh={"!":"︕","#":"＃",$:"＄","%":"％","&":"＆","(":"︵",")":"︶","*":"＊","+":"＋",",":"︐","-":"︲",".":"・","/":"／",":":"︓",";":"︔","<":"︿","=":"＝",">":"﹀","?":"︖","@":"＠","[":"﹇","\\":"＼","]":"﹈","^":"＾",_:"︳","`":"｀","{":"︷","|":"―","}":"︸","~":"～","¢":"￠","£":"￡","¥":"￥","¦":"￤","¬":"￢","¯":"￣","–":"︲","—":"︱","‘":"﹃","’":"﹄","“":"﹁","”":"﹂","…":"︙","‧":"・","₩":"￦","、":"︑","。":"︒","〈":"︿","〉":"﹀","《":"︽","》":"︾","「":"﹁","」":"﹂","『":"﹃","』":"﹄","【":"︻","】":"︼","〔":"︹","〕":"︺","〖":"︗","〗":"︘","！":"︕","（":"︵","）":"︶","，":"︐","－":"︲","．":"・","：":"︓","；":"︔","＜":"︿","＞":"﹀","？":"︖","［":"﹇","］":"﹈","＿":"︳","｛":"︷","｜":"―","｝":"︸","｟":"︵","｠":"︶","｡":"︒","｢":"﹁","｣":"﹂","←":"↑","→":"↓"};function Zh(t){return "︶"===t||"﹈"===t||"︸"===t||"﹄"===t||"﹂"===t||"︾"===t||"︼"===t||"︺"===t||"︘"===t||"﹀"===t||"︐"===t||"︓"===t||"︔"===t||"｀"===t||"￣"===t||"︑"===t||"︒"===t}function Kh(t){return "︵"===t||"﹇"===t||"︷"===t||"﹃"===t||"﹁"===t||"︽"===t||"︻"===t||"︹"===t||"︗"===t||"︿"===t}var Xh=Yh,Jh=function(t,e,r,n,i){var s,a,o=8*i-n-1,l=(1<<o)-1,u=l>>1,c=-7,h=r?i-1:0,p=r?-1:1,d=t[e+h];for(h+=p,s=d&(1<<-c)-1,d>>=-c,c+=o;c>0;s=256*s+t[e+h],h+=p,c-=8);for(a=s&(1<<-c)-1,s>>=-c,c+=n;c>0;a=256*a+t[e+h],h+=p,c-=8);if(0===s)s=1-u;else {if(s===l)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,n),s-=u;}return (d?-1:1)*a*Math.pow(2,s-n)},Hh=function(t,e,r,n,i,s){var a,o,l,u=8*s-i-1,c=(1<<u)-1,h=c>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:s-1,f=n?1:-1,y=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(o=isNaN(e)?1:0,a=c):(a=Math.floor(Math.log(e)/Math.LN2),e*(l=Math.pow(2,-a))<1&&(a--,l*=2),(e+=a+h>=1?p/l:p*Math.pow(2,1-h))*l>=2&&(a++,l/=2),a+h>=c?(o=0,a=c):a+h>=1?(o=(e*l-1)*Math.pow(2,i),a+=h):(o=e*Math.pow(2,h-1)*Math.pow(2,i),a=0));i>=8;t[r+d]=255&o,d+=f,o/=256,i-=8);for(a=a<<i|o,u+=i;u>0;t[r+d]=255&a,d+=f,a/=256,u-=8);t[r+d-f]|=128*y;};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */function Yh(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length;}Yh.Varint=0,Yh.Fixed64=1,Yh.Bytes=2,Yh.Fixed32=5;var Wh=4294967296,Qh=1/Wh,tp="undefined"==typeof TextDecoder?null:new TextDecoder("utf8");function ep(t){return t.type===Yh.Bytes?t.readVarint()+t.pos:t.pos+1}function rp(t,e,r){return r?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function np(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(7*Math.LN2));r.realloc(n);for(var i=r.pos-1;i>=t;i--)r.buf[i+n]=r.buf[i];}function ip(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r]);}function sp(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r]);}function ap(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r]);}function op(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r]);}function lp(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r]);}function up(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r]);}function cp(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r]);}function hp(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r]);}function pp(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r]);}function dp(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function fp(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24;}function yp(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}Yh.prototype={destroy:function(){this.buf=null;},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,s=this.pos;this.type=7&n,t(i,e,this),this.pos===s&&this.skip(n);}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=dp(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=yp(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=dp(this.buf,this.pos)+dp(this.buf,this.pos+4)*Wh;return this.pos+=8,t},readSFixed64:function(){var t=dp(this.buf,this.pos)+yp(this.buf,this.pos+4)*Wh;return this.pos+=8,t},readFloat:function(){var t=Jh(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=Jh(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e,r,n=this.buf;return e=127&(r=n[this.pos++]),r<128?e:(e|=(127&(r=n[this.pos++]))<<7,r<128?e:(e|=(127&(r=n[this.pos++]))<<14,r<128?e:(e|=(127&(r=n[this.pos++]))<<21,r<128?e:function(t,e,r){var n,i,s=r.buf;if(n=(112&(i=s[r.pos++]))>>4,i<128)return rp(t,n,e);if(n|=(127&(i=s[r.pos++]))<<3,i<128)return rp(t,n,e);if(n|=(127&(i=s[r.pos++]))<<10,i<128)return rp(t,n,e);if(n|=(127&(i=s[r.pos++]))<<17,i<128)return rp(t,n,e);if(n|=(127&(i=s[r.pos++]))<<24,i<128)return rp(t,n,e);if(n|=(1&(i=s[r.pos++]))<<31,i<128)return rp(t,n,e);throw new Error("Expected varint not more than 10 bytes")}(e|=(15&(r=n[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,e=this.pos;return this.pos=t,t-e>=12&&tp?function(t,e,r){return tp.decode(t.subarray(e,r))}(this.buf,e,t):function(t,e,r){for(var n="",i=e;i<r;){var s,a,o,l=t[i],u=null,c=l>239?4:l>223?3:l>191?2:1;if(i+c>r)break;1===c?l<128&&(u=l):2===c?128==(192&(s=t[i+1]))&&(u=(31&l)<<6|63&s)<=127&&(u=null):3===c?(a=t[i+2],128==(192&(s=t[i+1]))&&128==(192&a)&&((u=(15&l)<<12|(63&s)<<6|63&a)<=2047||u>=55296&&u<=57343)&&(u=null)):4===c&&(a=t[i+2],o=t[i+3],128==(192&(s=t[i+1]))&&128==(192&a)&&128==(192&o)&&((u=(15&l)<<18|(63&s)<<12|(63&a)<<6|63&o)<=65535||u>=1114112)&&(u=null)),null===u?(u=65533,c=1):u>65535&&(u-=65536,n+=String.fromCharCode(u>>>10&1023|55296),u=56320|1023&u),n+=String.fromCharCode(u),i+=c;}return n}(this.buf,e,t)},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==Yh.Bytes)return t.push(this.readVarint(e));var r=ep(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==Yh.Bytes)return t.push(this.readSVarint());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==Yh.Bytes)return t.push(this.readBoolean());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==Yh.Bytes)return t.push(this.readFloat());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==Yh.Bytes)return t.push(this.readDouble());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==Yh.Bytes)return t.push(this.readFixed32());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==Yh.Bytes)return t.push(this.readSFixed32());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==Yh.Bytes)return t.push(this.readFixed64());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==Yh.Bytes)return t.push(this.readSFixed64());var e=ep(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=7&t;if(e===Yh.Varint)for(;this.buf[this.pos++]>127;);else if(e===Yh.Bytes)this.pos=this.readVarint()+this.pos;else if(e===Yh.Fixed32)this.pos+=4;else {if(e!==Yh.Fixed64)throw new Error("Unimplemented type: "+e);this.pos+=8;}},writeTag:function(t,e){this.writeVarint(t<<3|e);},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e;}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),fp(this.buf,t,this.pos),this.pos+=4;},writeSFixed32:function(t){this.realloc(4),fp(this.buf,t,this.pos),this.pos+=4;},writeFixed64:function(t){this.realloc(8),fp(this.buf,-1&t,this.pos),fp(this.buf,Math.floor(t*Qh),this.pos+4),this.pos+=8;},writeSFixed64:function(t){this.realloc(8),fp(this.buf,-1&t,this.pos),fp(this.buf,Math.floor(t*Qh),this.pos+4),this.pos+=8;},writeVarint:function(t){(t=+t||0)>268435455||t<0?function(t,e){var r,n;if(t>=0?(r=t%4294967296|0,n=t/4294967296|0):(n=~(-t/4294967296),4294967295^(r=~(-t%4294967296))?r=r+1|0:(r=0,n=n+1|0)),t>=0x10000000000000000||t<-0x10000000000000000)throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10),function(t,e,r){r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,r.buf[r.pos]=127&(t>>>=7);}(r,0,e),function(t,e){var r=(7&t)<<4;e.buf[e.pos++]|=r|((t>>>=3)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t)))));}(n,e);}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))));},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t);},writeBoolean:function(t){this.writeVarint(Boolean(t));},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var e=this.pos;this.pos=function(t,e,r){for(var n,i,s=0;s<e.length;s++){if((n=e.charCodeAt(s))>55295&&n<57344){if(!i){n>56319||s+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):i=n;continue}if(n<56320){t[r++]=239,t[r++]=191,t[r++]=189,i=n;continue}n=i-55296<<10|n-56320|65536,i=null;}else i&&(t[r++]=239,t[r++]=191,t[r++]=189,i=null);n<128?t[r++]=n:(n<2048?t[r++]=n>>6|192:(n<65536?t[r++]=n>>12|224:(t[r++]=n>>18|240,t[r++]=n>>12&63|128),t[r++]=n>>6&63|128),t[r++]=63&n|128);}return r}(this.buf,t,this.pos);var r=this.pos-e;r>=128&&np(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r;},writeFloat:function(t){this.realloc(4),Hh(this.buf,t,this.pos,!0,23,4),this.pos+=4;},writeDouble:function(t){this.realloc(8),Hh(this.buf,t,this.pos,!0,52,8),this.pos+=8;},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r];},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&np(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n;},writeMessage:function(t,e,r){this.writeTag(t,Yh.Bytes),this.writeRawMessage(e,r);},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,ip,e);},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,sp,e);},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,lp,e);},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,ap,e);},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,op,e);},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,up,e);},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,cp,e);},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,hp,e);},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,pp,e);},writeBytesField:function(t,e){this.writeTag(t,Yh.Bytes),this.writeBytes(e);},writeFixed32Field:function(t,e){this.writeTag(t,Yh.Fixed32),this.writeFixed32(e);},writeSFixed32Field:function(t,e){this.writeTag(t,Yh.Fixed32),this.writeSFixed32(e);},writeFixed64Field:function(t,e){this.writeTag(t,Yh.Fixed64),this.writeFixed64(e);},writeSFixed64Field:function(t,e){this.writeTag(t,Yh.Fixed64),this.writeSFixed64(e);},writeVarintField:function(t,e){this.writeTag(t,Yh.Varint),this.writeVarint(e);},writeSVarintField:function(t,e){this.writeTag(t,Yh.Varint),this.writeSVarint(e);},writeStringField:function(t,e){this.writeTag(t,Yh.Bytes),this.writeString(e);},writeFloatField:function(t,e){this.writeTag(t,Yh.Fixed32),this.writeFloat(e);},writeDoubleField:function(t,e){this.writeTag(t,Yh.Fixed64),this.writeDouble(e);},writeBooleanField:function(t,e){this.writeVarintField(t,Boolean(e));}};var mp=p(Xh);const gp=3;function xp(t,e,r){e.glyphs=[],1===t&&r.readMessage(vp,e);}function vp(t,e,r){if(3===t){const{id:t,bitmap:n,width:i,height:s,left:a,top:o,advance:l}=r.readMessage(bp,{});e.glyphs.push({id:t,bitmap:new Ru({width:i+2*gp,height:s+2*gp},n),metrics:{width:i,height:s,left:a,top:o,advance:l}});}else 4===t?e.ascender=r.readSVarint():5===t&&(e.descender=r.readSVarint());}function bp(t,e,r){1===t?e.id=r.readVarint():2===t?e.bitmap=r.readBytes():3===t?e.width=r.readVarint():4===t?e.height=r.readVarint():5===t?e.left=r.readSVarint():6===t?e.top=r.readSVarint():7===t&&(e.advance=r.readVarint());}const wp=gp;function _p(t){let e=0,r=0;for(const n of t)e+=n.w*n.h,r=Math.max(r,n.w);t.sort(((t,e)=>e.h-t.h));const n=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),r),h:1/0}];let i=0,s=0;for(const e of t)for(let t=n.length-1;t>=0;t--){const r=n[t];if(!(e.w>r.w||e.h>r.h)){if(e.x=r.x,e.y=r.y,s=Math.max(s,e.y+e.h),i=Math.max(i,e.x+e.w),e.w===r.w&&e.h===r.h){const e=n.pop();t<n.length&&(n[t]=e);}else e.h===r.h?(r.x+=e.w,r.w-=e.w):e.w===r.w?(r.y+=e.h,r.h-=e.h):(n.push({x:r.x+e.w,y:r.y,w:r.w-e.w,h:e.h}),r.y+=e.h,r.h-=e.h);break}}return {w:i,h:s,fill:e/(i*s)||0}}const Ap=1;class Sp{constructor(t,{pixelRatio:e,version:r,stretchX:n,stretchY:i,content:s}){this.paddedRect=t,this.pixelRatio=e,this.stretchX=n,this.stretchY=i,this.content=s,this.version=r;}get tl(){return [this.paddedRect.x+Ap,this.paddedRect.y+Ap]}get br(){return [this.paddedRect.x+this.paddedRect.w-Ap,this.paddedRect.y+this.paddedRect.h-Ap]}get displaySize(){return [(this.paddedRect.w-2*Ap)/this.pixelRatio,(this.paddedRect.h-2*Ap)/this.pixelRatio]}}class kp{constructor(t,e){const r={},n={};this.haveRenderCallbacks=[];const i=[];this.addImages(t,r,i),this.addImages(e,n,i);const{w:s,h:a}=_p(i),o=new Uu({width:s||1,height:a||1});for(const e in t){const n=t[e],i=r[e].paddedRect;Uu.copy(n.data,o,{x:0,y:0},{x:i.x+Ap,y:i.y+Ap},n.data);}for(const t in e){const r=e[t],i=n[t].paddedRect,s=i.x+Ap,a=i.y+Ap,l=r.data.width,u=r.data.height;Uu.copy(r.data,o,{x:0,y:0},{x:s,y:a},r.data),Uu.copy(r.data,o,{x:0,y:u-1},{x:s,y:a-1},{width:l,height:1}),Uu.copy(r.data,o,{x:0,y:0},{x:s,y:a+u},{width:l,height:1}),Uu.copy(r.data,o,{x:l-1,y:0},{x:s-1,y:a},{width:1,height:u}),Uu.copy(r.data,o,{x:0,y:0},{x:s+l,y:a},{width:1,height:u});}this.image=o,this.iconPositions=r,this.patternPositions=n;}addImages(t,e,r){for(const n in t){const i=t[n],s={x:0,y:0,w:i.data.width+2*Ap,h:i.data.height+2*Ap};r.push(s),e[n]=new Sp(s,i),i.hasRenderCallback&&this.haveRenderCallbacks.push(n);}}patchUpdatedImages(t,e){this.haveRenderCallbacks=this.haveRenderCallbacks.filter((e=>t.hasImage(e))),t.dispatchRenderCallbacks(this.haveRenderCallbacks);for(const r in t.updatedImages)this.patchUpdatedImage(this.iconPositions[r],t.getImage(r),e),this.patchUpdatedImage(this.patternPositions[r],t.getImage(r),e);}patchUpdatedImage(t,e,r){if(!t||!e)return;if(t.version===e.version)return;t.version=e.version;const[n,i]=t.tl;r.update(e.data,void 0,{x:n,y:i});}}Ji(Sp,"ImagePosition"),Ji(kp,"ImageAtlas");const Ip={horizontal:1,vertical:2,horizontalOnly:3},Mp=-17;class Tp{constructor(){this.scale=1,this.fontStack="",this.imageName=null;}static forText(t,e){const r=new Tp;return r.scale=t||1,r.fontStack=e,r}static forImage(t){const e=new Tp;return e.imageName=t,e}}class zp{constructor(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null;}static fromFeature(t,e){const r=new zp;for(let n=0;n<t.sections.length;n++){const i=t.sections[n];i.image?r.addImageSection(i):r.addTextSection(i,e);}return r}length(){return this.text.length}getSection(t){return this.sections[this.sectionIndex[t]]}getSections(){return this.sections}getSectionIndex(t){return this.sectionIndex[t]}getCharCode(t){return this.text.charCodeAt(t)}verticalizePunctuation(t){this.text=function(t,e){let r="";for(let n=0;n<t.length;n++){const i=t.charCodeAt(n+1)||null,s=t.charCodeAt(n-1)||null;r+=!e&&(i&&ss(i)&&!Gh[t[n+1]]||s&&ss(s)&&!Gh[t[n-1]])||!Gh[t[n]]?t[n]:Gh[t[n]];}return r}(this.text,t);}trim(){let t=0;for(let e=0;e<this.text.length&&Ep[this.text.charCodeAt(e)];e++)t++;let e=this.text.length;for(let r=this.text.length-1;r>=0&&r>=t&&Ep[this.text.charCodeAt(r)];r--)e--;this.text=this.text.substring(t,e),this.sectionIndex=this.sectionIndex.slice(t,e);}substring(t,e){const r=new zp;return r.text=this.text.substring(t,e),r.sectionIndex=this.sectionIndex.slice(t,e),r.sections=this.sections,r}toString(){return this.text}getMaxScale(){return this.sectionIndex.reduce(((t,e)=>Math.max(t,this.sections[e].scale)),0)}addTextSection(t,e){this.text+=t.text,this.sections.push(Tp.forText(t.scale,t.fontStack||e));const r=this.sections.length-1;for(let e=0;e<t.text.length;++e)this.sectionIndex.push(r);}addImageSection(t){const e=t.image?t.image.name:"";if(0===e.length)return void N("Can't add FormattedSection with an empty image.");const r=this.getNextImageSectionCharCode();r?(this.text+=String.fromCharCode(r),this.sections.push(Tp.forImage(e)),this.sectionIndex.push(this.sections.length-1)):N("Reached maximum number of images 6401");}getNextImageSectionCharCode(){return this.imageSectionID?this.imageSectionID>=63743?null:++this.imageSectionID:(this.imageSectionID=57344,this.imageSectionID)}}function Bp(t,e,r,n,i,s,a,o,l,u,c,h,p,d,f){const y=zp.fromFeature(t,i);h===Ip.vertical&&y.verticalizePunctuation(p);let m=[];const g=function(t,e,r,n,i,s){if(!t)return [];const a=[],o=function(t,e,r,n,i,s){let a=0;for(let r=0;r<t.length();r++){const o=t.getSection(r);a+=Pp(t.getCharCode(r),o,n,i,e,s);}return a/Math.max(1,Math.ceil(a/r))}(t,e,r,n,i,s),l=t.text.indexOf("​")>=0;let u=0;for(let r=0;r<t.length();r++){const h=t.getSection(r),p=t.getCharCode(r);if(Ep[p]||(u+=Pp(p,h,n,i,e,s)),r<t.length()-1){const e=!((c=p)<11904||!(ts["Bopomofo Extended"](c)||ts.Bopomofo(c)||ts["CJK Compatibility Forms"](c)||ts["CJK Compatibility Ideographs"](c)||ts["CJK Compatibility"](c)||ts["CJK Radicals Supplement"](c)||ts["CJK Strokes"](c)||ts["CJK Symbols and Punctuation"](c)||ts["CJK Unified Ideographs Extension A"](c)||ts["CJK Unified Ideographs"](c)||ts["Enclosed CJK Letters and Months"](c)||ts["Halfwidth and Fullwidth Forms"](c)||ts.Hiragana(c)||ts["Ideographic Description Characters"](c)||ts["Kangxi Radicals"](c)||ts["Katakana Phonetic Extensions"](c)||ts.Katakana(c)||ts["Vertical Forms"](c)||ts["Yi Radicals"](c)||ts["Yi Syllables"](c)));(Cp[p]||e||h.imageName)&&a.push(Lp(r+1,u,o,a,Vp(p,t.getCharCode(r+1),e&&l),!1));}}var c;return Fp(Lp(t.length(),u,o,a,0,!0))}(y,u,s,e,n,d),{processBidirectionalText:x,processStyledBidirectionalText:v}=bs;if(x&&1===y.sections.length){const t=x(y.toString(),g);for(const e of t){const t=new zp;t.text=e,t.sections=y.sections;for(let r=0;r<e.length;r++)t.sectionIndex.push(0);m.push(t);}}else if(v){const t=v(y.text,y.sectionIndex,g);for(const e of t){const t=new zp;t.text=e[0],t.sectionIndex=e[1],t.sections=y.sections,m.push(t);}}else m=function(t,e){const r=[],n=t.text;let i=0;for(const n of e)r.push(t.substring(i,n)),i=n;return i<n.length&&r.push(t.substring(i,n.length)),r}(y,g);const b=[],w={positionedLines:b,text:y.toString(),top:c[1],bottom:c[1],left:c[0],right:c[0],writingMode:h,iconsInText:!1,verticalizable:!1,hasBaseline:!1};return function(t,e,r,n,i,s,a,o,l,u,c,h){let p=0,d=0,f=0;const y="right"===o?1:"left"===o?0:.5;let m=!1;for(const t of i){const r=t.getSections();for(const t of r){if(t.imageName)continue;const r=e[t.fontStack];if(r&&(m=void 0!==r.ascender&&void 0!==r.descender,!m))break}if(!m)break}let g=0;for(const a of i){a.trim();const i=a.getMaxScale(),o=(i-1)*Rh,v={positionedGlyphs:[],lineOffset:0};t.positionedLines[g]=v;const b=v.positionedGlyphs;let w=0;if(!a.length()){d+=s,++g;continue}let _=0,A=0;for(let s=0;s<a.length();s++){const o=a.getSection(s),f=a.getSectionIndex(s),y=a.getCharCode(s);let g=o.scale,v=null,S=null,k=null,I=Rh,M=0;const T=!(l===Ip.horizontal||!c&&!is(y)||c&&(Ep[y]||(x=y,ts.Arabic(x)||ts["Arabic Supplement"](x)||ts["Arabic Extended-A"](x)||ts["Arabic Presentation Forms-A"](x)||ts["Arabic Presentation Forms-B"](x))));if(o.imageName){const e=n[o.imageName];if(!e)continue;k=o.imageName,t.iconsInText=t.iconsInText||!0,S=e.paddedRect;const r=e.displaySize;g=g*Rh/h,v={width:r[0],height:r[1],left:Ap,top:-wp,advance:T?r[1]:r[0],localGlyph:!1},M=m?-v.height*g:Mp+i*Rh-r[1]*g,I=v.advance;const s=(T?r[0]:r[1])*g-Rh*i;s>0&&s>w&&(w=s);}else {const t=r[o.fontStack];if(!t)continue;t[y]&&(S=t[y]);const n=e[o.fontStack];if(!n)continue;const s=n.glyphs[y];if(!s)continue;if(v=s.metrics,I=8203!==y?Rh:0,m){const t=void 0!==n.ascender?Math.abs(n.ascender):0,e=void 0!==n.descender?Math.abs(n.descender):0,r=(t+e)*g;_<r&&(_=r,A=(t-e)/2*g),M=-t*g;}else M=Mp+(i-g)*Rh;}T?(t.verticalizable=!0,b.push({glyph:y,imageName:k,x:p,y:d+M,vertical:T,scale:g,localGlyph:v.localGlyph,fontStack:o.fontStack,sectionIndex:f,metrics:v,rect:S}),p+=I*g+u):(b.push({glyph:y,imageName:k,x:p,y:d+M,vertical:T,scale:g,localGlyph:v.localGlyph,fontStack:o.fontStack,sectionIndex:f,metrics:v,rect:S}),p+=v.advance*g+u);}0!==b.length&&(f=Math.max(p-u,f),m?Up(b,y,w,A,s*i/2):Up(b,y,w,0,s/2)),p=0;const S=s*i+w;v.lineOffset=Math.max(w,o),d+=S,++g;}var x;const v=d,{horizontalAlign:b,verticalAlign:w}=Rp(a);((((function(t,e,r,n,i,s){const a=(e-r)*i,o=-s*n;for(const e of t)for(const t of e.positionedGlyphs)t.x+=a,t.y+=o;}))))(t.positionedLines,y,b,w,f,v),t.top+=-w*v,t.bottom=t.top+v,t.left+=-b*f,t.right=t.left+f,t.hasBaseline=m;}(w,e,r,n,m,a,o,l,h,u,p,f),!function(t){for(const e of t)if(0!==e.positionedGlyphs.length)return !1;return !0}(b)&&w}const Ep={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},Cp={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function Pp(t,e,r,n,i,s){if(e.imageName){const t=n[e.imageName];return t?t.displaySize[0]*e.scale*Rh/s+i:0}{const n=r[e.fontStack],s=n&&n.glyphs[t];return s?s.metrics.advance*e.scale+i:0}}function Dp(t,e,r,n){const i=Math.pow(t-e,2);return n?t<e?i/2:2*i:i+Math.abs(r)*r}function Vp(t,e,r){let n=0;return 10===t&&(n-=1e4),r&&(n+=150),40!==t&&65288!==t||(n+=50),41!==e&&65289!==e||(n+=50),n}function Lp(t,e,r,n,i,s){let a=null,o=Dp(e,r,i,s);for(const t of n){const n=Dp(e-t.x,r,i,s)+t.badness;n<=o&&(a=t,o=n);}return {index:t,x:e,priorBreak:a,badness:o}}function Fp(t){return t?Fp(t.priorBreak).concat(t.index):[]}function Rp(t){let e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=1;break;case"left":case"top-left":case"bottom-left":e=0;}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;}return {horizontalAlign:e,verticalAlign:r}}function Up(t,e,r,n,i){if(!(e||r||n||i))return;const s=t.length-1,a=t[s],o=(a.x+a.metrics.advance*a.scale)*e;for(let e=0;e<=s;e++)t[e].x-=o,t[e].y+=r+n+i;}function $p(t,e,r){const{horizontalAlign:n,verticalAlign:i}=Rp(r),s=e[0]-t.displaySize[0]*n,a=e[1]-t.displaySize[1]*i;return {image:t,top:a,bottom:a+t.displaySize[1],left:s,right:s+t.displaySize[0]}}function jp(t,e,r,n,i,s){const a=t.image;let o;if(a.content){const t=a.content,e=a.pixelRatio||1;o=[t[0]/e,t[1]/e,a.displaySize[0]-t[2]/e,a.displaySize[1]-t[3]/e];}const l=e.left*s,u=e.right*s;let c,h,p,d;"width"===r||"both"===r?(d=i[0]+l-n[3],h=i[0]+u+n[1]):(d=i[0]+(l+u-a.displaySize[0])/2,h=d+a.displaySize[0]);const f=e.top*s,y=e.bottom*s;return "height"===r||"both"===r?(c=i[1]+f-n[0],p=i[1]+y+n[2]):(c=i[1]+(f+y-a.displaySize[1])/2,p=c+a.displaySize[1]),{image:a,top:c,right:h,bottom:p,left:d,collisionPadding:o}}class Op extends x{constructor(t,e,r,n,i){super(t,e),this.angle=n,this.z=r,void 0!==i&&(this.segment=i);}clone(){return new Op(this.x,this.y,this.z,this.angle,this.segment)}}function qp(t,e,r,n,i){if(void 0===e.segment)return !0;let s=e,a=e.segment+1,o=0;for(;o>-r/2;){if(a--,a<0)return !1;o-=t[a].dist(s),s=t[a];}o+=t[a].dist(t[a+1]),a++;const l=[];let u=0;for(;o<r/2;){const e=t[a],r=t[a+1];if(!r)return !1;let s=t[a-1].angleTo(e)-e.angleTo(r);for(s=Math.abs((s+3*Math.PI)%(2*Math.PI)-Math.PI),l.push({distance:o,angleDelta:s}),u+=s;o-l[0].distance>n;)u-=l.shift().angleDelta;if(u>i)return !1;a++,o+=e.dist(r);}return !0}function Np(t){let e=0;for(let r=0;r<t.length-1;r++)e+=t[r].dist(t[r+1]);return e}function Gp(t,e,r){return t?.6*e*r:0}function Zp(t,e){return Math.max(t?t.right-t.left:0,e?e.right-e.left:0)}function Kp(t,e,r,n,i,s){const a=Gp(r,i,s),o=Zp(r,n)*s;let l=0;const u=Np(t)/2;for(let r=0;r<t.length-1;r++){const n=t[r],i=t[r+1],s=n.dist(i);if(l+s>u){const c=(u-l)/s,h=Er(n.x,i.x,c),p=Er(n.y,i.y,c),d=new Op(h,p,0,i.angleTo(n),r);return !a||qp(t,d,o,a,e)?d:void 0}l+=s;}}function Xp(t,e,r,n,i,s,a,o,l){const u=Gp(n,s,a),c=Zp(n,i),h=c*a,p=0===t[0].x||t[0].x===l||0===t[0].y||t[0].y===l;return e-h<e/4&&(e=h+e/4),Jp(t,p?e/2*o%e:(c/2+2*s)*a*o%e,e,u,r,h,p,!1,l)}function Jp(t,e,r,n,i,s,a,o,l){const u=s/2,c=Np(t);let h=0,p=e-r,d=[];for(let e=0;e<t.length-1;e++){const a=t[e],o=t[e+1],f=a.dist(o),y=o.angleTo(a);for(;p+r<h+f;){p+=r;const m=(p-h)/f,g=Er(a.x,o.x,m),x=Er(a.y,o.y,m);if(g>=0&&g<l&&x>=0&&x<l&&p-u>=0&&p+u<=c){const r=new Op(g,x,0,y,e);r._round(),n&&!qp(t,r,s,n,i)||d.push(r);}}h+=f;}return o||d.length||a||(d=Jp(t,h/2,r,n,i,s,a,!0,l)),d}function Hp(t,e,r,n,i){const s=[];for(let a=0;a<t.length;a++){const o=t[a];let l;for(let t=0;t<o.length-1;t++){let a=o[t],u=o[t+1];a.x<e&&u.x<e||(a.x<e?a=new x(e,a.y+(e-a.x)/(u.x-a.x)*(u.y-a.y))._round():u.x<e&&(u=new x(e,a.y+(e-a.x)/(u.x-a.x)*(u.y-a.y))._round()),a.y<r&&u.y<r||(a.y<r?a=new x(a.x+(r-a.y)/(u.y-a.y)*(u.x-a.x),r)._round():u.y<r&&(u=new x(a.x+(r-a.y)/(u.y-a.y)*(u.x-a.x),r)._round()),a.x>=n&&u.x>=n||(a.x>=n?a=new x(n,a.y+(n-a.x)/(u.x-a.x)*(u.y-a.y))._round():u.x>=n&&(u=new x(n,a.y+(n-a.x)/(u.x-a.x)*(u.y-a.y))._round()),a.y>=i&&u.y>=i||(a.y>=i?a=new x(a.x+(i-a.y)/(u.y-a.y)*(u.x-a.x),i)._round():u.y>=i&&(u=new x(a.x+(i-a.y)/(u.y-a.y)*(u.x-a.x),i)._round()),l&&a.equals(l[l.length-1])||(l=[a],s.push(l)),l.push(u)))));}}return s}Ji(Op,"Anchor");const Yp=1e20;function Wp(t,e,r,n,i,s,a,o,l){for(let u=e;u<e+n;u++)Qp(t,r*s+u,s,i,a,o,l);for(let u=r;u<r+i;u++)Qp(t,u*s+e,1,n,a,o,l);}function Qp(t,e,r,n,i,s,a){s[0]=0,a[0]=-Yp,a[1]=Yp,i[0]=t[e];for(let o=1,l=0,u=0;o<n;o++){i[o]=t[e+o*r];const n=o*o;do{const t=s[l];u=(i[o]-i[t]+n-t*t)/(o-t)/2;}while(u<=a[l]&&--l>-1);l++,s[l]=o,a[l]=u,a[l+1]=Yp;}for(let o=0,l=0;o<n;o++){for(;a[l+1]<o;)l++;const n=s[l],u=o-n;t[e+o*r]=i[n]+u*u;}}const td=2,ed={none:0,ideographs:1,all:2};class rd{constructor(t,e,r){this.requestManager=t,this.localGlyphMode=e,this.localFontFamily=r,this.entries={},this.localGlyphs={200:{},400:{},500:{},900:{}};}setURL(t){this.url=t;}getGlyphs(t,e){const r=[];for(const e in t)for(const n of t[e])r.push({stack:e,id:n});B(r,(({stack:t,id:e},r)=>{let n=this.entries[t];n||(n=this.entries[t]={glyphs:{},requests:{},ranges:{},ascender:void 0,descender:void 0});let i=n.glyphs[e];if(void 0!==i)return void r(null,{stack:t,id:e,glyph:i});if(i=this._tinySDF(n,t,e),i)return n.glyphs[e]=i,void r(null,{stack:t,id:e,glyph:i});const s=Math.floor(e/256);if(256*s>65535)return void r(new Error("glyphs > 65535 not supported"));if(n.ranges[s])return void r(null,{stack:t,id:e,glyph:i});let a=n.requests[s];a||(a=n.requests[s]=[],rd.loadGlyphRange(t,s,this.url,this.requestManager,((t,e)=>{if(e){n.ascender=e.ascender,n.descender=e.descender;for(const t in e.glyphs)this._doesCharSupportLocalGlyph(+t)||(n.glyphs[+t]=e.glyphs[+t]);n.ranges[s]=!0;}for(const r of a)r(t,e);delete n.requests[s];}))),a.push(((n,i)=>{n?r(n):i&&r(null,{stack:t,id:e,glyph:i.glyphs[e]||null});}));}),((t,r)=>{if(t)e(t);else if(r){const t={};for(const{stack:e,id:n,glyph:i}of r)void 0===t[e]&&(t[e]={}),void 0===t[e].glyphs&&(t[e].glyphs={}),t[e].glyphs[n]=i&&{id:i.id,bitmap:i.bitmap.clone(),metrics:i.metrics},t[e].ascender=this.entries[e].ascender,t[e].descender=this.entries[e].descender;e(null,t);}}));}_doesCharSupportLocalGlyph(t){return this.localGlyphMode!==ed.none&&(this.localGlyphMode===ed.all?!!this.localFontFamily:!!this.localFontFamily&&(ts["CJK Unified Ideographs"](t)||ts["Hangul Syllables"](t)||ts.Hiragana(t)||ts.Katakana(t)||ts["CJK Symbols and Punctuation"](t)))}_tinySDF(t,e,r){const n=this.localFontFamily;if(!n||!this._doesCharSupportLocalGlyph(r))return;let i=t.tinySDF;if(!i){let r="400";/bold/i.test(e)?r="900":/medium/i.test(e)?r="500":/light/i.test(e)&&(r="200"),i=t.tinySDF=new rd.TinySDF({fontFamily:n,fontWeight:r,fontSize:24*td,buffer:3*td,radius:8*td}),i.fontWeight=r;}if(this.localGlyphs[i.fontWeight][r])return this.localGlyphs[i.fontWeight][r];const s=String.fromCharCode(r),{data:a,width:o,height:l,glyphWidth:u,glyphHeight:c,glyphLeft:h,glyphTop:p,glyphAdvance:d}=i.draw(s);return this.localGlyphs[i.fontWeight][r]={id:r,bitmap:new Ru({width:o,height:l},a),metrics:{width:u/td,height:c/td,left:h/td,top:p/td-27,advance:d/td,localGlyph:!0}}}}rd.loadGlyphRange=function(t,e,r,n,i){const s=256*e,a=s+255,o=n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}",t).replace("{range}",`${s}-${a}`),lt.Glyphs);pt(o,((t,e)=>{if(t)i(t);else if(e){const t={},r=function(t){return new mp(t).readFields(xp,{})}(e);for(const e of r.glyphs)t[e.id]=e;i(null,{glyphs:t,ascender:r.ascender,descender:r.descender});}}));},rd.TinySDF=class{constructor({fontSize:t=24,buffer:e=3,radius:r=8,cutoff:n=.25,fontFamily:i="sans-serif",fontWeight:s="normal",fontStyle:a="normal"}={}){this.buffer=e,this.cutoff=n,this.radius=r;const o=this.size=t+4*e,l=this._createCanvas(o),u=this.ctx=l.getContext("2d",{willReadFrequently:!0});u.font=`${a} ${s} ${t}px ${i}`,u.textBaseline="alphabetic",u.textAlign="left",u.fillStyle="black",this.gridOuter=new Float64Array(o*o),this.gridInner=new Float64Array(o*o),this.f=new Float64Array(o),this.z=new Float64Array(o+1),this.v=new Uint16Array(o);}_createCanvas(t){const e=document.createElement("canvas");return e.width=e.height=t,e}draw(t){const{width:e,actualBoundingBoxAscent:r,actualBoundingBoxDescent:n,actualBoundingBoxLeft:i,actualBoundingBoxRight:s}=this.ctx.measureText(t),a=Math.ceil(r),o=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-i))),l=Math.min(this.size-this.buffer,a+Math.ceil(n)),u=o+2*this.buffer,c=l+2*this.buffer,h=Math.max(u*c,0),p=new Uint8ClampedArray(h),d={data:p,width:u,height:c,glyphWidth:o,glyphHeight:l,glyphTop:a,glyphLeft:0,glyphAdvance:e};if(0===o||0===l)return d;const{ctx:f,buffer:y,gridInner:m,gridOuter:g}=this;f.clearRect(y,y,o,l),f.fillText(t,y,y+a);const x=f.getImageData(y,y,o,l);g.fill(Yp,0,h),m.fill(0,0,h);for(let t=0;t<l;t++)for(let e=0;e<o;e++){const r=x.data[4*(t*o+e)+3]/255;if(0===r)continue;const n=(t+y)*u+e+y;if(1===r)g[n]=0,m[n]=Yp;else {const t=.5-r;g[n]=t>0?t*t:0,m[n]=t<0?t*t:0;}}Wp(g,0,0,u,c,u,this.f,this.v,this.z),Wp(m,y,y,o,l,u,this.f,this.v,this.z);for(let t=0;t<h;t++){const e=Math.sqrt(g[t])-Math.sqrt(m[t]);p[t]=Math.round(255-255*(e/this.radius+this.cutoff));}return d}};const nd=Ap;function id(t,e,r,n){const i=[],s=t.image,a=s.pixelRatio,o=s.paddedRect.w-2*nd,l=s.paddedRect.h-2*nd,u=t.right-t.left,c=t.bottom-t.top,h=s.stretchX||[[0,o]],p=s.stretchY||[[0,l]],d=(t,e)=>t+e[1]-e[0],f=h.reduce(d,0),y=p.reduce(d,0),m=o-f,g=l-y;let v=0,b=f,w=0,_=y,A=0,S=m,k=0,I=g;if(s.content&&n){const t=s.content;v=sd(h,0,t[0]),w=sd(p,0,t[1]),b=sd(h,t[0],t[2]),_=sd(p,t[1],t[3]),A=t[0]-v,k=t[1]-w,S=t[2]-t[0]-b,I=t[3]-t[1]-_;}const M=(n,i,o,l)=>{const h=od(n.stretch-v,b,u,t.left),p=ld(n.fixed-A,S,n.stretch,f),d=od(i.stretch-w,_,c,t.top),m=ld(i.fixed-k,I,i.stretch,y),g=od(o.stretch-v,b,u,t.left),M=ld(o.fixed-A,S,o.stretch,f),T=od(l.stretch-w,_,c,t.top),z=ld(l.fixed-k,I,l.stretch,y),B=new x(h,d),E=new x(g,d),C=new x(g,T),P=new x(h,T),D=new x(p/a,m/a),V=new x(M/a,z/a),L=e*Math.PI/180;if(L){const t=Math.sin(L),e=Math.cos(L),r=[e,-t,t,e];B._matMult(r),E._matMult(r),P._matMult(r),C._matMult(r);}const F=n.stretch+n.fixed,R=i.stretch+i.fixed;return {tl:B,tr:E,bl:P,br:C,tex:{x:s.paddedRect.x+nd+F,y:s.paddedRect.y+nd+R,w:o.stretch+o.fixed-F,h:l.stretch+l.fixed-R},writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:D,pixelOffsetBR:V,minFontScaleX:S/a/u,minFontScaleY:I/a/c,isSDF:r}};if(n&&(s.stretchX||s.stretchY)){const t=ad(h,m,f),e=ad(p,g,y);for(let r=0;r<t.length-1;r++){const n=t[r],s=t[r+1];for(let t=0;t<e.length-1;t++)i.push(M(n,e[t],s,e[t+1]));}}else i.push(M({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:o+1},{fixed:0,stretch:l+1}));return i}function sd(t,e,r){let n=0;for(const i of t)n+=Math.max(e,Math.min(r,i[1]))-Math.max(e,Math.min(r,i[0]));return n}function ad(t,e,r){const n=[{fixed:-nd,stretch:0}];for(const[e,r]of t){const t=n[n.length-1];n.push({fixed:e-t.stretch,stretch:t.stretch}),n.push({fixed:e-t.stretch,stretch:t.stretch+(r-e)});}return n.push({fixed:e+nd,stretch:r}),n}function od(t,e,r,n){return t/e*r+n}function ld(t,e,r,n){return t-e*r/n}function ud(t,e,r,n){const i=e+t.positionedLines[n].lineOffset;return 0===n?r+i/2:r+(i+(e+t.positionedLines[n-1].lineOffset))/2}class cd{constructor(t=[],e=hd){if(this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t);}push(t){this.data.push(t),this.length++,this._up(this.length-1);}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:r}=this,n=e[t];for(;t>0;){const i=t-1>>1,s=e[i];if(r(n,s)>=0)break;e[t]=s,t=i;}e[t]=n;}_down(t){const{data:e,compare:r}=this,n=this.length>>1,i=e[t];for(;t<n;){let n=1+(t<<1),s=e[n];const a=n+1;if(a<this.length&&r(e[a],s)<0&&(n=a,s=e[a]),r(s,i)>=0)break;e[t]=s,t=n;}e[t]=i;}}function hd(t,e){return t<e?-1:t>e?1:0}function pd(t,e=1,r=!1){let n=1/0,i=1/0,s=-1/0,a=-1/0;const o=t[0];for(let t=0;t<o.length;t++){const e=o[t];(!t||e.x<n)&&(n=e.x),(!t||e.y<i)&&(i=e.y),(!t||e.x>s)&&(s=e.x),(!t||e.y>a)&&(a=e.y);}const l=Math.min(s-n,a-i);let u=l/2;const c=new cd([],dd);if(0===l)return new x(n,i);for(let e=n;e<s;e+=l)for(let r=i;r<a;r+=l)c.push(new fd(e+u,r+u,u,t));let h=function(t){let e=0,r=0,n=0;const i=t[0];for(let t=0,s=i.length,a=s-1;t<s;a=t++){const s=i[t],o=i[a],l=s.x*o.y-o.x*s.y;r+=(s.x+o.x)*l,n+=(s.y+o.y)*l,e+=3*l;}return new fd(r/e,n/e,0,t)}(t),p=c.length;for(;c.length;){const n=c.pop();(n.d>h.d||!h.d)&&(h=n,r&&console.log("found best %d after %d probes",Math.round(1e4*n.d)/1e4,p)),n.max-h.d<=e||(u=n.h/2,c.push(new fd(n.p.x-u,n.p.y-u,u,t)),c.push(new fd(n.p.x+u,n.p.y-u,u,t)),c.push(new fd(n.p.x-u,n.p.y+u,u,t)),c.push(new fd(n.p.x+u,n.p.y+u,u,t)),p+=4);}return r&&(console.log(`num probes: ${p}`),console.log(`best distance: ${h.d}`)),h.p}function dd(t,e){return e.max-t.max}class fd{constructor(t,e,r,n){this.p=new x(t,e),this.h=r,this.d=function(t,e){let r=!1,n=1/0;for(let i=0;i<e.length;i++){const s=e[i];for(let e=0,i=s.length,a=i-1;e<i;a=e++){const i=s[e],o=s[a];i.y>t.y!=o.y>t.y&&t.x<(o.x-i.x)*(t.y-i.y)/(o.y-i.y)+i.x&&(r=!r),n=Math.min(n,xu(t,i,o));}}return (r?1:-1)*Math.sqrt(n)}(this.p,n),this.max=this.d+this.h*Math.SQRT2;}}const yd=7,md=Number.POSITIVE_INFINITY,gd=Math.sqrt(2);function xd(t,[e,r]){let n=0,i=0;if(r===md){e<0&&(e=0);const r=e/gd;switch(t){case"top-right":case"top-left":i=r-yd;break;case"bottom-right":case"bottom-left":i=-r+yd;break;case"bottom":i=-e+yd;break;case"top":i=e-yd;}switch(t){case"top-right":case"bottom-right":n=-r;break;case"top-left":case"bottom-left":n=r;break;case"left":n=e;break;case"right":n=-e;}}else {switch(e=Math.abs(e),r=Math.abs(r),t){case"top-right":case"top-left":case"top":i=r-yd;break;case"bottom-right":case"bottom-left":case"bottom":i=-r+yd;}switch(t){case"top-right":case"bottom-right":case"right":n=-e;break;case"top-left":case"bottom-left":case"left":n=e;}}return [n,i]}function vd(t,e,r,n,i,s,a,o,l,u){t.createArrays(),t.tilePixelRatio=ao/(512*t.overscaling),t.compareText={},t.iconsNeedLinear=!1;const c=t.layers[0].layout,h=t.layers[0]._unevaluatedLayout._values,p={};if("composite"===t.textSizeData.kind){const{minZoom:e,maxZoom:r}=t.textSizeData;p.compositeTextSizes=[h["text-size"].possiblyEvaluate(new ws(e),o),h["text-size"].possiblyEvaluate(new ws(r),o)];}if("composite"===t.iconSizeData.kind){const{minZoom:e,maxZoom:r}=t.iconSizeData;p.compositeIconSizes=[h["icon-size"].possiblyEvaluate(new ws(e),o),h["icon-size"].possiblyEvaluate(new ws(r),o)];}p.layoutTextSize=h["text-size"].possiblyEvaluate(new ws(l+1),o),p.layoutIconSize=h["icon-size"].possiblyEvaluate(new ws(l+1),o),p.textMaxSize=h["text-size"].possiblyEvaluate(new ws(18),o);const d="map"===c.get("text-rotation-alignment")&&"point"!==c.get("symbol-placement"),f=c.get("text-size");for(const s of t.features){const l=c.get("text-font").evaluate(s,{},o).join(","),h=f.evaluate(s,{},o),y=p.layoutTextSize.evaluate(s,{},o),m=(p.layoutIconSize.evaluate(s,{},o),{horizontal:{},vertical:void 0}),g=s.text;let x,v=[0,0];if(g){const n=g.toString(),a=c.get("text-letter-spacing").evaluate(s,{},o)*Rh,u=c.get("text-line-height").evaluate(s,{},o)*Rh,p=rs(n)?a:0,f=c.get("text-anchor").evaluate(s,{},o),x=c.get("text-variable-anchor");if(!x){const t=c.get("text-radial-offset").evaluate(s,{},o);v=t?xd(f,[t*Rh,md]):c.get("text-offset").evaluate(s,{},o).map((t=>t*Rh));}let b=d?"center":c.get("text-justify").evaluate(s,{},o);const w="point"===c.get("symbol-placement"),_=w?c.get("text-max-width").evaluate(s,{},o)*Rh:1/0,A=s=>{t.allowVerticalPlacement&&es(n)&&(m.vertical=Bp(g,e,r,i,l,_,u,f,s,p,v,Ip.vertical,!0,y,h));};if(!d&&x){const t="auto"===b?x.map((t=>bd(t))):[b];let n=!1;for(let s=0;s<t.length;s++){const a=t[s];if(!m.horizontal[a])if(n)m.horizontal[a]=m.horizontal[0];else {const t=Bp(g,e,r,i,l,_,u,"center",a,p,v,Ip.horizontal,!1,y,h);t&&(m.horizontal[a]=t,n=1===t.positionedLines.length);}}A("left");}else {if("auto"===b&&(b=bd(f)),w||c.get("text-writing-mode").indexOf("horizontal")>=0||!es(n)){const t=Bp(g,e,r,i,l,_,u,f,b,p,v,Ip.horizontal,!1,y,h);t&&(m.horizontal[b]=t);}A(w?"left":b);}}let b=!1;if(s.icon&&s.icon.name){const e=n[s.icon.name];e&&(x=$p(i[s.icon.name],c.get("icon-offset").evaluate(s,{},o),c.get("icon-anchor").evaluate(s,{},o)),b=e.sdf,void 0===t.sdfIcons?t.sdfIcons=e.sdf:t.sdfIcons!==e.sdf&&N("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(e.pixelRatio!==t.pixelRatio||0!==c.get("icon-rotate").constantOr(1))&&(t.iconsNeedLinear=!0));}const w=kd(m.horizontal)||m.vertical;t.iconsInText||(t.iconsInText=!!w&&w.iconsInText),(w||x)&&wd(t,s,m,x,n,p,y,0,v,b,a,o,u);}s&&t.generateCollisionDebugBuffers(l,t.collisionBoxArray);}function bd(t){switch(t){case"right":case"top-right":case"bottom-right":return "right";case"left":case"top-left":case"bottom-left":return "left"}return "center"}function wd(t,e,r,n,i,s,a,o,l,u,c,h,p){let d=s.textMaxSize.evaluate(e,{},h);void 0===d&&(d=a);const f=t.layers[0].layout,y=f.get("icon-offset").evaluate(e,{},h),m=kd(r.horizontal)||r.vertical,g="globe"===p.name,x=Rh,v=a/x,b=t.tilePixelRatio*d/x,_=(B=t.overscaling,t.zoom>18&&B>2&&(B>>=1),Math.max(ao/(512*B),1)*f.get("symbol-spacing")),A=f.get("text-padding")*t.tilePixelRatio,S=f.get("icon-padding")*t.tilePixelRatio,k=w(f.get("text-max-angle")),I="map"===f.get("text-rotation-alignment")&&"point"!==f.get("symbol-placement"),M="map"===f.get("icon-rotation-alignment")&&"point"!==f.get("symbol-placement"),T=f.get("symbol-placement"),z=_/2;var B;const E=f.get("icon-text-fit");let C;n&&"none"!==E&&(t.allowVerticalPlacement&&r.vertical&&(C=jp(n,r.vertical,E,f.get("icon-text-fit-padding"),y,v)),m&&(n=jp(n,m,E,f.get("icon-text-fit-padding"),y,v)));const P=(a,o,d)=>{if(o.x<0||o.x>=ao||o.y<0||o.y>=ao)return;let f=null;if(g){const{x:t,y:e,z:r}=p.projectTilePoint(o.x,o.y,d);f={anchor:new Op(t,e,r,0,void 0),up:p.upVector(d,o.x,o.y)};}!function(t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m,g,x,v,b,w,_,A,S){const k=t.addToLineVertexArray(e,n);let I,M,T,z,B,E,C,P=0,D=0,V=0,L=0,F=-1,R=-1;const U={};let $=Ba("");const j=r?r.anchor:e;let O=0,q=0;if(void 0===l._unevaluatedLayout.getValue("text-radial-offset")?[O,q]=l.layout.get("text-offset").evaluate(b,{},S).map((t=>t*Rh)):(O=l.layout.get("text-radial-offset").evaluate(b,{},S)*Rh,q=md),t.allowVerticalPlacement&&i.vertical){const t=i.vertical;if(f)E=Md(t),o&&(C=Md(o));else {const r=l.layout.get("text-rotate").evaluate(b,{},S)+90;T=Id(u,j,e,c,h,p,t,d,r,y),o&&(z=Id(u,j,e,c,h,p,o,g,r));}}if(s){const n=l.layout.get("icon-rotate").evaluate(b,{},S),i="none"!==l.layout.get("icon-text-fit"),a=id(s,n,_,i),d=o?id(o,n,_,i):void 0;M=Id(u,j,e,c,h,p,s,g,n),P=4*a.length;const f=t.iconSizeData;let y=null;"source"===f.kind?(y=[Uh*l.layout.get("icon-size").evaluate(b,{},S)],y[0]>Ad&&N(`${t.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)):"composite"===f.kind&&(y=[Uh*w.compositeIconSizes[0].evaluate(b,{},S),Uh*w.compositeIconSizes[1].evaluate(b,{},S)],(y[0]>Ad||y[1]>Ad)&&N(`${t.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)),t.addSymbols(t.icon,a,y,v,x,b,!1,r,e,k.lineStartIndex,k.lineLength,-1,A,S),F=t.icon.placedSymbolArray.length-1,d&&(D=4*d.length,t.addSymbols(t.icon,d,y,v,x,b,Ip.vertical,r,e,k.lineStartIndex,k.lineLength,-1,A,S),R=t.icon.placedSymbolArray.length-1);}for(const n in i.horizontal){const s=i.horizontal[n];I||($=Ba(s.text),f?B=Md(s):I=Id(u,j,e,c,h,p,s,d,l.layout.get("text-rotate").evaluate(b,{},S),y));const o=1===s.positionedLines.length;if(V+=Sd(t,r,e,s,a,l,f,b,y,k,i.vertical?Ip.horizontal:Ip.horizontalOnly,o?Object.keys(i.horizontal):[n],U,F,w,A,S),o)break}i.vertical&&(L+=Sd(t,r,e,i.vertical,a,l,f,b,y,k,Ip.vertical,["vertical"],U,R,w,A,S));let G=-1;const Z=(t,e)=>t?Math.max(t,e):e;G=Z(B,G),G=Z(E,G),G=Z(C,G);const K=G>-1?1:0;t.glyphOffsetArray.length>=of.MAX_GLYPHS&&N("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),void 0!==b.sortKey&&t.addToSortKeyRanges(t.symbolInstances.length,b.sortKey),t.symbolInstances.emplaceBack(j.x,j.y,j.z,e.x,e.y,U.right>=0?U.right:-1,U.center>=0?U.center:-1,U.left>=0?U.left:-1,U.vertical>=0?U.vertical:-1,F,R,$,void 0!==I?I:t.collisionBoxArray.length,void 0!==I?I+1:t.collisionBoxArray.length,void 0!==T?T:t.collisionBoxArray.length,void 0!==T?T+1:t.collisionBoxArray.length,void 0!==M?M:t.collisionBoxArray.length,void 0!==M?M+1:t.collisionBoxArray.length,z||t.collisionBoxArray.length,z?z+1:t.collisionBoxArray.length,c,V,L,P,D,K,0,O,q,G);}(t,o,f,a,r,n,i,C,t.layers[0],t.collisionBoxArray,e.index,e.sourceLayerIndex,t.index,A,I,l,0,S,M,y,e,s,u,c,h);};if("line"===T)for(const i of Hp(e.geometry,0,0,ao,ao)){const e=Xp(i,_,k,r.vertical||m,n,x,b,t.overscaling,ao);for(const r of e)m&&Td(t,m.text,z,r)||P(i,r,h);}else if("line-center"===T){for(const t of e.geometry)if(t.length>1){const e=Kp(t,k,r.vertical||m,n,x,b);e&&P(t,e,h);}}else if("Polygon"===e.type)for(const t of Ac(e.geometry,0)){const e=pd(t,16);P(t[0],new Op(e.x,e.y,0,0,void 0),h);}else if("LineString"===e.type)for(const t of e.geometry)P(t,new Op(t[0].x,t[0].y,0,0,void 0),h);else if("Point"===e.type)for(const t of e.geometry)for(const e of t)P([e],new Op(e.x,e.y,0,0,void 0),h);}const _d=255,Ad=_d*Uh;function Sd(t,e,r,n,i,s,a,o,l,u,c,h,p,d,f,y,m){const g=function(t,e,r,n,i,s,a,o){const l=[];if(0===e.positionedLines.length)return l;const u=n.layout.get("text-rotate").evaluate(s,{})*Math.PI/180,c=function(t){const e=t[0],r=t[1],n=e*r;return n>0?[e,-r]:n<0?[-e,r]:0===e?[r,e]:[r,-e]}(r);let h=Math.abs(e.top-e.bottom);for(const t of e.positionedLines)h-=t.lineOffset;const p=e.positionedLines.length,d=h/p;let f=e.top-r[1];for(let t=0;t<p;++t){const n=e.positionedLines[t];f=ud(e,d,f,t);for(const t of n.positionedGlyphs){if(!t.rect)continue;const n=t.rect||{};let s=wp+1,h=!0,p=1,d=0;if(t.imageName){const e=a[t.imageName];if(!e)continue;if(e.sdf){N("SDF images are not supported in formatted text and will be ignored.");continue}h=!1,p=e.pixelRatio,s=Ap/p;}const y=(i||o)&&t.vertical,m=t.metrics.advance*t.scale/2,g=t.metrics,v=t.rect;if(null===v)continue;o&&e.verticalizable&&(d=t.imageName?m-t.metrics.width*t.scale/2:0);const b=i?[t.x+m,t.y]:[0,0];let w=[0,0],_=[0,0],A=!1;i||(y?(_=[t.x+m+c[0],t.y+c[1]-d],A=!0):w=[t.x+m+r[0],t.y+r[1]-d]);const S=v.w*t.scale/(p*(t.localGlyph?td:1)),k=v.h*t.scale/(p*(t.localGlyph?td:1));let I,M,T,z;if(y){const e=t.y-f,r=new x(-m,m-e),n=-Math.PI/2,i=new x(..._);I=new x(-m+w[0],w[1]),I._rotateAround(n,r)._add(i),I.x+=-e+m,I.y-=(g.left-s)*t.scale;const a=t.imageName?g.advance*t.scale:Rh*t.scale,o=String.fromCharCode(t.glyph);Zh(o)?I.x+=(1-s)*t.scale:Kh(o)?I.x+=a-g.height*t.scale+(-s-1)*t.scale:I.x+=t.imageName||g.width+2*s===v.w&&g.height+2*s===v.h?(a-k)/2:(a-(g.height+2*s)*t.scale)/2,M=new x(I.x,I.y-S),T=new x(I.x+k,I.y),z=new x(I.x+k,I.y-S);}else {const e=(g.left-s)*t.scale-m+w[0],r=(-g.top-s)*t.scale+w[1],n=e+S,i=r+k;I=new x(e,r),M=new x(n,r),T=new x(e,i),z=new x(n,i);}if(u){let t;t=i?new x(0,0):A?new x(c[0],c[1]):new x(r[0],r[1]),I._rotateAround(u,t),M._rotateAround(u,t),T._rotateAround(u,t),z._rotateAround(u,t);}const B=new x(0,0),E=new x(0,0);l.push({tl:I,tr:M,bl:T,br:z,tex:n,writingMode:e.writingMode,glyphOffset:b,sectionIndex:t.sectionIndex,isSDF:h,pixelOffsetTL:B,pixelOffsetBR:E,minFontScaleX:0,minFontScaleY:0});}}return l}(0,n,l,s,a,o,i,t.allowVerticalPlacement),v=t.textSizeData;let b=null;"source"===v.kind?(b=[Uh*s.layout.get("text-size").evaluate(o,{},m)],b[0]>Ad&&N(`${t.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)):"composite"===v.kind&&(b=[Uh*f.compositeTextSizes[0].evaluate(o,{},m),Uh*f.compositeTextSizes[1].evaluate(o,{},m)],(b[0]>Ad||b[1]>Ad)&&N(`${t.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)),t.addSymbols(t.text,g,b,l,a,o,c,e,r,u.lineStartIndex,u.lineLength,d,y,m);for(const e of h)p[e]=t.text.placedSymbolArray.length-1;return 4*g.length}function kd(t){for(const e in t)return t[e];return null}function Id(t,e,r,n,i,s,a,o,l,u){let c=a.top,h=a.bottom,p=a.left,d=a.right;const f=a.collisionPadding;if(f&&(p-=f[0],c-=f[1],d+=f[2],h+=f[3]),l){const t=new x(p,c),e=new x(d,c),r=new x(p,h),n=new x(d,h),i=w(l);let s=new x(0,0);u&&(s=new x(u[0],u[1])),t._rotateAround(i,s),e._rotateAround(i,s),r._rotateAround(i,s),n._rotateAround(i,s),p=Math.min(t.x,e.x,r.x,n.x),d=Math.max(t.x,e.x,r.x,n.x),c=Math.min(t.y,e.y,r.y,n.y),h=Math.max(t.y,e.y,r.y,n.y);}return t.emplaceBack(e.x,e.y,e.z,r.x,r.y,p,c,d,h,o,n,i,s),t.length-1}function Md(t){t.collisionPadding&&(t.top-=t.collisionPadding[1],t.bottom+=t.collisionPadding[3]);const e=t.bottom-t.top;return e>0?Math.max(10,e):null}function Td(t,e,r,n){const i=t.compareText;if(e in i){const t=i[e];for(let e=t.length-1;e>=0;e--)if(n.dist(t[e])<r)return !0}else i[e]=[];return i[e].push(n),!1}function zd(t,e){const r=t.fovAboveCenter,n=t.elevation?t.elevation.getMinElevationBelowMSL()*e:0,i=(t._camera.position[2]*t.worldSize-n)/Math.cos(t._pitch),s=Math.sin(r)*i/Math.sin(Math.max(Math.PI/2-t._pitch-r,.01)),a=Math.sin(t._pitch)*s+i;return Math.min(1.01*a,i*(1/t._horizonShift))}function Bd(t,e){if(!e.isReprojectedInTileSpace)return {scale:1<<t.z,x:t.x,y:t.y,x2:t.x+1,y2:t.y+1,projection:e};const r=Math.pow(2,-t.z),n=t.x*r,i=(t.x+1)*r,s=t.y*r,a=(t.y+1)*r,o=Kl(n),l=Kl(i),u=Xl(s),c=Xl(a),h=e.project(o,u),p=e.project(l,u),d=e.project(l,c),f=e.project(o,c);let y=Math.min(h.x,p.x,d.x,f.x),m=Math.min(h.y,p.y,d.y,f.y),g=Math.max(h.x,p.x,d.x,f.x),x=Math.max(h.y,p.y,d.y,f.y);const v=r/16;function b(t,r,n,i,s,a){const o=(n+s)/2,l=(i+a)/2,u=e.project(Kl(o),Xl(l)),c=Math.max(0,y-u.x,m-u.y,u.x-g,u.y-x);y=Math.min(y,u.x),g=Math.max(g,u.x),m=Math.min(m,u.y),x=Math.max(x,u.y),c>v&&(b(t,u,n,i,o,l),b(u,r,o,l,s,a));}b(h,p,n,s,i,s),b(p,d,i,s,i,a),b(d,f,i,a,n,a),b(f,h,n,a,n,s),y-=v,m-=v,g+=v,x+=v;const w=1/Math.max(g-y,x-m);return {scale:w,x:y*w,y:m*w,x2:g*w,y2:x*w,projection:e}}const Ed=po(new Float32Array(16));class Cd{constructor(t){this.spec=t,this.name=t.name,this.wrap=!1,this.requiresDraping=!1,this.supportsWorldCopies=!1,this.supportsTerrain=!1,this.supportsFog=!1,this.supportsFreeCamera=!1,this.zAxisUnit="meters",this.isReprojectedInTileSpace=!0,this.unsupportedLayers=["custom"],this.center=[0,0],this.range=[3.5,7];}project(t,e){return {x:0,y:0,z:0}}unproject(t,e){return new Ol(0,0)}projectTilePoint(t,e,r){return {x:t,y:e,z:0}}locationPoint(t,e,r=!0){return t._coordinatePoint(t.locationCoordinate(e),r)}pixelsPerMeter(t,e){return Zl(1,t)*e}pixelSpaceConversion(t,e,r){return 1}farthestPixelDistance(t){return zd(t,t.pixelsPerMeter)}pointCoordinate(t,e,r,n){const i=t.horizonLineFromTop(!1),s=new x(e,Math.max(i,r));return t.rayIntersectionCoordinate(t.pointRayIntersection(s,n))}pointCoordinate3D(t,e,r){const n=new x(e,r);if(t.elevation)return t.elevation.pointCoordinate(n);{const e=this.pointCoordinate(t,n.x,n.y,0);return [e.x,e.y,e.z]}}isPointAboveHorizon(t,e){if(t.elevation)return !this.pointCoordinate3D(t,e.x,e.y);const r=t.horizonLineFromTop();return e.y<r}createInversionMatrix(t,e){return Ed}createTileMatrix(t,e,r){let n,i,s;const a=r.canonical,o=po(new Float64Array(16));if(this.isReprojectedInTileSpace){const l=Bd(a,this);n=1,i=l.x+r.wrap*l.scale,s=l.y,go(o,o,[n/l.scale,n/l.scale,t.pixelsPerMeter/e]);}else n=e/t.zoomScale(a.z),i=(a.x+Math.pow(2,a.z)*r.wrap)*n,s=a.y*n;return mo(o,o,[i,s,0]),go(o,o,[n/ao,n/ao,1]),o}upVector(t,e,r){return [0,0,1]}upVectorScale(t,e,r){return {metersToTile:1}}}class Pd extends Cd{constructor(t){super(t),this.range=[4,7],this.center=t.center||[-96,37.5];const[e,r]=this.parallels=t.parallels||[29.5,45.5],n=Math.sin(w(e));this.n=(n+Math.sin(w(r)))/2,this.c=1+n*(2*this.n-n),this.r0=Math.sqrt(this.c)/this.n;}project(t,e){const{n:r,c:n,r0:i}=this,s=w(t-this.center[0]),a=w(e),o=Math.sqrt(n-2*r*Math.sin(a))/r;return {x:o*Math.sin(s*r),y:o*Math.cos(s*r)-i,z:0}}unproject(t,e){const{n:r,c:n,r0:i}=this,s=i+e;let a=Math.atan2(t,Math.abs(s))*Math.sign(s);s*r<0&&(a-=Math.PI*Math.sign(t)*Math.sign(s));const o=w(this.center[0])*r;a=z(a,-Math.PI-o,Math.PI-o);const l=M(_(a/r)+this.center[0],-180,180),u=Math.asin(M((n-(t*t+s*s)*r*r)/(2*r),-1,1)),c=M(_(u),-Hl,Hl);return new Ol(l,c)}}const Dd=1.340264,Vd=-.081106,Ld=893e-6,Fd=.003796,Rd=Math.sqrt(3)/2;class Ud extends Cd{project(t,e){e=e/180*Math.PI,t=t/180*Math.PI;const r=Math.asin(Rd*Math.sin(e)),n=r*r,i=n*n*n;return {x:.5*(t*Math.cos(r)/(Rd*(Dd+3*Vd*n+i*(7*Ld+9*Fd*n)))/Math.PI+.5),y:1-.5*(r*(Dd+Vd*n+i*(Ld+Fd*n))/Math.PI+1),z:0}}unproject(t,e){t=(2*t-.5)*Math.PI;let r=e=(2*(1-e)-1)*Math.PI,n=r*r,i=n*n*n;for(let t,s,a,o=0;o<12&&(s=r*(Dd+Vd*n+i*(Ld+Fd*n))-e,a=Dd+3*Vd*n+i*(7*Ld+9*Fd*n),t=s/a,r=M(r-t,-Math.PI/3,Math.PI/3),n=r*r,i=n*n*n,!(Math.abs(t)<1e-12));++o);const s=Rd*t*(Dd+3*Vd*n+i*(7*Ld+9*Fd*n))/Math.cos(r),a=Math.asin(Math.sin(r)/Rd),o=M(180*s/Math.PI,-180,180),l=M(180*a/Math.PI,-Hl,Hl);return new Ol(o,l)}}class $d extends Cd{constructor(t){super(t),this.wrap=!0,this.supportsWorldCopies=!0;}project(t,e){return {x:.5+t/360,y:.5-e/360,z:0}}unproject(t,e){const r=360*(t-.5),n=M(360*(.5-e),-Hl,Hl);return new Ol(r,n)}}const jd=Math.PI/2;function Od(t){return Math.tan((jd+t)/2)}class qd extends Cd{constructor(t){super(t),this.center=t.center||[0,30];const[e,r]=this.parallels=t.parallels||[30,30];let n=w(e),i=w(r);this.southernCenter=n+i<0,this.southernCenter&&(n=-n,i=-i);const s=Math.cos(n),a=Od(n);this.n=n===i?Math.sin(n):Math.log(s/Math.cos(i))/Math.log(Od(i)/a),this.f=s*Math.pow(Od(n),this.n)/this.n;}project(t,e){e=w(e),this.southernCenter&&(e=-e),t=w(t-this.center[0]);const r=1e-6,{n:n,f:i}=this;i>0?e<-jd+r&&(e=-jd+r):e>jd-r&&(e=jd-r);const s=i/Math.pow(Od(e),n);let a=s*Math.sin(n*t),o=i-s*Math.cos(n*t);return a=.5*(a/Math.PI+.5),o=.5*(o/Math.PI+.5),{x:a,y:this.southernCenter?o:1-o,z:0}}unproject(t,e){t=(2*t-.5)*Math.PI,this.southernCenter&&(e=1-e),e=(2*(1-e)-.5)*Math.PI;const{n:r,f:n}=this,i=n-e,s=Math.sign(i),a=Math.sign(r)*Math.sqrt(t*t+i*i);let o=Math.atan2(t,Math.abs(i))*s;i*r<0&&(o-=Math.PI*Math.sign(t)*s);const l=M(_(o/r)+this.center[0],-180,180),u=M(_(2*Math.atan(Math.pow(n/a,1/r))-jd),-Hl,Hl);return new Ol(l,this.southernCenter?-u:u)}}class Nd extends Cd{constructor(t){super(t),this.wrap=!0,this.supportsWorldCopies=!0,this.supportsTerrain=!0,this.supportsFog=!0,this.supportsFreeCamera=!0,this.isReprojectedInTileSpace=!1,this.unsupportedLayers=[],this.range=null;}project(t,e){return {x:Nl(t),y:Gl(e),z:0}}unproject(t,e){const r=Kl(t),n=Xl(e);return new Ol(r,n)}}const Gd=w(Hl);class Zd extends Cd{project(t,e){const r=(e=w(e))*e,n=r*r;return {x:.5*((t=w(t))*(.8707-.131979*r+n*(n*(.003971*r-.001529*n)-.013791))/Math.PI+.5),y:1-.5*(e*(1.007226+r*(.015085+n*(.028874*r-.044475-.005916*n)))/Math.PI+1),z:0}}unproject(t,e){t=(2*t-.5)*Math.PI;let r=e=(2*(1-e)-1)*Math.PI,n=25,i=0,s=r*r;do{s=r*r;const t=s*s;i=(r*(1.007226+s*(.015085+t*(.028874*s-.044475-.005916*t)))-e)/(1.007226+s*(.045255+t*(.259866*s-.311325-.005916*11*t))),r=M(r-i,-Gd,Gd);}while(Math.abs(i)>1e-6&&--n>0);s=r*r;const a=M(_(t/(.8707+s*(s*(s*s*s*(.003971-.001529*s)-.013791)-.131979))),-180,180),o=_(r);return new Ol(a,o)}}const Kd=w(Hl);class Xd extends Cd{project(t,e){e=w(e),t=w(t);const r=Math.cos(e),n=2/Math.PI,i=Math.acos(r*Math.cos(t/2)),s=Math.sin(i)/i,a=.5*(t*n+2*r*Math.sin(t/2)/s)||0,o=.5*(e+Math.sin(e)/s)||0;return {x:.5*(a/Math.PI+.5),y:1-.5*(o/Math.PI+1),z:0}}unproject(t,e){let r=t=(2*t-.5)*Math.PI,n=e=(2*(1-e)-1)*Math.PI,i=25;const s=1e-6;let a=0,o=0;do{const i=Math.cos(n),s=Math.sin(n),l=2*s*i,u=s*s,c=i*i,h=Math.cos(r/2),p=Math.sin(r/2),d=2*h*p,f=p*p,y=1-c*h*h,m=y?1/y:0,g=y?Math.acos(i*h)*Math.sqrt(1/y):0,x=.5*(2*g*i*p+2*r/Math.PI)-t,v=.5*(g*s+n)-e,b=.5*m*(c*f+g*i*h*u)+1/Math.PI,w=m*(d*l/4-g*s*p),_=.125*m*(l*p-g*s*c*d),A=.5*m*(u*h+g*f*i)+.5,S=w*_-A*b;a=(v*w-x*A)/S,o=(x*_-v*b)/S,r=M(r-a,-Math.PI,Math.PI),n=M(n-o,-Kd,Kd);}while((Math.abs(a)>s||Math.abs(o)>s)&&--i>0);return new Ol(_(r),_(n))}}class Jd extends Cd{constructor(t){super(t),this.center=t.center||[0,0],this.parallels=t.parallels||[0,0],this.cosPhi=Math.max(.01,Math.cos(w(this.parallels[0]))),this.scale=1/(2*Math.max(Math.PI*this.cosPhi,1/this.cosPhi)),this.wrap=!0,this.supportsWorldCopies=!0;}project(t,e){const{scale:r,cosPhi:n}=this;return {x:w(t)*n*r+.5,y:-Math.sin(w(e))/n*r+.5,z:0}}unproject(t,e){const{scale:r,cosPhi:n}=this,i=-(e-.5)/r,s=M(_((t-.5)/r)/n,-180,180),a=Math.asin(M(i*n,-1,1)),o=M(_(a),-Hl,Hl);return new Ol(s,o)}}class Hd extends Nd{constructor(t){super(t),this.requiresDraping=!0,this.supportsWorldCopies=!1,this.supportsFog=!0,this.zAxisUnit="pixels",this.unsupportedLayers=["debug"],this.range=[3,5];}projectTilePoint(t,e,r){const n=Ml(t,e,r);return Fo(n,n,Bl(xl(r))),{x:n[0],y:n[1],z:n[2]}}locationPoint(t,e){const r=Il(e.lat,e.lng),n=Do([],r),i=t.elevation?t.elevation.getAtPointOrZero(t.locationCoordinate(e),t._centerAltitude):t._centerAltitude;Po(r,r,n,Zl(1,0)*ao*i);const s=po(new Float64Array(16));return yo(s,t.pixelMatrix,t.globeMatrix),Fo(r,r,s),new x(r[0],r[1])}pixelsPerMeter(t,e){return Zl(1,0)*e}pixelSpaceConversion(t,e,r){const n=Zl(1,t)*e,i=Er(Zl(1,45)*e,n,r);return this.pixelsPerMeter(t,e)/i}createTileMatrix(t,e,r){const n=El(xl(r.canonical));return yo(new Float64Array(16),t.globeMatrix,n)}createInversionMatrix(t,e){const{center:r}=t,n=Bl(xl(e));return vo(n,n,w(r.lng)),xo(n,n,w(r.lat)),go(n,n,[t._pixelsPerMercatorPixel,t._pixelsPerMercatorPixel,1]),Float32Array.from(n)}pointCoordinate(t,e,r,n){return yl(t,e,r,!0)||new Wl(0,0)}pointCoordinate3D(t,e,r){const n=this.pointCoordinate(t,e,r,0);return [n.x,n.y,n.z]}isPointAboveHorizon(t,e){return !yl(t,e.x,e.y,!1)}farthestPixelDistance(t){const e=function(t,e){const r=t.cameraToCenterDistance,n=t._centerAltitude*e,i=t._camera,s=t._camera.forward(),a=Mo([],Co([],s,-r),[0,0,n]),o=t.worldSize/(2*Math.PI),l=[0,0,-o],u=t.width/t.height,c=Math.tan(t.fovAboveCenter),h=Co([],i.up(),c),p=Co([],i.right(),c*u),d=Do([],Mo([],Mo([],s,h),p)),f=[];let y;if(new el(a,d).closestPointOnSphere(l,o,f)){const e=Mo([],f,l),r=$o([],e,a);y=Math.cos(t.fovAboveCenter)*ko(r);}else {const t=$o([],a,l),e=$o([],l,a);Do(e,e);const r=ko(t)-o;y=Math.sqrt(r*(r+2*o));const n=Math.acos(y/(o+r))-Math.acos(Vo(s,e));y*=Math.cos(n);}return 1.01*y}(t,this.pixelsPerMeter(t.center.lat,t.worldSize)),r=Pl(t.zoom);if(r>0){const n=zd(t,Zl(1,t.center.lat)*t.worldSize),i=t.worldSize/(2*Math.PI),s=Math.max(t.width,t.height)/t.worldSize*Math.PI;return Er(e,n+i*(1-Math.cos(s)),Math.pow(r,10))}return e}upVector(t,e,r){return Ml(e,r,t,1)}upVectorScale(t){return {metersToTile:fl(Tl(xl(t)))}}}function Yd(t){const e=t.parallels,r=!!e&&Math.abs(e[0]+e[1])<.01;switch(t.name){case"mercator":return new Nd(t);case"equirectangular":return new $d(t);case"naturalEarth":return new Zd(t);case"equalEarth":return new Ud(t);case"winkelTripel":return new Xd(t);case"albers":return r?new Jd(t):new Pd(t);case"lambertConformalConic":return r?new Jd(t):new qd(t);case"globe":return new Hd(t)}throw new Error(`Invalid projection name: ${t.name}`)}const Wd=Kc.types,Qd=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function tf(t,e,r,n,i,s,a,o,l,u,c,h,p){const d=o?Math.min(Ad,Math.round(o[0])):0,f=o?Math.min(Ad,Math.round(o[1])):0;t.emplaceBack(e,r,Math.round(32*n),Math.round(32*i),s,a,(d<<1)+(l?1:0),f,16*u,16*c,256*h,256*p);}function ef(t,e,r,n,i,s,a){t.emplaceBack(e,r,n,i,s,a);}function rf(t,e,r,n,i){t.emplaceBack(e,r,n,i),t.emplaceBack(e,r,n,i),t.emplaceBack(e,r,n,i),t.emplaceBack(e,r,n,i);}function nf(t){for(const e of t.sections)if(ls(e.text))return !0;return !1}class sf{constructor(t){this.layoutVertexArray=new Xs,this.indexArray=new ra,this.programConfigurations=t,this.segments=new so,this.dynamicLayoutVertexArray=new Ns,this.opacityVertexArray=new Hs,this.placedSymbolArray=new fa,this.globeExtVertexArray=new Js;}isEmpty(){return 0===this.layoutVertexArray.length&&0===this.indexArray.length&&0===this.dynamicLayoutVertexArray.length&&0===this.opacityVertexArray.length}upload(t,e,r,n){this.isEmpty()||(r&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Eh.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,e),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,Ph.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,Qd,!0),this.globeExtVertexArray.length>0&&(this.globeExtVertexBuffer=t.createVertexBuffer(this.globeExtVertexArray,Ch.members,!0)),this.opacityVertexBuffer.itemSize=1),(r||n)&&this.programConfigurations.upload(t));}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy(),this.globeExtVertexBuffer&&this.globeExtVertexBuffer.destroy());}}Ji(sf,"SymbolBuffers");class af{constructor(t,e,r){this.layoutVertexArray=new t,this.layoutAttributes=e,this.indexArray=new r,this.segments=new so,this.collisionVertexArray=new ta,this.collisionVertexArrayExt=new ea;}upload(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,Dh.members,!0),this.collisionVertexBufferExt=t.createVertexBuffer(this.collisionVertexArrayExt,Vh.members,!0);}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy(),this.collisionVertexBufferExt.destroy());}}Ji(af,"CollisionBuffers");class of{constructor(t){this.collisionBoxArray=t.collisionBoxArray,this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.id)),this.index=t.index,this.pixelRatio=t.pixelRatio,this.sourceLayerIndex=t.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.fullyClipped=!1,this.sortKeyRanges=[],this.collisionCircleArray=[],this.placementInvProjMatrix=po([]),this.placementViewportMatrix=po([]);const e=this.layers[0]._unevaluatedLayout._values;this.textSizeData=$h(this.zoom,e["text-size"]),this.iconSizeData=$h(this.zoom,e["icon-size"]);const r=this.layers[0].layout,n=r.get("symbol-sort-key"),i=r.get("symbol-z-order");this.canOverlap=r.get("text-allow-overlap")||r.get("icon-allow-overlap")||r.get("text-ignore-placement")||r.get("icon-ignore-placement"),this.sortFeaturesByKey="viewport-y"!==i&&void 0!==n.constantOr(1),this.sortFeaturesByY=("viewport-y"===i||"auto"===i&&!this.sortFeaturesByKey)&&this.canOverlap,this.writingModes=r.get("text-writing-mode").map((t=>Ip[t])),this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),this.sourceID=t.sourceID,this.projection=t.projection;}createArrays(){this.text=new sf(new Ja(this.layers,this.zoom,(t=>/^text/.test(t)))),this.icon=new sf(new Ja(this.layers,this.zoom,(t=>/^icon/.test(t)))),this.glyphOffsetArray=new ga,this.lineVertexArray=new xa,this.symbolInstances=new ma;}calculateGlyphDependencies(t,e,r,n,i){for(let r=0;r<t.length;r++)if(e[t.charCodeAt(r)]=!0,n&&i){const n=Gh[t.charAt(r)];n&&(e[n.charCodeAt(0)]=!0);}}populate(t,e,r,n){const i=this.layers[0],s=i.layout,a="globe"===this.projection.name,o=s.get("text-font"),l=s.get("text-field"),u=s.get("icon-image"),c=("constant"!==l.value.kind||l.value.value instanceof De&&!l.value.value.isEmpty()||l.value.value.toString().length>0)&&("constant"!==o.value.kind||o.value.value.length>0),h="constant"!==u.value.kind||!!u.value.value||Object.keys(u.parameters).length>0,p=s.get("symbol-sort-key");if(this.features=[],!c&&!h)return;const d=e.iconDependencies,f=e.glyphDependencies,y=e.availableImages,m=new ws(this.zoom);for(const{feature:e,id:l,index:u,sourceLayerIndex:g}of t){const t=i._featureFilter.needGeometry,x=ou(e,t);if(!i._featureFilter.filter(m,x,r))continue;if(t||(x.geometry=au(e,r,n)),a&&1!==e.type&&r.z<=5){const t=x.geometry,e=.98078528056,n=(t,n)=>Vo(Ml(t.x,t.y,r,1),Ml(n.x,n.y,r,1))<e;for(let e=0;e<t.length;e++)t[e]=ru(t[e],n);}let v,b;if(c){const t=i.getValueAndResolveTokens("text-field",x,r,y),e=De.factory(t);nf(e)&&(this.hasRTLText=!0),(!this.hasRTLText||"unavailable"===xs()||this.hasRTLText&&bs.isParsed())&&(v=Nh(e,i,x));}if(h){const t=i.getValueAndResolveTokens("icon-image",x,r,y);b=t instanceof Ve?t:Ve.fromString(t);}if(!v&&!b)continue;const w=this.sortFeaturesByKey?p.evaluate(x,{},r):void 0;if(this.features.push({id:l,text:v,icon:b,index:u,sourceLayerIndex:g,geometry:x.geometry,properties:e.properties,type:Wd[e.type],sortKey:w}),b&&(d[b.name]=!0),v){const t=o.evaluate(x,{},r).join(","),e="map"===s.get("text-rotation-alignment")&&"point"!==s.get("symbol-placement");this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(Ip.vertical)>=0;for(const r of v.sections)if(r.image)d[r.image.name]=!0;else {const n=es(v.toString()),i=r.fontStack||t,s=f[i]=f[i]||{};this.calculateGlyphDependencies(r.text,s,e,this.allowVerticalPlacement,n);}}}"line"===s.get("symbol-placement")&&(this.features=function(t){const e={},r={},n=[];let i=0;function s(e){n.push(t[e]),i++;}function a(t,e,i){const s=r[t];return delete r[t],r[e]=s,n[s].geometry[0].pop(),n[s].geometry[0]=n[s].geometry[0].concat(i[0]),s}function o(t,r,i){const s=e[r];return delete e[r],e[t]=s,n[s].geometry[0].shift(),n[s].geometry[0]=i[0].concat(n[s].geometry[0]),s}function l(t,e,r){const n=r?e[0][e[0].length-1]:e[0][0];return `${t}:${n.x}:${n.y}`}for(let u=0;u<t.length;u++){const c=t[u],h=c.geometry,p=c.text?c.text.toString():null;if(!p){s(u);continue}const d=l(p,h),f=l(p,h,!0);if(d in r&&f in e&&r[d]!==e[f]){const t=o(d,f,h),i=a(d,f,n[t].geometry);delete e[d],delete r[f],r[l(p,n[i].geometry,!0)]=i,n[t].geometry=null;}else d in r?a(d,f,h):f in e?o(d,f,h):(s(u),e[d]=i-1,r[f]=i-1);}return n.filter((t=>t.geometry))}(this.features)),this.sortFeaturesByKey&&this.features.sort(((t,e)=>t.sortKey-e.sortKey));}update(t,e,r,n){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(t,e,this.layers,r,n),this.icon.programConfigurations.updatePaintArrays(t,e,this.layers,r,n));}isEmpty(){return 0===this.symbolInstances.length&&!this.hasRTLText}uploadPending(){return !this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload}upload(t){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0;}destroyDebugData(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy();}getProjection(){return this.projectionInstance||(this.projectionInstance=Yd(this.projection)),this.projectionInstance}destroy(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData();}addToLineVertexArray(t,e){const r=this.lineVertexArray.length;if(void 0!==t.segment)for(const{x:t,y:r}of e)this.lineVertexArray.emplaceBack(t,r);return {lineStartIndex:r,lineLength:this.lineVertexArray.length-r}}addSymbols(t,e,r,n,i,s,a,o,l,u,c,h,p,d){const f=t.indexArray,y=t.layoutVertexArray,m=t.globeExtVertexArray,g=t.segments.prepareSegment(4*e.length,y,f,this.canOverlap?s.sortKey:void 0),x=this.glyphOffsetArray.length,v=g.vertexLength,b=this.allowVerticalPlacement&&a===Ip.vertical?Math.PI/2:0,w=s.text&&s.text.sections;for(let n=0;n<e.length;n++){const{tl:i,tr:a,bl:u,br:c,tex:h,pixelOffsetTL:x,pixelOffsetBR:v,minFontScaleX:_,minFontScaleY:A,glyphOffset:S,isSDF:k,sectionIndex:I}=e[n],M=g.vertexLength,T=S[1];if(tf(y,l.x,l.y,i.x,T+i.y,h.x,h.y,r,k,x.x,x.y,_,A),tf(y,l.x,l.y,a.x,T+a.y,h.x+h.w,h.y,r,k,v.x,x.y,_,A),tf(y,l.x,l.y,u.x,T+u.y,h.x,h.y+h.h,r,k,x.x,v.y,_,A),tf(y,l.x,l.y,c.x,T+c.y,h.x+h.w,h.y+h.h,r,k,v.x,v.y,_,A),o){const{x:e,y:r,z:n}=o.anchor,[i,s,a]=o.up;ef(m,e,r,n,i,s,a),ef(m,e,r,n,i,s,a),ef(m,e,r,n,i,s,a),ef(m,e,r,n,i,s,a),rf(t.dynamicLayoutVertexArray,e,r,n,b);}else rf(t.dynamicLayoutVertexArray,l.x,l.y,l.z,b);f.emplaceBack(M,M+1,M+2),f.emplaceBack(M+1,M+2,M+3),g.vertexLength+=4,g.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(S[0]),n!==e.length-1&&I===e[n+1].sectionIndex||t.programConfigurations.populatePaintArrays(y.length,s,s.index,{},p,d,w&&w[I]);}const _=o?o.anchor:l;t.placedSymbolArray.emplaceBack(_.x,_.y,_.z,l.x,l.y,x,this.glyphOffsetArray.length-x,v,u,c,l.segment,r?r[0]:0,r?r[1]:0,n[0],n[1],a,0,!1,0,h,0);}_commitLayoutVertex(t,e,r,n,i,s,a){t.emplaceBack(e,r,n,i,s,Math.round(a.x),Math.round(a.y));}_addCollisionDebugVertices(t,e,r,n,i,s,a){const o=r.segments.prepareSegment(4,r.layoutVertexArray,r.indexArray),l=o.vertexLength,u=a.tileAnchorX,c=a.tileAnchorY;for(let t=0;t<4;t++)r.collisionVertexArray.emplaceBack(0,0,0,0);r.collisionVertexArrayExt.emplaceBack(e,-t.padding,-t.padding),r.collisionVertexArrayExt.emplaceBack(e,t.padding,-t.padding),r.collisionVertexArrayExt.emplaceBack(e,t.padding,t.padding),r.collisionVertexArrayExt.emplaceBack(e,-t.padding,t.padding),this._commitLayoutVertex(r.layoutVertexArray,n,i,s,u,c,new x(t.x1,t.y1)),this._commitLayoutVertex(r.layoutVertexArray,n,i,s,u,c,new x(t.x2,t.y1)),this._commitLayoutVertex(r.layoutVertexArray,n,i,s,u,c,new x(t.x2,t.y2)),this._commitLayoutVertex(r.layoutVertexArray,n,i,s,u,c,new x(t.x1,t.y2)),o.vertexLength+=4;const h=r.indexArray;h.emplaceBack(l,l+1),h.emplaceBack(l+1,l+2),h.emplaceBack(l+2,l+3),h.emplaceBack(l+3,l),o.primitiveLength+=4;}_addTextDebugCollisionBoxes(t,e,r,n,i,s){for(let a=n;a<i;a++){const n=r.get(a),i=this.getSymbolInstanceTextSize(t,s,e,a);this._addCollisionDebugVertices(n,i,this.textCollisionBox,n.projectedAnchorX,n.projectedAnchorY,n.projectedAnchorZ,s);}}_addIconDebugCollisionBoxes(t,e,r,n,i,s){for(let a=n;a<i;a++){const n=r.get(a),i=this.getSymbolInstanceIconSize(t,e,s.placedIconSymbolIndex);this._addCollisionDebugVertices(n,i,this.iconCollisionBox,n.projectedAnchorX,n.projectedAnchorY,n.projectedAnchorZ,s);}}generateCollisionDebugBuffers(t,e){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new af(Ws,Lh.members,la),this.iconCollisionBox=new af(Ws,Lh.members,la);const r=Oh(this.iconSizeData,t),n=Oh(this.textSizeData,t);for(let i=0;i<this.symbolInstances.length;i++){const s=this.symbolInstances.get(i);this._addTextDebugCollisionBoxes(n,t,e,s.textBoxStartIndex,s.textBoxEndIndex,s),this._addTextDebugCollisionBoxes(n,t,e,s.verticalTextBoxStartIndex,s.verticalTextBoxEndIndex,s),this._addIconDebugCollisionBoxes(r,t,e,s.iconBoxStartIndex,s.iconBoxEndIndex,s),this._addIconDebugCollisionBoxes(r,t,e,s.verticalIconBoxStartIndex,s.verticalIconBoxEndIndex,s);}}getSymbolInstanceTextSize(t,e,r,n){const i=this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex>=0?e.rightJustifiedTextSymbolIndex:e.centerJustifiedTextSymbolIndex>=0?e.centerJustifiedTextSymbolIndex:e.leftJustifiedTextSymbolIndex>=0?e.leftJustifiedTextSymbolIndex:e.verticalPlacedTextSymbolIndex>=0?e.verticalPlacedTextSymbolIndex:n),s=jh(this.textSizeData,t,i)/Rh;return this.tilePixelRatio*s}getSymbolInstanceIconSize(t,e,r){const n=this.icon.placedSymbolArray.get(r),i=jh(this.iconSizeData,t,n);return this.tilePixelRatio*i}_commitDebugCollisionVertexUpdate(t,e,r){t.emplaceBack(e,-r,-r),t.emplaceBack(e,r,-r),t.emplaceBack(e,r,r),t.emplaceBack(e,-r,r);}_updateTextDebugCollisionBoxes(t,e,r,n,i,s){for(let a=n;a<i;a++){const n=r.get(a),i=this.getSymbolInstanceTextSize(t,s,e,a);this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt,i,n.padding);}}_updateIconDebugCollisionBoxes(t,e,r,n,i,s){for(let a=n;a<i;a++){const n=r.get(a),i=this.getSymbolInstanceIconSize(t,e,s);this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt,i,n.padding);}}updateCollisionDebugBuffers(t,e){if(!this.hasDebugData())return;this.hasTextCollisionBoxData()&&this.textCollisionBox.collisionVertexArrayExt.clear(),this.hasIconCollisionBoxData()&&this.iconCollisionBox.collisionVertexArrayExt.clear();const r=Oh(this.iconSizeData,t),n=Oh(this.textSizeData,t);for(let i=0;i<this.symbolInstances.length;i++){const s=this.symbolInstances.get(i);this._updateTextDebugCollisionBoxes(n,t,e,s.textBoxStartIndex,s.textBoxEndIndex,s),this._updateTextDebugCollisionBoxes(n,t,e,s.verticalTextBoxStartIndex,s.verticalTextBoxEndIndex,s),this._updateIconDebugCollisionBoxes(r,t,e,s.iconBoxStartIndex,s.iconBoxEndIndex,s.placedIconSymbolIndex),this._updateIconDebugCollisionBoxes(r,t,e,s.verticalIconBoxStartIndex,s.verticalIconBoxEndIndex,s.placedIconSymbolIndex);}this.hasTextCollisionBoxData()&&this.textCollisionBox.collisionVertexBufferExt&&this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt),this.hasIconCollisionBoxData()&&this.iconCollisionBox.collisionVertexBufferExt&&this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);}_deserializeCollisionBoxesForSymbol(t,e,r,n,i,s,a,o,l){const u={};if(e<r){const{x1:r,y1:n,x2:i,y2:s,padding:a,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:d}=t.get(e);u.textBox={x1:r,y1:n,x2:i,y2:s,padding:a,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.textFeatureIndex=d;}if(n<i){const{x1:e,y1:r,x2:i,y2:s,padding:a,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:d}=t.get(n);u.verticalTextBox={x1:e,y1:r,x2:i,y2:s,padding:a,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.verticalTextFeatureIndex=d;}if(s<a){const{x1:e,y1:r,x2:n,y2:i,padding:a,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:d}=t.get(s);u.iconBox={x1:e,y1:r,x2:n,y2:i,padding:a,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.iconFeatureIndex=d;}if(o<l){const{x1:e,y1:r,x2:n,y2:i,padding:s,projectedAnchorX:a,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:d}=t.get(o);u.verticalIconBox={x1:e,y1:r,x2:n,y2:i,padding:s,projectedAnchorX:a,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.verticalIconFeatureIndex=d;}return u}deserializeCollisionBoxes(t){this.collisionArrays=[];for(let e=0;e<this.symbolInstances.length;e++){const r=this.symbolInstances.get(e);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,r.textBoxStartIndex,r.textBoxEndIndex,r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r.iconBoxStartIndex,r.iconBoxEndIndex,r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex));}}hasTextData(){return this.text.segments.get().length>0}hasIconData(){return this.icon.segments.get().length>0}hasDebugData(){return this.textCollisionBox&&this.iconCollisionBox}hasTextCollisionBoxData(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0}hasIconCollisionBoxData(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0}addIndicesForPlacedSymbol(t,e){const r=t.placedSymbolArray.get(e),n=r.vertexStartIndex+4*r.numGlyphs;for(let e=r.vertexStartIndex;e<n;e+=4)t.indexArray.emplaceBack(e,e+1,e+2),t.indexArray.emplaceBack(e+1,e+2,e+3);}getSortedSymbolIndexes(t){if(this.sortedAngle===t&&void 0!==this.symbolInstanceIndexes)return this.symbolInstanceIndexes;const e=Math.sin(t),r=Math.cos(t),n=[],i=[],s=[];for(let t=0;t<this.symbolInstances.length;++t){s.push(t);const a=this.symbolInstances.get(t);n.push(0|Math.round(e*a.tileAnchorX+r*a.tileAnchorY)),i.push(a.featureIndex);}return s.sort(((t,e)=>n[t]-n[e]||i[e]-i[t])),s}addToSortKeyRanges(t,e){const r=this.sortKeyRanges[this.sortKeyRanges.length-1];r&&r.sortKey===e?r.symbolInstanceEnd=t+1:this.sortKeyRanges.push({sortKey:e,symbolInstanceStart:t,symbolInstanceEnd:t+1});}sortFeatures(t){if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(const t of this.symbolInstanceIndexes){const e=this.symbolInstances.get(t);this.featureSortOrder.push(e.featureIndex);const{rightJustifiedTextSymbolIndex:r,centerJustifiedTextSymbolIndex:n,leftJustifiedTextSymbolIndex:i,verticalPlacedTextSymbolIndex:s,placedIconSymbolIndex:a,verticalPlacedIconSymbolIndex:o}=e;r>=0&&this.addIndicesForPlacedSymbol(this.text,r),n>=0&&n!==r&&this.addIndicesForPlacedSymbol(this.text,n),i>=0&&i!==n&&i!==r&&this.addIndicesForPlacedSymbol(this.text,i),s>=0&&this.addIndicesForPlacedSymbol(this.text,s),a>=0&&this.addIndicesForPlacedSymbol(this.icon,a),o>=0&&this.addIndicesForPlacedSymbol(this.icon,o);}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray);}}}Ji(of,"SymbolBucket",{omit:["layers","collisionBoxArray","features","compareText"]}),of.MAX_GLYPHS=65535,of.addDynamicAttributes=rf;const lf=new Ps({"symbol-placement":new Bs(te.layout_symbol["symbol-placement"]),"symbol-spacing":new Bs(te.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new Bs(te.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new Es(te.layout_symbol["symbol-sort-key"]),"symbol-z-order":new Bs(te.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new Bs(te.layout_symbol["icon-allow-overlap"]),"icon-ignore-placement":new Bs(te.layout_symbol["icon-ignore-placement"]),"icon-optional":new Bs(te.layout_symbol["icon-optional"]),"icon-rotation-alignment":new Bs(te.layout_symbol["icon-rotation-alignment"]),"icon-size":new Es(te.layout_symbol["icon-size"]),"icon-text-fit":new Bs(te.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new Bs(te.layout_symbol["icon-text-fit-padding"]),"icon-image":new Es(te.layout_symbol["icon-image"]),"icon-rotate":new Es(te.layout_symbol["icon-rotate"]),"icon-padding":new Bs(te.layout_symbol["icon-padding"]),"icon-keep-upright":new Bs(te.layout_symbol["icon-keep-upright"]),"icon-offset":new Es(te.layout_symbol["icon-offset"]),"icon-anchor":new Es(te.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new Bs(te.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new Bs(te.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new Bs(te.layout_symbol["text-rotation-alignment"]),"text-field":new Es(te.layout_symbol["text-field"]),"text-font":new Es(te.layout_symbol["text-font"]),"text-size":new Es(te.layout_symbol["text-size"]),"text-max-width":new Es(te.layout_symbol["text-max-width"]),"text-line-height":new Es(te.layout_symbol["text-line-height"]),"text-letter-spacing":new Es(te.layout_symbol["text-letter-spacing"]),"text-justify":new Es(te.layout_symbol["text-justify"]),"text-radial-offset":new Es(te.layout_symbol["text-radial-offset"]),"text-variable-anchor":new Bs(te.layout_symbol["text-variable-anchor"]),"text-anchor":new Es(te.layout_symbol["text-anchor"]),"text-max-angle":new Bs(te.layout_symbol["text-max-angle"]),"text-writing-mode":new Bs(te.layout_symbol["text-writing-mode"]),"text-rotate":new Es(te.layout_symbol["text-rotate"]),"text-padding":new Bs(te.layout_symbol["text-padding"]),"text-keep-upright":new Bs(te.layout_symbol["text-keep-upright"]),"text-transform":new Es(te.layout_symbol["text-transform"]),"text-offset":new Es(te.layout_symbol["text-offset"]),"text-allow-overlap":new Bs(te.layout_symbol["text-allow-overlap"]),"text-ignore-placement":new Bs(te.layout_symbol["text-ignore-placement"]),"text-optional":new Bs(te.layout_symbol["text-optional"])});var uf={paint:new Ps({"icon-opacity":new Es(te.paint_symbol["icon-opacity"]),"icon-color":new Es(te.paint_symbol["icon-color"]),"icon-halo-color":new Es(te.paint_symbol["icon-halo-color"]),"icon-halo-width":new Es(te.paint_symbol["icon-halo-width"]),"icon-halo-blur":new Es(te.paint_symbol["icon-halo-blur"]),"icon-translate":new Bs(te.paint_symbol["icon-translate"]),"icon-translate-anchor":new Bs(te.paint_symbol["icon-translate-anchor"]),"text-opacity":new Es(te.paint_symbol["text-opacity"]),"text-color":new Es(te.paint_symbol["text-color"],{runtimeType:pe,getOverride:t=>t.textColor,hasOverride:t=>!!t.textColor}),"text-halo-color":new Es(te.paint_symbol["text-halo-color"]),"text-halo-width":new Es(te.paint_symbol["text-halo-width"]),"text-halo-blur":new Es(te.paint_symbol["text-halo-blur"]),"text-translate":new Bs(te.paint_symbol["text-translate"]),"text-translate-anchor":new Bs(te.paint_symbol["text-translate-anchor"])}),layout:lf};class cf{constructor(t){this.type=t.property.overrides?t.property.overrides.runtimeType:le,this.defaultValue=t;}evaluate(t){if(t.formattedSection){const e=this.defaultValue.property.overrides;if(e&&e.hasOverride(t.formattedSection))return e.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default}eachChild(t){this.defaultValue.isConstant()||t(this.defaultValue.value._styleExpression.expression);}outputDefined(){return !1}serialize(){return null}}Ji(cf,"FormatSectionOverride",{omit:["defaultValue"]});class hf extends ro{constructor(t){super(t,uf);}recalculate(t,e){super.recalculate(t,e),"auto"===this.layout.get("icon-rotation-alignment")&&(this.layout._values["icon-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-rotation-alignment")&&(this.layout._values["text-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-pitch-alignment")&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")),"auto"===this.layout.get("icon-pitch-alignment")&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment"));const r=this.layout.get("text-writing-mode");if(r){const t=[];for(const e of r)t.indexOf(e)<0&&t.push(e);this.layout._values["text-writing-mode"]=t;}else this.layout._values["text-writing-mode"]="point"===this.layout.get("symbol-placement")?["horizontal"]:["horizontal","vertical"];this._setPaintOverrides();}getValueAndResolveTokens(t,e,r,n){const i=this.layout.get(t).evaluate(e,{},r,n),s=this._unevaluatedLayout._values[t];return s.isDataDriven()||Jn(s.value)||!i?i:function(t,e){return e.replace(/{([^{}]+)}/g,((e,r)=>r in t?String(t[r]):""))}(e.properties,i)}createBucket(t){return new of(t)}queryRadius(){return 0}queryIntersectsFeature(){return !1}_setPaintOverrides(){for(const t of uf.paint.overridableProperties){if(!hf.hasPaintOverride(this.layout,t))continue;const e=this.paint.get(t),r=new cf(e),n=new Xn(r,e.property.specification);let i=null;i="constant"===e.value.kind||"source"===e.value.kind?new Yn("source",n):new Wn("composite",n,e.value.zoomStops,e.value._interpolationType),this.paint._values[t]=new Ts(e.property,i,e.parameters);}}_handleOverridablePaintPropertyUpdate(t,e,r){return !(!this.layout||e.isDataDriven()||r.isDataDriven())&&hf.hasPaintOverride(this.layout,t)}static hasPaintOverride(t,e){const r=t.get("text-field"),n=uf.paint.properties[e];let i=!1;const s=t=>{for(const e of t)if(n.overrides&&n.overrides.hasOverride(e))return void(i=!0)};if("constant"===r.value.kind&&r.value.value instanceof De)s(r.value.value.sections);else if("source"===r.value.kind){const t=e=>{i||(e instanceof je&&Re(e.value)===me?s(e.value.sections):e instanceof Ze?s(e.sections):e.eachChild(t));},e=r.value;e._styleExpression&&t(e._styleExpression.expression);}return i}getProgramConfiguration(t){return new Xa(this,t)}}var pf={paint:new Ps({"background-color":new Bs(te.paint_background["background-color"]),"background-pattern":new Bs(te.paint_background["background-pattern"]),"background-opacity":new Bs(te.paint_background["background-opacity"])})},df={paint:new Ps({"raster-opacity":new Bs(te.paint_raster["raster-opacity"]),"raster-hue-rotate":new Bs(te.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new Bs(te.paint_raster["raster-brightness-min"]),"raster-brightness-max":new Bs(te.paint_raster["raster-brightness-max"]),"raster-saturation":new Bs(te.paint_raster["raster-saturation"]),"raster-contrast":new Bs(te.paint_raster["raster-contrast"]),"raster-resampling":new Bs(te.paint_raster["raster-resampling"]),"raster-fade-duration":new Bs(te.paint_raster["raster-fade-duration"])})};class ff extends ro{constructor(t){super(t,{}),this.implementation=t;}is3D(){return "3d"===this.implementation.renderingMode}hasOffscreenPass(){return void 0!==this.implementation.prerender}isLayerDraped(){return void 0!==this.implementation.renderToTile}shouldRedrape(){return !!this.implementation.shouldRerenderTiles&&this.implementation.shouldRerenderTiles()}recalculate(){}updateTransitions(){}hasTransition(){return !1}serialize(){}onAdd(t){this.implementation.onAdd&&this.implementation.onAdd(t,t.painter.context.gl);}onRemove(t){this.implementation.onRemove&&this.implementation.onRemove(t,t.painter.context.gl);}}var yf={paint:new Ps({"sky-type":new Bs(te.paint_sky["sky-type"]),"sky-atmosphere-sun":new Bs(te.paint_sky["sky-atmosphere-sun"]),"sky-atmosphere-sun-intensity":new Bs(te.paint_sky["sky-atmosphere-sun-intensity"]),"sky-gradient-center":new Bs(te.paint_sky["sky-gradient-center"]),"sky-gradient-radius":new Bs(te.paint_sky["sky-gradient-radius"]),"sky-gradient":new Cs(te.paint_sky["sky-gradient"]),"sky-atmosphere-halo-color":new Bs(te.paint_sky["sky-atmosphere-halo-color"]),"sky-atmosphere-color":new Bs(te.paint_sky["sky-atmosphere-color"]),"sky-opacity":new Bs(te.paint_sky["sky-opacity"])})};function mf(t,e,r){const n=[0,0,1],i=Ko([]);return Jo(i,i,r?-w(t)+Math.PI:w(t)),Xo(i,i,-w(e)),Ro(n,n,i),Do(n,n)}const gf={circle:class extends ro{constructor(t){super(t,Tu);}createBucket(t){return new cu(t)}queryRadius(t){const e=t;return Au("circle-radius",this,e)+Au("circle-stroke-width",this,e)+Su(this.paint.get("circle-translate"))}queryIntersectsFeature(t,e,r,n,i,s,a,o){const l=Iu(this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),s.angle,t.pixelToTileUnitsFactor),u=this.paint.get("circle-radius").evaluate(e,r)+this.paint.get("circle-stroke-width").evaluate(e,r);return zu(t,n,s,a,o,"map"===this.paint.get("circle-pitch-alignment"),"map"===this.paint.get("circle-pitch-scale"),l,u)}getProgramIds(){return ["circle"]}getProgramConfiguration(t){return new Xa(this,t)}},heatmap:class extends ro{createBucket(t){return new Du(t)}constructor(t){super(t,$u),this._updateColorRamp();}_handleSpecialPaintPropertyUpdate(t){"heatmap-color"===t&&this._updateColorRamp();}_updateColorRamp(){this.colorRamp=ju({expression:this._transitionablePaint._values["heatmap-color"].value.expression,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null;}resize(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null);}queryRadius(t){return Au("heatmap-radius",this,t)}queryIntersectsFeature(t,e,r,n,i,s,a,o){const l=this.paint.get("heatmap-radius").evaluate(e,r);return zu(t,n,s,a,o,!0,!0,new x(0,0),l)}hasOffscreenPass(){return 0!==this.paint.get("heatmap-opacity")&&"none"!==this.visibility}getProgramIds(){return ["heatmap","heatmapTexture"]}getProgramConfiguration(t){return new Xa(this,t)}},hillshade:class extends ro{constructor(t){super(t,Ou);}hasOffscreenPass(){return 0!==this.paint.get("hillshade-exaggeration")&&"none"!==this.visibility}getProgramIds(){return ["hillshade","hillshadePrepare"]}},fill:class extends ro{constructor(t){super(t,zc);}getProgramIds(){const t=this.paint.get("fill-pattern"),e=t&&t.constantOr(1),r=[e?"fillPattern":"fill"];return this.paint.get("fill-antialias")&&r.push(e&&!this.getPaintProperty("fill-outline-color")?"fillOutlinePattern":"fillOutline"),r}getProgramConfiguration(t){return new Xa(this,t)}recalculate(t,e){super.recalculate(t,e);const r=this.paint._values["fill-outline-color"];"constant"===r.value.kind&&void 0===r.value.value&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"]);}createBucket(t){return new Mc(t)}queryRadius(){return Su(this.paint.get("fill-translate"))}queryIntersectsFeature(t,e,r,n,i,s){return !t.queryGeometry.isAboveHorizon&&du(ku(t.tilespaceGeometry,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),s.angle,t.pixelToTileUnitsFactor),n)}isTileClipped(){return !0}},"fill-extrusion":class extends ro{constructor(t){super(t,ch);}createBucket(t){return new th(t)}queryRadius(){return Su(this.paint.get("fill-extrusion-translate"))}is3D(){return !0}getProgramIds(){return [this.paint.get("fill-extrusion-pattern").constantOr(1)?"fillExtrusionPattern":"fillExtrusion"]}getProgramConfiguration(t){return new Xa(this,t)}queryIntersectsFeature(t,e,r,n,i,s,a,o,l){const u=Iu(this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),s.angle,t.pixelToTileUnitsFactor),c=this.paint.get("fill-extrusion-height").evaluate(e,r),h=this.paint.get("fill-extrusion-base").evaluate(e,r),p=[0,0],d=o&&s.elevation,f=s.elevation?s.elevation.exaggeration():1,y=t.tile.getBucket(this);if(d&&y instanceof th){const t=y.centroidVertexArray,e=l+1;e<t.length&&(p[0]=t.geta_centroid_pos0(e),p[1]=t.geta_centroid_pos1(e));}if(0===p[0]&&1===p[1])return !1;"globe"===s.projection.name&&(n=lh([n],[new x(0,0),new x(ao,ao)],t.tileID.canonical).map((t=>t.polygon)).flat());const m=d?o:null,[g,v]=function(t,e,r,n,i,s,a,o,l,u,c){return "globe"===t.projection.name?function(t,e,r,n,i,s,a,o,l,u,c){const h=[],p=[],d=t.projection.upVectorScale(c,t.center.lat,t.worldSize).metersToTile,f=[0,0,0,1],y=[0,0,0,1],m=(t,e,r,n)=>{t[0]=e,t[1]=r,t[2]=n,t[3]=1;},g=oh();r>0&&(r+=g),n+=g;for(const g of e){const e=[],x=[];for(const h of g){const p=h.x+i.x,g=h.y+i.y,v=t.projection.projectTilePoint(p,g,c),b=t.projection.upVector(c,h.x,h.y);let w=r,_=n;if(a){const t=vh(p,g,r,n,a,o,l,u);w+=t.base,_+=t.top;}0!==r?m(f,v.x+b[0]*d*w,v.y+b[1]*d*w,v.z+b[2]*d*w):m(f,v.x,v.y,v.z),m(y,v.x+b[0]*d*_,v.y+b[1]*d*_,v.z+b[2]*d*_),Fo(f,f,s),Fo(y,y,s),e.push(new mh(f[0],f[1],f[2])),x.push(new mh(y[0],y[1],y[2]));}h.push(e),p.push(x);}return [h,p]}(t,e,r,n,i,s,a,o,l,u,c):a?function(t,e,r,n,i,s,a,o,l){const u=[],c=[],h=[0,0,0,1];for(const p of t){const t=[],d=[];for(const u of p){const c=u.x+n.x,p=u.y+n.y,f=vh(c,p,e,r,s,a,o,l);h[0]=c,h[1]=p,h[2]=f.base,h[3]=1,Go(h,h,i),h[3]=Math.max(h[3],1e-5);const y=new mh(h[0]/h[3],h[1]/h[3],h[2]/h[3]);h[0]=c,h[1]=p,h[2]=f.top,h[3]=1,Go(h,h,i),h[3]=Math.max(h[3],1e-5);const m=new mh(h[0]/h[3],h[1]/h[3],h[2]/h[3]);t.push(y),d.push(m);}u.push(t),c.push(d);}return [u,c]}(e,r,n,i,s,a,o,l,u):function(t,e,r,n,i){const s=[],a=[],o=i[8]*e,l=i[9]*e,u=i[10]*e,c=i[11]*e,h=i[8]*r,p=i[9]*r,d=i[10]*r,f=i[11]*r;for(const e of t){const t=[],r=[];for(const s of e){const e=s.x+n.x,a=s.y+n.y,y=i[0]*e+i[4]*a+i[12],m=i[1]*e+i[5]*a+i[13],g=i[2]*e+i[6]*a+i[14],x=i[3]*e+i[7]*a+i[15],v=y+o,b=m+l,w=g+u,_=Math.max(x+c,1e-5),A=y+h,S=m+p,k=g+d,I=Math.max(x+f,1e-5);t.push(new mh(v/_,b/_,w/_)),r.push(new mh(A/I,S/I,k/I));}s.push(t),a.push(r);}return [s,a]}(e,r,n,i,s)}(s,n,h,c,u,a,m,p,f,s.center.lat,t.tileID.canonical),b=t.queryGeometry;return function(t,e,r){let n=1/0;du(r,e)&&(n=xh(r,e[0]));for(let i=0;i<e.length;i++){const s=e[i],a=t[i];for(let t=0;t<s.length-1;t++){const e=s[t],i=[e,s[t+1],a[t+1],a[t],e];hu(r,i)&&(n=Math.min(n,xh(r,i)));}}return n!==1/0&&n}(g,v,b.isPointQuery()?b.screenBounds:b.screenGeometry)}},line:class extends ro{constructor(t){super(t,Th),this.gradientVersion=0;}_handleSpecialPaintPropertyUpdate(t){if("line-gradient"===t){const t=this._transitionablePaint._values["line-gradient"].value.expression;this.stepInterpolant=t._styleExpression&&t._styleExpression.expression instanceof Br,this.gradientVersion=(this.gradientVersion+1)%Number.MAX_SAFE_INTEGER;}}gradientExpression(){return this._transitionablePaint._values["line-gradient"].value.expression}widthExpression(){return this._transitionablePaint._values["line-width"].value.expression}recalculate(t,e){super.recalculate(t,e),this.paint._values["line-floorwidth"]=zh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,t);}createBucket(t){return new Ih(t)}getProgramIds(){return [this.paint.get("line-pattern").constantOr(1)?"linePattern":"line"]}getProgramConfiguration(t){return new Xa(this,t)}queryRadius(t){const e=t,r=Bh(Au("line-width",this,e),Au("line-gap-width",this,e)),n=Au("line-offset",this,e);return r/2+Math.abs(n)+Su(this.paint.get("line-translate"))}queryIntersectsFeature(t,e,r,n,i,s){if(t.queryGeometry.isAboveHorizon)return !1;const a=ku(t.tilespaceGeometry,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),s.angle,t.pixelToTileUnitsFactor),o=t.pixelToTileUnitsFactor/2*Bh(this.paint.get("line-width").evaluate(e,r),this.paint.get("line-gap-width").evaluate(e,r)),l=this.paint.get("line-offset").evaluate(e,r);return l&&(n=function(t,e){const r=[],n=new x(0,0);for(let i=0;i<t.length;i++){const s=t[i],a=[];for(let t=0;t<s.length;t++){const r=s[t],i=s[t+1],o=0===t?n:r.sub(s[t-1])._unit()._perp(),l=t===s.length-1?n:i.sub(r)._unit()._perp(),u=o._add(l)._unit();u._mult(1/(u.x*l.x+u.y*l.y)),a.push(u._mult(e)._add(r));}r.push(a);}return r}(n,l*t.pixelToTileUnitsFactor)),function(t,e,r){for(let n=0;n<e.length;n++){const i=e[n];if(t.length>=3)for(let e=0;e<i.length;e++)if(bu(t,i[e]))return !0;if(fu(t,i,r))return !0}return !1}(a,n,o)}isTileClipped(){return !0}},symbol:hf,background:class extends ro{constructor(t){super(t,pf);}getProgramIds(){return [this.paint.get("background-pattern")?"backgroundPattern":"background"]}},raster:class extends ro{constructor(t){super(t,df);}getProgramIds(){return ["raster"]}},sky:class extends ro{constructor(t){super(t,yf),this._updateColorRamp();}_handleSpecialPaintPropertyUpdate(t){"sky-gradient"===t?this._updateColorRamp():"sky-atmosphere-sun"!==t&&"sky-atmosphere-halo-color"!==t&&"sky-atmosphere-color"!==t&&"sky-atmosphere-sun-intensity"!==t||(this._skyboxInvalidated=!0);}_updateColorRamp(){this.colorRamp=ju({expression:this._transitionablePaint._values["sky-gradient"].value.expression,evaluationKey:"skyRadialProgress"}),this.colorRampTexture&&(this.colorRampTexture.destroy(),this.colorRampTexture=null);}needsSkyboxCapture(t){if(this._skyboxInvalidated||!this.skyboxTexture||!this.skyboxGeometry)return !0;if(!this.paint.get("sky-atmosphere-sun")){const e=t.style.light.properties.get("position");return this._lightPosition.azimuthal!==e.azimuthal||this._lightPosition.polar!==e.polar}return !1}getCenter(t,e){if("atmosphere"===this.paint.get("sky-type")){const r=this.paint.get("sky-atmosphere-sun"),n=!r,i=t.style.light,s=i.properties.get("position");return n&&"viewport"===i.properties.get("anchor")&&N("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."),n?mf(s.azimuthal,90-s.polar,e):mf(r[0],90-r[1],e)}const r=this.paint.get("sky-gradient-center");return mf(r[0],90-r[1],e)}is3D(){return !1}isSky(){return !0}markSkyboxValid(t){this._skyboxInvalidated=!1,this._lightPosition=t.style.light.properties.get("position");}hasOffscreenPass(){return !0}getProgramIds(){const t=this.paint.get("sky-type");return "atmosphere"===t?["skyboxCapture","skybox"]:"gradient"===t?["skyboxGradient"]:null}}};class xf{constructor(t,e,r,n){this.context=t,this.format=r,this.texture=t.gl.createTexture(),this.update(e,n);}update(t,r,n){const{width:i,height:s}=t,{context:a}=this,{gl:o}=a,{HTMLImageElement:l,HTMLCanvasElement:u,HTMLVideoElement:c,ImageData:h,ImageBitmap:p}=e;if(o.bindTexture(o.TEXTURE_2D,this.texture),a.pixelStoreUnpackFlipY.set(!1),a.pixelStoreUnpack.set(1),a.pixelStoreUnpackPremultiplyAlpha.set(this.format===o.RGBA&&(!r||!1!==r.premultiply)),n||this.size&&this.size[0]===i&&this.size[1]===s){const{x:e,y:r}=n||{x:0,y:0};t instanceof l||t instanceof u||t instanceof c||t instanceof h||p&&t instanceof p?o.texSubImage2D(o.TEXTURE_2D,0,e,r,o.RGBA,o.UNSIGNED_BYTE,t):o.texSubImage2D(o.TEXTURE_2D,0,e,r,i,s,o.RGBA,o.UNSIGNED_BYTE,t.data);}else this.size=[i,s],t instanceof l||t instanceof u||t instanceof c||t instanceof h||p&&t instanceof p?o.texImage2D(o.TEXTURE_2D,0,this.format,this.format,o.UNSIGNED_BYTE,t):o.texImage2D(o.TEXTURE_2D,0,this.format,i,s,0,this.format,o.UNSIGNED_BYTE,t.data);this.useMipmap=Boolean(r&&r.useMipmap&&this.isSizePowerOfTwo()),this.useMipmap&&o.generateMipmap(o.TEXTURE_2D);}bind(t,e){const{context:r}=this,{gl:n}=r;n.bindTexture(n.TEXTURE_2D,this.texture),t!==this.filter&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,this.useMipmap?t===n.NEAREST?n.NEAREST_MIPMAP_NEAREST:n.LINEAR_MIPMAP_NEAREST:t),this.filter=t),e!==this.wrap&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,e),this.wrap=e);}isSizePowerOfTwo(){return this.size[0]===this.size[1]&&Math.log(this.size[0])/Math.LN2%1==0}destroy(){const{gl:t}=this.context;t.deleteTexture(this.texture),this.texture=null;}}class vf{constructor(t){this._callback=t,this._triggered=!1,"undefined"!=typeof MessageChannel&&(this._channel=new MessageChannel,this._channel.port2.onmessage=()=>{this._triggered=!1,this._callback();});}trigger(){this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout((()=>{this._triggered=!1,this._callback();}),0));}remove(){this._channel=void 0,this._callback=()=>{};}}class bf{constructor(){this.tasks={},this.taskQueue=[],R(["process"],this),this.invoker=new vf(this.process),this.nextId=0;}add(t,e){const r=this.nextId++,n=function({type:t,isSymbolTile:e,zoom:r}){return r=r||0,"message"===t?0:"maybePrepare"!==t||e?"parseTile"!==t||e?"parseTile"===t&&e?300-r:"maybePrepare"===t&&e?400-r:500:200-r:100-r}(e);if(0===n){K();try{t();}finally{}return {cancel:()=>{}}}return this.tasks[r]={fn:t,metadata:e,priority:n,id:r},this.taskQueue.push(r),this.invoker.trigger(),{cancel:()=>{delete this.tasks[r];}}}process(){K();try{if(this.taskQueue=this.taskQueue.filter((t=>!!this.tasks[t])),!this.taskQueue.length)return;const t=this.pick();if(null===t)return;const e=this.tasks[t];if(delete this.tasks[t],this.taskQueue.length&&this.invoker.trigger(),!e)return;e.fn();}finally{}}pick(){let t=null,e=1/0;for(let r=0;r<this.taskQueue.length;r++){const n=this.tasks[this.taskQueue[r]];n.priority<e&&(e=n.priority,t=r);}if(null===t)return null;const r=this.taskQueue[t];return this.taskQueue.splice(t,1),r}remove(){this.invoker.remove();}}class wf{constructor(t){this._stringToNumber={},this._numberToString=[];for(let e=0;e<t.length;e++){const r=t[e];this._stringToNumber[r]=e,this._numberToString[e]=r;}}encode(t){return this._stringToNumber[t]}decode(t){return this._numberToString[t]}}const _f=["tile","layer","source","sourceLayer","state"];class Af{constructor(t,e,r,n,i){this.type="Feature",this._vectorTileFeature=t,this._z=e,this._x=r,this._y=n,this.properties=t.properties,this.id=i;}get geometry(){return void 0===this._geometry&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._x,this._y,this._z).geometry),this._geometry}set geometry(t){this._geometry=t;}toJSON(){const t={type:"Feature",state:void 0,geometry:this.geometry,properties:this.properties};void 0!==this.id&&(t.id=this.id);for(const e of _f)void 0!==this[e]&&(t[e]=this[e]);return t}}const Sf=32,kf=33,If=new Uint16Array(8184);for(let t=0;t<2046;t++){let e=t+2,r=0,n=0,i=0,s=0,a=0,o=0;for(1&e?i=s=a=Sf:r=n=o=Sf;(e>>=1)>1;){const t=r+i>>1,l=n+s>>1;1&e?(i=r,s=n,r=a,n=o):(r=i,n=s,i=a,s=o),a=t,o=l;}const l=4*t;If[l+0]=r,If[l+1]=n,If[l+2]=i,If[l+3]=s;}const Mf=new Uint16Array(2178),Tf=new Uint8Array(1089),zf=new Uint16Array(1089);function Bf(t){return 0===t?-.03125:32===t?.03125:0}var Ef=Rs([{name:"a_pos",type:"Int16",components:2},{name:"a_texture_pos",type:"Int16",components:2}]);const Cf={type:2,extent:ao,loadGeometry:()=>[[new x(0,0),new x(ao+1,0),new x(ao+1,ao+1),new x(0,ao+1),new x(0,0)]]};class Pf{constructor(t,e,r,n,i){this.tileID=t,this.uid=D(),this.uses=0,this.tileSize=e,this.tileZoom=r,this.buckets={},this.expirationTime=null,this.queryPadding=0,this.hasSymbolBuckets=!1,this.hasRTLText=!1,this.dependencies={},this.isRaster=i,this.expiredRequestCount=0,this.state="loading",n&&n.transform&&(this.projection=n.transform.projection);}registerFadeDuration(t){const e=t+this.timeAdded;e<Xt.now()||this.fadeEndTime&&e<this.fadeEndTime||(this.fadeEndTime=e);}wasRequested(){return "errored"===this.state||"loaded"===this.state||"reloading"===this.state}get tileTransform(){return this._tileTransform||(this._tileTransform=Bd(this.tileID.canonical,this.projection)),this._tileTransform}loadVectorData(t,e,r){if(this.unloadVectorData(),this.state="loaded",t){t.featureIndex&&(this.latestFeatureIndex=t.featureIndex,t.rawTileData?(this.latestRawTileData=t.rawTileData,this.latestFeatureIndex.rawTileData=t.rawTileData):this.latestRawTileData&&(this.latestFeatureIndex.rawTileData=this.latestRawTileData)),this.collisionBoxArray=t.collisionBoxArray,this.buckets=function(t,e){const r={};if(!e)return r;for(const n of t){const t=n.layerIds.map((t=>e.getLayer(t))).filter(Boolean);if(0!==t.length){n.layers=t,n.stateDependentLayerIds&&(n.stateDependentLayers=n.stateDependentLayerIds.map((e=>t.filter((t=>t.id===e))[0])));for(const e of t)r[e.id]=n;}}return r}(t.buckets,e.style),this.hasSymbolBuckets=!1;for(const t in this.buckets){const e=this.buckets[t];if(e instanceof of){if(this.hasSymbolBuckets=!0,!r)break;e.justReloaded=!0;}}if(this.hasRTLText=!1,this.hasSymbolBuckets)for(const t in this.buckets){const e=this.buckets[t];if(e instanceof of&&e.hasRTLText){this.hasRTLText=!0,bs.isLoading()||bs.isLoaded()||"deferred"!==xs()||vs();break}}this.queryPadding=0;for(const t in this.buckets){const r=this.buckets[t];this.queryPadding=Math.max(this.queryPadding,e.style.getLayer(t).queryRadius(r));}t.imageAtlas&&(this.imageAtlas=t.imageAtlas),t.glyphAtlasImage&&(this.glyphAtlasImage=t.glyphAtlasImage),t.lineAtlas&&(this.lineAtlas=t.lineAtlas);}else this.collisionBoxArray=new pa;}unloadVectorData(){if(this.hasData()){for(const t in this.buckets)this.buckets[t].destroy();this.buckets={},this.imageAtlas&&(this.imageAtlas=null),this.lineAtlas&&(this.lineAtlas=null),this.imageAtlasTexture&&this.imageAtlasTexture.destroy(),this.glyphAtlasTexture&&this.glyphAtlasTexture.destroy(),this.lineAtlasTexture&&this.lineAtlasTexture.destroy(),this._tileBoundsBuffer&&(this._tileBoundsBuffer.destroy(),this._tileBoundsIndexBuffer.destroy(),this._tileBoundsSegments.destroy(),this._tileBoundsBuffer=null),this._tileDebugBuffer&&(this._tileDebugBuffer.destroy(),this._tileDebugSegments.destroy(),this._tileDebugBuffer=null),this._tileDebugIndexBuffer&&(this._tileDebugIndexBuffer.destroy(),this._tileDebugIndexBuffer=null),this._globeTileDebugBorderBuffer&&(this._globeTileDebugBorderBuffer.destroy(),this._globeTileDebugBorderBuffer=null),this._tileDebugTextBuffer&&(this._tileDebugTextBuffer.destroy(),this._tileDebugTextSegments.destroy(),this._tileDebugTextIndexBuffer.destroy(),this._tileDebugTextBuffer=null),this._globeTileDebugTextBuffer&&(this._globeTileDebugTextBuffer.destroy(),this._globeTileDebugTextBuffer=null),this.latestFeatureIndex=null,this.state="unloaded";}}getBucket(t){return this.buckets[t.id]}upload(t){for(const e in this.buckets){const r=this.buckets[e];r.uploadPending()&&r.upload(t);}const e=t.gl;this.imageAtlas&&!this.imageAtlas.uploaded&&(this.imageAtlasTexture=new xf(t,this.imageAtlas.image,e.RGBA),this.imageAtlas.uploaded=!0),this.glyphAtlasImage&&(this.glyphAtlasTexture=new xf(t,this.glyphAtlasImage,e.ALPHA),this.glyphAtlasImage=null),this.lineAtlas&&!this.lineAtlas.uploaded&&(this.lineAtlasTexture=new xf(t,this.lineAtlas.image,e.ALPHA),this.lineAtlas.uploaded=!0);}prepare(t){this.imageAtlas&&this.imageAtlas.patchUpdatedImages(t,this.imageAtlasTexture);}queryRenderedFeatures(t,e,r,n,i,s,a,o){return this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData?this.latestFeatureIndex.query({tileResult:n,pixelPosMatrix:a,transform:s,params:i,tileTransform:this.tileTransform},t,e,r):{}}querySourceFeatures(t,e){const r=this.latestFeatureIndex;if(!r||!r.rawTileData)return;const n=r.loadVTLayers(),i=e?e.sourceLayer:"",s=n._geojsonTileLayer||n[i];if(!s)return;const a=hi(e&&e.filter),{z:o,x:l,y:u}=this.tileID.canonical,c={z:o,x:l,y:u};for(let e=0;e<s.length;e++){const n=s.feature(e);if(a.needGeometry){const t=ou(n,!0);if(!a.filter(new ws(this.tileID.overscaledZ),t,this.tileID.canonical))continue}else if(!a.filter(new ws(this.tileID.overscaledZ),n))continue;const h=r.getId(n,i),p=new Af(n,o,l,u,h);p.tile=c,t.push(p);}}hasData(){return "loaded"===this.state||"reloading"===this.state||"expired"===this.state}patternsLoaded(){return !!this.imageAtlas&&!!Object.keys(this.imageAtlas.patternPositions).length}setExpiryData(t){const e=this.expirationTime;if(t.cacheControl){const e=X(t.cacheControl);e["max-age"]&&(this.expirationTime=Date.now()+1e3*e["max-age"]);}else t.expires&&(this.expirationTime=new Date(t.expires).getTime());if(this.expirationTime){const t=Date.now();let r=!1;if(this.expirationTime>t)r=!1;else if(e)if(this.expirationTime<e)r=!0;else {const n=this.expirationTime-e;n?this.expirationTime=t+Math.max(n,3e4):r=!0;}else r=!0;r?(this.expiredRequestCount++,this.state="expired"):this.expiredRequestCount=0;}}getExpiryTimeout(){if(this.expirationTime)return this.expiredRequestCount?1e3*(1<<Math.min(this.expiredRequestCount-1,31)):Math.min(this.expirationTime-(new Date).getTime(),Math.pow(2,31)-1)}setFeatureState(t,e){if(!this.latestFeatureIndex||!this.latestFeatureIndex.rawTileData||0===Object.keys(t).length||!e)return;const r=this.latestFeatureIndex.loadVTLayers(),n=e.style.listImages();for(const i in this.buckets){if(!e.style.hasLayer(i))continue;const s=this.buckets[i],a=s.layers[0].sourceLayer||"_geojsonTileLayer",o=r[a],l=t[a];if(!o||!l||0===Object.keys(l).length)continue;if(s.update(l,o,n,this.imageAtlas&&this.imageAtlas.patternPositions||{}),s instanceof Ih||s instanceof Mc){const t=e.style._getSourceCache(s.layers[0].source);e._terrain&&e._terrain.enabled&&t&&s.programConfigurations.needsUpload&&e._terrain._clearRenderCacheForTile(t.id,this.tileID);}const u=e&&e.style&&e.style.getLayer(i);u&&(this.queryPadding=Math.max(this.queryPadding,u.queryRadius(s)));}}holdingForFade(){return void 0!==this.symbolFadeHoldUntil}symbolFadeFinished(){return !this.symbolFadeHoldUntil||this.symbolFadeHoldUntil<Xt.now()}clearFadeHold(){this.symbolFadeHoldUntil=void 0;}setHoldDuration(t){this.symbolFadeHoldUntil=Xt.now()+t;}setTexture(t,e){const r=e.context,n=r.gl;this.texture=this.texture||e.getTileTexture(t.width),this.texture?this.texture.update(t,{useMipmap:!0}):(this.texture=new xf(r,t,n.RGBA,{useMipmap:!0}),this.texture.bind(n.LINEAR,n.CLAMP_TO_EDGE));}setDependencies(t,e){const r={};for(const t of e)r[t]=!0;this.dependencies[t]=r;}hasDependency(t,e){for(const r of t){const t=this.dependencies[r];if(t)for(const r of e)if(t[r])return !0}return !1}clearQueryDebugViz(){}_makeDebugTileBoundsBuffers(t,e){if(!e||"mercator"===e.name||this._tileDebugBuffer)return;const r=au(Cf,this.tileID.canonical,this.tileTransform)[0],n=new $s,i=new ua;for(let t=0;t<r.length;t++){const{x:e,y:s}=r[t];n.emplaceBack(e,s),i.emplaceBack(t);}i.emplaceBack(0),this._tileDebugIndexBuffer=t.createIndexBuffer(i),this._tileDebugBuffer=t.createVertexBuffer(n,tl.members),this._tileDebugSegments=so.simpleSegment(0,0,n.length,i.length);}_makeTileBoundsBuffers(t,e){if(this._tileBoundsBuffer||!e||"mercator"===e.name)return;const r=au(Cf,this.tileID.canonical,this.tileTransform)[0];let n,i;if(this.isRaster){const t=function(t,e){const r=Bd(t,e),n=Math.pow(2,t.z);for(let i=0;i<kf;i++)for(let s=0;s<kf;s++){const a=Kl((t.x+(s+Bf(s))/Sf)/n),o=Xl((t.y+(i+Bf(i))/Sf)/n),l=e.project(a,o),u=i*kf+s;Mf[2*u+0]=Math.round((l.x*r.scale-r.x)*ao),Mf[2*u+1]=Math.round((l.y*r.scale-r.y)*ao);}Tf.fill(0),zf.fill(0);for(let t=2045;t>=0;t--){const e=4*t,r=If[e+0],n=If[e+1],i=If[e+2],s=If[e+3],a=r+i>>1,o=n+s>>1,l=a+o-n,u=o+r-a,c=n*kf+r,h=s*kf+i,p=o*kf+a,d=Math.hypot((Mf[2*c+0]+Mf[2*h+0])/2-Mf[2*p+0],(Mf[2*c+1]+Mf[2*h+1])/2-Mf[2*p+1])>=16;Tf[p]=Tf[p]||(d?1:0),t<1022&&(Tf[p]=Tf[p]||Tf[(n+u>>1)*kf+(r+l>>1)]||Tf[(s+u>>1)*kf+(i+l>>1)]);}const i=new Os,s=new ra;let a=0;function o(t,e){const r=e*kf+t;return 0===zf[r]&&(i.emplaceBack(Mf[2*r+0],Mf[2*r+1],t*ao/Sf,e*ao/Sf),zf[r]=++a),zf[r]-1}function l(t,e,r,n,i,a){const u=t+r>>1,c=e+n>>1;if(Math.abs(t-i)+Math.abs(e-a)>1&&Tf[c*kf+u])l(i,a,t,e,u,c),l(r,n,i,a,u,c);else {const l=o(t,e),u=o(r,n),c=o(i,a);s.emplaceBack(l,u,c);}}return l(0,0,Sf,Sf,Sf,0),l(Sf,Sf,0,0,0,Sf),{vertices:i,indices:s}}(this.tileID.canonical,e);n=t.vertices,i=t.indices;}else {n=new Os,i=new ra;for(const{x:t,y:e}of r)n.emplaceBack(t,e,0,0);const t=xc(n.int16,void 0,4);for(let e=0;e<t.length;e+=3)i.emplaceBack(t[e],t[e+1],t[e+2]);}this._tileBoundsBuffer=t.createVertexBuffer(n,Ef.members),this._tileBoundsIndexBuffer=t.createIndexBuffer(i),this._tileBoundsSegments=so.simpleSegment(0,0,n.length,i.length);}_makeGlobeTileDebugBuffers(t,e){const r=e.projection;if(!r||"globe"!==r.name||e.freezeTileCoverage)return;const n=this.tileID.canonical,i=Bl(bl(n,e)),s=Pl(e.zoom);let a;s>0&&(a=fo(new Float64Array(16),e.globeMatrix)),this._makeGlobeTileDebugBorderBuffer(t,n,e,i,a,s),this._makeGlobeTileDebugTextBuffer(t,n,e,i,a,s);}_globePoint(t,e,r,n,i,s,a){let o=Ml(t,e,r);if(s){const i=1<<r.z,l=Nl(n.center.lng),u=Gl(n.center.lat),c=(r.x+.5)/i-l;let h=0;c>.5?h=-1:c<-.5&&(h=1);let p=(t/ao+r.x)/i+h,d=(e/ao+r.y)/i;p=(p-l)*n._pixelsPerMercatorPixel+l,d=(d-u)*n._pixelsPerMercatorPixel+u;const f=[p*n.worldSize,d*n.worldSize,0];Fo(f,f,s),o=vl(o,f,a);}return Fo(o,o,i)}_makeGlobeTileDebugBorderBuffer(t,e,r,n,i,s){const a=new $s,o=new ua,l=new js,u=(t,u,c,h,p)=>{const d=(c-t)/(p-1),f=(h-u)/(p-1),y=a.length;for(let c=0;c<p;c++){const h=t+c*d,p=u+c*f;a.emplaceBack(h,p);const m=this._globePoint(h,p,e,r,n,i,s);l.emplaceBack(m[0],m[1],m[2]),o.emplaceBack(y+c);}},c=ao;u(0,0,c,0,16),u(c,0,c,c,16),u(c,c,0,c,16),u(0,c,0,0,16),this._tileDebugIndexBuffer=t.createIndexBuffer(o),this._tileDebugBuffer=t.createVertexBuffer(a,tl.members),this._globeTileDebugBorderBuffer=t.createVertexBuffer(l,Qo.members),this._tileDebugSegments=so.simpleSegment(0,0,a.length,o.length);}_makeGlobeTileDebugTextBuffer(t,e,r,n,i,s){const a=ao/4,o=new $s,l=new ra,u=new js,c=25;l.reserve(32),o.reserve(c),u.reserve(c);const h=(t,e)=>c*t+e;for(let t=0;t<c;t++){const l=t*a;for(let t=0;t<c;t++){const c=t*a;o.emplaceBack(c,l);const h=this._globePoint(c,l,e,r,n,i,s);u.emplaceBack(h[0],h[1],h[2]);}}for(let t=0;t<4;t++)for(let e=0;e<4;e++){const r=h(t,e),n=h(t,e+1),i=h(t+1,e),s=h(t+1,e+1);l.emplaceBack(r,n,i),l.emplaceBack(i,n,s);}this._tileDebugTextIndexBuffer=t.createIndexBuffer(l),this._tileDebugTextBuffer=t.createVertexBuffer(o,tl.members),this._globeTileDebugTextBuffer=t.createVertexBuffer(u,Qo.members),this._tileDebugTextSegments=so.simpleSegment(0,0,c,32);}}class Df{constructor(){this.state={},this.stateChanges={},this.deletedStates={};}updateState(t,e,r){const n=String(e);if(this.stateChanges[t]=this.stateChanges[t]||{},this.stateChanges[t][n]=this.stateChanges[t][n]||{},C(this.stateChanges[t][n],r),null===this.deletedStates[t]){this.deletedStates[t]={};for(const e in this.state[t])e!==n&&(this.deletedStates[t][e]=null);}else if(this.deletedStates[t]&&null===this.deletedStates[t][n]){this.deletedStates[t][n]={};for(const e in this.state[t][n])r[e]||(this.deletedStates[t][n][e]=null);}else for(const e in r)this.deletedStates[t]&&this.deletedStates[t][n]&&null===this.deletedStates[t][n][e]&&delete this.deletedStates[t][n][e];}removeFeatureState(t,e,r){if(null===this.deletedStates[t])return;const n=String(e);if(this.deletedStates[t]=this.deletedStates[t]||{},r&&void 0!==e)null!==this.deletedStates[t][n]&&(this.deletedStates[t][n]=this.deletedStates[t][n]||{},this.deletedStates[t][n][r]=null);else if(void 0!==e)if(this.stateChanges[t]&&this.stateChanges[t][n])for(r in this.deletedStates[t][n]={},this.stateChanges[t][n])this.deletedStates[t][n][r]=null;else this.deletedStates[t][n]=null;else this.deletedStates[t]=null;}getState(t,e){const r=String(e),n=C({},(this.state[t]||{})[r],(this.stateChanges[t]||{})[r]);if(null===this.deletedStates[t])return {};if(this.deletedStates[t]){const r=this.deletedStates[t][e];if(null===r)return {};for(const t in r)delete n[t];}return n}initializeTileState(t,e){t.setFeatureState(this.state,e);}coalesceChanges(t,e){const r={};for(const t in this.stateChanges){this.state[t]=this.state[t]||{};const e={};for(const r in this.stateChanges[t])this.state[t][r]||(this.state[t][r]={}),C(this.state[t][r],this.stateChanges[t][r]),e[r]=this.state[t][r];r[t]=e;}for(const t in this.deletedStates){this.state[t]=this.state[t]||{};const e={};if(null===this.deletedStates[t])for(const r in this.state[t])e[r]={},this.state[t][r]={};else for(const r in this.deletedStates[t]){if(null===this.deletedStates[t][r])this.state[t][r]={};else if(this.state[t][r])for(const e of Object.keys(this.deletedStates[t][r]))delete this.state[t][r][e];e[r]=this.state[t][r];}r[t]=r[t]||{},C(r[t],e);}if(this.stateChanges={},this.deletedStates={},0!==Object.keys(r).length)for(const n in t)t[n].setFeatureState(r,e);}}class Vf{constructor(t){this.size=t,this.minimums=[],this.maximums=[],this.leaves=[];}getElevation(t,e){const r=this.toIdx(t,e);return {min:this.minimums[r],max:this.maximums[r]}}isLeaf(t,e){return this.leaves[this.toIdx(t,e)]}toIdx(t,e){return e*this.size+t}}function Lf(t,e,r,n){let i=0,s=Number.MAX_VALUE;for(let a=0;a<3;a++)if(Math.abs(n[a])<1e-15){if(r[a]<t[a]||r[a]>e[a])return null}else {const o=1/n[a];let l=(t[a]-r[a])*o,u=(e[a]-r[a])*o;if(l>u){const t=l;l=u,u=t;}if(l>i&&(i=l),u<s&&(s=u),i>s)return null}return i}function Ff(t,e,r,n,i,s,a,o,l,u,c){const h=n-t,p=i-e,d=s-r,f=a-t,y=o-e,m=l-r,g=c[1]*m-c[2]*y,x=c[2]*f-c[0]*m,v=c[0]*y-c[1]*f,b=h*g+p*x+d*v;if(Math.abs(b)<1e-15)return null;const w=1/b,_=u[0]-t,A=u[1]-e,S=u[2]-r,k=(_*g+A*x+S*v)*w;if(k<0||k>1)return null;const I=A*d-S*p,M=S*h-_*d,T=_*p-A*h,z=(c[0]*I+c[1]*M+c[2]*T)*w;return z<0||k+z>1?null:(f*I+y*M+m*T)*w}function Rf(t,e,r){return (t-e)/(r-e)}function Uf(t,e,r,n,i,s,a,o,l){const u=1<<r,c=s-n,h=a-i,p=(t+1)/u*c+n,d=(e+0)/u*h+i,f=(e+1)/u*h+i;o[0]=(t+0)/u*c+n,o[1]=d,l[0]=p,l[1]=f;}class $f{constructor(t){if(this.maximums=[],this.minimums=[],this.leaves=[],this.childOffsets=[],this.nodeCount=0,this.dem=t,this._siblingOffset=[[0,0],[1,0],[0,1],[1,1]],!this.dem)return;const e=function(t){const e=Math.ceil(Math.log2(t.dim/8)),r=[];let n=Math.ceil(Math.pow(2,e));const i=1/n,s=(t,e,r,n,i)=>{const s=n?1:0,a=(t+1)*r-s,o=e*r,l=(e+1)*r-s;i[0]=t*r,i[1]=o,i[2]=a,i[3]=l;};let a=new Vf(n);const o=[];for(let e=0;e<n*n;e++){s(e%n,Math.floor(e/n),i,!1,o);const r=Of(o[0],o[1],t),l=Of(o[2],o[1],t),u=Of(o[2],o[3],t),c=Of(o[0],o[3],t);a.minimums.push(Math.min(r,l,u,c)),a.maximums.push(Math.max(r,l,u,c)),a.leaves.push(1);}for(r.push(a),n/=2;n>=1;n/=2){const t=r[r.length-1];a=new Vf(n);for(let e=0;e<n*n;e++){s(e%n,Math.floor(e/n),2,!0,o);const r=t.getElevation(o[0],o[1]),i=t.getElevation(o[2],o[1]),l=t.getElevation(o[2],o[3]),u=t.getElevation(o[0],o[3]),c=t.isLeaf(o[0],o[1]),h=t.isLeaf(o[2],o[1]),p=t.isLeaf(o[2],o[3]),d=t.isLeaf(o[0],o[3]),f=Math.min(r.min,i.min,l.min,u.min),y=Math.max(r.max,i.max,l.max,u.max),m=c&&h&&p&&d;a.maximums.push(y),a.minimums.push(f),a.leaves.push(y-f<=5&&m?1:0);}r.push(a);}return r}(this.dem),r=e.length-1,n=e[r];this._addNode(n.minimums[0],n.maximums[0],n.leaves[0]),this._construct(e,0,0,r,0);}raycastRoot(t,e,r,n,i,s,a=1){return Lf([t,e,-100],[r,n,this.maximums[0]*a],i,s)}raycast(t,e,r,n,i,s,a=1){if(!this.nodeCount)return null;const o=this.raycastRoot(t,e,r,n,i,s,a);if(null==o)return null;const l=[],u=[],c=[],h=[],p=[{idx:0,t:o,nodex:0,nodey:0,depth:0}];for(;p.length>0;){const{idx:o,t:d,nodex:f,nodey:y,depth:m}=p.pop();if(this.leaves[o]){Uf(f,y,m,t,e,r,n,c,h);const o=1<<m,l=(f+0)/o,u=(f+1)/o,p=(y+0)/o,g=(y+1)/o,x=Of(l,p,this.dem)*a,v=Of(u,p,this.dem)*a,b=Of(u,g,this.dem)*a,w=Of(l,g,this.dem)*a,_=Ff(c[0],c[1],x,h[0],c[1],v,h[0],h[1],b,i,s),A=Ff(h[0],h[1],b,c[0],h[1],w,c[0],c[1],x,i,s),S=Math.min(null!==_?_:Number.MAX_VALUE,null!==A?A:Number.MAX_VALUE);if(S!==Number.MAX_VALUE)return S;{const t=Po([],i,s,d);if(jf(x,v,w,b,Rf(t[0],c[0],h[0]),Rf(t[1],c[1],h[1]))>=t[2])return d}continue}let g=0;for(let p=0;p<this._siblingOffset.length;p++){Uf((f<<1)+this._siblingOffset[p][0],(y<<1)+this._siblingOffset[p][1],m+1,t,e,r,n,c,h),c[2]=-100,h[2]=this.maximums[this.childOffsets[o]+p]*a;const d=Lf(c,h,i,s);if(null!=d){const t=d;l[p]=t;let e=!1;for(let r=0;r<g&&!e;r++)t>=l[u[r]]&&(u.splice(r,0,p),e=!0);e||(u[g]=p),g++;}}for(let t=0;t<g;t++){const e=u[t];p.push({idx:this.childOffsets[o]+e,t:l[e],nodex:(f<<1)+this._siblingOffset[e][0],nodey:(y<<1)+this._siblingOffset[e][1],depth:m+1});}}return null}_addNode(t,e,r){return this.minimums.push(t),this.maximums.push(e),this.leaves.push(r),this.childOffsets.push(0),this.nodeCount++}_construct(t,e,r,n,i){if(1===t[n].isLeaf(e,r))return;this.childOffsets[i]||(this.childOffsets[i]=this.nodeCount);const s=n-1,a=t[s];let o=0,l=0;for(let t=0;t<this._siblingOffset.length;t++){const n=2*e+this._siblingOffset[t][0],i=2*r+this._siblingOffset[t][1],s=a.getElevation(n,i),u=a.isLeaf(n,i),c=this._addNode(s.min,s.max,u);u&&(o|=1<<t),l||(l=c);}for(let n=0;n<this._siblingOffset.length;n++)o&1<<n||this._construct(t,2*e+this._siblingOffset[n][0],2*r+this._siblingOffset[n][1],s,l+n);}}function jf(t,e,r,n,i,s){return Er(Er(t,r,s),Er(e,n,s),i)}function Of(t,e,r){const n=r.dim,i=M(t*n-.5,0,n-1),s=M(e*n-.5,0,n-1),a=Math.floor(i),o=Math.floor(s),l=Math.min(a+1,n-1),u=Math.min(o+1,n-1);return jf(r.get(a,o),r.get(l,o),r.get(a,u),r.get(l,u),i-a,s-o)}const qf={mapbox:[6553.6,25.6,.1,1e4],terrarium:[256,1,1/256,32768]};function Nf(t,e,r){return (256*t*256+256*e+r)/10-1e4}function Gf(t,e,r){return 256*t+e+r/256-32768}class Zf{get tree(){return this._tree||this._buildQuadTree(),this._tree}constructor(t,e,r,n=!1,i=!1){if(this.uid=t,e.height!==e.width)throw new RangeError("DEM tiles must be square");if(r&&"mapbox"!==r&&"terrarium"!==r)return N(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);this.stride=e.height;const s=this.dim=e.height-2,a=new Uint32Array(e.data.buffer);if(this.pixels=new Uint8Array(e.data.buffer),this.encoding=r||"mapbox",this.borderReady=n,!n){for(let t=0;t<s;t++)a[this._idx(-1,t)]=a[this._idx(0,t)],a[this._idx(s,t)]=a[this._idx(s-1,t)],a[this._idx(t,-1)]=a[this._idx(t,0)],a[this._idx(t,s)]=a[this._idx(t,s-1)];a[this._idx(-1,-1)]=a[this._idx(0,0)],a[this._idx(s,-1)]=a[this._idx(s-1,0)],a[this._idx(-1,s)]=a[this._idx(0,s-1)],a[this._idx(s,s)]=a[this._idx(s-1,s-1)],i&&this._buildQuadTree();}}_buildQuadTree(){this._tree=new $f(this);}get(t,e,r=!1){r&&(t=M(t,-1,this.dim),e=M(e,-1,this.dim));const n=4*this._idx(t,e);return ("terrarium"===this.encoding?Gf:Nf)(this.pixels[n],this.pixels[n+1],this.pixels[n+2])}static getUnpackVector(t){return qf[t]}get unpackVector(){return qf[this.encoding]}_idx(t,e){if(t<-1||t>=this.dim+1||e<-1||e>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return (e+1)*this.stride+(t+1)}static pack(t,e){const r=[0,0,0,0],n=Zf.getUnpackVector(e);let i=Math.floor((t+n[3])/n[2]);return r[2]=i%256,i=Math.floor(i/256),r[1]=i%256,i=Math.floor(i/256),r[0]=i,r}getPixels(){return new Uu({width:this.stride,height:this.stride},this.pixels)}backfillBorder(t,e,r){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");let n=e*this.dim,i=e*this.dim+this.dim,s=r*this.dim,a=r*this.dim+this.dim;switch(e){case-1:n=i-1;break;case 1:i=n+1;}switch(r){case-1:s=a-1;break;case 1:a=s+1;}const o=-e*this.dim,l=-r*this.dim;for(let e=s;e<a;e++)for(let r=n;r<i;r++){const n=4*this._idx(r,e),i=4*this._idx(r+o,e+l);this.pixels[n+0]=t.pixels[i+0],this.pixels[n+1]=t.pixels[i+1],this.pixels[n+2]=t.pixels[i+2],this.pixels[n+3]=t.pixels[i+3];}}onDeserialize(){this._tree&&(this._tree.dem=this);}}Ji(Zf,"DEMData"),Ji($f,"DemMinMaxQuadTree",{omit:["dem"]});class Kf{constructor(t,e){this.max=t,this.onRemove=e,this.reset();}reset(){for(const t in this.data)for(const e of this.data[t])e.timeout&&clearTimeout(e.timeout),this.onRemove(e.value);return this.data={},this.order=[],this}add(t,e,r){const n=t.wrapped().key;void 0===this.data[n]&&(this.data[n]=[]);const i={value:e,timeout:void 0};if(void 0!==r&&(i.timeout=setTimeout((()=>{this.remove(t,i);}),r)),this.data[n].push(i),this.order.push(n),this.order.length>this.max){const t=this._getAndRemoveByKey(this.order[0]);t&&this.onRemove(t);}return this}has(t){return t.wrapped().key in this.data}getAndRemove(t){return this.has(t)?this._getAndRemoveByKey(t.wrapped().key):null}_getAndRemoveByKey(t){const e=this.data[t].shift();return e.timeout&&clearTimeout(e.timeout),0===this.data[t].length&&delete this.data[t],this.order.splice(this.order.indexOf(t),1),e.value}getByKey(t){const e=this.data[t];return e?e[0].value:null}get(t){return this.has(t)?this.data[t.wrapped().key][0].value:null}remove(t,e){if(!this.has(t))return this;const r=t.wrapped().key,n=void 0===e?0:this.data[r].indexOf(e),i=this.data[r][n];return this.data[r].splice(n,1),i.timeout&&clearTimeout(i.timeout),0===this.data[r].length&&delete this.data[r],this.onRemove(i.value),this.order.splice(this.order.indexOf(r),1),this}setMaxSize(t){for(this.max=t;this.order.length>this.max;){const t=this._getAndRemoveByKey(this.order[0]);t&&this.onRemove(t);}return this}filter(t){const e=[];for(const r in this.data)for(const n of this.data[r])t(n.value)||e.push(n);for(const t of e)this.remove(t.value.tileID,t);}}class Xf{constructor(t,e,r){this.func=t,this.mask=e,this.range=r;}}Xf.ReadOnly=!1,Xf.ReadWrite=!0,Xf.disabled=new Xf(519,Xf.ReadOnly,[0,1]);const Jf=7680;class Hf{constructor(t,e,r,n,i,s){this.test=t,this.ref=e,this.mask=r,this.fail=n,this.depthFail=i,this.pass=s;}}Hf.disabled=new Hf({func:519,mask:0},0,0,Jf,Jf,Jf);class Yf{constructor(t,e,r){this.blendFunction=t,this.blendColor=e,this.mask=r;}}Yf.Replace=[1,0],Yf.disabled=new Yf(Yf.Replace,Ee.transparent,[!1,!1,!1,!1]),Yf.unblended=new Yf(Yf.Replace,Ee.transparent,[!0,!0,!0,!0]),Yf.alphaBlended=new Yf([1,771],Ee.transparent,[!0,!0,!0,!0]);const Wf=1029,Qf=2305;class ty{constructor(t,e,r){this.enable=t,this.mode=e,this.frontFace=r;}}ty.disabled=new ty(!1,Wf,Qf),ty.backCCW=new ty(!0,Wf,Qf),ty.backCW=new ty(!0,Wf,2304),ty.frontCW=new ty(!0,1028,2304),ty.frontCCW=new ty(!0,1028,Qf);class ey extends Qt{constructor(t,e,r){super(),this.id=t,this._onlySymbols=r,e.on("data",(t=>{"source"===t.dataType&&"metadata"===t.sourceDataType&&(this._sourceLoaded=!0),this._sourceLoaded&&!this._paused&&"source"===t.dataType&&"content"===t.sourceDataType&&(this.reload(),this.transform&&this.update(this.transform));})),e.on("error",(()=>{this._sourceErrored=!0;})),this._source=e,this._tiles={},this._cache=new Kf(0,this._unloadTile.bind(this)),this._timers={},this._cacheTimers={},this._minTileCacheSize=e.minTileCacheSize,this._maxTileCacheSize=e.maxTileCacheSize,this._loadedParentTiles={},this._coveredTiles={},this._state=new Df,this._isRaster="raster"===this._source.type||"raster-dem"===this._source.type||"custom"===this._source.type&&"raster"===this._source._dataType;}onAdd(t){this.map=t,this._minTileCacheSize=void 0===this._minTileCacheSize&&t?t._minTileCacheSize:this._minTileCacheSize,this._maxTileCacheSize=void 0===this._maxTileCacheSize&&t?t._maxTileCacheSize:this._maxTileCacheSize;}loaded(){if(this._sourceErrored)return !0;if(!this._sourceLoaded)return !1;if(!this._source.loaded())return !1;for(const t in this._tiles){const e=this._tiles[t];if("loaded"!==e.state&&"errored"!==e.state)return !1}return !0}getSource(){return this._source}pause(){this._paused=!0;}resume(){if(!this._paused)return;const t=this._shouldReloadOnResume;this._paused=!1,this._shouldReloadOnResume=!1,t&&this.reload(),this.transform&&this.update(this.transform);}_loadTile(t,e){return t.isSymbolTile=this._onlySymbols,this._source.loadTile(t,e)}_unloadTile(t){if(this._source.unloadTile)return this._source.unloadTile(t,(()=>{}))}_abortTile(t){if(this._source.abortTile)return this._source.abortTile(t,(()=>{}))}serialize(){return this._source.serialize()}prepare(t){this._source.prepare&&this._source.prepare(),this._state.coalesceChanges(this._tiles,this.map?this.map.painter:null);for(const e in this._tiles){const r=this._tiles[e];r.upload(t),r.prepare(this.map.style.imageManager);}}getIds(){return E(this._tiles).map((t=>t.tileID)).sort(ry).map((t=>t.key))}getRenderableIds(t){const e=[];for(const r in this._tiles)this._isIdRenderable(+r,t)&&e.push(this._tiles[r]);return t?e.sort(((t,e)=>{const r=t.tileID,n=e.tileID,i=new x(r.canonical.x,r.canonical.y)._rotate(this.transform.angle),s=new x(n.canonical.x,n.canonical.y)._rotate(this.transform.angle);return r.overscaledZ-n.overscaledZ||s.y-i.y||s.x-i.x})).map((t=>t.tileID.key)):e.map((t=>t.tileID)).sort(ry).map((t=>t.key))}hasRenderableParent(t){const e=this.findLoadedParent(t,0);return !!e&&this._isIdRenderable(e.tileID.key)}_isIdRenderable(t,e){return this._tiles[t]&&this._tiles[t].hasData()&&!this._coveredTiles[t]&&(e||!this._tiles[t].holdingForFade())}reload(){if(this._paused)this._shouldReloadOnResume=!0;else {this._cache.reset();for(const t in this._tiles)"errored"!==this._tiles[t].state&&this._reloadTile(+t,"reloading");}}_reloadTile(t,e){const r=this._tiles[t];r&&("loading"!==r.state&&(r.state=e),this._loadTile(r,this._tileLoaded.bind(this,r,t,e)));}_tileLoaded(t,e,r,n){if(n)if(t.state="errored",404!==n.status)this._source.fire(new Wt(n,{tile:t}));else if("raster-dem"===this._source.type&&this.usedForTerrain&&this.map.painter.terrain){const t=this.map.painter.terrain;this.update(this.transform,t.getScaledDemTileSize(),!0),t.resetTileLookupCache(this.id);}else this.update(this.transform);else t.timeAdded=Xt.now(),"expired"===r&&(t.refreshedUponExpiration=!0),this._setTileReloadTimer(e,t),"raster-dem"===this._source.type&&t.dem&&this._backfillDEM(t),this._state.initializeTileState(t,this.map?this.map.painter:null),this._source.fire(new Yt("data",{dataType:"source",tile:t,coord:t.tileID,sourceCacheId:this.id}));}_backfillDEM(t){const e=this.getRenderableIds();for(let n=0;n<e.length;n++){const i=e[n];if(t.neighboringTiles&&t.neighboringTiles[i]){const e=this.getTileByID(i);r(t,e),r(e,t);}}function r(t,e){if(!t.dem||t.dem.borderReady)return;t.needsHillshadePrepare=!0,t.needsDEMTextureUpload=!0;let r=e.tileID.canonical.x-t.tileID.canonical.x;const n=e.tileID.canonical.y-t.tileID.canonical.y,i=Math.pow(2,t.tileID.canonical.z),s=e.tileID.key;0===r&&0===n||Math.abs(n)>1||(Math.abs(r)>1&&(1===Math.abs(r+i)?r+=i:1===Math.abs(r-i)&&(r-=i)),e.dem&&t.dem&&(t.dem.backfillBorder(e.dem,r,n),t.neighboringTiles&&t.neighboringTiles[s]&&(t.neighboringTiles[s].backfilled=!0)));}}getTile(t){return this.getTileByID(t.key)}getTileByID(t){return this._tiles[t]}_retainLoadedChildren(t,e,r,n){for(const i in this._tiles){let s=this._tiles[i];if(n[i]||!s.hasData()||s.tileID.overscaledZ<=e||s.tileID.overscaledZ>r)continue;let a=s.tileID;for(;s&&s.tileID.overscaledZ>e+1;){const t=s.tileID.scaledTo(s.tileID.overscaledZ-1);s=this._tiles[t.key],s&&s.hasData()&&(a=t);}let o=a;for(;o.overscaledZ>e;)if(o=o.scaledTo(o.overscaledZ-1),t[o.key]){n[a.key]=a;break}}}findLoadedParent(t,e){if(t.key in this._loadedParentTiles){const r=this._loadedParentTiles[t.key];return r&&r.tileID.overscaledZ>=e?r:null}for(let r=t.overscaledZ-1;r>=e;r--){const e=t.scaledTo(r),n=this._getLoadedTile(e);if(n)return n}}_getLoadedTile(t){const e=this._tiles[t.key];return e&&e.hasData()?e:this._cache.getByKey(this._source.reparseOverscaled?t.wrapped().key:t.canonical.key)}updateCacheSize(t,e){e=e||this._source.tileSize;const r=Math.ceil(t.width/e)+1,n=Math.ceil(t.height/e)+1,i=Math.floor(r*n*5),s="number"==typeof this._minTileCacheSize?Math.max(this._minTileCacheSize,i):i,a="number"==typeof this._maxTileCacheSize?Math.min(this._maxTileCacheSize,s):s;this._cache.setMaxSize(a);}handleWrapJump(t){const e=Math.round((t-(void 0===this._prevLng?t:this._prevLng))/360);if(this._prevLng=t,e){const t={};for(const r in this._tiles){const n=this._tiles[r];n.tileID=n.tileID.unwrapTo(n.tileID.wrap+e),t[n.tileID.key]=n;}this._tiles=t;for(const t in this._timers)clearTimeout(this._timers[t]),delete this._timers[t];for(const t in this._tiles)this._setTileReloadTimer(+t,this._tiles[t]);}}update(t,e,r){if(this.transform=t,!this._sourceLoaded||this._paused||this.transform.freezeTileCoverage)return;if(this.usedForTerrain&&!r)return;let n;this.updateCacheSize(t,e),"globe"!==this.transform.projection.name&&this.handleWrapJump(this.transform.center.lng),this._coveredTiles={},this.used||this.usedForTerrain?this._source.tileID?n=t.getVisibleUnwrappedCoordinates(this._source.tileID).map((t=>new fh(t.canonical.z,t.wrap,t.canonical.z,t.canonical.x,t.canonical.y))):(n=t.coveringTiles({tileSize:e||this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom&&!r,reparseOverscaled:this._source.reparseOverscaled,isTerrainDEM:this.usedForTerrain}),this._source.hasTile&&(n=n.filter((t=>this._source.hasTile(t))))):n=[];const i=this._updateRetainedTiles(n);if(ny(this._source.type)&&0!==n.length){const t={},e={},r=Object.keys(i);for(const n of r){const r=i[n],s=this._tiles[n];if(!s||s.fadeEndTime&&s.fadeEndTime<=Xt.now())continue;const a=this.findLoadedParent(r,Math.max(r.overscaledZ-ey.maxOverzooming,this._source.minzoom));a&&(this._addTile(a.tileID),t[a.tileID.key]=a.tileID),e[n]=r;}const s=n[n.length-1].overscaledZ;for(const t in this._tiles){const r=this._tiles[t];if(i[t]||!r.hasData())continue;let n=r.tileID;for(;n.overscaledZ>s;){n=n.scaledTo(n.overscaledZ-1);const s=this._tiles[n.key];if(s&&s.hasData()&&e[n.key]){i[t]=r.tileID;break}}}for(const e in t)i[e]||(this._coveredTiles[e]=!0,i[e]=t[e]);}for(const t in i)this._tiles[t].clearFadeHold();const s=function(t,e){const r=[];for(const n in t)n in e||r.push(n);return r}(this._tiles,i);for(const t of s){const e=this._tiles[t];e.hasSymbolBuckets&&!e.holdingForFade()?e.setHoldDuration(this.map._fadeDuration):e.hasSymbolBuckets&&!e.symbolFadeFinished()||this._removeTile(+t);}this._updateLoadedParentTileCache(),this._onlySymbols&&this._source.afterUpdate&&this._source.afterUpdate();}releaseSymbolFadeTiles(){for(const t in this._tiles)this._tiles[t].holdingForFade()&&this._removeTile(+t);}_updateRetainedTiles(t){const e={};if(0===t.length)return e;const r={},n=t.reduce(((t,e)=>Math.min(t,e.overscaledZ)),1/0),i=t[0].overscaledZ,s=Math.max(i-ey.maxOverzooming,this._source.minzoom),a=Math.max(i+ey.maxUnderzooming,this._source.minzoom),o={};for(const r of t){const t=this._addTile(r);e[r.key]=r,t.hasData()||n<this._source.maxzoom&&(o[r.key]=r);}this._retainLoadedChildren(o,n,a,e);for(const n of t){let t=this._tiles[n.key];if(t.hasData())continue;if(n.canonical.z>=this._source.maxzoom){const t=n.children(this._source.maxzoom)[0],r=this.getTile(t);if(r&&r.hasData()){e[t.key]=t;continue}}else {const t=n.children(this._source.maxzoom);if(e[t[0].key]&&e[t[1].key]&&e[t[2].key]&&e[t[3].key])continue}let i=t.wasRequested();for(let a=n.overscaledZ-1;a>=s;--a){const s=n.scaledTo(a);if(r[s.key])break;if(r[s.key]=!0,t=this.getTile(s),!t&&i&&(t=this._addTile(s)),t&&(e[s.key]=s,i=t.wasRequested(),t.hasData()))break}}return e}_updateLoadedParentTileCache(){this._loadedParentTiles={};for(const t in this._tiles){const e=[];let r,n=this._tiles[t].tileID;for(;n.overscaledZ>0;){if(n.key in this._loadedParentTiles){r=this._loadedParentTiles[n.key];break}e.push(n.key);const t=n.scaledTo(n.overscaledZ-1);if(r=this._getLoadedTile(t),r)break;n=t;}for(const t of e)this._loadedParentTiles[t]=r;}}_addTile(t){let e=this._tiles[t.key];if(e)return e;e=this._cache.getAndRemove(t),e&&(this._setTileReloadTimer(t.key,e),e.tileID=t,this._state.initializeTileState(e,this.map?this.map.painter:null),this._cacheTimers[t.key]&&(clearTimeout(this._cacheTimers[t.key]),delete this._cacheTimers[t.key],this._setTileReloadTimer(t.key,e)));const r=Boolean(e);if(!r){const r=this.map?this.map.painter:null;e=new Pf(t,this._source.tileSize*t.overscaleFactor(),this.transform.tileZoom,r,this._isRaster),this._loadTile(e,this._tileLoaded.bind(this,e,t.key,e.state));}return e?(e.uses++,this._tiles[t.key]=e,r||this._source.fire(new Yt("dataloading",{tile:e,coord:e.tileID,dataType:"source"})),e):null}_setTileReloadTimer(t,e){t in this._timers&&(clearTimeout(this._timers[t]),delete this._timers[t]);const r=e.getExpiryTimeout();r&&(this._timers[t]=setTimeout((()=>{this._reloadTile(t,"expired"),delete this._timers[t];}),r));}_removeTile(t){const e=this._tiles[t];e&&(e.uses--,delete this._tiles[t],this._timers[t]&&(clearTimeout(this._timers[t]),delete this._timers[t]),e.uses>0||(e.hasData()&&"reloading"!==e.state?this._cache.add(e.tileID,e,e.getExpiryTimeout()):(e.aborted=!0,this._abortTile(e),this._unloadTile(e))));}clearTiles(){this._shouldReloadOnResume=!1,this._paused=!1;for(const t in this._tiles)this._removeTile(+t);this._source._clear&&this._source._clear(),this._cache.reset(),this.map&&this.usedForTerrain&&this.map.painter.terrain&&this.map.painter.terrain.resetTileLookupCache(this.id);}tilesIn(t,e,r){const n=[],i=this.transform;if(!i)return n;const s="globe"===i.projection.name,a=Nl(i.center.lng);for(const o in this._tiles){const l=this._tiles[o];if(r&&l.clearQueryDebugViz(),l.holdingForFade())continue;let u;if(s){const t=l.tileID.canonical;if(0===t.z){const e=[Math.abs(M(a,...iy(t,-1))-a),Math.abs(M(a,...iy(t,1))-a)];u=[0,2*e.indexOf(Math.min(...e))-1];}else {const e=[Math.abs(M(a,...iy(t,-1))-a),Math.abs(M(a,...iy(t,0))-a),Math.abs(M(a,...iy(t,1))-a)];u=[e.indexOf(Math.min(...e))-1];}}else u=[0];for(const r of u){const s=t.containsTile(l,i,e,r);s&&n.push(s);}}return n}getVisibleCoordinates(t){const e=this.getRenderableIds(t).map((t=>this._tiles[t].tileID));for(const t of e)t.projMatrix=this.transform.calculateProjMatrix(t.toUnwrapped());return e}hasTransition(){if(this._source.hasTransition())return !0;if(ny(this._source.type))for(const t in this._tiles){const e=this._tiles[t];if(void 0!==e.fadeEndTime&&e.fadeEndTime>=Xt.now())return !0}return !1}setFeatureState(t,e,r){this._state.updateState(t=t||"_geojsonTileLayer",e,r);}removeFeatureState(t,e,r){this._state.removeFeatureState(t=t||"_geojsonTileLayer",e,r);}getFeatureState(t,e){return this._state.getState(t=t||"_geojsonTileLayer",e)}setDependencies(t,e,r){const n=this._tiles[t];n&&n.setDependencies(e,r);}reloadTilesForDependencies(t,e){for(const r in this._tiles)this._tiles[r].hasDependency(t,e)&&this._reloadTile(+r,"reloading");this._cache.filter((r=>!r.hasDependency(t,e)));}_preloadTiles(t,e){if(!this._sourceLoaded){const r=()=>{this._sourceLoaded&&(this._source.off("data",r),this._preloadTiles(t,e));};return void this._source.on("data",r)}const r=new Map,n=Array.isArray(t)?t:[t],i=this.map.painter.terrain,s=this.usedForTerrain&&i?i.getScaledDemTileSize():this._source.tileSize;for(const t of n){const e=t.coveringTiles({tileSize:s,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom&&!this.usedForTerrain,reparseOverscaled:this._source.reparseOverscaled,isTerrainDEM:this.usedForTerrain});for(const t of e)r.set(t.key,t);this.usedForTerrain&&t.updateElevation(!1);}B(Array.from(r.values()),((t,e)=>{const r=new Pf(t,this._source.tileSize*t.overscaleFactor(),this.transform.tileZoom,this.map.painter,this._isRaster);this._loadTile(r,(t=>{"raster-dem"===this._source.type&&r.dem&&this._backfillDEM(r),e(t,r);}));}),e);}}function ry(t,e){const r=Math.abs(2*t.wrap)-+(t.wrap<0),n=Math.abs(2*e.wrap)-+(e.wrap<0);return t.overscaledZ-e.overscaledZ||n-r||e.canonical.y-t.canonical.y||e.canonical.x-t.canonical.x}function ny(t){return "raster"===t||"image"===t||"video"===t||"custom"===t}function iy(t,e){const r=1<<t.z;return [t.x/r+e,(t.x+1)/r+e]}ey.maxOverzooming=10,ey.maxUnderzooming=3;class sy{constructor(t,e,r){this._demTile=t,this._dem=this._demTile.dem,this._scale=e,this._offset=r;}static create(t,e,r){const n=r||t.findDEMTileFor(e);if(!n||!n.dem)return;const i=n.dem,s=n.tileID,a=1<<e.canonical.z-s.canonical.z;return new sy(n,n.tileSize/ao/a,[(e.canonical.x/a-s.canonical.x)*i.dim,(e.canonical.y/a-s.canonical.y)*i.dim])}tileCoordToPixel(t,e){const r=e*this._scale+this._offset[1],n=Math.floor(t*this._scale+this._offset[0]),i=Math.floor(r);return new x(n,i)}getElevationAt(t,e,r,n){const i=t*this._scale+this._offset[0],s=e*this._scale+this._offset[1],a=Math.floor(i),o=Math.floor(s),l=this._dem;return n=!!n,r?Er(Er(l.get(a,o,n),l.get(a,o+1,n),s-o),Er(l.get(a+1,o,n),l.get(a+1,o+1,n),s-o),i-a):l.get(a,o,n)}getElevationAtPixel(t,e,r){return this._dem.get(t,e,!!r)}getMeterToDEM(t){return (1<<this._demTile.tileID.canonical.z)*Zl(1,t)*this._dem.stride}}class ay{constructor(t,e){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=new Ki(ao,16,0),this.featureIndexArray=new ba,this.promoteId=e;}insert(t,e,r,n,i,s=0){const a=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(r,n,i,s);const o=this.grid;for(let t=0;t<e.length;t++){const r=e[t],n=[1/0,1/0,-1/0,-1/0];for(let t=0;t<r.length;t++){const e=r[t];n[0]=Math.min(n[0],e.x),n[1]=Math.min(n[1],e.y),n[2]=Math.max(n[2],e.x),n[3]=Math.max(n[3],e.y);}n[0]<ao&&n[1]<ao&&n[2]>=0&&n[3]>=0&&o.insert(a,n[0],n[1],n[2],n[3]);}}loadVTLayers(){if(!this.vtLayers){this.vtLayers=new Zc(new mp(this.rawTileData)).layers,this.sourceLayerCoder=new wf(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"]),this.vtFeatures={};for(const t in this.vtLayers)this.vtFeatures[t]=[];}return this.vtLayers}query(t,e,r,n){this.loadVTLayers();const i=t.params||{},s=hi(i.filter),a=t.tileResult,o=t.transform,l=a.bufferedTilespaceBounds,u=this.grid.query(l.min.x,l.min.y,l.max.x,l.max.y,((t,e,r,n)=>wu(a.bufferedTilespaceGeometry,t,e,r,n)));u.sort(ly);let c=null;o.elevation&&u.length>0&&(c=sy.create(o.elevation,this.tileID));const h={};let p;for(let o=0;o<u.length;o++){const l=u[o];if(l===p)continue;p=l;const d=this.featureIndexArray.get(l);let f=null;this.loadMatchingFeature(h,d,s,i.layers,i.availableImages,e,r,n,((e,r,n,i=0)=>(f||(f=au(e,this.tileID.canonical,t.tileTransform)),r.queryIntersectsFeature(a,e,n,f,this.z,t.transform,t.pixelPosMatrix,c,i))));}return h}loadMatchingFeature(t,e,r,n,i,s,a,o,l){const{featureIndex:u,bucketIndex:c,sourceLayerIndex:h,layoutVertexArrayOffset:p}=e,d=this.bucketLayerIDs[c];if(n&&!function(t,e){for(let r=0;r<t.length;r++)if(e.indexOf(t[r])>=0)return !0;return !1}(n,d))return;const f=this.sourceLayerCoder.decode(h),y=this.vtLayers[f].feature(u);if(r.needGeometry){const t=ou(y,!0);if(!r.filter(new ws(this.tileID.overscaledZ),t,this.tileID.canonical))return}else if(!r.filter(new ws(this.tileID.overscaledZ),y))return;const m=this.getId(y,f);for(let e=0;e<d.length;e++){const r=d[e];if(n&&n.indexOf(r)<0)continue;const c=s[r];if(!c)continue;let h={};void 0!==m&&o&&(h=o.getState(c.sourceLayer||"_geojsonTileLayer",m));const f=C({},a[r]);f.paint=oy(f.paint,c.paint,y,h,i),f.layout=oy(f.layout,c.layout,y,h,i);const g=!l||l(y,c,h,p);if(!g)continue;const x=new Af(y,this.z,this.x,this.y,m);x.layer=f;let v=t[r];void 0===v&&(v=t[r]=[]),v.push({featureIndex:u,feature:x,intersectionZ:g});}}lookupSymbolFeatures(t,e,r,n,i,s,a,o){const l={};this.loadVTLayers();const u=hi(i);for(const i of t)this.loadMatchingFeature(l,{bucketIndex:r,sourceLayerIndex:n,featureIndex:i,layoutVertexArrayOffset:0},u,s,a,o,e);return l}loadFeature(t){const{featureIndex:e,sourceLayerIndex:r}=t;this.loadVTLayers();const n=this.sourceLayerCoder.decode(r),i=this.vtFeatures[n];if(i[e])return i[e];const s=this.vtLayers[n].feature(e);return i[e]=s,s}hasLayer(t){for(const e of this.bucketLayerIDs)for(const r of e)if(t===r)return !0;return !1}getId(t,e){let r=t.id;if(this.promoteId){const n="string"==typeof this.promoteId?this.promoteId:this.promoteId[e];null!=n&&(r=t.properties[n]),"boolean"==typeof r&&(r=Number(r));}return r}}function oy(t,e,r,n,i){return $(t,((t,s)=>{const a=e instanceof zs?e.get(s):null;return a&&a.evaluate?a.evaluate(r,n,i):a}))}function ly(t,e){return e-t}Ji(ay,"FeatureIndex",{omit:["rawTileData","sourceLayerCoder"]});class uy{constructor(t,e){this.width=t,this.height=e,this.nextRow=0,this.image=new Ru({width:t,height:e}),this.positions={},this.uploaded=!1;}getDash(t,e){const r=this.getKey(t,e);return this.positions[r]}trim(){const t=this.width,e=this.height=L(this.nextRow);this.image.resize({width:t,height:e});}getKey(t,e){return t.join(",")+e}getDashRanges(t,e,r){const n=[];let i=t.length%2==1?-t[t.length-1]*r:0,s=t[0]*r,a=!0;n.push({left:i,right:s,isDash:a,zeroLength:0===t[0]});let o=t[0];for(let e=1;e<t.length;e++){a=!a;const l=t[e];i=o*r,o+=l,s=o*r,n.push({left:i,right:s,isDash:a,zeroLength:0===l});}return n}addRoundDash(t,e,r){const n=e/2;for(let e=-r;e<=r;e++){const i=this.width*(this.nextRow+r+e);let s=0,a=t[s];for(let o=0;o<this.width;o++){o/a.right>1&&(a=t[++s]);const l=Math.abs(o-a.left),u=Math.abs(o-a.right),c=Math.min(l,u);let h;const p=e/r*(n+1);if(a.isDash){const t=n-Math.abs(p);h=Math.sqrt(c*c+t*t);}else h=n-Math.sqrt(c*c+p*p);this.image.data[i+o]=Math.max(0,Math.min(255,h+128));}}}addRegularDash(t,e){for(let e=t.length-1;e>=0;--e){const r=t[e],n=t[e+1];r.zeroLength?t.splice(e,1):n&&n.isDash===r.isDash&&(n.left=r.left,t.splice(e,1));}const r=t[0],n=t[t.length-1];r.isDash===n.isDash&&(r.left=n.left-this.width,n.right=r.right+this.width);const i=this.width*this.nextRow;let s=0,a=t[s];for(let r=0;r<this.width;r++){r/a.right>1&&(a=t[++s]);const n=Math.abs(r-a.left),o=Math.abs(r-a.right),l=Math.min(n,o);this.image.data[i+r]=Math.max(0,Math.min(255,(a.isDash?l:-l)+e+128));}}addDash(t,e){const r=this.getKey(t,e);if(this.positions[r])return this.positions[r];const n="round"===e,i=n?7:0,s=2*i+1;if(this.nextRow+s>this.height)return N("LineAtlas out of space"),null;0===t.length&&t.push(1);let a=0;for(let e=0;e<t.length;e++)t[e]<0&&(N("Negative value is found in line dasharray, replacing values with 0"),t[e]=0),a+=t[e];if(0!==a){const r=this.width/a,s=this.getDashRanges(t,this.width,r);n?this.addRoundDash(s,r,i):this.addRegularDash(s,"square"===e?.5*r:0);}const o=this.nextRow+i;this.nextRow+=s;const l={tl:[o,i],br:[a,0]};return this.positions[r]=l,l}}Ji(uy,"LineAtlas");const cy=1*td;class hy{constructor(t){const e={},r=[];for(const n in t){const i=t[n],s=e[n]={};for(const t in i.glyphs){const e=i.glyphs[+t];if(!e||0===e.bitmap.width||0===e.bitmap.height)continue;const n=e.metrics.localGlyph?cy:1,a={x:0,y:0,w:e.bitmap.width+2*n,h:e.bitmap.height+2*n};r.push(a),s[t]=a;}}const{w:n,h:i}=_p(r),s=new Ru({width:n||1,height:i||1});for(const r in t){const n=t[r];for(const t in n.glyphs){const i=n.glyphs[+t];if(!i||0===i.bitmap.width||0===i.bitmap.height)continue;const a=e[r][t],o=i.metrics.localGlyph?cy:1;Ru.copy(i.bitmap,s,{x:0,y:0},{x:a.x+o,y:a.y+o},i.bitmap);}}this.image=s,this.positions=e;}}Ji(hy,"GlyphAtlas");class py{constructor(t){this.tileID=new fh(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.tileZoom=t.tileZoom,this.uid=t.uid,this.zoom=t.zoom,this.canonical=t.tileID.canonical,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.returnDependencies=!!t.returnDependencies,this.promoteId=t.promoteId,this.enableTerrain=!!t.enableTerrain,this.isSymbolTile=t.isSymbolTile,this.tileTransform=Bd(t.tileID.canonical,t.projection),this.projection=t.projection;}parse(t,e,r,n,i){this.status="parsing",this.data=t,this.collisionBoxArray=new pa;const s=new wf(Object.keys(t.layers).sort()),a=new ay(this.tileID,this.promoteId);a.bucketLayerIDs=[];const o={},l=new uy(256,256),u={featureIndex:a,iconDependencies:{},patternDependencies:{},glyphDependencies:{},lineAtlas:l,availableImages:r},c=e.familiesBySource[this.source];for(const e in c){const n=t.layers[e];if(!n)continue;let i=!1,l=!1;for(const t of c[e])"symbol"===t[0].type?i=!0:l=!0;if(!0===this.isSymbolTile&&!i)continue;if(!1===this.isSymbolTile&&!l)continue;1===n.version&&N(`Vector tile source "${this.source}" layer "${e}" does not use vector tile spec v2 and therefore may have some rendering errors.`);const h=s.encode(e),p=[];for(let t=0;t<n.length;t++){const r=n.feature(t),i=a.getId(r,e);p.push({feature:r,id:i,index:t,sourceLayerIndex:h});}for(const t of c[e]){const e=t[0];void 0!==this.isSymbolTile&&"symbol"===e.type!==this.isSymbolTile||e.minzoom&&this.zoom<Math.floor(e.minzoom)||e.maxzoom&&this.zoom>=e.maxzoom||"none"!==e.visibility&&(dy(t,this.zoom,r),(o[e.id]=e.createBucket({index:a.bucketLayerIDs.length,layers:t,zoom:this.zoom,canonical:this.canonical,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:h,sourceID:this.source,enableTerrain:this.enableTerrain,projection:this.projection.spec,availableImages:r})).populate(p,u,this.tileID.canonical,this.tileTransform),a.bucketLayerIDs.push(t.map((t=>t.id))));}}let h,p,d,f;l.trim();const y={type:"maybePrepare",isSymbolTile:this.isSymbolTile,zoom:this.zoom},m=()=>{if(h)return i(h);if(p&&d&&f){const t=new hy(p),e=new kp(d,f);for(const n in o){const i=o[n];i instanceof of?(dy(i.layers,this.zoom,r),vd(i,p,t.positions,d,e.iconPositions,this.showCollisionBoxes,r,this.tileID.canonical,this.tileZoom,this.projection)):i.hasPattern&&(i instanceof Ih||i instanceof Mc||i instanceof th)&&(dy(i.layers,this.zoom,r),i.addFeatures(u,this.tileID.canonical,e.patternPositions,r,this.tileTransform));}this.status="done",i(null,{buckets:E(o).filter((t=>!t.isEmpty())),featureIndex:a,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:t.image,lineAtlas:l,imageAtlas:e,glyphMap:this.returnDependencies?p:null,iconMap:this.returnDependencies?d:null,glyphPositions:this.returnDependencies?t.positions:null});}},g=$(u.glyphDependencies,(t=>Object.keys(t).map(Number)));Object.keys(g).length?n.send("getGlyphs",{uid:this.uid,stacks:g},((t,e)=>{h||(h=t,p=e,m());}),void 0,!1,y):p={};const x=Object.keys(u.iconDependencies);x.length?n.send("getImages",{icons:x,source:this.source,tileID:this.tileID,type:"icons"},((t,e)=>{h||(h=t,d=e,m());}),void 0,!1,y):d={};const v=Object.keys(u.patternDependencies);v.length?n.send("getImages",{icons:v,source:this.source,tileID:this.tileID,type:"patterns"},((t,e)=>{h||(h=t,f=e,m());}),void 0,!1,y):f={},m();}}function dy(t,e,r){const n=new ws(e);for(const e of t)e.recalculate(n,r);}class fy{constructor(t){this.entries={},this.scheduler=t;}request(t,e,r,n){const i=this.entries[t]=this.entries[t]||{callbacks:[]};if(i.result){const[t,r]=i.result;return this.scheduler?this.scheduler.add((()=>{n(t,r);}),e):n(t,r),()=>{}}return i.callbacks.push(n),i.cancel||(i.cancel=r(((r,n)=>{i.result=[r,n];for(const t of i.callbacks)this.scheduler?this.scheduler.add((()=>{t(r,n);}),e):t(r,n);setTimeout((()=>delete this.entries[t]),3e3);}))),()=>{i.result||(i.callbacks=i.callbacks.filter((t=>t!==n)),i.callbacks.length||(i.cancel(),delete this.entries[t]));}}}function yy(t,e,r){const n=JSON.stringify(t.request);return t.data&&(this.deduped.entries[n]={result:[null,t.data]}),this.deduped.request(n,{type:"parseTile",isSymbolTile:t.isSymbolTile,zoom:t.tileZoom},(e=>{const n=pt(t.request,((t,n,i,s)=>{t?e(t):n&&e(null,{vectorTile:r?void 0:new Zc(new mp(n)),rawData:n,cacheControl:i,expires:s});}));return ()=>{n.cancel(),e();}}),e)}const my=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class gy{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,r]=new Uint8Array(t,0,2);if(219!==e)throw new Error("Data does not appear to be in a KDBush format.");const n=r>>4;if(1!==n)throw new Error(`Got v${n} data when expected v1.`);const i=my[15&r];if(!i)throw new Error("Unrecognized array type.");const[s]=new Uint16Array(t,2,1),[a]=new Uint32Array(t,4,1);return new gy(a,s,i,t)}constructor(t,e=64,r=Float64Array,n){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=r,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const i=my.indexOf(this.ArrayType),s=2*t*this.ArrayType.BYTES_PER_ELEMENT,a=t*this.IndexArrayType.BYTES_PER_ELEMENT,o=(8-a%8)%8;if(i<0)throw new Error(`Unexpected typed array class: ${r}.`);n&&n instanceof ArrayBuffer?(this.data=n,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+o,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+s+a+o),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+o,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+i]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t);}add(t,e){const r=this._pos>>1;return this.ids[r]=r,this.coords[this._pos++]=t,this.coords[this._pos++]=e,r}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return xy(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,r,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:s,nodeSize:a}=this,o=[0,i.length-1,0],l=[];for(;o.length;){const u=o.pop()||0,c=o.pop()||0,h=o.pop()||0;if(c-h<=a){for(let a=h;a<=c;a++){const o=s[2*a],u=s[2*a+1];o>=t&&o<=r&&u>=e&&u<=n&&l.push(i[a]);}continue}const p=h+c>>1,d=s[2*p],f=s[2*p+1];d>=t&&d<=r&&f>=e&&f<=n&&l.push(i[p]),(0===u?t<=d:e<=f)&&(o.push(h),o.push(p-1),o.push(1-u)),(0===u?r>=d:n>=f)&&(o.push(p+1),o.push(c),o.push(1-u));}return l}within(t,e,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:n,coords:i,nodeSize:s}=this,a=[0,n.length-1,0],o=[],l=r*r;for(;a.length;){const u=a.pop()||0,c=a.pop()||0,h=a.pop()||0;if(c-h<=s){for(let r=h;r<=c;r++)_y(i[2*r],i[2*r+1],t,e)<=l&&o.push(n[r]);continue}const p=h+c>>1,d=i[2*p],f=i[2*p+1];_y(d,f,t,e)<=l&&o.push(n[p]),(0===u?t-r<=d:e-r<=f)&&(a.push(h),a.push(p-1),a.push(1-u)),(0===u?t+r>=d:e+r>=f)&&(a.push(p+1),a.push(c),a.push(1-u));}return o}}function xy(t,e,r,n,i,s){if(i-n<=r)return;const a=n+i>>1;vy(t,e,a,n,i,s),xy(t,e,r,n,a-1,1-s),xy(t,e,r,a+1,i,1-s);}function vy(t,e,r,n,i,s){for(;i>n;){if(i-n>600){const a=i-n+1,o=r-n+1,l=Math.log(a),u=.5*Math.exp(2*l/3),c=.5*Math.sqrt(l*u*(a-u)/a)*(o-a/2<0?-1:1);vy(t,e,r,Math.max(n,Math.floor(r-o*u/a+c)),Math.min(i,Math.floor(r+(a-o)*u/a+c)),s);}const a=e[2*r+s];let o=n,l=i;for(by(t,e,n,r),e[2*i+s]>a&&by(t,e,n,i);o<l;){for(by(t,e,o,l),o++,l--;e[2*o+s]<a;)o++;for(;e[2*l+s]>a;)l--;}e[2*n+s]===a?by(t,e,n,l):(l++,by(t,e,l,i)),l<=r&&(n=l+1),r<=l&&(i=l-1);}}function by(t,e,r,n){wy(t,r,n),wy(e,2*r,2*n),wy(e,2*r+1,2*n+1);}function wy(t,e,r){const n=t[e];t[e]=t[r],t[r]=n;}function _y(t,e,r,n){const i=t-r,s=e-n;return i*i+s*s}t.ARRAY_TYPE=uo,t.AUTH_ERR_MSG=xt,t.Aabb=il,t.Actor=class{constructor(t,r,n){this.target=t,this.parent=r,this.mapId=n,this.callbacks={},this.cancelCallbacks={},R(["receive"],this),this.target.addEventListener("message",this.receive,!1),this.globalScope=K()?t:e,this.scheduler=new bf;}send(t,e,r,n,i=!1,s){const a=Math.round(1e18*Math.random()).toString(36).substring(0,10);r&&(r.metadata=s,this.callbacks[a]=r);const o=H(this.globalScope)?void 0:[];return this.target.postMessage({id:a,type:t,hasCallback:!!r,targetMapId:n,mustQueue:i,sourceMapId:this.mapId,data:Wi(e,o)},o),{cancel:()=>{r&&delete this.callbacks[a],this.target.postMessage({id:a,type:"<cancel>",targetMapId:n,sourceMapId:this.mapId});}}}receive(t){const e=t.data,r=e.id;if(r&&(!e.targetMapId||this.mapId===e.targetMapId))if("<cancel>"===e.type){const t=this.cancelCallbacks[r];delete this.cancelCallbacks[r],t&&t.cancel();}else if(e.mustQueue||K()){const t=this.callbacks[r];this.cancelCallbacks[r]=this.scheduler.add((()=>this.processTask(r,e)),t&&t.metadata||{type:"message"});}else this.processTask(r,e);}processTask(t,e){if("<response>"===e.type){const r=this.callbacks[t];delete this.callbacks[t],r&&(e.error?r(Qi(e.error)):r(null,Qi(e.data)));}else {const r=H(this.globalScope)?void 0:[],n=e.hasCallback?(e,n)=>{delete this.cancelCallbacks[t],this.target.postMessage({id:t,type:"<response>",sourceMapId:this.mapId,error:e?Wi(e):null,data:Wi(n,r)},r);}:t=>{},i=Qi(e.data);if(this.parent[e.type])this.parent[e.type](e.sourceMapId,i,n);else if(this.parent.getWorkerSource){const t=e.type.split(".");this.parent.getWorkerSource(e.sourceMapId,t[0],i.source)[t[1]](i,n);}else n(new Error(`Could not find function ${e.type}`));}}remove(){this.scheduler.remove(),this.target.removeEventListener("message",this.receive,!1);}},t.CanonicalTileID=ph,t.Color=Ee,t.ColorMode=Yf,t.CullFaceMode=ty,t.DEMData=Zf,t.DataConstantProperty=Bs,t.DedupedRequest=fy,t.DepthMode=Xf,t.EXTENT=ao,t.Elevation=class{isDataAvailableAtPoint(t){const e=this._source();if(this.isUsingMockSource()||!e||t.y<0||t.y>1)return !1;const r=e.getSource().maxzoom,n=1<<r,i=Math.floor(t.x),s=Math.floor((t.x-i)*n),a=Math.floor(t.y*n),o=this.findDEMTileFor(new fh(r,i,r,s,a));return !(!o||!o.dem)}getAtPointOrZero(t,e=0){return this.getAtPoint(t,e)||0}getAtPoint(t,e,r=!0){if(this.isUsingMockSource())return null;null==e&&(e=null);const n=this._source();if(!n)return e;if(t.y<0||t.y>1)return e;const i=n.getSource().maxzoom,s=1<<i,a=Math.floor(t.x),o=t.x-a,l=new fh(i,a,i,Math.floor(o*s),Math.floor(t.y*s)),u=this.findDEMTileFor(l);if(!u||!u.dem)return e;const c=u.dem,h=1<<u.tileID.canonical.z,p=(o*h-u.tileID.canonical.x)*c.dim,d=(t.y*h-u.tileID.canonical.y)*c.dim,f=Math.floor(p),y=Math.floor(d);return (r?this.exaggeration():1)*Er(Er(c.get(f,y),c.get(f,y+1),d-y),Er(c.get(f+1,y),c.get(f+1,y+1),d-y),p-f)}getAtTileOffset(t,e,r){const n=1<<t.canonical.z;return this.getAtPointOrZero(new Wl(t.wrap+(t.canonical.x+e/ao)/n,(t.canonical.y+r/ao)/n))}getAtTileOffsetFunc(t,e,r,n){return i=>{const s=this.getAtTileOffset(t,i.x,i.y),a=n.upVector(t.canonical,i.x,i.y);return Co(a,a,s*n.upVectorScale(t.canonical,e,r).metersToTile),a}}getForTilePoints(t,e,r,n){if(this.isUsingMockSource())return !1;const i=sy.create(this,t,n);return !!i&&(e.forEach((t=>{t[2]=this.exaggeration()*i.getElevationAt(t[0],t[1],r);})),!0)}getMinMaxForTile(t){if(this.isUsingMockSource())return null;const e=this.findDEMTileFor(t);if(!e||!e.dem)return null;const r=e.dem.tree,n=e.tileID,i=1<<t.canonical.z-n.canonical.z;let s=t.canonical.x/i-n.canonical.x,a=t.canonical.y/i-n.canonical.y,o=0;for(let e=0;e<t.canonical.z-n.canonical.z&&!r.leaves[o];e++){s*=2,a*=2;const t=2*Math.floor(a)+Math.floor(s);o=r.childOffsets[o]+t,s%=1,a%=1;}return {min:this.exaggeration()*r.minimums[o],max:this.exaggeration()*r.maximums[o]}}getMinElevationBelowMSL(){throw new Error("Pure virtual method called.")}raycast(t,e,r){throw new Error("Pure virtual method called.")}pointCoordinate(t){throw new Error("Pure virtual method called.")}_source(){throw new Error("Pure virtual method called.")}isUsingMockSource(){throw new Error("Pure virtual method called.")}exaggeration(){throw new Error("Pure virtual method called.")}findDEMTileFor(t){throw new Error("Pure virtual method called.")}get visibleDemTiles(){throw new Error("Getter must be implemented in subclass.")}},t.ErrorEvent=Wt,t.EvaluationParameters=ws,t.Event=Yt,t.Evented=Qt,t.FillExtrusionBucket=th,t.Frustum=nl,t.FrustumCorners=rl,t.GLOBE_RADIUS=ol,t.GLOBE_SCALE_MATCH_LATITUDE=45,t.GLOBE_ZOOM_THRESHOLD_MAX=al,t.GLOBE_ZOOM_THRESHOLD_MIN=sl,t.GlobeSharedBuffers=class{constructor(t){this._createGrid(t),this._createPoles(t);}destroy(){this._poleIndexBuffer.destroy(),this._gridBuffer.destroy(),this._gridIndexBuffer.destroy(),this._poleNorthVertexBuffer.destroy(),this._poleSouthVertexBuffer.destroy();for(const t of this._poleSegments)t.destroy();for(const t of this._gridSegments)t.withSkirts.destroy(),t.withoutSkirts.destroy();if(this._wireframeIndexBuffer){this._wireframeIndexBuffer.destroy();for(const t of this._wireframeSegments)t.destroy();}}_fillGridMeshWithLods(t,e){const r=new $s,n=new ra,i=[],s=t+1+2,a=e[0]+1,o=e[0]+1+(1+e.length),l=(t,e,r)=>{let n=t===s-1?t-2:0===t?t:t-1;return n+=r?24575:0,[n,e]};for(let t=0;t<s;++t)r.emplaceBack(...l(t,0,!0));for(let t=0;t<a;++t)for(let e=0;e<s;++e)r.emplaceBack(...l(e,t,(0===e||e===s-1)&&!0));for(let t=0;t<e.length;++t){const n=e[t];for(let t=0;t<s;++t)r.emplaceBack(...l(t,n,!0));}for(let t=0;t<e.length;++t){const a=n.length,l=e[t]+1+2,u=new ra;for(let r=0;r<l-1;r++){const i=r===l-2,a=i?s*(o-e.length+t-r):s;for(let t=0;t<s-1;t++){const e=r*s+t;0===r||i||0===t||t===s-2?(u.emplaceBack(e+1,e,e+a),u.emplaceBack(e+a,e+a+1,e+1)):(n.emplaceBack(e+1,e,e+a),n.emplaceBack(e+a,e+a+1,e+1));}}const c=so.simpleSegment(0,a,r.length,n.length-a);for(let t=0;t<u.uint16.length;t+=3)n.emplaceBack(u.uint16[t],u.uint16[t+1],u.uint16[t+2]);const h=so.simpleSegment(0,a,r.length,n.length-a);i.push({withoutSkirts:c,withSkirts:h});}return {vertices:r,indices:n,segments:i}}_createGrid(t){const e=this._fillGridMeshWithLods(ul,cl);this._gridSegments=e.segments,this._gridBuffer=t.createVertexBuffer(e.vertices,tl.members),this._gridIndexBuffer=t.createIndexBuffer(e.indices,!0);}_createPoles(t){const e=new ra;for(let t=0;t<=ul;t++)e.emplaceBack(0,t+1,t+2);this._poleIndexBuffer=t.createIndexBuffer(e,!0);const r=new aa,n=new aa;this._poleSegments=[];for(let t=0,e=0;t<sl;t++){const i=360/(1<<t);r.emplaceBack(0,-ol,0,.5,0),n.emplaceBack(0,-ol,0,.5,1);for(let t=0;t<=ul;t++){const e=t/ul,s=Er(0,i,e),[a,o,l]=kl(Fl,Rl,s,ol);r.emplaceBack(a,o,l,e,0),n.emplaceBack(a,o,l,e,1);}this._poleSegments.push(so.simpleSegment(e,0,66,64)),e+=66;}this._poleNorthVertexBuffer=t.createVertexBuffer(r,Wo,!1),this._poleSouthVertexBuffer=t.createVertexBuffer(n,Wo,!1);}getGridBuffers(t,e){return [this._gridBuffer,this._gridIndexBuffer,e?this._gridSegments[t].withSkirts:this._gridSegments[t].withoutSkirts]}getPoleBuffers(t){return [this._poleNorthVertexBuffer,this._poleSouthVertexBuffer,this._poleIndexBuffer,this._poleSegments[t]]}getWirefameBuffers(t,e){if(!this._wireframeSegments){const e=new la,r=ul,n=r+1+2,i=1;this._wireframeSegments=[];for(let t=0,s=0;t<cl.length;t++){const a=cl[t];for(let t=i;t<a+i;t++)for(let s=i;s<r+i;s++){const r=t*n+s;e.emplaceBack(r,r+1),e.emplaceBack(r,r+n),e.emplaceBack(r,r+n+1);}const o=a*r*3;this._wireframeSegments.push(so.simpleSegment(0,s,(a+1)*n,o)),s+=o;}this._wireframeIndexBuffer=t.createIndexBuffer(e);}return [this._gridBuffer,this._wireframeIndexBuffer,this._wireframeSegments[e]]}},t.GlyphManager=rd,t.ImagePosition=Sp,t.KDBush=gy,t.LivePerformanceUtils=$t,t.LngLat=Ol,t.LngLatBounds=oo,t.LocalGlyphMode=ed,t.MAX_MERCATOR_LATITUDE=Hl,t.MercatorCoordinate=Wl,t.ONE_EM=Rh,t.OverscaledTileID=fh,t.PerformanceMarkers=Ut,t.Point=x,t.Properties=Ps,t.RGBAImage=Uu,t.Ray=el,t.RequestManager=class{constructor(t,e,r){this._transformRequestFn=t,this._customAccessToken=e,this._silenceAuthErrors=!!r,this._createSkuToken();}_createSkuToken(){const t=function(){let t="";for(let e=0;e<10;e++)t+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62*Math.random())];return {token:["1",h,t].join(""),tokenExpiresAt:Date.now()+432e5}}();this._skuToken=t.token,this._skuTokenExpiresAt=t.tokenExpiresAt;}_isSkuTokenExpired(){return Date.now()>this._skuTokenExpiresAt}transformRequest(t,e){return this._transformRequestFn&&this._transformRequestFn(t,e)||{url:t}}normalizeStyleURL(t,e){if(!vt(t))return t;const r=kt(t);return r.path=`/styles/v1${r.path}`,this._makeAPIURL(r,this._customAccessToken||e)}normalizeGlyphsURL(t,e){if(!vt(t))return t;const r=kt(t);return r.path=`/fonts/v1${r.path}`,this._makeAPIURL(r,this._customAccessToken||e)}normalizeSourceURL(t,e,r,n){if(!vt(t))return t;const i=kt(t);return i.path=`/v4/${i.authority}.json`,i.params.push("secure"),r&&i.params.push(`language=${r}`),n&&i.params.push(`worldview=${n}`),this._makeAPIURL(i,this._customAccessToken||e)}normalizeSpriteURL(t,e,r,n){const i=kt(t);return vt(t)?(i.path=`/styles/v1${i.path}/sprite${e}${r}`,this._makeAPIURL(i,this._customAccessToken||n)):(i.path+=`${e}${r}`,It(i))}normalizeTileURL(t,e,r){if(this._isSkuTokenExpired()&&this._createSkuToken(),t&&!vt(t))return t;const n=kt(t);n.path=n.path.replace(/(\.(png|jpg)\d*)(?=$)/,`${e||r&&"raster"!==n.authority&&512===r?"@2x":""}${s.supported?".webp":"$1"}`),"raster"===n.authority?n.path=`/${i.RASTER_URL_PREFIX}${n.path}`:(n.path=n.path.replace(/^.+\/v4\//,"/"),n.path=`/${i.TILE_URL_VERSION}${n.path}`);const a=this._customAccessToken||function(t){for(const e of t){const t=e.match(/^access_token=(.*)$/);if(t)return t[1]}return null}(n.params)||i.ACCESS_TOKEN;return i.REQUIRE_ACCESS_TOKEN&&a&&this._skuToken&&n.params.push(`sku=${this._skuToken}`),this._makeAPIURL(n,a)}canonicalizeTileURL(t,e){const r=kt(t);if(!r.path.match(/^(\/v4\/|\/raster\/v1\/)/)||!r.path.match(/\.[\w]+$/))return t;let n="mapbox://";r.path.match(/^\/raster\/v1\//)?n+=`raster/${r.path.replace(`/${i.RASTER_URL_PREFIX}/`,"")}`:n+=`tiles/${r.path.replace(`/${i.TILE_URL_VERSION}/`,"")}`;let s=r.params;return e&&(s=s.filter((t=>!t.match(/^access_token=/)))),s.length&&(n+=`?${s.join("&")}`),n}canonicalizeTileset(t,e){const r=!!e&&vt(e),n=[];for(const e of t.tiles||[])bt(e)?n.push(this.canonicalizeTileURL(e,r)):n.push(e);return n}_makeAPIURL(t,e){const r="See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",n=kt(i.API_URL);if(t.protocol=n.protocol,t.authority=n.authority,"http"===t.protocol){const e=t.params.indexOf("secure");e>=0&&t.params.splice(e,1);}if("/"!==n.path&&(t.path=`${n.path}${t.path}`),!i.REQUIRE_ACCESS_TOKEN)return It(t);if(e=e||i.ACCESS_TOKEN,!this._silenceAuthErrors){if(!e)throw new Error(`An API access token is required to use Mapbox GL. ${r}`);if("s"===e[0])throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`)}return t.params=t.params.filter((t=>-1===t.indexOf("access_token"))),t.params.push(`access_token=${e||""}`),It(t)}},t.ResourceType=lt,t.SegmentVector=so,t.SourceCache=ey,t.StencilMode=Hf,t.StructArrayLayout1ui2=ua,t.StructArrayLayout2f1f2i16=Qs,t.StructArrayLayout2i4=$s,t.StructArrayLayout2ui4=la,t.StructArrayLayout3f12=ea,t.StructArrayLayout3ui6=ra,t.StructArrayLayout4i8=Os,t.StructArrayLayout5f20=aa,t.Texture=xf,t.Tile=Pf,t.Transitionable=Ss,t.Uniform1f=La,t.Uniform1i=class extends Va{constructor(t){super(t),this.current=0;}set(t,e,r){this.fetchUniformLocation(t,e)&&this.current!==r&&(this.current=r,this.gl.uniform1i(this.location,r));}},t.Uniform2f=class extends Va{constructor(t){super(t),this.current=[0,0];}set(t,e,r){this.fetchUniformLocation(t,e)&&(r[0]===this.current[0]&&r[1]===this.current[1]||(this.current=r,this.gl.uniform2f(this.location,r[0],r[1])));}},t.Uniform3f=class extends Va{constructor(t){super(t),this.current=[0,0,0];}set(t,e,r){this.fetchUniformLocation(t,e)&&(r[0]===this.current[0]&&r[1]===this.current[1]&&r[2]===this.current[2]||(this.current=r,this.gl.uniform3f(this.location,r[0],r[1],r[2])));}},t.Uniform4f=Fa,t.UniformColor=Ra,t.UniformMatrix2f=class extends Va{constructor(t){super(t),this.current=ja;}set(t,e,r){if(this.fetchUniformLocation(t,e))for(let t=0;t<4;t++)if(r[t]!==this.current[t]){this.current=r,this.gl.uniformMatrix2fv(this.location,!1,r);break}}},t.UniformMatrix3f=class extends Va{constructor(t){super(t),this.current=$a;}set(t,e,r){if(this.fetchUniformLocation(t,e))for(let t=0;t<9;t++)if(r[t]!==this.current[t]){this.current=r,this.gl.uniformMatrix3fv(this.location,!1,r);break}}},t.UniformMatrix4f=class extends Va{constructor(t){super(t),this.current=Ua;}set(t,e,r){if(this.fetchUniformLocation(t,e)){if(r[12]!==this.current[12]||r[0]!==this.current[0])return this.current=r,void this.gl.uniformMatrix4fv(this.location,!1,r);for(let t=1;t<16;t++)if(r[t]!==this.current[t]){this.current=r,this.gl.uniformMatrix4fv(this.location,!1,r);break}}}},t.UnwrappedTileID=dh,t.ValidationError=ri,t.VectorTileFeature=Kc,t.VectorTileWorkerSource=class extends Qt{constructor(t,e,r,n,i){super(),this.actor=t,this.layerIndex=e,this.availableImages=r,this.loadVectorData=i||yy,this.loading={},this.loaded={},this.deduped=new fy(t.scheduler),this.isSpriteLoaded=n,this.scheduler=t.scheduler;}loadTile(t,e){const r=t.uid,n=t&&t.request,i=n&&n.collectResourceTiming,s=this.loading[r]=new py(t);s.abort=this.loadVectorData(t,((a,o)=>{const l=!this.loading[r];if(delete this.loading[r],l||a||!o)return s.status="done",l||(this.loaded[r]=s),e(a);const u=o.rawData,c={};o.expires&&(c.expires=o.expires),o.cacheControl&&(c.cacheControl=o.cacheControl),s.vectorTile=o.vectorTile||new Zc(new mp(u));const h=()=>{s.parse(s.vectorTile,this.layerIndex,this.availableImages,this.actor,((t,r)=>{if(t||!r)return e(t);const s={};if(i){const t=qt(n);t.length>0&&(s.resourceTiming=JSON.parse(JSON.stringify(t)));}e(null,C({rawTileData:u.slice(0)},r,c,s));}));};this.isSpriteLoaded?h():this.once("isSpriteLoaded",(()=>{this.scheduler?this.scheduler.add(h,{type:"parseTile",isSymbolTile:t.isSymbolTile,zoom:t.tileZoom}):h();})),this.loaded=this.loaded||{},this.loaded[r]=s;}));}reloadTile(t,e){const r=this.loaded,n=t.uid,i=this;if(r&&r[n]){const s=r[n];s.showCollisionBoxes=t.showCollisionBoxes,s.enableTerrain=!!t.enableTerrain,s.projection=t.projection,s.tileTransform=Bd(t.tileID.canonical,t.projection);const a=(t,r)=>{const n=s.reloadCallback;n&&(delete s.reloadCallback,s.parse(s.vectorTile,i.layerIndex,this.availableImages,i.actor,n)),e(t,r);};"parsing"===s.status?s.reloadCallback=a:"done"===s.status&&(s.vectorTile?s.parse(s.vectorTile,this.layerIndex,this.availableImages,this.actor,a):a());}}abortTile(t,e){const r=t.uid,n=this.loading[r];n&&(n.abort&&n.abort(),delete this.loading[r]),e();}removeTile(t,e){const r=this.loaded,n=t.uid;r&&r[n]&&delete r[n],e();}},t.WritingMode=Ip,t.ZoomDependentExpression=Wn,t.add=Mo,t.addDynamicAttributes=rf,t.adjoint=function(t,e){var r=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8];return t[0]=a*c-o*u,t[1]=i*u-n*c,t[2]=n*o-i*a,t[3]=o*l-s*c,t[4]=r*c-i*l,t[5]=i*s-r*o,t[6]=s*u-a*l,t[7]=n*l-r*u,t[8]=r*a-n*s,t},t.asyncAll=B,t.bezier=k,t.bindAll=R,t.boundsAttributes=Ef,t.bufferConvexPolygon=function(t,e){const r=[];for(let n=0;n<t.length;n++){const i=z(n-1,-1,t.length-1),s=z(n+1,-1,t.length-1),a=t[n],o=t[s],l=t[i].sub(a).unit(),u=o.sub(a).unit(),c=u.angleWithSep(l.x,l.y),h=l.add(u).unit().mult(-1*e/Math.sin(c/2));r.push(a.add(h));}return r},t.cacheEntryPossiblyAdded=function(t){ot++,ot>et&&(t.getActor().send("enforceCacheSizeLimit",tt),ot=0);},t.calculateGlobeLabelMatrix=function(t,e){const{x:r,y:n}=t.point,i=Cl(r,n,t.worldSize/t._pixelsPerMercatorPixel,0,0);return yo(i,i,El(xl(e)))},t.calculateGlobeMatrix=function(t){const{x:e,y:r}=t.point,{lng:n,lat:i}=t._center;return Cl(e,r,t.worldSize,n,i)},t.calculateGlobeMercatorMatrix=function(t){const e=t.pixelsPerMeter,r=e/Zl(1,t.center.lat),n=po(new Float64Array(16));return mo(n,n,[t.point.x,t.point.y,0]),go(n,n,[r,r,e]),Float32Array.from(n)},t.circumferenceAtLatitude=ql,t.clamp=M,t.clearTileCache=function(t){if(!it())return;const r=e.caches.delete(Q);t&&r.catch(t).then((()=>t()));},t.clipLine=Hp,t.clone=function(t){var e=new uo(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},t.clone$1=O,t.collisionCircleLayout=Fh,t.config=i,t.conjugate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},t.create=function(){var t=new uo(16);return uo!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},t.create$1=co,t.createExpression=Hn,t.createLayout=Rs,t.createStyleLayer=function(t){return "custom"===t.type?new ff(t):new gf[t.type](t)},t.cross=Lo,t.degToRad=w,t.distance=function(t,e){return Math.hypot(e[0]-t[0],e[1]-t[1],e[2]-t[2])},t.div=function(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t},t.dot=Vo,t.earthRadius=Ul,t.ease=I,t.easeCubicInOut=S,t.ecefToLatLng=function([t,e,r]){const n=Math.hypot(t,e,r),i=Math.atan2(t,r),s=.5*Math.PI-Math.acos(-e/n);return new Ol(_(i),_(s))},t.emitValidationErrors=qi,t.endsWith=U,t.enforceCacheSizeLimit=function(t){st(),rt&&rt.then((e=>{e.keys().then((r=>{for(let n=0;n<r.length-t;n++)e.delete(r[n]);}));}));},t.evaluateSizeForFeature=jh,t.evaluateSizeForZoom=Oh,t.evaluateVariableOffset=xd,t.evented=gs,t.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]},t.exactEquals$1=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},t.exported=Xt,t.exported$1=s,t.extend=C,t.extend$1=ee,t.fillExtrusionHeightLift=oh,t.filterObject=j,t.fromMat4=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10],t},t.fromQuat=function(t,e){var r=e[0],n=e[1],i=e[2],s=e[3],a=r+r,o=n+n,l=i+i,u=r*a,c=n*a,h=n*o,p=i*a,d=i*o,f=i*l,y=s*a,m=s*o,g=s*l;return t[0]=1-h-f,t[1]=c+g,t[2]=p-m,t[3]=0,t[4]=c-g,t[5]=1-u-f,t[6]=d+y,t[7]=0,t[8]=p+m,t[9]=d-y,t[10]=1-u-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},t.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=-r,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},t.fromScaling=bo,t.furthestTileCorner=function(t){const e=Math.round((t+45+360)%360/90)%4;return A[e]},t.getAABBPointSquareDist=function(t,e,r){let n=0;for(let i=0;i<2;++i){const s=r?r[i]:0;t[i]>s&&(n+=(t[i]-s)*(t[i]-s)),e[i]<s&&(n+=(s-e[i])*(s-e[i]));}return n},t.getAnchorAlignment=Rp,t.getAnchorJustification=bd,t.getBounds=function(t){let e=1/0,r=1/0,n=-1/0,i=-1/0;for(const s of t)e=Math.min(e,s.x),r=Math.min(r,s.y),n=Math.max(n,s.x),i=Math.max(i,s.y);return {min:new x(e,r),max:new x(n,i)}},t.getColumn=W,t.getDefaultExportFromCjs=p,t.getGridMatrix=function(t,e,r,n){const i=e.getNorth(),s=e.getSouth(),a=e.getWest(),o=e.getEast(),l=1<<t.z,u=o-a,c=i-s,h=u/ul,p=-c/cl[r],d=[0,h,0,p,0,0,i,a,0];if(t.z>0){const t=180/n;ho(d,d,[t/u+1,0,0,0,t/c+1,0,-.5*t/h,.5*t/p,1]);}return d[2]=l,d[5]=t.x,d[8]=t.y,d},t.getImage=gt,t.getJSON=function(t,e){return ht(C(t,{type:"json"}),e)},t.getLatitudinalLod=function(t){const e=Hl-5;t=M(t,-e,e)/e*90;const r=Math.pow(Math.abs(Math.sin(w(t))),3);return Math.round(r*(cl.length-1))},t.getMapSessionAPI=Ft,t.getPerformanceMeasurement=qt,t.getProjection=Yd,t.getRTLTextPluginStatus=xs,t.getReferrer=ct,t.getTilePoint=function(t,{x:e,y:r},n=0){return new x(((e-n)*t.scale-t.x)*ao,(r*t.scale-t.y)*ao)},t.getTileVec3=function(t,e,r=0){return Io(((e.x-r)*t.scale-t.x)*ao,(e.y*t.scale-t.y)*ao,Jl(e.z,e.y))},t.getVideo=function(t,r){const n=e.document.createElement("video");n.muted=!0,n.onloadstart=function(){r(null,n);};for(let r=0;r<t.length;r++){const i=e.document.createElement("source");dt(t[r])||(n.crossOrigin="Anonymous"),i.src=t[r],n.appendChild(i);}return {cancel:()=>{}}},t.globeCenterToScreenPoint=function(t){const e=[0,0,0],r=po(new Float64Array(16));return yo(r,t.pixelMatrix,t.globeMatrix),Fo(e,e,r),new x(e[0],e[1])},t.globeDenormalizeECEF=El,t.globeECEFOrigin=function(t,e){const r=[0,0,0];return Fo(r,r,Bl(xl(e.canonical))),Fo(r,r,t),r},t.globeMetersToEcef=fl,t.globeNormalizeECEF=Bl,t.globePixelsToTileUnits=function(t,e){return ao/(512*Math.pow(2,t))*Tl(xl(e))},t.globePoleMatrixForTile=function(t,e,r){const n=po(new Float64Array(16)),i=(e/(1<<t)-.5)*Math.PI*2;return vo(n,r.globeMatrix,i),Float32Array.from(n)},t.globeTileBounds=xl,t.globeTiltAtLngLat=Dl,t.globeToMercatorTransition=Pl,t.globeUseCustomAntiAliasing=function(t,e,r){const n=Pl(r.zoom),i=t.style.map._antialias,s=!!e.extStandardDerivatives,a=e.extStandardDerivativesForceOff||t.terrain&&t.terrain.exaggeration()>0;return 0===n&&!i&&!a&&s},t.identity=po,t.identity$1=Ko,t.invert=fo,t.isFullscreen=function(){return !!e.document.fullscreenElement||!!e.document.webkitFullscreenElement},t.isLngLatBehindGlobe=Vl,t.isMapAuthenticated=function(t){return Rt.has(t)},t.isMapboxURL=vt,t.isSafariWithAntialiasingBug=function(t){const e=t.navigator?t.navigator.userAgent:null;return !!H(t)&&e&&(e.match("Version/15.4")||e.match("Version/15.5")||e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))},t.latFromMercatorY=Xl,t.latLngToECEF=Il,t.len=Oo,t.length=ko,t.length$1=function(t){return Math.hypot(t[0],t[1],t[2],t[3])},t.lngFromMercatorX=Kl,t.loadVectorTile=yy,t.makeRequest=ht,t.mapValue=function(t,e,r,n,i){return M((t-e)/(r-e)*(i-n)+n,n,i)},t.mercatorScale=Yl,t.mercatorXfromLng=Nl,t.mercatorYfromLat=Gl,t.mercatorZfromAltitude=Zl,t.mul=_o,t.mul$1=jo,t.multiply=yo,t.multiply$1=ho,t.multiply$2=zo,t.nextPowerOfTwo=L,t.normalize=Do,t.normalize$1=Ho,t.normalize$2=No,t.number=Er,t.ortho=function(t,e,r,n,i,s,a){var o=1/(e-r),l=1/(n-i),u=1/(s-a);return t[0]=-2*o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*u,t[11]=0,t[12]=(e+r)*o,t[13]=(i+n)*l,t[14]=(a+s)*u,t[15]=1,t},t.pbf=Xh,t.perspective=function(t,e,r,n,i){var s,a=1/Math.tan(e/2);return t[0]=a/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(t[10]=(i+n)*(s=1/(n-i)),t[14]=2*i*n*s):(t[10]=-1,t[14]=-2*n),t},t.pick=function(t,e){const r={};for(let n=0;n<e.length;n++){const i=e[n];i in t&&(r[i]=t[i]);}return r},t.plugin=bs,t.pointGeometry=m,t.polesInViewport=function(t){const e=po(new Float64Array(16));yo(e,t.pixelMatrix,t.globeMatrix);const r=[0,hl,0],n=[0,pl,0];return Fo(r,r,e),Fo(n,n,e),[r[0]>0&&r[0]<=t.width&&r[1]>0&&r[1]<=t.height&&!Vl(t,new Ol(t.center.lat,90)),n[0]>0&&n[0]<=t.width&&n[1]>0&&n[1]<=t.height&&!Vl(t,new Ol(t.center.lat,-90))]},t.polygonContainsPoint=bu,t.polygonIntersectsBox=wu,t.polygonIntersectsPolygon=hu,t.polygonizeBounds=function(t,e,r=0,n=!0){const i=new x(r,r),s=t.sub(i),a=e.add(i),o=[s,new x(a.x,s.y),a,new x(s.x,a.y)];return n&&o.push(s.clone()),o},t.posAttributes=tl,t.postMapLoadEvent=Pt,t.postPerformanceEvent=Vt,t.postTurnstileEvent=Et,t.potpack=_p,t.prevPowerOfTwo=function(t){return t<=1?1:Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},t.radToDeg=_,t.refProperties=["type","source","source-layer","minzoom","maxzoom","filter","layout"],t.registerForPluginStateChange=function(t){return t({pluginStatus:ds,pluginURL:fs}),gs.on("pluginStateChange",t),t},t.removeAuthState=function(t){Rt.delete(t);},t.renderColorRamp=ju,t.resample=tu,t.rotateX=xo,t.rotateX$1=Xo,t.rotateY=vo,t.rotateY$1=Jo,t.rotateZ=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),s=e[0],a=e[1],o=e[2],l=e[3],u=e[4],c=e[5],h=e[6],p=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*i+u*n,t[1]=a*i+c*n,t[2]=o*i+h*n,t[3]=l*i+p*n,t[4]=u*i-s*n,t[5]=c*i-a*n,t[6]=h*i-o*n,t[7]=p*i-l*n,t},t.rotateZ$1=function(t,e,r){r*=.5;var n=e[0],i=e[1],s=e[2],a=e[3],o=Math.sin(r),l=Math.cos(r);return t[0]=n*l+i*o,t[1]=i*l-n*o,t[2]=s*l+a*o,t[3]=a*l-s*o,t},t.scale=go,t.scale$1=qo,t.scale$2=Co,t.scaleAndAdd=Po,t.set=function(t,e,r,n){return t[0]=e,t[1]=r,t[2]=n,t},t.setCacheLimits=function(t,e){tt=t,et=e;},t.setColumn=function(t,e,r){t[4*e+0]=r[0],t[4*e+1]=r[1],t[4*e+2]=r[2],t[4*e+3]=r[3];},t.setRTLTextPlugin=function(t,e,r=!1){if(ds===us||ds===cs||ds===hs)throw new Error("setRTLTextPlugin cannot be called multiple times.");fs=Xt.resolveURL(t),ds=us,ps=e,ms(),r||vs();},t.smoothstep=T,t.spec=te,t.squaredLength=function(t){var e=t[0],r=t[1],n=t[2];return e*e+r*r+n*n},t.storeAuthState=function(t,e){e?Rt.add(t):Rt.delete(t);},t.sub=$o,t.subtract=To,t.symbolSize=qh,t.tileAABB=function(t,e,r,n,i,s,a,o,l){if("globe"===l.name)return _l(t,e,new ph(r,n,i));const u=Bd({z:r,x:n,y:i},l);return new il([(s+u.x/u.scale)*e,e*(u.y/u.scale),a],[(s+u.x2/u.scale)*e,e*(u.y2/u.scale),o])},t.tileCornersToBounds=Al,t.tileTransform=Bd,t.transformMat3=function(t,e,r){var n=e[0],i=e[1],s=e[2];return t[0]=n*r[0]+i*r[3]+s*r[6],t[1]=n*r[1]+i*r[4]+s*r[7],t[2]=n*r[2]+i*r[5]+s*r[8],t},t.transformMat4=Fo,t.transformMat4$1=Go,t.transformQuat=Ro,t.transitionTileAABBinECEF=bl,t.translate=mo,t.transpose=function(t,e){if(t===e){var r=e[1],n=e[2],i=e[5];t[1]=e[3],t[2]=e[6],t[3]=r,t[5]=e[7],t[6]=n,t[7]=i;}else t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8];return t},t.triggerPluginCompletionEvent=ys,t.uniqueId=D,t.updateGlobeVertexNormal=function(t,e,r,n,i){const s=5*e+2;t.float32[s+0]=r,t.float32[s+1]=n,t.float32[s+2]=i;},t.validateCustomStyleLayer=function(t){const e=[],r=t.id;return void 0===r&&e.push({message:`layers.${r}: missing required property "id"`}),void 0===t.render&&e.push({message:`layers.${r}: missing required method "render"`}),t.renderingMode&&"2d"!==t.renderingMode&&"3d"!==t.renderingMode&&e.push({message:`layers.${r}: property "renderingMode" must be either "2d" or "3d"`}),e},t.validateFilter=t=>Oi(Ai(t)),t.validateFog=t=>Oi(Vi(t)),t.validateLayer=t=>Oi(Ti(t)),t.validateLight=t=>Oi(Pi(t)),t.validateSource=t=>Oi(Ei(t)),t.validateStyle=Ui,t.validateTerrain=t=>Oi(Di(t)),t.values=E,t.vectorTile=Dc,t.version=r,t.warnOnce=N,t.window=e,t.wrap=z;}));

  define(["./shared"],(function(e){function t(e){if("number"==typeof e||"boolean"==typeof e||"string"==typeof e||null==e)return JSON.stringify(e);if(Array.isArray(e)){let r="[";for(const o of e)r+=`${t(o)},`;return `${r}]`}let r="{";for(const o of Object.keys(e).sort())r+=`${o}:${t(e[o])},`;return `${r}}`}function r(r){let o="";for(const i of e.refProperties)o+=`/${t(r[i])}`;return o}class o{constructor(e){this.keyCache={},e&&this.replace(e);}replace(e){this._layerConfigs={},this._layers={},this.update(e,[]);}update(t,o){for(const r of t)this._layerConfigs[r.id]=r,(this._layers[r.id]=e.createStyleLayer(r)).compileFilter(),this.keyCache[r.id]&&delete this.keyCache[r.id];for(const e of o)delete this.keyCache[e],delete this._layerConfigs[e],delete this._layers[e];this.familiesBySource={};const i=function(e,t){const o={};for(let i=0;i<e.length;i++){const n=t&&t[e[i].id]||r(e[i]);t&&(t[e[i].id]=n);let s=o[n];s||(s=o[n]=[]),s.push(e[i]);}const i=[];for(const e in o)i.push(o[e]);return i}(e.values(this._layerConfigs),this.keyCache);for(const e of i){const t=e.map((e=>this._layers[e.id])),r=t[0];if("none"===r.visibility)continue;const o=r.source||"";let i=this.familiesBySource[o];i||(i=this.familiesBySource[o]={});const n=r.sourceLayer||"_geojsonTileLayer";let s=i[n];s||(s=i[n]=[]),s.push(t);}}}class i{loadTile(t,r){const{uid:o,encoding:i,rawImageData:n,padding:s,buildQuadTree:a}=t,l=e.window.ImageBitmap&&n instanceof e.window.ImageBitmap?this.getImageData(n,s):n;r(null,new e.DEMData(o,l,i,s<1,a));}getImageData(e,t){this.offscreenCanvas&&this.offscreenCanvasContext||(this.offscreenCanvas=new OffscreenCanvas(e.width,e.height),this.offscreenCanvasContext=this.offscreenCanvas.getContext("2d",{willReadFrequently:!0})),this.offscreenCanvas.width=e.width,this.offscreenCanvas.height=e.height,this.offscreenCanvasContext.drawImage(e,0,0,e.width,e.height);const r=this.offscreenCanvasContext.getImageData(-t,-t,e.width+2*t,e.height+2*t);return this.offscreenCanvasContext.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),r}}function n(e,t){if(0!==e.length){s(e[0],t);for(var r=1;r<e.length;r++)s(e[r],!t);}}function s(e,t){for(var r=0,o=0,i=0,n=e.length,s=n-1;i<n;s=i++){var a=(e[i][0]-e[s][0])*(e[s][1]+e[i][1]),l=r+a;o+=Math.abs(r)>=Math.abs(a)?r-l+a:a-l+r,r=l;}r+o>=0!=!!t&&e.reverse();}var a=e.getDefaultExportFromCjs((function e(t,r){var o,i=t&&t.type;if("FeatureCollection"===i)for(o=0;o<t.features.length;o++)e(t.features[o],r);else if("GeometryCollection"===i)for(o=0;o<t.geometries.length;o++)e(t.geometries[o],r);else if("Feature"===i)e(t.geometry,r);else if("Polygon"===i)n(t.coordinates,r);else if("MultiPolygon"===i)for(o=0;o<t.coordinates.length;o++)n(t.coordinates[o],r);return t}));const l=e.VectorTileFeature.prototype.toGeoJSON;var u={exports:{}},h=e.pointGeometry,c=e.vectorTile.VectorTileFeature,f=p;function p(e,t){this.options=t||{},this.features=e,this.length=e.length;}function g(e,t){this.id="number"==typeof e.id?e.id:void 0,this.type=e.type,this.rawGeometry=1===e.type?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096;}p.prototype.feature=function(e){return new g(this.features[e],this.options.extent)},g.prototype.loadGeometry=function(){var e=this.rawGeometry;this.geometry=[];for(var t=0;t<e.length;t++){for(var r=e[t],o=[],i=0;i<r.length;i++)o.push(new h(r[i][0],r[i][1]));this.geometry.push(o);}return this.geometry},g.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-1/0,o=1/0,i=-1/0,n=0;n<e.length;n++)for(var s=e[n],a=0;a<s.length;a++){var l=s[a];t=Math.min(t,l.x),r=Math.max(r,l.x),o=Math.min(o,l.y),i=Math.max(i,l.y);}return [t,o,r,i]},g.prototype.toGeoJSON=c.prototype.toGeoJSON;var d=e.pbf,m=f;function y(e){var t=new d;return function(e,t){for(var r in e.layers)t.writeMessage(3,v,e.layers[r]);}(e,t),t.finish()}function v(e,t){var r;t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var o={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<e.length;r++)o.feature=e.feature(r),t.writeMessage(2,x,o);var i=o.keys;for(r=0;r<i.length;r++)t.writeStringField(3,i[r]);var n=o.values;for(r=0;r<n.length;r++)t.writeMessage(4,b,n[r]);}function x(e,t){var r=e.feature;void 0!==r.id&&t.writeVarintField(1,r.id),t.writeMessage(2,w,e),t.writeVarintField(3,r.type),t.writeMessage(4,P,r);}function w(e,t){var r=e.feature,o=e.keys,i=e.values,n=e.keycache,s=e.valuecache;for(var a in r.properties){var l=r.properties[a],u=n[a];if(null!==l){void 0===u&&(o.push(a),n[a]=u=o.length-1),t.writeVarint(u);var h=typeof l;"string"!==h&&"boolean"!==h&&"number"!==h&&(l=JSON.stringify(l));var c=h+":"+l,f=s[c];void 0===f&&(i.push(l),s[c]=f=i.length-1),t.writeVarint(f);}}}function S(e,t){return (t<<3)+(7&e)}function M(e){return e<<1^e>>31}function P(e,t){for(var r=e.loadGeometry(),o=e.type,i=0,n=0,s=r.length,a=0;a<s;a++){var l=r[a],u=1;1===o&&(u=l.length),t.writeVarint(S(1,u));for(var h=3===o?l.length-1:l.length,c=0;c<h;c++){1===c&&1!==o&&t.writeVarint(S(2,h-1));var f=l[c].x-i,p=l[c].y-n;t.writeVarint(M(f)),t.writeVarint(M(p)),i+=f,n+=p;}3===o&&t.writeVarint(S(7,1));}}function b(e,t){var r=typeof e;"string"===r?t.writeStringField(1,e):"boolean"===r?t.writeBooleanField(7,e):"number"===r&&(e%1!=0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e));}u.exports=y,u.exports.fromVectorTileJs=y,u.exports.fromGeojsonVt=function(e,t){t=t||{};var r={};for(var o in e)r[o]=new m(e[o].features,t),r[o].name=o,r[o].version=t.version,r[o].extent=t.extent;return y({layers:r})},u.exports.GeoJSONWrapper=m;var T=e.getDefaultExportFromCjs(u.exports);const k={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},I=Math.fround||(_=new Float32Array(1),e=>(_[0]=+e,_[0]));var _;const C=3,L=5,O=6;class E{constructor(e){this.options=Object.assign(Object.create(k),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[];}load(e){const{log:t,minZoom:r,maxZoom:o}=this.options;t&&console.time("total time");const i=`prepare ${e.length} points`;t&&console.time(i),this.points=e;const n=[];for(let t=0;t<e.length;t++){const r=e[t];if(!r.geometry)continue;const[o,i]=r.geometry.coordinates,s=I(N(o)),a=I(Z(i));n.push(s,a,1/0,t,-1,1),this.options.reduce&&n.push(0);}let s=this.trees[o+1]=this._createTree(n);t&&console.timeEnd(i);for(let e=o;e>=r;e--){const r=+Date.now();s=this.trees[e]=this._createTree(this._cluster(s,e)),t&&console.log("z%d: %d clusters in %dms",e,s.numItems,+Date.now()-r);}return t&&console.timeEnd("total time"),this}getClusters(e,t){let r=((e[0]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,e[1]));let i=180===e[2]?180:((e[2]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)r=-180,i=180;else if(r>i){const e=this.getClusters([r,o,180,n],t),s=this.getClusters([-180,o,i,n],t);return e.concat(s)}const s=this.trees[this._limitZoom(t)],a=s.range(N(r),Z(n),N(i),Z(o)),l=s.data,u=[];for(const e of a){const t=this.stride*e;u.push(l[t+L]>1?j(l,t,this.clusterProps):this.points[l[t+C]]);}return u}getChildren(e){const t=this._getOriginId(e),r=this._getOriginZoom(e),o="No cluster with the specified id.",i=this.trees[r];if(!i)throw new Error(o);const n=i.data;if(t*this.stride>=n.length)throw new Error(o);const s=this.options.radius/(this.options.extent*Math.pow(2,r-1)),a=i.within(n[t*this.stride],n[t*this.stride+1],s),l=[];for(const t of a){const r=t*this.stride;n[r+4]===e&&l.push(n[r+L]>1?j(n,r,this.clusterProps):this.points[n[r+C]]);}if(0===l.length)throw new Error(o);return l}getLeaves(e,t,r){const o=[];return this._appendLeaves(o,e,t=t||10,r=r||0,0),o}getTile(e,t,r){const o=this.trees[this._limitZoom(e)],i=Math.pow(2,e),{extent:n,radius:s}=this.options,a=s/n,l=(r-a)/i,u=(r+1+a)/i,h={features:[]};return this._addTileFeatures(o.range((t-a)/i,l,(t+1+a)/i,u),o.data,t,r,i,h),0===t&&this._addTileFeatures(o.range(1-a/i,l,1,u),o.data,i,r,i,h),t===i-1&&this._addTileFeatures(o.range(0,l,a/i,u),o.data,-1,r,i,h),h.features.length?h:null}getClusterExpansionZoom(e){let t=this._getOriginZoom(e)-1;for(;t<=this.options.maxZoom;){const r=this.getChildren(e);if(t++,1!==r.length)break;e=r[0].properties.cluster_id;}return t}_appendLeaves(e,t,r,o,i){const n=this.getChildren(t);for(const t of n){const n=t.properties;if(n&&n.cluster?i+n.point_count<=o?i+=n.point_count:i=this._appendLeaves(e,n.cluster_id,r,o,i):i<o?i++:e.push(t),e.length===r)break}return i}_createTree(t){const r=new e.KDBush(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let e=0;e<t.length;e+=this.stride)r.add(t[e],t[e+1]);return r.finish(),r.data=t,r}_addTileFeatures(e,t,r,o,i,n){for(const s of e){const e=s*this.stride,a=t[e+L]>1;let l,u,h;if(a)l=F(t,e,this.clusterProps),u=t[e],h=t[e+1];else {const r=this.points[t[e+C]];l=r.properties;const[o,i]=r.geometry.coordinates;u=N(o),h=Z(i);}const c={type:1,geometry:[[Math.round(this.options.extent*(u*i-r)),Math.round(this.options.extent*(h*i-o))]],tags:l};let f;f=a||this.options.generateId?t[e+C]:this.points[t[e+C]].id,void 0!==f&&(c.id=f),n.features.push(c);}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,t){const{radius:r,extent:o,reduce:i,minPoints:n}=this.options,s=r/(o*Math.pow(2,t)),a=e.data,l=[],u=this.stride;for(let r=0;r<a.length;r+=u){if(a[r+2]<=t)continue;a[r+2]=t;const o=a[r],h=a[r+1],c=e.within(a[r],a[r+1],s),f=a[r+L];let p=f;for(const e of c){const r=e*u;a[r+2]>t&&(p+=a[r+L]);}if(p>f&&p>=n){let e,n=o*f,s=h*f,g=-1;const d=((r/u|0)<<5)+(t+1)+this.points.length;for(const o of c){const l=o*u;if(a[l+2]<=t)continue;a[l+2]=t;const h=a[l+L];n+=a[l]*h,s+=a[l+1]*h,a[l+4]=d,i&&(e||(e=this._map(a,r,!0),g=this.clusterProps.length,this.clusterProps.push(e)),i(e,this._map(a,l)));}a[r+4]=d,l.push(n/p,s/p,1/0,d,-1,p),i&&l.push(g);}else {for(let e=0;e<u;e++)l.push(a[r+e]);if(p>1)for(const e of c){const r=e*u;if(!(a[r+2]<=t)){a[r+2]=t;for(let e=0;e<u;e++)l.push(a[r+e]);}}}}return l}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return (e-this.points.length)%32}_map(e,t,r){if(e[t+L]>1){const o=this.clusterProps[e[t+O]];return r?Object.assign({},o):o}const o=this.points[e[t+C]].properties,i=this.options.map(o);return r&&i===o?Object.assign({},i):i}}function j(e,t,r){return {type:"Feature",id:e[t+C],properties:F(e,t,r),geometry:{type:"Point",coordinates:[(o=e[t],360*(o-.5)),J(e[t+1])]}};var o;}function F(e,t,r){const o=e[t+L],i=o>=1e4?`${Math.round(o/1e3)}k`:o>=1e3?Math.round(o/100)/10+"k":o,n=e[t+O],s=-1===n?{}:Object.assign({},r[n]);return Object.assign(s,{cluster:!0,cluster_id:e[t+C],point_count:o,point_count_abbreviated:i})}function N(e){return e/360+.5}function Z(e){const t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function J(e){const t=(180-360*e)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function z(e,t,r,o){for(var i,n=o,s=r-t>>1,a=r-t,l=e[t],u=e[t+1],h=e[r],c=e[r+1],f=t+3;f<r;f+=3){var p=G(e[f],e[f+1],l,u,h,c);if(p>n)i=f,n=p;else if(p===n){var g=Math.abs(f-s);g<a&&(i=f,a=g);}}n>o&&(i-t>3&&z(e,t,i,o),e[i+2]=n,r-i>3&&z(e,i,r,o));}function G(e,t,r,o,i,n){var s=i-r,a=n-o;if(0!==s||0!==a){var l=((e-r)*s+(t-o)*a)/(s*s+a*a);l>1?(r=i,o=n):l>0&&(r+=s*l,o+=a*l);}return (s=e-r)*s+(a=t-o)*a}function W(e,t,r,o){var i={id:void 0===e?null:e,type:t,geometry:r,tags:o,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return function(e){var t=e.geometry,r=e.type;if("Point"===r||"MultiPoint"===r||"LineString"===r)Y(e,t);else if("Polygon"===r||"MultiLineString"===r)for(var o=0;o<t.length;o++)Y(e,t[o]);else if("MultiPolygon"===r)for(o=0;o<t.length;o++)for(var i=0;i<t[o].length;i++)Y(e,t[o][i]);}(i),i}function Y(e,t){for(var r=0;r<t.length;r+=3)e.minX=Math.min(e.minX,t[r]),e.minY=Math.min(e.minY,t[r+1]),e.maxX=Math.max(e.maxX,t[r]),e.maxY=Math.max(e.maxY,t[r+1]);}function X(e,t,r,o){if(t.geometry){var i=t.geometry.coordinates,n=t.geometry.type,s=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),a=[],l=t.id;if(r.promoteId?l=t.properties[r.promoteId]:r.generateId&&(l=o||0),"Point"===n)V(i,a);else if("MultiPoint"===n)for(var u=0;u<i.length;u++)V(i[u],a);else if("LineString"===n)D(i,a,s,!1);else if("MultiLineString"===n){if(r.lineMetrics){for(u=0;u<i.length;u++)D(i[u],a=[],s,!1),e.push(W(l,"LineString",a,t.properties));return}$(i,a,s,!1);}else if("Polygon"===n)$(i,a,s,!0);else {if("MultiPolygon"!==n){if("GeometryCollection"===n){for(u=0;u<t.geometry.geometries.length;u++)X(e,{id:l,geometry:t.geometry.geometries[u],properties:t.properties},r,o);return}throw new Error("Input data is not a valid GeoJSON object.")}for(u=0;u<i.length;u++){var h=[];$(i[u],h,s,!0),a.push(h);}}e.push(W(l,n,a,t.properties));}}function V(e,t){t.push(A(e[0])),t.push(B(e[1])),t.push(0);}function D(e,t,r,o){for(var i,n,s=0,a=0;a<e.length;a++){var l=A(e[a][0]),u=B(e[a][1]);t.push(l),t.push(u),t.push(0),a>0&&(s+=o?(i*u-l*n)/2:Math.sqrt(Math.pow(l-i,2)+Math.pow(u-n,2))),i=l,n=u;}var h=t.length-3;t[2]=1,z(t,0,h,r),t[h+2]=1,t.size=Math.abs(s),t.start=0,t.end=t.size;}function $(e,t,r,o){for(var i=0;i<e.length;i++){var n=[];D(e[i],n,r,o),t.push(n);}}function A(e){return e/360+.5}function B(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function R(e,t,r,o,i,n,s,a){if(o/=t,n>=(r/=t)&&s<o)return e;if(s<r||n>=o)return null;for(var l=[],u=0;u<e.length;u++){var h=e[u],c=h.geometry,f=h.type,p=0===i?h.minX:h.minY,g=0===i?h.maxX:h.maxY;if(p>=r&&g<o)l.push(h);else if(!(g<r||p>=o)){var d=[];if("Point"===f||"MultiPoint"===f)q(c,d,r,o,i);else if("LineString"===f)Q(c,d,r,o,i,!1,a.lineMetrics);else if("MultiLineString"===f)K(c,d,r,o,i,!1);else if("Polygon"===f)K(c,d,r,o,i,!0);else if("MultiPolygon"===f)for(var m=0;m<c.length;m++){var y=[];K(c[m],y,r,o,i,!0),y.length&&d.push(y);}if(d.length){if(a.lineMetrics&&"LineString"===f){for(m=0;m<d.length;m++)l.push(W(h.id,f,d[m],h.tags));continue}"LineString"!==f&&"MultiLineString"!==f||(1===d.length?(f="LineString",d=d[0]):f="MultiLineString"),"Point"!==f&&"MultiPoint"!==f||(f=3===d.length?"Point":"MultiPoint"),l.push(W(h.id,f,d,h.tags));}}}return l.length?l:null}function q(e,t,r,o,i){for(var n=0;n<e.length;n+=3){var s=e[n+i];s>=r&&s<=o&&(t.push(e[n]),t.push(e[n+1]),t.push(e[n+2]));}}function Q(e,t,r,o,i,n,s){for(var a,l,u=U(e),h=0===i?ee:te,c=e.start,f=0;f<e.length-3;f+=3){var p=e[f],g=e[f+1],d=e[f+2],m=e[f+3],y=e[f+4],v=0===i?p:g,x=0===i?m:y,w=!1;s&&(a=Math.sqrt(Math.pow(p-m,2)+Math.pow(g-y,2))),v<r?x>r&&(l=h(u,p,g,m,y,r),s&&(u.start=c+a*l)):v>o?x<o&&(l=h(u,p,g,m,y,o),s&&(u.start=c+a*l)):H(u,p,g,d),x<r&&v>=r&&(l=h(u,p,g,m,y,r),w=!0),x>o&&v<=o&&(l=h(u,p,g,m,y,o),w=!0),!n&&w&&(s&&(u.end=c+a*l),t.push(u),u=U(e)),s&&(c+=a);}var S=e.length-3;p=e[S],g=e[S+1],d=e[S+2],(v=0===i?p:g)>=r&&v<=o&&H(u,p,g,d),S=u.length-3,n&&S>=3&&(u[S]!==u[0]||u[S+1]!==u[1])&&H(u,u[0],u[1],u[2]),u.length&&t.push(u);}function U(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function K(e,t,r,o,i,n){for(var s=0;s<e.length;s++)Q(e[s],t,r,o,i,n,!1);}function H(e,t,r,o){e.push(t),e.push(r),e.push(o);}function ee(e,t,r,o,i,n){var s=(n-t)/(o-t);return e.push(n),e.push(r+(i-r)*s),e.push(1),s}function te(e,t,r,o,i,n){var s=(n-r)/(i-r);return e.push(t+(o-t)*s),e.push(n),e.push(1),s}function re(e,t){for(var r=[],o=0;o<e.length;o++){var i,n=e[o],s=n.type;if("Point"===s||"MultiPoint"===s||"LineString"===s)i=oe(n.geometry,t);else if("MultiLineString"===s||"Polygon"===s){i=[];for(var a=0;a<n.geometry.length;a++)i.push(oe(n.geometry[a],t));}else if("MultiPolygon"===s)for(i=[],a=0;a<n.geometry.length;a++){for(var l=[],u=0;u<n.geometry[a].length;u++)l.push(oe(n.geometry[a][u],t));i.push(l);}r.push(W(n.id,s,i,n.tags));}return r}function oe(e,t){var r=[];r.size=e.size,void 0!==e.start&&(r.start=e.start,r.end=e.end);for(var o=0;o<e.length;o+=3)r.push(e[o]+t,e[o+1],e[o+2]);return r}function ie(e,t){if(e.transformed)return e;var r,o,i,n=1<<e.z,s=e.x,a=e.y;for(r=0;r<e.features.length;r++){var l=e.features[r],u=l.geometry,h=l.type;if(l.geometry=[],1===h)for(o=0;o<u.length;o+=2)l.geometry.push(ne(u[o],u[o+1],t,n,s,a));else for(o=0;o<u.length;o++){var c=[];for(i=0;i<u[o].length;i+=2)c.push(ne(u[o][i],u[o][i+1],t,n,s,a));l.geometry.push(c);}}return e.transformed=!0,e}function ne(e,t,r,o,i,n){return [Math.round(r*(e*o-i)),Math.round(r*(t*o-n))]}function se(e,t,r,o,i){for(var n=t===i.maxZoom?0:i.tolerance/((1<<t)*i.extent),s={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:o,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},a=0;a<e.length;a++){s.numFeatures++,ae(s,e[a],n,i);var l=e[a].minX,u=e[a].minY,h=e[a].maxX,c=e[a].maxY;l<s.minX&&(s.minX=l),u<s.minY&&(s.minY=u),h>s.maxX&&(s.maxX=h),c>s.maxY&&(s.maxY=c);}return s}function ae(e,t,r,o){var i=t.geometry,n=t.type,s=[];if("Point"===n||"MultiPoint"===n)for(var a=0;a<i.length;a+=3)s.push(i[a]),s.push(i[a+1]),e.numPoints++,e.numSimplified++;else if("LineString"===n)le(s,i,e,r,!1,!1);else if("MultiLineString"===n||"Polygon"===n)for(a=0;a<i.length;a++)le(s,i[a],e,r,"Polygon"===n,0===a);else if("MultiPolygon"===n)for(var l=0;l<i.length;l++){var u=i[l];for(a=0;a<u.length;a++)le(s,u[a],e,r,!0,0===a);}if(s.length){var h=t.tags||null;if("LineString"===n&&o.lineMetrics){for(var c in h={},t.tags)h[c]=t.tags[c];h.mapbox_clip_start=i.start/i.size,h.mapbox_clip_end=i.end/i.size;}var f={geometry:s,type:"Polygon"===n||"MultiPolygon"===n?3:"LineString"===n||"MultiLineString"===n?2:1,tags:h};null!==t.id&&(f.id=t.id),e.features.push(f);}}function le(e,t,r,o,i,n){var s=o*o;if(o>0&&t.size<(i?s:o))r.numPoints+=t.length/3;else {for(var a=[],l=0;l<t.length;l+=3)(0===o||t[l+2]>s)&&(r.numSimplified++,a.push(t[l]),a.push(t[l+1])),r.numPoints++;i&&function(e,t){for(var r=0,o=0,i=e.length,n=i-2;o<i;n=o,o+=2)r+=(e[o]-e[n])*(e[o+1]+e[n+1]);if(r>0===t)for(o=0,i=e.length;o<i/2;o+=2){var s=e[o],a=e[o+1];e[o]=e[i-2-o],e[o+1]=e[i-1-o],e[i-2-o]=s,e[i-1-o]=a;}}(a,n),e.push(a);}}function ue(e,t){var r=(t=this.options=function(e,t){for(var r in t)e[r]=t[r];return e}(Object.create(this.options),t)).debug;if(r&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var o=function(e,t){var r=[];if("FeatureCollection"===e.type)for(var o=0;o<e.features.length;o++)X(r,e.features[o],t,o);else X(r,"Feature"===e.type?e:{geometry:e},t);return r}(e,t);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),o=function(e,t){var r=t.buffer/t.extent,o=e,i=R(e,1,-1-r,r,0,-1,2,t),n=R(e,1,1-r,2+r,0,-1,2,t);return (i||n)&&(o=R(e,1,-r,1+r,0,-1,2,t)||[],i&&(o=re(i,1).concat(o)),n&&(o=o.concat(re(n,-1)))),o}(o,t),o.length&&this.splitTile(o,0,0,0),r&&(o.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)));}function he(e,t,r){return 32*((1<<e)*r+t)+e}function ce(t,r){const o=t.tileID.canonical;if(!this._geoJSONIndex)return r(null,null);const i=this._geoJSONIndex.getTile(o.z,o.x,o.y);if(!i)return r(null,null);const n=new class{constructor(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=e.EXTENT,this.length=t.length,this._features=t;}feature(t){return new class{constructor(t){this._feature=t,this.extent=e.EXTENT,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10));}loadGeometry(){if(1===this._feature.type){const t=[];for(const r of this._feature.geometry)t.push([new e.Point(r[0],r[1])]);return t}{const t=[];for(const r of this._feature.geometry){const o=[];for(const t of r)o.push(new e.Point(t[0],t[1]));t.push(o);}return t}}toGeoJSON(e,t,r){return l.call(this,e,t,r)}}(this._features[t])}}(i.features);let s=T(n);0===s.byteOffset&&s.byteLength===s.buffer.byteLength||(s=new Uint8Array(s)),r(null,{vectorTile:n,rawData:s.buffer});}ue.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0},ue.prototype.splitTile=function(e,t,r,o,i,n,s){for(var a=[e,t,r,o],l=this.options,u=l.debug;a.length;){o=a.pop(),r=a.pop(),t=a.pop(),e=a.pop();var h=1<<t,c=he(t,r,o),f=this.tiles[c];if(!f&&(u>1&&console.time("creation"),f=this.tiles[c]=se(e,t,r,o,l),this.tileCoords.push({z:t,x:r,y:o}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,r,o,f.numFeatures,f.numPoints,f.numSimplified),console.timeEnd("creation"));var p="z"+t;this.stats[p]=(this.stats[p]||0)+1,this.total++;}if(f.source=e,i){if(t===l.maxZoom||t===i)continue;var g=1<<i-t;if(r!==Math.floor(n/g)||o!==Math.floor(s/g))continue}else if(t===l.indexMaxZoom||f.numPoints<=l.indexMaxPoints)continue;if(f.source=null,0!==e.length){u>1&&console.time("clipping");var d,m,y,v,x,w,S=.5*l.buffer/l.extent,M=.5-S,P=.5+S,b=1+S;d=m=y=v=null,x=R(e,h,r-S,r+P,0,f.minX,f.maxX,l),w=R(e,h,r+M,r+b,0,f.minX,f.maxX,l),e=null,x&&(d=R(x,h,o-S,o+P,1,f.minY,f.maxY,l),m=R(x,h,o+M,o+b,1,f.minY,f.maxY,l),x=null),w&&(y=R(w,h,o-S,o+P,1,f.minY,f.maxY,l),v=R(w,h,o+M,o+b,1,f.minY,f.maxY,l),w=null),u>1&&console.timeEnd("clipping"),a.push(d||[],t+1,2*r,2*o),a.push(m||[],t+1,2*r,2*o+1),a.push(y||[],t+1,2*r+1,2*o),a.push(v||[],t+1,2*r+1,2*o+1);}}},ue.prototype.getTile=function(e,t,r){var o=this.options,i=o.extent,n=o.debug;if(e<0||e>24)return null;var s=1<<e,a=he(e,t=(t%s+s)%s,r);if(this.tiles[a])return ie(this.tiles[a],i);n>1&&console.log("drilling down to z%d-%d-%d",e,t,r);for(var l,u=e,h=t,c=r;!l&&u>0;)u--,h=Math.floor(h/2),c=Math.floor(c/2),l=this.tiles[he(u,h,c)];return l&&l.source?(n>1&&console.log("found parent tile z%d-%d-%d",u,h,c),n>1&&console.time("drilling down"),this.splitTile(l.source,u,h,c,e,t,r),n>1&&console.timeEnd("drilling down"),this.tiles[a]?ie(this.tiles[a],i):null):null};class fe extends e.VectorTileWorkerSource{constructor(e,t,r,o,i){super(e,t,r,o,ce),i&&(this.loadGeoJSON=i);}loadData(t,r){const o=t&&t.request,i=o&&o.collectResourceTiming;this.loadGeoJSON(t,((n,s)=>{if(n||!s)return r(n);if("object"!=typeof s)return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));{a(s,!0);try{if(t.filter){const r=e.createExpression(t.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if("error"===r.result)throw new Error(r.value.map((e=>`${e.key}: ${e.message}`)).join(", "));const o=s.features.filter((e=>r.value.evaluate({zoom:0},e)));s={type:"FeatureCollection",features:o};}this._geoJSONIndex=t.cluster?new E(function({superclusterOptions:t,clusterProperties:r}){if(!r||!t)return t;const o={},i={},n={accumulated:null,zoom:0},s={properties:null},a=Object.keys(r);for(const t of a){const[n,s]=r[t],a=e.createExpression(s),l=e.createExpression("string"==typeof n?[n,["accumulated"],["get",t]]:n);o[t]=a.value,i[t]=l.value;}return t.map=e=>{s.properties=e;const t={};for(const e of a)t[e]=o[e].evaluate(n,s);return t},t.reduce=(e,t)=>{s.properties=t;for(const t of a)n.accumulated=e[t],e[t]=i[t].evaluate(n,s);},t}(t)).load(s.features):function(e,t){return new ue(e,t)}(s,t.geojsonVtOptions);}catch(n){return r(n)}this.loaded={};const l={};if(i){const r=e.getPerformanceMeasurement(o);r&&(l.resourceTiming={},l.resourceTiming[t.source]=JSON.parse(JSON.stringify(r)));}r(null,l);}}));}reloadTile(e,t){const r=this.loaded;return r&&r[e.uid]?super.reloadTile(e,t):this.loadTile(e,t)}loadGeoJSON(t,r){if(t.request)e.getJSON(t.request,r);else {if("string"!=typeof t.data)return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));try{return r(null,JSON.parse(t.data))}catch(e){return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`))}}}getClusterExpansionZoom(e,t){try{t(null,this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));}catch(e){t(e);}}getClusterChildren(e,t){try{t(null,this._geoJSONIndex.getChildren(e.clusterId));}catch(e){t(e);}}getClusterLeaves(e,t){try{t(null,this._geoJSONIndex.getLeaves(e.clusterId,e.limit,e.offset));}catch(e){t(e);}}}class pe{constructor(t){this.self=t,this.actor=new e.Actor(t,this),this.layerIndexes={},this.availableImages={},this.isSpriteLoaded={},this.projections={},this.defaultProjection=e.getProjection({name:"mercator"}),this.workerSourceTypes={vector:e.VectorTileWorkerSource,geojson:fe},this.workerSources={},this.demWorkerSources={},this.self.registerWorkerSource=(e,t)=>{if(this.workerSourceTypes[e])throw new Error(`Worker source with name "${e}" already registered.`);this.workerSourceTypes[e]=t;},this.self.registerRTLTextPlugin=t=>{if(e.plugin.isParsed())throw new Error("RTL text plugin already registered.");e.plugin.applyArabicShaping=t.applyArabicShaping,e.plugin.processBidirectionalText=t.processBidirectionalText,e.plugin.processStyledBidirectionalText=t.processStyledBidirectionalText;};}clearCaches(e,t,r){delete this.layerIndexes[e],delete this.availableImages[e],delete this.workerSources[e],delete this.demWorkerSources[e],r();}checkIfReady(e,t,r){r();}setReferrer(e,t){this.referrer=t;}spriteLoaded(t,r){this.isSpriteLoaded[t]=r;for(const o in this.workerSources[t]){const i=this.workerSources[t][o];for(const t in i)i[t]instanceof e.VectorTileWorkerSource&&(i[t].isSpriteLoaded=r,i[t].fire(new e.Event("isSpriteLoaded")));}}setImages(e,t,r){this.availableImages[e]=t;for(const r in this.workerSources[e]){const o=this.workerSources[e][r];for(const e in o)o[e].availableImages=t;}r();}enableTerrain(e,t,r){this.terrain=t,r();}setProjection(t,r){this.projections[t]=e.getProjection(r);}setLayers(e,t,r){this.getLayerIndex(e).replace(t),r();}updateLayers(e,t,r){this.getLayerIndex(e).update(t.layers,t.removedIds),r();}loadTile(t,r,o){const i=this.enableTerrain?e.extend({enableTerrain:this.terrain},r):r;i.projection=this.projections[t]||this.defaultProjection,this.getWorkerSource(t,r.type,r.source).loadTile(i,o);}loadDEMTile(t,r,o){const i=this.enableTerrain?e.extend({buildQuadTree:this.terrain},r):r;this.getDEMWorkerSource(t,r.source).loadTile(i,o);}reloadTile(t,r,o){const i=this.enableTerrain?e.extend({enableTerrain:this.terrain},r):r;i.projection=this.projections[t]||this.defaultProjection,this.getWorkerSource(t,r.type,r.source).reloadTile(i,o);}abortTile(e,t,r){this.getWorkerSource(e,t.type,t.source).abortTile(t,r);}removeTile(e,t,r){this.getWorkerSource(e,t.type,t.source).removeTile(t,r);}removeSource(e,t,r){if(!this.workerSources[e]||!this.workerSources[e][t.type]||!this.workerSources[e][t.type][t.source])return;const o=this.workerSources[e][t.type][t.source];delete this.workerSources[e][t.type][t.source],void 0!==o.removeSource?o.removeSource(t,r):r();}loadWorkerSource(e,t,r){try{this.self.importScripts(t.url),r();}catch(e){r(e.toString());}}syncRTLPluginState(t,r,o){try{e.plugin.setState(r);const t=e.plugin.getPluginURL();if(e.plugin.isLoaded()&&!e.plugin.isParsed()&&null!=t){this.self.importScripts(t);const r=e.plugin.isParsed();o(r?void 0:new Error(`RTL Text Plugin failed to import scripts from ${t}`),r);}}catch(e){o(e.toString());}}getAvailableImages(e){let t=this.availableImages[e];return t||(t=[]),t}getLayerIndex(e){let t=this.layerIndexes[e];return t||(t=this.layerIndexes[e]=new o),t}getWorkerSource(e,t,r){if(this.workerSources[e]||(this.workerSources[e]={}),this.workerSources[e][t]||(this.workerSources[e][t]={}),!this.workerSources[e][t][r]){const o={send:(t,r,o,i,n,s)=>{this.actor.send(t,r,o,e,n,s);},scheduler:this.actor.scheduler};this.workerSources[e][t][r]=new this.workerSourceTypes[t](o,this.getLayerIndex(e),this.getAvailableImages(e),this.isSpriteLoaded[e]);}return this.workerSources[e][t][r]}getDEMWorkerSource(e,t){return this.demWorkerSources[e]||(this.demWorkerSources[e]={}),this.demWorkerSources[e][t]||(this.demWorkerSources[e][t]=new i),this.demWorkerSources[e][t]}enforceCacheSizeLimit(t,r){e.enforceCacheSizeLimit(r);}getWorkerPerformanceMetrics(e,t,r){r(void 0,void 0);}}return "undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope&&(self.worker=new pe(self)),pe}));

  define(["./shared"],(function(e){function t(e,i){if(Array.isArray(e)){if(!Array.isArray(i)||e.length!==i.length)return !1;for(let o=0;o<e.length;o++)if(!t(e[o],i[o]))return !1;return !0}if("object"==typeof e&&null!==e&&null!==i){if("object"!=typeof i)return !1;if(Object.keys(e).length!==Object.keys(i).length)return !1;for(const o in e)if(!t(e[o],i[o]))return !1;return !0}return e===i}var i=o;function o(e){return !function(e){return "undefined"==typeof window||"undefined"==typeof document?"not a browser":Array.prototype&&Array.prototype.every&&Array.prototype.filter&&Array.prototype.forEach&&Array.prototype.indexOf&&Array.prototype.lastIndexOf&&Array.prototype.map&&Array.prototype.some&&Array.prototype.reduce&&Array.prototype.reduceRight&&Array.isArray?Function.prototype&&Function.prototype.bind?Object.keys&&Object.create&&Object.getPrototypeOf&&Object.getOwnPropertyNames&&Object.isSealed&&Object.isFrozen&&Object.isExtensible&&Object.getOwnPropertyDescriptor&&Object.defineProperty&&Object.defineProperties&&Object.seal&&Object.freeze&&Object.preventExtensions?"JSON"in window&&"parse"in JSON&&"stringify"in JSON?function(){if(!("Worker"in window&&"Blob"in window&&"URL"in window))return !1;var e,t,i=new Blob([""],{type:"text/javascript"}),o=URL.createObjectURL(i);try{t=new Worker(o),e=!0;}catch(t){e=!1;}return t&&t.terminate(),URL.revokeObjectURL(o),e}()?"Uint8ClampedArray"in window?ArrayBuffer.isView?function(){var e=document.createElement("canvas");e.width=e.height=1;var t=e.getContext("2d");if(!t)return !1;var i=t.getImageData(0,0,1,1);return i&&i.width===e.width}()?(void 0===r[t=e&&e.failIfMajorPerformanceCaveat]&&(r[t]=function(e){var t,i=function(e){var t=document.createElement("canvas"),i=Object.create(o.webGLContextAttributes);return i.failIfMajorPerformanceCaveat=e,t.getContext("webgl",i)||t.getContext("experimental-webgl",i)}(e);if(!i)return !1;try{t=i.createShader(i.VERTEX_SHADER);}catch(e){return !1}return !(!t||i.isContextLost())&&(i.shaderSource(t,"void main() {}"),i.compileShader(t),!0===i.getShaderParameter(t,i.COMPILE_STATUS))}(t)),r[t]?document.documentMode?"insufficient ECMAScript 6 support":void 0:"insufficient WebGL support"):"insufficient Canvas/getImageData support":"insufficient ArrayBuffer support":"insufficient Uint8ClampedArray support":"insufficient worker support":"insufficient JSON support":"insufficient Object support":"insufficient Function support":"insufficent Array support";var t;}(e)}var r={};function n(t,i,o){const r=e.window.document.createElement(t);return void 0!==i&&(r.className=i),o&&o.appendChild(r),r}function s(t,i,o){const r=e.window.document.createElementNS("http://www.w3.org/2000/svg",t);for(const e of Object.keys(i))r.setAttributeNS(null,e,i[e]);return o&&o.appendChild(r),r}o.webGLContextAttributes={antialias:!1,alpha:!0,stencil:!0,depth:!0};const a=e.window.document&&e.window.document.documentElement.style,l=a&&void 0!==a.userSelect?"userSelect":"WebkitUserSelect";let c;function h(){a&&l&&(c=a[l],a[l]="none");}function u(){a&&l&&(a[l]=c);}function _(t){t.preventDefault(),t.stopPropagation(),e.window.removeEventListener("click",_,!0);}function d(){e.window.addEventListener("click",_,!0),e.window.setTimeout((()=>{e.window.removeEventListener("click",_,!0);}),0);}function p(e,t){const i=e.getBoundingClientRect();return g(e,i,t)}function m(e,t){const i=e.getBoundingClientRect(),o=[];for(let r=0;r<t.length;r++)o.push(g(e,i,t[r]));return o}function f(t){return void 0!==e.window.InstallTrigger&&2===t.button&&t.ctrlKey&&e.window.navigator.platform.toUpperCase().indexOf("MAC")>=0?0:t.button}function g(t,i,o){const r=t.offsetWidth===i.width?1:t.offsetWidth/i.width;return new e.Point((o.clientX-i.left)*r,(o.clientY-i.top)*r)}function v(e,t){var i=t[0],o=t[1],r=t[2],n=t[3],s=i*n-r*o;return s?(e[0]=n*(s=1/s),e[1]=-o*s,e[2]=-r*s,e[3]=i*s,e):null}function x(e){const{userImage:t}=e;return !!(t&&t.render&&t.render())&&(e.data.replace(new Uint8Array(t.data.buffer)),!0)}class y extends e.Evented{constructor(){super(),this.images={},this.updatedImages={},this.callbackDispatchedThisFrame={},this.loaded=!1,this.requestors=[],this.patterns={},this.atlasImage=new e.RGBAImage({width:1,height:1}),this.dirty=!0;}isLoaded(){return this.loaded}setLoaded(e){if(this.loaded!==e&&(this.loaded=e,e)){for(const{ids:e,callback:t}of this.requestors)this._notify(e,t);this.requestors=[];}}hasImage(e){return !!this.getImage(e)}getImage(e){return this.images[e]}addImage(e,t){this._validate(e,t)&&(this.images[e]=t);}_validate(t,i){let o=!0;return this._validateStretch(i.stretchX,i.data&&i.data.width)||(this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))),o=!1),this._validateStretch(i.stretchY,i.data&&i.data.height)||(this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))),o=!1),this._validateContent(i.content,i)||(this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))),o=!1),o}_validateStretch(e,t){if(!e)return !0;let i=0;for(const o of e){if(o[0]<i||o[1]<o[0]||t<o[1])return !1;i=o[1];}return !0}_validateContent(e,t){return !(e&&(4!==e.length||e[0]<0||t.data.width<e[0]||e[1]<0||t.data.height<e[1]||e[2]<0||t.data.width<e[2]||e[3]<0||t.data.height<e[3]||e[2]<e[0]||e[3]<e[1]))}updateImage(e,t){t.version=this.images[e].version+1,this.images[e]=t,this.updatedImages[e]=!0;}removeImage(e){const t=this.images[e];delete this.images[e],delete this.patterns[e],t.userImage&&t.userImage.onRemove&&t.userImage.onRemove();}listImages(){return Object.keys(this.images)}getImages(e,t){let i=!0;if(!this.isLoaded())for(const t of e)this.images[t]||(i=!1);this.isLoaded()||i?this._notify(e,t):this.requestors.push({ids:e,callback:t});}_notify(t,i){const o={};for(const i of t){this.images[i]||this.fire(new e.Event("styleimagemissing",{id:i}));const t=this.images[i];t?o[i]={data:t.data.clone(),pixelRatio:t.pixelRatio,sdf:t.sdf,version:t.version,stretchX:t.stretchX,stretchY:t.stretchY,content:t.content,hasRenderCallback:Boolean(t.userImage&&t.userImage.render)}:e.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);}i(null,o);}getPixelSize(){const{width:e,height:t}=this.atlasImage;return {width:e,height:t}}getPattern(t){const i=this.patterns[t],o=this.getImage(t);if(!o)return null;if(i&&i.position.version===o.version)return i.position;if(i)i.position.version=o.version;else {const i={w:o.data.width+2,h:o.data.height+2,x:0,y:0},r=new e.ImagePosition(i,o);this.patterns[t]={bin:i,position:r};}return this._updatePatternAtlas(),this.patterns[t].position}bind(t){const i=t.gl;this.atlasTexture?this.dirty&&(this.atlasTexture.update(this.atlasImage),this.dirty=!1):this.atlasTexture=new e.Texture(t,this.atlasImage,i.RGBA),this.atlasTexture&&this.atlasTexture.bind(i.LINEAR,i.CLAMP_TO_EDGE);}_updatePatternAtlas(){const t=[];for(const e in this.patterns)t.push(this.patterns[e].bin);const{w:i,h:o}=e.potpack(t),r=this.atlasImage;r.resize({width:i||1,height:o||1});for(const t in this.patterns){const{bin:i}=this.patterns[t],o=i.x+1,n=i.y+1,s=this.images[t].data,a=s.width,l=s.height;e.RGBAImage.copy(s,r,{x:0,y:0},{x:o,y:n},{width:a,height:l}),e.RGBAImage.copy(s,r,{x:0,y:l-1},{x:o,y:n-1},{width:a,height:1}),e.RGBAImage.copy(s,r,{x:0,y:0},{x:o,y:n+l},{width:a,height:1}),e.RGBAImage.copy(s,r,{x:a-1,y:0},{x:o-1,y:n},{width:1,height:l}),e.RGBAImage.copy(s,r,{x:0,y:0},{x:o+a,y:n},{width:1,height:l});}this.dirty=!0;}beginFrame(){this.callbackDispatchedThisFrame={};}dispatchRenderCallbacks(e){for(const t of e){if(this.callbackDispatchedThisFrame[t])continue;this.callbackDispatchedThisFrame[t]=!0;const e=this.images[t];x(e)&&this.updateImage(t,e);}}}const b=new e.Properties({anchor:new e.DataConstantProperty(e.spec.light.anchor),position:new class{constructor(){this.specification=e.spec.light.position;}possiblyEvaluate(t,i){return function([t,i,o]){const r=e.degToRad(i+90),n=e.degToRad(o);return {x:t*Math.cos(r)*Math.sin(n),y:t*Math.sin(r)*Math.sin(n),z:t*Math.cos(n),azimuthal:i,polar:o}}(t.expression.evaluate(i))}interpolate(t,i,o){return {x:e.number(t.x,i.x,o),y:e.number(t.y,i.y,o),z:e.number(t.z,i.z,o),azimuthal:e.number(t.azimuthal,i.azimuthal,o),polar:e.number(t.polar,i.polar,o)}}},color:new e.DataConstantProperty(e.spec.light.color),intensity:new e.DataConstantProperty(e.spec.light.intensity)});class w extends e.Evented{constructor(t){super(),this._transitionable=new e.Transitionable(b),this.setLight(t),this._transitioning=this._transitionable.untransitioned();}getLight(){return this._transitionable.serialize()}setLight(t,i={}){if(!this._validate(e.validateLight,t,i))for(const i in t){const o=t[i];e.endsWith(i,"-transition")?this._transitionable.setTransition(i.slice(0,-11),o):this._transitionable.setValue(i,o);}}updateTransitions(e){this._transitioning=this._transitionable.transitioned(e,this._transitioning);}hasTransition(){return this._transitioning.hasTransition()}recalculate(e){this.properties=this._transitioning.possiblyEvaluate(e);}_validate(t,i,o){return (!o||!1!==o.validate)&&e.emitValidationErrors(this,t.call(e.validateStyle,e.extend({value:i,style:{glyphs:!0,sprite:!0},styleSpec:e.spec})))}}const T=new e.Properties({source:new e.DataConstantProperty(e.spec.terrain.source),exaggeration:new e.DataConstantProperty(e.spec.terrain.exaggeration)});let E=class extends e.Evented{constructor(t,i){super(),this._transitionable=new e.Transitionable(T),this.set(t),this._transitioning=this._transitionable.untransitioned(),this.drapeRenderMode=i;}get(){return this._transitionable.serialize()}set(t){for(const i in t){const o=t[i];e.endsWith(i,"-transition")?this._transitionable.setTransition(i.slice(0,-11),o):this._transitionable.setValue(i,o);}}updateTransitions(e){this._transitioning=this._transitionable.transitioned(e,this._transitioning);}hasTransition(){return this._transitioning.hasTransition()}recalculate(e){this.properties=this._transitioning.possiblyEvaluate(e);}};function C(t,i,o,r){const n=e.smoothstep(45,65,o),[s,a]=M(t,r),l=e.length(i);let c=1-Math.min(1,Math.exp((l-s)/(a-s)*-6));return c*=c*c,c=Math.min(1,1.00747*c),c*n*t.alpha}function M(e,t){const i=.5/Math.tan(.5*t);return [e.range[0]+i,e.range[1]+i]}const I=new e.Properties({range:new e.DataConstantProperty(e.spec.fog.range),color:new e.DataConstantProperty(e.spec.fog.color),"high-color":new e.DataConstantProperty(e.spec.fog["high-color"]),"space-color":new e.DataConstantProperty(e.spec.fog["space-color"]),"horizon-blend":new e.DataConstantProperty(e.spec.fog["horizon-blend"]),"star-intensity":new e.DataConstantProperty(e.spec.fog["star-intensity"])});class P extends e.Evented{constructor(t,i){super(),this._transitionable=new e.Transitionable(I),this.set(t),this._transitioning=this._transitionable.untransitioned(),this._transform=i;}get state(){const t=this._transform,i="globe"===t.projection.name,o=e.globeToMercatorTransition(t.zoom),r=this.properties.get("range"),n=[.5,3];return {range:i?[e.number(n[0],r[0],o),e.number(n[1],r[1],o)]:r,horizonBlend:this.properties.get("horizon-blend"),alpha:this.properties.get("color").a}}get(){return this._transitionable.serialize()}set(t,i={}){if(!this._validate(e.validateFog,t,i)){for(const i of Object.keys(e.spec.fog))t&&void 0===t[i]&&(t[i]=e.spec.fog[i].default);for(const i in t){const o=t[i];e.endsWith(i,"-transition")?this._transitionable.setTransition(i.slice(0,-11),o):this._transitionable.setValue(i,o);}}}getOpacity(t){if(!this._transform.projection.supportsFog)return 0;const i=this.properties&&this.properties.get("color")||1;return ("globe"===this._transform.projection.name?1:e.smoothstep(45,65,t))*i.a}getOpacityAtLatLng(t,i){return this._transform.projection.supportsFog?function(t,i,o){const r=e.MercatorCoordinate.fromLngLat(i),n=o.elevation?o.elevation.getAtPointOrZero(r):0,s=[r.x,r.y,n];return e.transformMat4(s,s,o.mercatorFogMatrix),C(t,s,o.pitch,o._fov)}(this.state,t,i):0}getFovAdjustedRange(e){return this._transform.projection.supportsFog?M(this.state,e):[0,1]}updateTransitions(e){this._transitioning=this._transitionable.transitioned(e,this._transitioning);}hasTransition(){return this._transitioning.hasTransition()}recalculate(e){this.properties=this._transitioning.possiblyEvaluate(e);}_validate(t,i,o){return (!o||!1!==o.validate)&&e.emitValidationErrors(this,t.call(e.validateStyle,e.extend({value:i,style:{glyphs:!0,sprite:!0},styleSpec:e.spec})))}}class S{constructor(t,i){this.workerPool=t,this.actors=[],this.currentActor=0,this.id=e.uniqueId();const o=this.workerPool.acquire(this.id);for(let e=0;e<o.length;e++){const t=new S.Actor(o[e],i,this.id);t.name=`Worker ${e}`,this.actors.push(t);}this.ready=!1,this.broadcast("checkIfReady",null,(()=>{this.ready=!0;}));}broadcast(t,i,o){e.asyncAll(this.actors,((e,o)=>{e.send(t,i,o);}),o=o||function(){});}getActor(){return this.currentActor=(this.currentActor+1)%this.actors.length,this.actors[this.currentActor]}remove(){this.actors.forEach((e=>{e.remove();})),this.actors=[],this.workerPool.release(this.id);}}function D(t,i,o){return i*(e.EXTENT/(t.tileSize*Math.pow(2,o-t.tileID.overscaledZ)))}S.Actor=e.Actor;class L{constructor(e,t,i,o){this.screenBounds=e,this.cameraPoint=t,this._screenRaycastCache={},this._cameraRaycastCache={},this.isAboveHorizon=i,this.screenGeometry=this.bufferedScreenGeometry(0),this.screenGeometryMercator=this._bufferedScreenMercator(0,o);}static createFromScreenPoints(t,i){let o,r;if(t instanceof e.Point||"number"==typeof t[0]){const n=e.Point.convert(t);o=[n],r=i.isPointAboveHorizon(n);}else {const n=e.Point.convert(t[0]),s=e.Point.convert(t[1]);o=[n,s],r=e.polygonizeBounds(n,s).every((e=>i.isPointAboveHorizon(e)));}return new L(o,i.getCameraPoint(),r,i)}isPointQuery(){return 1===this.screenBounds.length}bufferedScreenGeometry(t){return e.polygonizeBounds(this.screenBounds[0],1===this.screenBounds.length?this.screenBounds[0]:this.screenBounds[1],t)}bufferedCameraGeometry(t){const i=this.screenBounds[0],o=1===this.screenBounds.length?this.screenBounds[0].add(new e.Point(1,1)):this.screenBounds[1],r=e.polygonizeBounds(i,o,0,!1);return this.cameraPoint.y>o.y&&(this.cameraPoint.x>i.x&&this.cameraPoint.x<o.x?r.splice(3,0,this.cameraPoint):this.cameraPoint.x>=o.x?r[2]=this.cameraPoint:this.cameraPoint.x<=i.x&&(r[3]=this.cameraPoint)),e.bufferConvexPolygon(r,t)}bufferedCameraGeometryGlobe(t){const i=this.screenBounds[0],o=1===this.screenBounds.length?this.screenBounds[0].add(new e.Point(1,1)):this.screenBounds[1],r=e.polygonizeBounds(i,o,t),n=this.cameraPoint.clone();switch(3*((n.y>i.y)+(n.y>o.y))+((n.x>i.x)+(n.x>o.x))){case 0:r[0]=n,r[4]=n.clone();break;case 1:r.splice(1,0,n);break;case 2:r[1]=n;break;case 3:r.splice(4,0,n);break;case 5:r.splice(2,0,n);break;case 6:r[3]=n;break;case 7:r.splice(3,0,n);break;case 8:r[2]=n;}return r}containsTile(t,i,o,r=0){const n=t.queryPadding/i._pixelsPerMercatorPixel+1,s=o?this._bufferedCameraMercator(n,i):this._bufferedScreenMercator(n,i);let a=t.tileID.wrap+(s.unwrapped?r:0);const l=s.polygon.map((i=>e.getTilePoint(t.tileTransform,i,a)));if(!e.polygonIntersectsBox(l,0,0,e.EXTENT,e.EXTENT))return;a=t.tileID.wrap+(this.screenGeometryMercator.unwrapped?r:0);const c=this.screenGeometryMercator.polygon.map((i=>e.getTileVec3(t.tileTransform,i,a))),h=c.map((t=>new e.Point(t[0],t[1]))),u=i.getFreeCameraOptions().position||new e.MercatorCoordinate(0,0,0),_=e.getTileVec3(t.tileTransform,u,a),d=c.map((t=>{const i=e.sub(t,t,_);return e.normalize(i,i),new e.Ray(_,i)})),p=D(t,1,i.zoom)*i._pixelsPerMercatorPixel;return {queryGeometry:this,tilespaceGeometry:h,tilespaceRays:d,bufferedTilespaceGeometry:l,bufferedTilespaceBounds:(m=e.getBounds(l),m.min.x=e.clamp(m.min.x,0,e.EXTENT),m.min.y=e.clamp(m.min.y,0,e.EXTENT),m.max.x=e.clamp(m.max.x,0,e.EXTENT),m.max.y=e.clamp(m.max.y,0,e.EXTENT),m),tile:t,tileID:t.tileID,pixelToTileUnitsFactor:p};var m;}_bufferedScreenMercator(e,t){const i=R(e);if(this._screenRaycastCache[i])return this._screenRaycastCache[i];{let o;return o="globe"===t.projection.name?this._projectAndResample(this.bufferedScreenGeometry(e),t):{polygon:this.bufferedScreenGeometry(e).map((e=>t.pointCoordinate3D(e))),unwrapped:!0},this._screenRaycastCache[i]=o,o}}_bufferedCameraMercator(e,t){const i=R(e);if(this._cameraRaycastCache[i])return this._cameraRaycastCache[i];{let o;return o="globe"===t.projection.name?this._projectAndResample(this.bufferedCameraGeometryGlobe(e),t):{polygon:this.bufferedCameraGeometry(e).map((e=>t.pointCoordinate3D(e))),unwrapped:!0},this._cameraRaycastCache[i]=o,o}}_projectAndResample(t,i){const o=function(t,i){const o=e.multiply([],i.pixelMatrix,i.globeMatrix),r=[0,-e.GLOBE_RADIUS,0,1],n=[0,e.GLOBE_RADIUS,0,1],s=[0,0,0,1];e.transformMat4$1(r,r,o),e.transformMat4$1(n,n,o),e.transformMat4$1(s,s,o);const a=new e.Point(r[0]/r[3],r[1]/r[3]),l=new e.Point(n[0]/n[3],n[1]/n[3]),c=e.polygonContainsPoint(t,a)&&r[3]<s[3],h=e.polygonContainsPoint(t,l)&&n[3]<s[3];if(!c&&!h)return null;const u=function(e,t,i){for(let o=1;o<e.length;o++){const r=z(t.pointCoordinate3D(e[o-1]).x),n=z(t.pointCoordinate3D(e[o]).x);if(i<0){if(r<n)return {idx:o,t:-r/(n-1-r)}}else if(n<r)return {idx:o,t:(1-r)/(n+1-r)}}return null}(t,i,c?-1:1);if(!u)return null;const{idx:_,t:d}=u;let p=_>1?A(t.slice(0,_),i):[],m=_<t.length?A(t.slice(_),i):[];p=p.map((t=>new e.Point(z(t.x),t.y))),m=m.map((t=>new e.Point(z(t.x),t.y)));const f=[...p];0===f.length&&f.push(m[m.length-1]);const g=e.number(f[f.length-1].y,(0===m.length?p[0]:m[0]).y,d);let v;return v=c?[new e.Point(0,g),new e.Point(0,0),new e.Point(1,0),new e.Point(1,g)]:[new e.Point(1,g),new e.Point(1,1),new e.Point(0,1),new e.Point(0,g)],f.push(...v),0===m.length?f.push(p[0]):f.push(...m),{polygon:f.map((t=>new e.MercatorCoordinate(t.x,t.y))),unwrapped:!1}}(t,i);if(o)return o;const r=function(t,i){let o=!1,r=-1/0,n=0;for(let e=0;e<t.length-1;e++)t[e].x>r&&(r=t[e].x,n=e);for(let e=0;e<t.length-1;e++){const i=(n+e)%(t.length-1),r=t[i],s=t[i+1];Math.abs(r.x-s.x)>.5&&(r.x<s.x?(r.x+=1,0===i&&(t[t.length-1].x+=1)):(s.x+=1,i+1===t.length-1&&(t[0].x+=1)),o=!0);}const s=e.mercatorXfromLng(i.center.lng);return o&&s<Math.abs(s-1)&&t.forEach((e=>{e.x-=1;})),{polygon:t,unwrapped:o}}(A(t,i).map((t=>new e.Point(z(t.x),t.y))),i);return {polygon:r.polygon.map((t=>new e.MercatorCoordinate(t.x,t.y))),unwrapped:r.unwrapped}}}function A(t,i){return e.resample(t,(e=>{const t=i.pointCoordinate3D(e);e.x=t.x,e.y=t.y;}),1/256)}function z(e){return e<0?1+e%1:e%1}function R(e){return 100*e|0}function O(t,i,o,r,n){const s=function(o,r){if(o)return n(o);if(r){t.url&&r.tiles&&t.tiles&&delete t.tiles;const o=e.pick(e.extend(r,t),["tiles","minzoom","maxzoom","attribution","mapbox_logo","bounds","scheme","tileSize","encoding"]);r.vector_layers&&(o.vectorLayers=r.vector_layers,o.vectorLayerIds=o.vectorLayers.map((e=>e.id))),o.tiles=i.canonicalizeTileset(o,t.url),n(null,o);}};return t.url?e.getJSON(i.transformRequest(i.normalizeSourceURL(t.url,null,o,r),e.ResourceType.Source),s):e.exported.frame((()=>s(null,t)))}class B{constructor(t,i,o){this.bounds=e.LngLatBounds.convert(this.validateBounds(t)),this.minzoom=i||0,this.maxzoom=o||24;}validateBounds(e){return Array.isArray(e)&&4===e.length?[Math.max(-180,e[0]),Math.max(-90,e[1]),Math.min(180,e[2]),Math.min(90,e[3])]:[-180,-90,180,90]}contains(t){const i=Math.pow(2,t.z),o=Math.floor(e.mercatorXfromLng(this.bounds.getWest())*i),r=Math.floor(e.mercatorYfromLat(this.bounds.getNorth())*i),n=Math.ceil(e.mercatorXfromLng(this.bounds.getEast())*i),s=Math.ceil(e.mercatorYfromLat(this.bounds.getSouth())*i);return t.x>=o&&t.x<n&&t.y>=r&&t.y<s}}class k{constructor(e,t,i){this.context=e;const o=e.gl;this.buffer=o.createBuffer(),this.dynamicDraw=Boolean(i),this.context.unbindVAO(),e.bindElementBuffer.set(this.buffer),o.bufferData(o.ELEMENT_ARRAY_BUFFER,t.arrayBuffer,this.dynamicDraw?o.DYNAMIC_DRAW:o.STATIC_DRAW),this.dynamicDraw||t.destroy();}bind(){this.context.bindElementBuffer.set(this.buffer);}updateData(e){const t=this.context.gl;this.context.unbindVAO(),this.bind(),t.bufferSubData(t.ELEMENT_ARRAY_BUFFER,0,e.arrayBuffer);}destroy(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);}}const F={Int8:"BYTE",Uint8:"UNSIGNED_BYTE",Int16:"SHORT",Uint16:"UNSIGNED_SHORT",Int32:"INT",Uint32:"UNSIGNED_INT",Float32:"FLOAT"};class U{constructor(e,t,i,o){this.length=t.length,this.attributes=i,this.itemSize=t.bytesPerElement,this.dynamicDraw=o,this.context=e;const r=e.gl;this.buffer=r.createBuffer(),e.bindVertexBuffer.set(this.buffer),r.bufferData(r.ARRAY_BUFFER,t.arrayBuffer,this.dynamicDraw?r.DYNAMIC_DRAW:r.STATIC_DRAW),this.dynamicDraw||t.destroy();}bind(){this.context.bindVertexBuffer.set(this.buffer);}updateData(e){const t=this.context.gl;this.bind(),t.bufferSubData(t.ARRAY_BUFFER,0,e.arrayBuffer);}enableAttributes(e,t){for(let i=0;i<this.attributes.length;i++){const o=t.attributes[this.attributes[i].name];void 0!==o&&e.enableVertexAttribArray(o);}}setVertexAttribPointers(e,t,i){for(let o=0;o<this.attributes.length;o++){const r=this.attributes[o],n=t.attributes[r.name];void 0!==n&&e.vertexAttribPointer(n,r.components,e[F[r.type]],!1,this.itemSize,r.offset+this.itemSize*(i||0));}}destroy(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);}}class N{constructor(e){this.gl=e.gl,this.default=this.getDefault(),this.current=this.default,this.dirty=!1;}get(){return this.current}set(e){}getDefault(){return this.default}setDefault(){this.set(this.default);}}class j extends N{getDefault(){return e.Color.transparent}set(e){const t=this.current;(e.r!==t.r||e.g!==t.g||e.b!==t.b||e.a!==t.a||this.dirty)&&(this.gl.clearColor(e.r,e.g,e.b,e.a),this.current=e,this.dirty=!1);}}class G extends N{getDefault(){return 1}set(e){(e!==this.current||this.dirty)&&(this.gl.clearDepth(e),this.current=e,this.dirty=!1);}}class Z extends N{getDefault(){return 0}set(e){(e!==this.current||this.dirty)&&(this.gl.clearStencil(e),this.current=e,this.dirty=!1);}}class V extends N{getDefault(){return [!0,!0,!0,!0]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||e[3]!==t[3]||this.dirty)&&(this.gl.colorMask(e[0],e[1],e[2],e[3]),this.current=e,this.dirty=!1);}}class W extends N{getDefault(){return !0}set(e){(e!==this.current||this.dirty)&&(this.gl.depthMask(e),this.current=e,this.dirty=!1);}}class X extends N{getDefault(){return 255}set(e){(e!==this.current||this.dirty)&&(this.gl.stencilMask(e),this.current=e,this.dirty=!1);}}class q extends N{getDefault(){return {func:this.gl.ALWAYS,ref:0,mask:255}}set(e){const t=this.current;(e.func!==t.func||e.ref!==t.ref||e.mask!==t.mask||this.dirty)&&(this.gl.stencilFunc(e.func,e.ref,e.mask),this.current=e,this.dirty=!1);}}class $ extends N{getDefault(){const e=this.gl;return [e.KEEP,e.KEEP,e.KEEP]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||this.dirty)&&(this.gl.stencilOp(e[0],e[1],e[2]),this.current=e,this.dirty=!1);}}class H extends N{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.STENCIL_TEST):t.disable(t.STENCIL_TEST),this.current=e,this.dirty=!1;}}class Y extends N{getDefault(){return [0,1]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||this.dirty)&&(this.gl.depthRange(e[0],e[1]),this.current=e,this.dirty=!1);}}class K extends N{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.DEPTH_TEST):t.disable(t.DEPTH_TEST),this.current=e,this.dirty=!1;}}class J extends N{getDefault(){return this.gl.LESS}set(e){(e!==this.current||this.dirty)&&(this.gl.depthFunc(e),this.current=e,this.dirty=!1);}}class Q extends N{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.BLEND):t.disable(t.BLEND),this.current=e,this.dirty=!1;}}class ee extends N{getDefault(){const e=this.gl;return [e.ONE,e.ZERO]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||this.dirty)&&(this.gl.blendFunc(e[0],e[1]),this.current=e,this.dirty=!1);}}class te extends N{getDefault(){return e.Color.transparent}set(e){const t=this.current;(e.r!==t.r||e.g!==t.g||e.b!==t.b||e.a!==t.a||this.dirty)&&(this.gl.blendColor(e.r,e.g,e.b,e.a),this.current=e,this.dirty=!1);}}class ie extends N{getDefault(){return this.gl.FUNC_ADD}set(e){(e!==this.current||this.dirty)&&(this.gl.blendEquation(e),this.current=e,this.dirty=!1);}}class oe extends N{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.CULL_FACE):t.disable(t.CULL_FACE),this.current=e,this.dirty=!1;}}class re extends N{getDefault(){return this.gl.BACK}set(e){(e!==this.current||this.dirty)&&(this.gl.cullFace(e),this.current=e,this.dirty=!1);}}class ne extends N{getDefault(){return this.gl.CCW}set(e){(e!==this.current||this.dirty)&&(this.gl.frontFace(e),this.current=e,this.dirty=!1);}}let se,ae=class extends N{getDefault(){return null}set(e){(e!==this.current||this.dirty)&&(this.gl.useProgram(e),this.current=e,this.dirty=!1);}};class le extends N{getDefault(){return this.gl.TEXTURE0}set(e){(e!==this.current||this.dirty)&&(this.gl.activeTexture(e),this.current=e,this.dirty=!1);}}class ce extends N{getDefault(){const e=this.gl;return [0,0,e.drawingBufferWidth,e.drawingBufferHeight]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||e[3]!==t[3]||this.dirty)&&(this.gl.viewport(e[0],e[1],e[2],e[3]),this.current=e,this.dirty=!1);}}class he extends N{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,e),this.current=e,this.dirty=!1;}}class ue extends N{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindRenderbuffer(t.RENDERBUFFER,e),this.current=e,this.dirty=!1;}}class _e extends N{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindTexture(t.TEXTURE_2D,e),this.current=e,this.dirty=!1;}}class de extends N{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,e),this.current=e,this.dirty=!1;}}class pe extends N{getDefault(){return null}set(e){const t=this.gl;t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e),this.current=e,this.dirty=!1;}}class me extends N{constructor(e){super(e),this.vao=e.extVertexArrayObject;}getDefault(){return null}set(e){this.vao&&(e!==this.current||this.dirty)&&(this.vao.bindVertexArrayOES(e),this.current=e,this.dirty=!1);}}class fe extends N{getDefault(){return 4}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.pixelStorei(t.UNPACK_ALIGNMENT,e),this.current=e,this.dirty=!1;}}class ge extends N{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e),this.current=e,this.dirty=!1;}}class ve extends N{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,e),this.current=e,this.dirty=!1;}}class xe extends N{constructor(e,t){super(e),this.context=e,this.parent=t;}getDefault(){return null}}class ye extends xe{setDirty(){this.dirty=!0;}set(e){if(e===this.current&&!this.dirty)return;this.context.bindFramebuffer.set(this.parent);const t=this.gl;t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),this.current=e,this.dirty=!1;}}class be extends xe{attachment(){return this.gl.DEPTH_ATTACHMENT}set(e){if(e===this.current&&!this.dirty)return;this.context.bindFramebuffer.set(this.parent);const t=this.gl;t.framebufferRenderbuffer(t.FRAMEBUFFER,this.attachment(),t.RENDERBUFFER,e),this.current=e,this.dirty=!1;}}class we extends be{attachment(){return this.gl.DEPTH_STENCIL_ATTACHMENT}}class Te{constructor(e,t,i,o){this.context=e,this.width=t,this.height=i;const r=this.framebuffer=e.gl.createFramebuffer();this.colorAttachment=new ye(e,r),o&&(this.depthAttachment=new be(e,r));}destroy(){const e=this.context.gl,t=this.colorAttachment.get();if(t&&e.deleteTexture(t),this.depthAttachment){const t=this.depthAttachment.get();t&&e.deleteRenderbuffer(t);}e.deleteFramebuffer(this.framebuffer);}}class Ee{constructor(e,t=!1){if(this.gl=e,this.isWebGL2=t,this.extVertexArrayObject=this.gl.getExtension("OES_vertex_array_object"),t){const t=e;this.extVertexArrayObject={createVertexArrayOES:t.createVertexArray.bind(e),deleteVertexArrayOES:t.deleteVertexArray.bind(e),bindVertexArrayOES:t.bindVertexArray.bind(e)};}this.clearColor=new j(this),this.clearDepth=new G(this),this.clearStencil=new Z(this),this.colorMask=new V(this),this.depthMask=new W(this),this.stencilMask=new X(this),this.stencilFunc=new q(this),this.stencilOp=new $(this),this.stencilTest=new H(this),this.depthRange=new Y(this),this.depthTest=new K(this),this.depthFunc=new J(this),this.blend=new Q(this),this.blendFunc=new ee(this),this.blendColor=new te(this),this.blendEquation=new ie(this),this.cullFace=new oe(this),this.cullFaceSide=new re(this),this.frontFace=new ne(this),this.program=new ae(this),this.activeTexture=new le(this),this.viewport=new ce(this),this.bindFramebuffer=new he(this),this.bindRenderbuffer=new ue(this),this.bindTexture=new _e(this),this.bindVertexBuffer=new de(this),this.bindElementBuffer=new pe(this),this.bindVertexArrayOES=this.extVertexArrayObject&&new me(this),this.pixelStoreUnpack=new fe(this),this.pixelStoreUnpackPremultiplyAlpha=new ge(this),this.pixelStoreUnpackFlipY=new ve(this),this.extTextureFilterAnisotropic=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.extTextureFilterAnisotropic&&(this.extTextureFilterAnisotropicMax=e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),this.extTextureFilterAnisotropicForceOff=!1,this.extStandardDerivativesForceOff=!1,this.extDebugRendererInfo=e.getExtension("WEBGL_debug_renderer_info"),this.extDebugRendererInfo&&(this.renderer=e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL),this.vendor=e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)),t||(this.extTextureHalfFloat=e.getExtension("OES_texture_half_float")),(t||this.extTextureHalfFloat&&e.getExtension("OES_texture_half_float_linear"))&&(this.extRenderToTextureHalfFloat=e.getExtension("EXT_color_buffer_half_float")),this.extStandardDerivatives=t||e.getExtension("OES_standard_derivatives"),this.extTimerQuery=e.getExtension("EXT_disjoint_timer_query"),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE);}setDefault(){this.unbindVAO(),this.clearColor.setDefault(),this.clearDepth.setDefault(),this.clearStencil.setDefault(),this.colorMask.setDefault(),this.depthMask.setDefault(),this.stencilMask.setDefault(),this.stencilFunc.setDefault(),this.stencilOp.setDefault(),this.stencilTest.setDefault(),this.depthRange.setDefault(),this.depthTest.setDefault(),this.depthFunc.setDefault(),this.blend.setDefault(),this.blendFunc.setDefault(),this.blendColor.setDefault(),this.blendEquation.setDefault(),this.cullFace.setDefault(),this.cullFaceSide.setDefault(),this.frontFace.setDefault(),this.program.setDefault(),this.activeTexture.setDefault(),this.bindFramebuffer.setDefault(),this.pixelStoreUnpack.setDefault(),this.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.pixelStoreUnpackFlipY.setDefault();}setDirty(){this.clearColor.dirty=!0,this.clearDepth.dirty=!0,this.clearStencil.dirty=!0,this.colorMask.dirty=!0,this.depthMask.dirty=!0,this.stencilMask.dirty=!0,this.stencilFunc.dirty=!0,this.stencilOp.dirty=!0,this.stencilTest.dirty=!0,this.depthRange.dirty=!0,this.depthTest.dirty=!0,this.depthFunc.dirty=!0,this.blend.dirty=!0,this.blendFunc.dirty=!0,this.blendColor.dirty=!0,this.blendEquation.dirty=!0,this.cullFace.dirty=!0,this.cullFaceSide.dirty=!0,this.frontFace.dirty=!0,this.program.dirty=!0,this.activeTexture.dirty=!0,this.viewport.dirty=!0,this.bindFramebuffer.dirty=!0,this.bindRenderbuffer.dirty=!0,this.bindTexture.dirty=!0,this.bindVertexBuffer.dirty=!0,this.bindElementBuffer.dirty=!0,this.extVertexArrayObject&&(this.bindVertexArrayOES.dirty=!0),this.pixelStoreUnpack.dirty=!0,this.pixelStoreUnpackPremultiplyAlpha.dirty=!0,this.pixelStoreUnpackFlipY.dirty=!0;}createIndexBuffer(e,t){return new k(this,e,t)}createVertexBuffer(e,t,i){return new U(this,e,t,i)}createRenderbuffer(e,t,i){const o=this.gl,r=o.createRenderbuffer();return this.bindRenderbuffer.set(r),o.renderbufferStorage(o.RENDERBUFFER,e,t,i),this.bindRenderbuffer.set(null),r}createFramebuffer(e,t,i){return new Te(this,e,t,i)}clear({color:e,depth:t,stencil:i}){const o=this.gl;let r=0;e&&(r|=o.COLOR_BUFFER_BIT,this.clearColor.set(e),this.colorMask.set([!0,!0,!0,!0])),void 0!==t&&(r|=o.DEPTH_BUFFER_BIT,this.depthRange.set([0,1]),this.clearDepth.set(t),this.depthMask.set(!0)),void 0!==i&&(r|=o.STENCIL_BUFFER_BIT,this.clearStencil.set(i),this.stencilMask.set(255)),o.clear(r);}setCullFace(e){!1===e.enable?this.cullFace.set(!1):(this.cullFace.set(!0),this.cullFaceSide.set(e.mode),this.frontFace.set(e.frontFace));}setDepthMode(e){e.func!==this.gl.ALWAYS||e.mask?(this.depthTest.set(!0),this.depthFunc.set(e.func),this.depthMask.set(e.mask),this.depthRange.set(e.range)):this.depthTest.set(!1);}setStencilMode(e){e.test.func!==this.gl.ALWAYS||e.mask?(this.stencilTest.set(!0),this.stencilMask.set(e.mask),this.stencilOp.set([e.fail,e.depthFail,e.pass]),this.stencilFunc.set({func:e.test.func,ref:e.ref,mask:e.test.mask})):this.stencilTest.set(!1);}setColorMode(i){t(i.blendFunction,e.ColorMode.Replace)?this.blend.set(!1):(this.blend.set(!0),this.blendFunc.set(i.blendFunction),this.blendColor.set(i.blendColor)),this.colorMask.set(i.mask);}unbindVAO(){this.extVertexArrayObject&&this.bindVertexArrayOES.set(null);}}class Ce extends e.Evented{constructor(t,i,o,r){if(super(),this.id=t,this.dispatcher=o,this.type="vector",this.minzoom=0,this.maxzoom=22,this.scheme="xyz",this.tileSize=512,this.reparseOverscaled=!0,this.isTileClipped=!0,this._loaded=!1,e.extend(this,e.pick(i,["url","scheme","tileSize","promoteId"])),this._options=e.extend({type:"vector"},i),this._collectResourceTiming=i.collectResourceTiming,512!==this.tileSize)throw new Error("vector tile sources must have a tileSize of 512");this.setEventedParent(r),this._tileWorkers={},this._deduped=new e.DedupedRequest;}load(t){this._loaded=!1,this.fire(new e.Event("dataloading",{dataType:"source"}));const i=Array.isArray(this.map._language)?this.map._language.join():this.map._language,o=this.map._worldview;this._tileJSONRequest=O(this._options,this.map._requestManager,i,o,((r,n)=>{this._tileJSONRequest=null,this._loaded=!0,r?(i&&console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`),o&&2!==o.length&&console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`),this.fire(new e.ErrorEvent(r))):n&&(e.extend(this,n),n.bounds&&(this.tileBounds=new B(n.bounds,this.minzoom,this.maxzoom)),e.postTurnstileEvent(n.tiles,this.map._requestManager._customAccessToken),this.fire(new e.Event("data",{dataType:"source",sourceDataType:"metadata"})),this.fire(new e.Event("data",{dataType:"source",sourceDataType:"content"}))),t&&t(r);}));}loaded(){return this._loaded}hasTile(e){return !this.tileBounds||this.tileBounds.contains(e.canonical)}onAdd(e){this.map=e,this.load();}reload(){this.cancelTileJSONRequest(),this.load((()=>this.map.style._clearSource(this.id)));}setTiles(e){return this._options.tiles=e,this.reload(),this}setUrl(e){return this.url=e,this._options.url=e,this.reload(),this}onRemove(){this.cancelTileJSONRequest();}serialize(){return e.extend({},this._options)}loadTile(t,i){const o=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme)),r={request:this.map._requestManager.transformRequest(o,e.ResourceType.Tile),data:void 0,uid:t.uid,tileID:t.tileID,tileZoom:t.tileZoom,zoom:t.tileID.overscaledZ,tileSize:this.tileSize*t.tileID.overscaleFactor(),type:this.type,source:this.id,pixelRatio:e.exported.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId,isSymbolTile:t.isSymbolTile};if(r.request.collectResourceTiming=this._collectResourceTiming,t.actor&&"expired"!==t.state)"loading"===t.state?t.reloadCallback=i:t.request=t.actor.send("reloadTile",r,n.bind(this));else if(t.actor=this._tileWorkers[o]=this._tileWorkers[o]||this.dispatcher.getActor(),this.dispatcher.ready)t.request=t.actor.send("loadTile",r,n.bind(this),void 0,!0);else {const i=e.loadVectorTile.call({deduped:this._deduped},r,((e,i)=>{e||!i?n.call(this,e):(r.data={cacheControl:i.cacheControl,expires:i.expires,rawData:i.rawData.slice(0)},t.actor&&t.actor.send("loadTile",r,n.bind(this),void 0,!0));}),!0);t.request={cancel:i};}function n(o,r){return delete t.request,t.aborted?i(null):o&&404!==o.status?i(o):(r&&r.resourceTiming&&(t.resourceTiming=r.resourceTiming),this.map._refreshExpiredTiles&&r&&t.setExpiryData(r),t.loadVectorData(r,this.map.painter),e.cacheEntryPossiblyAdded(this.dispatcher),i(null),void(t.reloadCallback&&(this.loadTile(t,t.reloadCallback),t.reloadCallback=null)))}}abortTile(e){e.request&&(e.request.cancel(),delete e.request),e.actor&&e.actor.send("abortTile",{uid:e.uid,type:this.type,source:this.id});}unloadTile(e){e.unloadVectorData(),e.actor&&e.actor.send("removeTile",{uid:e.uid,type:this.type,source:this.id});}hasTransition(){return !1}afterUpdate(){this._tileWorkers={};}cancelTileJSONRequest(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);}}class Me extends e.Evented{constructor(t,i,o,r){super(),this.id=t,this.dispatcher=o,this.setEventedParent(r),this.type="raster",this.minzoom=0,this.maxzoom=22,this.roundZoom=!0,this.scheme="xyz",this.tileSize=512,this._loaded=!1,this._options=e.extend({type:"raster"},i),e.extend(this,e.pick(i,["url","scheme","tileSize"]));}load(t){this._loaded=!1,this.fire(new e.Event("dataloading",{dataType:"source"})),this._tileJSONRequest=O(this._options,this.map._requestManager,null,null,((i,o)=>{this._tileJSONRequest=null,this._loaded=!0,i?this.fire(new e.ErrorEvent(i)):o&&(e.extend(this,o),o.bounds&&(this.tileBounds=new B(o.bounds,this.minzoom,this.maxzoom)),e.postTurnstileEvent(o.tiles),this.fire(new e.Event("data",{dataType:"source",sourceDataType:"metadata"})),this.fire(new e.Event("data",{dataType:"source",sourceDataType:"content"}))),t&&t(i);}));}loaded(){return this._loaded}onAdd(e){this.map=e,this.load();}reload(){this.cancelTileJSONRequest(),this.load((()=>this.map.style._clearSource(this.id)));}setTiles(e){return this._options.tiles=e,this.reload(),this}setUrl(e){return this.url=e,this._options.url=e,this.reload(),this}onRemove(){this.cancelTileJSONRequest();}serialize(){return e.extend({},this._options)}hasTile(e){return !this.tileBounds||this.tileBounds.contains(e.canonical)}loadTile(t,i){const o=e.exported.devicePixelRatio>=2,r=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme),o,this.tileSize);t.request=e.getImage(this.map._requestManager.transformRequest(r,e.ResourceType.Tile),((o,r,n,s)=>(delete t.request,t.aborted?(t.state="unloaded",i(null)):o?(t.state="errored",i(o)):r?(this.map._refreshExpiredTiles&&t.setExpiryData({cacheControl:n,expires:s}),t.setTexture(r,this.map.painter),t.state="loaded",e.cacheEntryPossiblyAdded(this.dispatcher),void i(null)):i(null))));}static loadTileData(e,t,i){e.setTexture(t,i);}static unloadTileData(e,t){e.texture&&t.saveTileTexture(e.texture);}abortTile(e,t){e.request&&(e.request.cancel(),delete e.request),t();}unloadTile(e,t){e.texture&&this.map.painter.saveTileTexture(e.texture),t();}hasTransition(){return !1}cancelTileJSONRequest(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);}}function Ie(t,i,o,r,n,s,a,l){const c=[t,o,n,i,r,s,1,1,1],h=[a,l,1],u=e.adjoint([],c),[_,d,p]=e.transformMat3(h,h,e.transpose(u,u));return e.multiply$1(c,[_,0,0,0,d,0,0,0,p],c)}class Pe extends e.Evented{constructor(e,t,i,o){super(),this.id=e,this.dispatcher=i,this.coordinates=t.coordinates,this.type="image",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this.tiles={},this._loaded=!1,this.setEventedParent(o),this.options=t,this._dirty=!1;}load(t,i){this._loaded=i||!1,this.fire(new e.Event("dataloading",{dataType:"source"})),this.url=this.options.url,this._imageRequest=e.getImage(this.map._requestManager.transformRequest(this.url,e.ResourceType.Image),((i,o)=>{if(this._imageRequest=null,this._loaded=!0,i)this.fire(new e.ErrorEvent(i));else if(o){const{HTMLImageElement:i}=e.window;this.image=o instanceof i?e.exported.getImageData(o):o,this._dirty=!0,this.width=this.image.width,this.height=this.image.height,t&&(this.coordinates=t),this._finishLoading();}}));}loaded(){return this._loaded}updateImage(e){return this.image&&e.url?(this._imageRequest&&e.url!==this.options.url&&(this._imageRequest.cancel(),this._imageRequest=null),this.options.url=e.url,this.load(e.coordinates,this._loaded),this):this}_finishLoading(){this.map&&(this.setCoordinates(this.coordinates),this.fire(new e.Event("data",{dataType:"source",sourceDataType:"metadata"})));}onAdd(e){this.map=e,this.load();}onRemove(){this._imageRequest&&(this._imageRequest.cancel(),this._imageRequest=null),this.texture&&this.texture.destroy();}setCoordinates(t){this.coordinates=t,this._boundsArray=void 0;const i=t.map(e.MercatorCoordinate.fromLngLat);return this.tileID=function(t){let i=1/0,o=1/0,r=-1/0,n=-1/0;for(const e of t)i=Math.min(i,e.x),o=Math.min(o,e.y),r=Math.max(r,e.x),n=Math.max(n,e.y);const s=Math.max(r-i,n-o),a=Math.max(0,Math.floor(-Math.log(s)/Math.LN2)),l=Math.pow(2,a);return new e.CanonicalTileID(a,Math.floor((i+r)/2*l),Math.floor((o+n)/2*l))}(i),this.minzoom=this.maxzoom=this.tileID.z,this.fire(new e.Event("data",{dataType:"source",sourceDataType:"content"})),this}_clear(){this._boundsArray=void 0;}_prepareData(t){for(const e in this.tiles){const t=this.tiles[e];"loaded"!==t.state&&(t.state="loaded",t.texture=this.texture);}if(this._boundsArray)return;const i=e.tileTransform(this.tileID,this.map.transform.projection),[o,r,n,s]=this.coordinates.map((t=>{const o=i.projection.project(t[0],t[1]);return e.getTilePoint(i,o)._round()}));this.perspectiveTransform=function(t,i,o,r,n,s,a,l,c,h){const u=Ie(0,0,t,0,0,i,t,i),_=Ie(o,r,n,s,a,l,c,h);return e.multiply$1(_,e.adjoint(u,u),_),[_[6]/_[8]*t/e.EXTENT,_[7]/_[8]*i/e.EXTENT]}(this.width,this.height,o.x,o.y,r.x,r.y,s.x,s.y,n.x,n.y);const a=this._boundsArray=new e.StructArrayLayout4i8;a.emplaceBack(o.x,o.y,0,0),a.emplaceBack(r.x,r.y,e.EXTENT,0),a.emplaceBack(s.x,s.y,0,e.EXTENT),a.emplaceBack(n.x,n.y,e.EXTENT,e.EXTENT),this.boundsBuffer&&this.boundsBuffer.destroy(),this.boundsBuffer=t.createVertexBuffer(a,e.boundsAttributes.members),this.boundsSegments=e.SegmentVector.simpleSegment(0,0,4,2);}prepare(){if(0===Object.keys(this.tiles).length||!this.image)return;const t=this.map.painter.context,i=t.gl;this._dirty&&(this.texture?this.texture.update(this.image):(this.texture=new e.Texture(t,this.image,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE)),this._dirty=!1),this._prepareData(t);}loadTile(e,t){this.tileID&&this.tileID.equals(e.tileID.canonical)?(this.tiles[String(e.tileID.wrap)]=e,e.buckets={},t(null)):(e.state="errored",t(null));}serialize(){return {type:"image",url:this.options.url,coordinates:this.coordinates}}hasTransition(){return !1}}const Se={vector:Ce,raster:Me,"raster-dem":class extends Me{constructor(t,i,o,r){super(t,i,o,r),this.type="raster-dem",this.maxzoom=22,this._options=e.extend({type:"raster-dem"},i),this.encoding=i.encoding||"mapbox";}loadTile(t,i){const o=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme),!1,this.tileSize);function r(e,o){e&&(t.state="errored",i(e)),o&&(t.dem=o,t.dem.onDeserialize(),t.needsHillshadePrepare=!0,t.needsDEMTextureUpload=!0,t.state="loaded",i(null));}t.request=e.getImage(this.map._requestManager.transformRequest(o,e.ResourceType.Tile),function(o,n,s,a){if(delete t.request,t.aborted)t.state="unloaded",i(null);else if(o)t.state="errored",i(o);else if(n){this.map._refreshExpiredTiles&&t.setExpiryData({cacheControl:s,expires:a});const i=e.window.ImageBitmap&&n instanceof e.window.ImageBitmap&&(null==se&&(se=e.window.OffscreenCanvas&&new e.window.OffscreenCanvas(1,1).getContext("2d")&&"function"==typeof e.window.createImageBitmap),se),o=1-(n.width-e.prevPowerOfTwo(n.width))/2;o<1||t.neighboringTiles||(t.neighboringTiles=this._getNeighboringTiles(t.tileID));const l=i?n:e.exported.getImageData(n,o),c={uid:t.uid,coord:t.tileID,source:this.id,rawImageData:l,encoding:this.encoding,padding:o};t.actor&&"expired"!==t.state||(t.actor=this.dispatcher.getActor(),t.actor.send("loadDEMTile",c,r.bind(this),void 0,!0));}}.bind(this));}_getNeighboringTiles(t){const i=t.canonical,o=Math.pow(2,i.z),r=(i.x-1+o)%o,n=0===i.x?t.wrap-1:t.wrap,s=(i.x+1+o)%o,a=i.x+1===o?t.wrap+1:t.wrap,l={};return l[new e.OverscaledTileID(t.overscaledZ,n,i.z,r,i.y).key]={backfilled:!1},l[new e.OverscaledTileID(t.overscaledZ,a,i.z,s,i.y).key]={backfilled:!1},i.y>0&&(l[new e.OverscaledTileID(t.overscaledZ,n,i.z,r,i.y-1).key]={backfilled:!1},l[new e.OverscaledTileID(t.overscaledZ,t.wrap,i.z,i.x,i.y-1).key]={backfilled:!1},l[new e.OverscaledTileID(t.overscaledZ,a,i.z,s,i.y-1).key]={backfilled:!1}),i.y+1<o&&(l[new e.OverscaledTileID(t.overscaledZ,n,i.z,r,i.y+1).key]={backfilled:!1},l[new e.OverscaledTileID(t.overscaledZ,t.wrap,i.z,i.x,i.y+1).key]={backfilled:!1},l[new e.OverscaledTileID(t.overscaledZ,a,i.z,s,i.y+1).key]={backfilled:!1}),l}unloadTile(e){e.demTexture&&this.map.painter.saveTileTexture(e.demTexture),e.fbo&&(e.fbo.destroy(),delete e.fbo),e.dem&&delete e.dem,delete e.neighboringTiles,e.state="unloaded";}},geojson:class extends e.Evented{constructor(t,i,o,r){super(),this.id=t,this.type="geojson",this.minzoom=0,this.maxzoom=18,this.tileSize=512,this.isTileClipped=!0,this.reparseOverscaled=!0,this._loaded=!1,this.actor=o.getActor(),this.setEventedParent(r),this._data=i.data,this._options=e.extend({},i),this._collectResourceTiming=i.collectResourceTiming,void 0!==i.maxzoom&&(this.maxzoom=i.maxzoom),i.type&&(this.type=i.type),i.attribution&&(this.attribution=i.attribution),this.promoteId=i.promoteId;const n=e.EXTENT/this.tileSize;this.workerOptions=e.extend({source:this.id,cluster:i.cluster||!1,geojsonVtOptions:{buffer:(void 0!==i.buffer?i.buffer:128)*n,tolerance:(void 0!==i.tolerance?i.tolerance:.375)*n,extent:e.EXTENT,maxZoom:this.maxzoom,lineMetrics:i.lineMetrics||!1,generateId:i.generateId||!1},superclusterOptions:{maxZoom:void 0!==i.clusterMaxZoom?i.clusterMaxZoom:this.maxzoom-1,minPoints:Math.max(2,i.clusterMinPoints||2),extent:e.EXTENT,radius:(void 0!==i.clusterRadius?i.clusterRadius:50)*n,log:!1,generateId:i.generateId||!1},clusterProperties:i.clusterProperties,filter:i.filter},i.workerOptions);}onAdd(e){this.map=e,this.setData(this._data);}setData(e){return this._data=e,this._updateWorkerData(),this}getClusterExpansionZoom(e,t){return this.actor.send("geojson.getClusterExpansionZoom",{clusterId:e,source:this.id},t),this}getClusterChildren(e,t){return this.actor.send("geojson.getClusterChildren",{clusterId:e,source:this.id},t),this}getClusterLeaves(e,t,i,o){return this.actor.send("geojson.getClusterLeaves",{source:this.id,clusterId:e,limit:t,offset:i},o),this}_updateWorkerData(){if(this._pendingLoad)return void(this._coalesce=!0);this.fire(new e.Event("dataloading",{dataType:"source"})),this._loaded=!1;const t=e.extend({},this.workerOptions),i=this._data;"string"==typeof i?(t.request=this.map._requestManager.transformRequest(e.exported.resolveURL(i),e.ResourceType.Source),t.request.collectResourceTiming=this._collectResourceTiming):t.data=JSON.stringify(i),this._pendingLoad=this.actor.send(`${this.type}.loadData`,t,((t,i)=>{if(this._loaded=!0,this._pendingLoad=null,t)this.fire(new e.ErrorEvent(t));else {const t={dataType:"source",sourceDataType:this._metadataFired?"content":"metadata"};this._collectResourceTiming&&i&&i.resourceTiming&&i.resourceTiming[this.id]&&(t.resourceTiming=i.resourceTiming[this.id]),this.fire(new e.Event("data",t)),this._metadataFired=!0;}this._coalesce&&(this._updateWorkerData(),this._coalesce=!1);}));}loaded(){return this._loaded}loadTile(t,i){const o=t.actor?"reloadTile":"loadTile";t.actor=this.actor,t.request=this.actor.send(o,{type:this.type,uid:t.uid,tileID:t.tileID,tileZoom:t.tileZoom,zoom:t.tileID.overscaledZ,maxZoom:this.maxzoom,tileSize:this.tileSize,source:this.id,pixelRatio:e.exported.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId},((e,r)=>(delete t.request,t.unloadVectorData(),t.aborted?i(null):e?i(e):(t.loadVectorData(r,this.map.painter,"reloadTile"===o),i(null)))),void 0,"loadTile"===o);}abortTile(e){e.request&&(e.request.cancel(),delete e.request),e.aborted=!0;}unloadTile(e){e.unloadVectorData(),this.actor.send("removeTile",{uid:e.uid,type:this.type,source:this.id});}onRemove(){this._pendingLoad&&this._pendingLoad.cancel();}serialize(){return e.extend({},this._options,{type:this.type,data:this._data})}hasTransition(){return !1}},video:class extends Pe{constructor(e,t,i,o){super(e,t,i,o),this.roundZoom=!0,this.type="video",this.options=t;}load(){this._loaded=!1;const t=this.options;this.urls=[];for(const i of t.urls)this.urls.push(this.map._requestManager.transformRequest(i,e.ResourceType.Source).url);e.getVideo(this.urls,((t,i)=>{this._loaded=!0,t?this.fire(new e.ErrorEvent(t)):i&&(this.video=i,this.video.loop=!0,this.video.setAttribute("playsinline",""),this.video.addEventListener("playing",(()=>{this.map.triggerRepaint();})),this.map&&this.video.play(),this._finishLoading());}));}pause(){this.video&&this.video.pause();}play(){this.video&&this.video.play();}seek(t){if(this.video){const i=this.video.seekable;t<i.start(0)||t>i.end(0)?this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`,null,`Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))):this.video.currentTime=t;}}getVideo(){return this.video}onAdd(e){this.map||(this.map=e,this.load(),this.video&&(this.video.play(),this.setCoordinates(this.coordinates)));}prepare(){if(0===Object.keys(this.tiles).length||this.video.readyState<2)return;const t=this.map.painter.context,i=t.gl;this.texture?this.video.paused||(this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE),i.texSubImage2D(i.TEXTURE_2D,0,0,0,i.RGBA,i.UNSIGNED_BYTE,this.video)):(this.texture=new e.Texture(t,this.video,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE),this.width=this.video.videoWidth,this.height=this.video.videoHeight),this._prepareData(t);}serialize(){return {type:"video",urls:this.urls,coordinates:this.coordinates}}hasTransition(){return this.video&&!this.video.paused}},image:Pe,canvas:class extends Pe{constructor(t,i,o,r){super(t,i,o,r),i.coordinates?Array.isArray(i.coordinates)&&4===i.coordinates.length&&!i.coordinates.some((e=>!Array.isArray(e)||2!==e.length||e.some((e=>"number"!=typeof e))))||this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))):this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`,null,'missing required property "coordinates"'))),i.animate&&"boolean"!=typeof i.animate&&this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`,null,'optional "animate" property must be a boolean value'))),i.canvas?"string"==typeof i.canvas||i.canvas instanceof e.window.HTMLCanvasElement||this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))):this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`,null,'missing required property "canvas"'))),this.options=i,this.animate=void 0===i.animate||i.animate;}load(){this._loaded=!0,this.canvas||(this.canvas=this.options.canvas instanceof e.window.HTMLCanvasElement?this.options.canvas:e.window.document.getElementById(this.options.canvas)),this.width=this.canvas.width,this.height=this.canvas.height,this._hasInvalidDimensions()?this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))):(this.play=function(){this._playing=!0,this.map.triggerRepaint();},this.pause=function(){this._playing&&(this.prepare(),this._playing=!1);},this._finishLoading());}getCanvas(){return this.canvas}onAdd(e){this.map=e,this.load(),this.canvas&&this.animate&&this.play();}onRemove(){this.pause();}prepare(){let t=!1;if(this.canvas.width!==this.width&&(this.width=this.canvas.width,t=!0),this.canvas.height!==this.height&&(this.height=this.canvas.height,t=!0),this._hasInvalidDimensions())return;if(0===Object.keys(this.tiles).length)return;const i=this.map.painter.context;this.texture?(t||this._playing)&&this.texture.update(this.canvas,{premultiply:!0}):this.texture=new e.Texture(i,this.canvas,i.gl.RGBA,{premultiply:!0}),this._prepareData(i);}serialize(){return {type:"canvas",coordinates:this.coordinates}}hasTransition(){return this._playing}_hasInvalidDimensions(){for(const e of [this.canvas.width,this.canvas.height])if(isNaN(e)||e<=0)return !0;return !1}},custom:class extends e.Evented{constructor(t,i,o,r){super(),this.id=t,this.type="custom",this._dataType="raster",this._dispatcher=o,this._implementation=i,this.setEventedParent(r),this.scheme="xyz",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this._loaded=!1,this.roundZoom=!0,this._implementation||this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))),this._implementation.loadTile||this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))),this._implementation.bounds&&(this.tileBounds=new B(this._implementation.bounds,this.minzoom,this.maxzoom)),i.update=this._update.bind(this),i.clearTiles=this._clearTiles.bind(this),i.coveringTiles=this._coveringTiles.bind(this),e.extend(this,e.pick(i,["dataType","scheme","minzoom","maxzoom","tileSize","attribution","minTileCacheSize","maxTileCacheSize"]));}serialize(){return e.pick(this,["type","scheme","minzoom","maxzoom","tileSize","attribution"])}load(){this._loaded=!0,this.fire(new e.Event("data",{dataType:"source",sourceDataType:"metadata"})),this.fire(new e.Event("data",{dataType:"source",sourceDataType:"content"}));}loaded(){return this._loaded}onAdd(t){this._map=t,this._loaded=!1,this.fire(new e.Event("dataloading",{dataType:"source"})),this._implementation.onAdd&&this._implementation.onAdd(t),this.load();}onRemove(e){this._implementation.onRemove&&this._implementation.onRemove(e);}hasTile(e){if(this._implementation.hasTile){const{x:t,y:i,z:o}=e.canonical;return this._implementation.hasTile({x:t,y:i,z:o})}return !this.tileBounds||this.tileBounds.contains(e.canonical)}loadTile(t,i){const{x:o,y:r,z:n}=t.tileID.canonical,s=new e.window.AbortController;t.request=Promise.resolve(this._implementation.loadTile({x:o,y:r,z:n},{signal:s.signal})).then(function(o){return delete t.request,t.aborted?(t.state="unloaded",i(null)):void 0===o?(t.state="errored",i(null)):null===o?(this.loadTileData(t,{width:this.tileSize,height:this.tileSize,data:null}),t.state="loaded",i(null)):function(t){return t instanceof e.window.ImageData||t instanceof e.window.HTMLCanvasElement||t instanceof e.window.ImageBitmap||t instanceof e.window.HTMLImageElement}(o)?(this.loadTileData(t,o),t.state="loaded",void i(null)):(t.state="errored",i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)))}.bind(this)).catch((e=>{20!==e.code&&(t.state="errored",i(e));})),t.request.cancel=()=>s.abort();}loadTileData(e,t){Me.loadTileData(e,t,this._map.painter);}unloadTileData(e){Me.unloadTileData(e,this._map.painter);}unloadTile(e,t){if(this.unloadTileData(e),this._implementation.unloadTile){const{x:t,y:i,z:o}=e.tileID.canonical;this._implementation.unloadTile({x:t,y:i,z:o});}t();}abortTile(e,t){e.request&&e.request.cancel&&(e.request.cancel(),delete e.request),t();}hasTransition(){return !1}_coveringTiles(){return this._map.transform.coveringTiles({tileSize:this.tileSize,minzoom:this.minzoom,maxzoom:this.maxzoom,roundZoom:this.roundZoom}).map((e=>({x:e.canonical.x,y:e.canonical.y,z:e.canonical.z})))}_clearTiles(){this._map.style._clearSource(this.id);}_update(){this.fire(new e.Event("data",{dataType:"source",sourceDataType:"content"}));}}},De=function(t,i,o,r){const n=new Se[i.type](t,i,o,r);if(n.id!==t)throw new Error(`Expected Source id to be ${t} instead of ${n.id}`);return e.bindAll(["load","abort","unload","serialize","prepare"],n),n};function Le(t,i){const o=e.identity([]);return e.scale(o,o,[.5*t.width,.5*-t.height,1]),e.translate(o,o,[1,-1,0]),e.multiply(o,o,t.calculateProjMatrix(i.toUnwrapped())),Float32Array.from(o)}function Ae(e,t,i,o,r,n,s,a=!1){const l=e.tilesIn(o,s,a);l.sort(Re);const c=[];for(const o of l)c.push({wrappedTileID:o.tile.tileID.wrapped().key,queryResults:o.tile.queryRenderedFeatures(t,i,e._state,o,r,n,Le(e.transform,o.tile.tileID),a)});const h=function(e){const t={},i={};for(const o of e){const e=o.queryResults,r=o.wrappedTileID,n=i[r]=i[r]||{};for(const i in e){const o=e[i],r=n[i]=n[i]||{},s=t[i]=t[i]||[];for(const e of o)r[e.featureIndex]||(r[e.featureIndex]=!0,s.push(e));}}return t}(c);for(const t in h)h[t].forEach((t=>{const i=t.feature,o=i.layer;o&&"background"!==o.type&&"sky"!==o.type&&(i.source=o.source,o["source-layer"]&&(i.sourceLayer=o["source-layer"]),i.state=void 0!==i.id?e.getFeatureState(o["source-layer"],i.id):{});}));return h}function ze(e,t){const i=e.getRenderableIds().map((t=>e.getTileByID(t))),o=[],r={};for(let e=0;e<i.length;e++){const n=i[e],s=n.tileID.canonical.key;r[s]||(r[s]=!0,n.querySourceFeatures(o,t));}return o}function Re(e,t){const i=e.tileID,o=t.tileID;return i.overscaledZ-o.overscaledZ||i.canonical.y-o.canonical.y||i.wrap-o.wrap||i.canonical.x-o.canonical.x}function Oe(){return null!=dn.workerClass?new dn.workerClass:new e.window.Worker(dn.workerUrl)}const Be="mapboxgl_preloaded_worker_pool";class ke{constructor(){this.active={};}acquire(e){if(!this.workers)for(this.workers=[];this.workers.length<ke.workerCount;)this.workers.push(new Oe);return this.active[e]=!0,this.workers.slice()}release(e){delete this.active[e],0===this.numActive()&&(this.workers.forEach((e=>{e.terminate();})),this.workers=null);}isPreloaded(){return !!this.active[Be]}numActive(){return Object.keys(this.active).length}}let Fe;function Ue(){return Fe||(Fe=new ke),Fe}function Ne(t,i){const o={};for(const e in t)"ref"!==e&&(o[e]=t[e]);return e.refProperties.forEach((e=>{e in i&&(o[e]=i[e]);})),o}function je(e){e=e.slice();const t=Object.create(null);for(let i=0;i<e.length;i++)t[e[i].id]=e[i];for(let i=0;i<e.length;i++)"ref"in e[i]&&(e[i]=Ne(e[i],t[e[i].ref]));return e}ke.workerCount=2;const Ge={setStyle:"setStyle",addLayer:"addLayer",removeLayer:"removeLayer",setPaintProperty:"setPaintProperty",setLayoutProperty:"setLayoutProperty",setFilter:"setFilter",addSource:"addSource",removeSource:"removeSource",setGeoJSONSourceData:"setGeoJSONSourceData",setLayerZoomRange:"setLayerZoomRange",setLayerProperty:"setLayerProperty",setCenter:"setCenter",setZoom:"setZoom",setBearing:"setBearing",setPitch:"setPitch",setSprite:"setSprite",setGlyphs:"setGlyphs",setTransition:"setTransition",setLight:"setLight",setTerrain:"setTerrain",setFog:"setFog",setProjection:"setProjection"};function Ze(e,t,i){i.push({command:Ge.addSource,args:[e,t[e]]});}function Ve(e,t,i){t.push({command:Ge.removeSource,args:[e]}),i[e]=!0;}function We(e,t,i,o){Ve(e,i,o),Ze(e,t,i);}function Xe(e,i,o){let r;for(r in e[o])if(e[o].hasOwnProperty(r)&&"data"!==r&&!t(e[o][r],i[o][r]))return !1;for(r in i[o])if(i[o].hasOwnProperty(r)&&"data"!==r&&!t(e[o][r],i[o][r]))return !1;return !0}function qe(e,i,o,r,n,s){let a;for(a in i=i||{},e=e||{})e.hasOwnProperty(a)&&(t(e[a],i[a])||o.push({command:s,args:[r,a,i[a],n]}));for(a in i)i.hasOwnProperty(a)&&!e.hasOwnProperty(a)&&(t(e[a],i[a])||o.push({command:s,args:[r,a,i[a],n]}));}function $e(e){return e.id}function He(e,t){return e[t.id]=t,e}class Ye{constructor(e,t){this.reset(e,t);}reset(e,t){this.points=e||[],this._distances=[0];for(let e=1;e<this.points.length;e++)this._distances[e]=this._distances[e-1]+this.points[e].dist(this.points[e-1]);this.length=this._distances[this._distances.length-1],this.padding=Math.min(t||0,.5*this.length),this.paddedLength=this.length-2*this.padding;}lerp(t){if(1===this.points.length)return this.points[0];t=e.clamp(t,0,1);let i=1,o=this._distances[i];const r=t*this.paddedLength+this.padding;for(;o<r&&i<this._distances.length;)o=this._distances[++i];const n=i-1,s=this._distances[n],a=o-s,l=a>0?(r-s)/a:0;return this.points[n].mult(1-l).add(this.points[i].mult(l))}}class Ke{constructor(e,t,i){const o=this.boxCells=[],r=this.circleCells=[];this.xCellCount=Math.ceil(e/i),this.yCellCount=Math.ceil(t/i);for(let e=0;e<this.xCellCount*this.yCellCount;e++)o.push([]),r.push([]);this.circleKeys=[],this.boxKeys=[],this.bboxes=[],this.circles=[],this.width=e,this.height=t,this.xScale=this.xCellCount/e,this.yScale=this.yCellCount/t,this.boxUid=0,this.circleUid=0;}keysLength(){return this.boxKeys.length+this.circleKeys.length}insert(e,t,i,o,r){this._forEachCell(t,i,o,r,this._insertBoxCell,this.boxUid++),this.boxKeys.push(e),this.bboxes.push(t),this.bboxes.push(i),this.bboxes.push(o),this.bboxes.push(r);}insertCircle(e,t,i,o){this._forEachCell(t-o,i-o,t+o,i+o,this._insertCircleCell,this.circleUid++),this.circleKeys.push(e),this.circles.push(t),this.circles.push(i),this.circles.push(o);}_insertBoxCell(e,t,i,o,r,n){this.boxCells[r].push(n);}_insertCircleCell(e,t,i,o,r,n){this.circleCells[r].push(n);}_query(e,t,i,o,r,n){if(i<0||e>this.width||o<0||t>this.height)return !r&&[];const s=[];if(e<=0&&t<=0&&this.width<=i&&this.height<=o){if(r)return !0;for(let e=0;e<this.boxKeys.length;e++)s.push({key:this.boxKeys[e],x1:this.bboxes[4*e],y1:this.bboxes[4*e+1],x2:this.bboxes[4*e+2],y2:this.bboxes[4*e+3]});for(let e=0;e<this.circleKeys.length;e++){const t=this.circles[3*e],i=this.circles[3*e+1],o=this.circles[3*e+2];s.push({key:this.circleKeys[e],x1:t-o,y1:i-o,x2:t+o,y2:i+o});}return n?s.filter(n):s}return this._forEachCell(e,t,i,o,this._queryCell,s,{hitTest:r,seenUids:{box:{},circle:{}}},n),r?s.length>0:s}_queryCircle(e,t,i,o,r){const n=e-i,s=e+i,a=t-i,l=t+i;if(s<0||n>this.width||l<0||a>this.height)return !o&&[];const c=[];return this._forEachCell(n,a,s,l,this._queryCellCircle,c,{hitTest:o,circle:{x:e,y:t,radius:i},seenUids:{box:{},circle:{}}},r),o?c.length>0:c}query(e,t,i,o,r){return this._query(e,t,i,o,!1,r)}hitTest(e,t,i,o,r){return this._query(e,t,i,o,!0,r)}hitTestCircle(e,t,i,o){return this._queryCircle(e,t,i,!0,o)}_queryCell(e,t,i,o,r,n,s,a){const l=s.seenUids,c=this.boxCells[r];if(null!==c){const r=this.bboxes;for(const h of c)if(!l.box[h]){l.box[h]=!0;const c=4*h;if(e<=r[c+2]&&t<=r[c+3]&&i>=r[c+0]&&o>=r[c+1]&&(!a||a(this.boxKeys[h]))){if(s.hitTest)return n.push(!0),!0;n.push({key:this.boxKeys[h],x1:r[c],y1:r[c+1],x2:r[c+2],y2:r[c+3]});}}}const h=this.circleCells[r];if(null!==h){const r=this.circles;for(const c of h)if(!l.circle[c]){l.circle[c]=!0;const h=3*c;if(this._circleAndRectCollide(r[h],r[h+1],r[h+2],e,t,i,o)&&(!a||a(this.circleKeys[c]))){if(s.hitTest)return n.push(!0),!0;{const e=r[h],t=r[h+1],i=r[h+2];n.push({key:this.circleKeys[c],x1:e-i,y1:t-i,x2:e+i,y2:t+i});}}}}}_queryCellCircle(e,t,i,o,r,n,s,a){const l=s.circle,c=s.seenUids,h=this.boxCells[r];if(null!==h){const e=this.bboxes;for(const t of h)if(!c.box[t]){c.box[t]=!0;const i=4*t;if(this._circleAndRectCollide(l.x,l.y,l.radius,e[i+0],e[i+1],e[i+2],e[i+3])&&(!a||a(this.boxKeys[t])))return n.push(!0),!0}}const u=this.circleCells[r];if(null!==u){const e=this.circles;for(const t of u)if(!c.circle[t]){c.circle[t]=!0;const i=3*t;if(this._circlesCollide(e[i],e[i+1],e[i+2],l.x,l.y,l.radius)&&(!a||a(this.circleKeys[t])))return n.push(!0),!0}}}_forEachCell(e,t,i,o,r,n,s,a){const l=this._convertToXCellCoord(e),c=this._convertToYCellCoord(t),h=this._convertToXCellCoord(i),u=this._convertToYCellCoord(o);for(let _=l;_<=h;_++)for(let l=c;l<=u;l++)if(r.call(this,e,t,i,o,this.xCellCount*l+_,n,s,a))return}_convertToXCellCoord(e){return Math.max(0,Math.min(this.xCellCount-1,Math.floor(e*this.xScale)))}_convertToYCellCoord(e){return Math.max(0,Math.min(this.yCellCount-1,Math.floor(e*this.yScale)))}_circlesCollide(e,t,i,o,r,n){const s=o-e,a=r-t,l=i+n;return l*l>s*s+a*a}_circleAndRectCollide(e,t,i,o,r,n,s){const a=(n-o)/2,l=Math.abs(e-(o+a));if(l>a+i)return !1;const c=(s-r)/2,h=Math.abs(t-(r+c));if(h>c+i)return !1;if(l<=a||h<=c)return !0;const u=l-a,_=h-c;return u*u+_*_<=i*i}}const Je={unknown:0,flipRequired:1,flipNotRequired:2},Qe=Math.tan(85*Math.PI/180);function et(t,i,o,r,n,s,a){const l=e.create();if(o)if("globe"===s.name){const t=e.calculateGlobeLabelMatrix(n,i);e.multiply(l,l,t);}else {const t=v([],a);l[0]=t[0],l[1]=t[1],l[4]=t[2],l[5]=t[3],r||e.rotateZ(l,l,n.angle);}else e.multiply(l,n.labelPlaneMatrix,t);return l}function tt(e,t,i,o,r,n,s){const a=et(e,t,i,o,r,n,s);return "globe"===n.name&&i||(a[2]=a[6]=a[10]=a[14]=0),a}function it(t,i,o,r,n,s,a){if(o){if("globe"===s.name){const l=et(t,i,o,r,n,s,a);return e.invert(l,l),e.multiply(l,t,l),l}{const i=e.clone(t),o=e.identity([]);return o[0]=a[0],o[1]=a[1],o[4]=a[2],o[5]=a[3],e.multiply(i,i,o),r||e.rotateZ(i,i,-n.angle),i}}return n.glCoordMatrix}function ot(t,i,o,r){const n=[t,i,o,1];o?e.transformMat4$1(n,n,r):pt(n,n,r);const s=n[3];return n[0]/=s,n[1]/=s,n[2]/=s,n}function rt(e,t){return Math.min(.5+e/t*.5,1.5)}function nt(e,t){const i=e[0]/e[3],o=e[1]/e[3];return i>=-t[0]&&i<=t[0]&&o>=-t[1]&&o<=t[1]}function st(t,i,o,r,n,s,a,l,c,h){const u=o.transform,_=r?t.textSizeData:t.iconSizeData,d=e.evaluateSizeForZoom(_,o.transform.zoom),p="globe"===u.projection.name,m=[256/o.width*2+1,256/o.height*2+1],f=r?t.text.dynamicLayoutVertexArray:t.icon.dynamicLayoutVertexArray;f.clear();let g=null;p&&(g=r?t.text.globeExtVertexArray:t.icon.globeExtVertexArray);const v=t.lineVertexArray,x=r?t.text.placedSymbolArray:t.icon.placedSymbolArray,y=o.transform.width/o.transform.height;let b,w=!1;for(let r=0;r<x.length;r++){const p=x.get(r),{numGlyphs:T,writingMode:E}=p;if(E!==e.WritingMode.vertical||w||b===e.WritingMode.horizontal||(w=!0),b=E,(p.hidden||E===e.WritingMode.vertical)&&!w){dt(T,f);continue}w=!1;const C=new e.Point(p.tileAnchorX,p.tileAnchorY);let{x:M,y:I,z:P}=u.projection.projectTilePoint(C.x,C.y,h.canonical);if(c){const[e,t,i]=c(C);M+=e,I+=t,P+=i;}const S=[M,I,P,1];if(e.transformMat4$1(S,S,i),!nt(S,m)){dt(T,f);continue}const D=rt(o.transform.cameraToCenterDistance,S[3]),L=e.evaluateSizeForFeature(_,d,p),A=a?L/D:L*D,z=ot(M,I,P,n);if(z[3]<=0){dt(T,f);continue}let R={};const O=a?null:c,B=ct(p,A,!1,l,i,n,s,t.glyphOffsetArray,v,f,g,z,C,R,y,O,u.projection,h,a);w=B.useVertical,O&&B.needsFlipping&&(R={}),(B.notEnoughRoom||w||B.needsFlipping&&ct(p,A,!0,l,i,n,s,t.glyphOffsetArray,v,f,g,z,C,R,y,O,u.projection,h,a).notEnoughRoom)&&dt(T,f);}r?(t.text.dynamicLayoutVertexBuffer.updateData(f),g&&t.text.globeExtVertexBuffer.updateData(g)):(t.icon.dynamicLayoutVertexBuffer.updateData(f),g&&t.icon.globeExtVertexBuffer.updateData(g));}function at(e,t,i,o,r,n,s,a,l,c,h,u,_,d,p,m){const{lineStartIndex:f,glyphStartIndex:g,segment:v}=a,x=g+a.numGlyphs,y=f+a.lineLength,b=t.getoffsetX(g),w=t.getoffsetX(x-1),T=_t(e*b,i,o,r,n,s,v,f,y,l,c,h,u,_,!0,d,p,m);if(!T)return null;const E=_t(e*w,i,o,r,n,s,v,f,y,l,c,h,u,_,!0,d,p,m);return E?{first:T,last:E}:null}function lt(t,i,o,r){return t===e.WritingMode.horizontal&&Math.abs(r)>Math.abs(o)?{useVertical:!0}:t===e.WritingMode.vertical?r>0?{needsFlipping:!0}:null:i!==Je.unknown&&function(e,t){return 0===e||Math.abs(t/e)>Qe}(o,r)?i===Je.flipRequired?{needsFlipping:!0}:null:o<0?{needsFlipping:!0}:null}function ct(t,i,o,r,n,s,a,l,c,h,u,_,d,p,m,f,g,v,x){const y=i/24,b=t.lineOffsetX*y,w=t.lineOffsetY*y,{lineStartIndex:T,glyphStartIndex:E,numGlyphs:C,segment:M,writingMode:I,flipState:P}=t,S=T+t.lineLength,D=t=>{if(u){const[i,o,r]=t.up,n=h.length;e.updateGlobeVertexNormal(u,n+0,i,o,r),e.updateGlobeVertexNormal(u,n+1,i,o,r),e.updateGlobeVertexNormal(u,n+2,i,o,r),e.updateGlobeVertexNormal(u,n+3,i,o,r);}const[i,o,r]=t.point;e.addDynamicAttributes(h,i,o,r,t.angle);};if(C>1){const e=at(y,l,b,w,o,_,d,t,c,s,p,f,!1,g,v,x);if(!e)return {notEnoughRoom:!0};if(r&&!o){let[i,o,r]=e.first.point,[n,s,l]=e.last.point;[i,o]=ot(i,o,r,a),[n,s]=ot(n,s,l,a);const c=lt(I,P,(n-i)*m,s-o);if(t.flipState=c&&c.needsFlipping?Je.flipRequired:Je.flipNotRequired,c)return c}D(e.first);for(let e=E+1;e<E+C-1;e++){const t=_t(y*l.getoffsetX(e),b,w,o,_,d,M,T,S,c,s,p,f,!1,!1,g,v,x);if(!t)return h.length-=4*(e-E),{notEnoughRoom:!0};D(t);}D(e.last);}else {if(r&&!o){const i=ot(d.x,d.y,0,n),o=T+M+1,r=new e.Point(c.getx(o),c.gety(o)),s=ot(r.x,r.y,0,n),a=s[3]>0?s:ut(d,r,i,1,n,void 0,g,v.canonical),l=lt(I,P,(a[0]-i[0])*m,a[1]-i[1]);if(t.flipState=l&&l.needsFlipping?Je.flipRequired:Je.flipNotRequired,l)return l}const i=_t(y*l.getoffsetX(E),b,w,o,_,d,M,T,S,c,s,p,f,!1,!1,g,v,x);if(!i)return {notEnoughRoom:!0};D(i);}return {}}function ht(e,t,i,o,r){const{x:n,y:s,z:a}=o.projectTilePoint(e.x,e.y,t);if(!r)return ot(n,s,a,i);const[l,c,h]=r(e);return ot(n+l,s+c,a+h,i)}function ut(t,i,o,r,n,s,a,l){const c=ht(t.sub(i)._unit()._add(t),l,n,a,s);return e.sub(c,o,c),e.normalize(c,c),e.scaleAndAdd(c,o,c,r)}function _t(t,i,o,r,n,s,a,l,c,h,u,_,d,p,m,f,g,v){const x=r?t-i:t+i;let y=x>0?1:-1,b=0;r&&(y*=-1,b=Math.PI),y<0&&(b+=Math.PI);let w=l+a+(y>0?0:1)|0,T=n,E=n,C=0,M=0;const I=Math.abs(x),P=[],S=[];let D=s,L=D;const A=()=>ut(L,D,E,I-C+1,u,d,f,g.canonical);for(;C+M<=I;){if(w+=y,w<l||w>=c)return null;if(E=T,L=D,P.push(E),p&&S.push(L),D=new e.Point(h.getx(w),h.gety(w)),T=_[w],!T){const e=ht(D,g.canonical,u,f,d);T=e[3]>0?_[w]=e:A();}C+=M,M=e.distance(E,T);}m&&d&&(_[w]&&(T=A(),M=e.distance(E,T)),_[w]=T);const z=(I-C)/M,R=D.sub(L)._mult(z)._add(L),O=e.sub([],T,E),B=e.scaleAndAdd([],E,O,z);let k=[0,0,1],F=O[0],U=O[1];if(v&&(k=f.upVector(g.canonical,R.x,R.y),0!==k[0]||0!==k[1]||1!==k[2])){const t=[k[2],0,-k[0]],i=e.cross([],k,t);e.normalize(t,t),e.normalize(i,i),F=e.dot(O,t),U=e.dot(O,i);}if(o){const t=e.cross([],k,O);e.normalize(t,t),e.scaleAndAdd(B,B,t,o*y);}const N=b+Math.atan2(U,F);return P.push(B),p&&S.push(R),{point:B,angle:N,path:P,tilePath:S,up:k}}function dt(e,t){const i=t.length,o=i+4*e;t.resize(o),t.float32.fill(-1/0,4*i,4*o);}function pt(e,t,i){const o=t[0],r=t[1];return e[0]=i[0]*o+i[4]*r+i[12],e[1]=i[1]*o+i[5]*r+i[13],e[3]=i[3]*o+i[7]*r+i[15],e}const mt=100;class ft{constructor(e,t,i=new Ke(e.width+200,e.height+200,25),o=new Ke(e.width+200,e.height+200,25)){this.transform=e,this.grid=i,this.ignoredGrid=o,this.pitchfactor=Math.cos(e._pitch)*e.cameraToCenterDistance,this.screenRightBoundary=e.width+mt,this.screenBottomBoundary=e.height+mt,this.gridRightBoundary=e.width+200,this.gridBottomBoundary=e.height+200,this.fogState=t;}placeCollisionBox(e,t,i,o,r,n,s,a){let l=i.projectedAnchorX,c=i.projectedAnchorY,h=i.projectedAnchorZ;const u=i.elevation,_=i.tileID,d=e.getProjection();if(u&&_){const[e,t,o]=d.upVector(_.canonical,i.tileAnchorX,i.tileAnchorY),r=d.upVectorScale(_.canonical,this.transform.center.lat,this.transform.worldSize).metersToTile;l+=e*u*r,c+=t*u*r,h+=o*u*r;}const p=this.projectAndGetPerspectiveRatio(s,l,c,h,i.tileID,"globe"===d.name||!!u||this.transform.pitch>0,d),m=n*p.perspectiveRatio,f=(i.x1*t+o.x-i.padding)*m+p.point.x,g=(i.y1*t+o.y-i.padding)*m+p.point.y,v=(i.x2*t+o.x+i.padding)*m+p.point.x,x=(i.y2*t+o.y+i.padding)*m+p.point.y,y=p.perspectiveRatio<=.55||p.occluded;return !this.isInsideGrid(f,g,v,x)||!r&&this.grid.hitTest(f,g,v,x,a)||y?{box:[],offscreen:!1,occluded:p.occluded}:{box:[f,g,v,x],offscreen:this.isOffscreen(f,g,v,x),occluded:!1}}placeCollisionCircles(t,i,o,r,n,s,a,l,c,h,u,_,d,p,m){const f=[],g=this.transform.elevation,v=t.getProjection(),x=g?g.getAtTileOffsetFunc(m,this.transform.center.lat,this.transform.worldSize,v):null,y=new e.Point(o.tileAnchorX,o.tileAnchorY);let{x:b,y:w,z:T}=v.projectTilePoint(y.x,y.y,m.canonical);if(x){const[e,t,i]=x(y);b+=e,w+=t,T+=i;}const E="globe"===v.name,C=this.projectAndGetPerspectiveRatio(a,b,w,T,m,E||!!g||this.transform.pitch>0,v),{perspectiveRatio:M}=C,I=(u?s/M:s*M)/e.ONE_EM,P=ot(b,w,T,l),S=C.signedDistanceFromCamera>0?at(I,n,o.lineOffsetX*I,o.lineOffsetY*I,!1,P,y,o,r,l,{},g&&!u?x:null,u&&!!g,v,m,u):null;let D=!1,L=!1,A=!0;if(S&&!C.occluded){const t=.5*d*M+p,o=new e.Point(-100,-100),r=new e.Point(this.screenRightBoundary,this.screenBottomBoundary),n=new Ye,{first:s,last:a}=S,l=s.path.length;let u=[];for(let e=l-1;e>=1;e--)u.push(s.path[e]);for(let e=1;e<a.path.length;e++)u.push(a.path[e]);const m=2.5*t;c&&(u=u.map((([e,t,i],o)=>(x&&!E&&(i=x(o<l-1?s.tilePath[l-1-o]:a.tilePath[o-l+2])[2]),ot(e,t,i,c)))),u.some((e=>e[3]<=0))&&(u=[]));let g=[];if(u.length>0){let t=1/0,i=-1/0,n=1/0,s=-1/0;for(const e of u)t=Math.min(t,e[0]),n=Math.min(n,e[1]),i=Math.max(i,e[0]),s=Math.max(s,e[1]);i>=o.x&&t<=r.x&&s>=o.y&&n<=r.y&&(g=[u.map((t=>new e.Point(t[0],t[1])))],(t<o.x||i>r.x||n<o.y||s>r.y)&&(g=e.clipLine(g,o.x,o.y,r.x,r.y)));}for(const e of g){n.reset(e,.25*t);let o=0;o=n.length<=.5*t?1:Math.ceil(n.paddedLength/m)+1;for(let e=0;e<o;e++){const r=e/Math.max(o-1,1),s=n.lerp(r),a=s.x+mt,l=s.y+mt;f.push(a,l,t,0);const c=a-t,u=l-t,d=a+t,p=l+t;if(A=A&&this.isOffscreen(c,u,d,p),L=L||this.isInsideGrid(c,u,d,p),!i&&this.grid.hitTestCircle(a,l,t,_)&&(D=!0,!h))return {circles:[],offscreen:!1,collisionDetected:D,occluded:!1}}}}return {circles:!h&&D||!L?[]:f,offscreen:A,collisionDetected:D,occluded:C.occluded}}queryRenderedSymbols(t){if(0===t.length||0===this.grid.keysLength()&&0===this.ignoredGrid.keysLength())return {};const i=[];let o=1/0,r=1/0,n=-1/0,s=-1/0;for(const a of t){const t=new e.Point(a.x+mt,a.y+mt);o=Math.min(o,t.x),r=Math.min(r,t.y),n=Math.max(n,t.x),s=Math.max(s,t.y),i.push(t);}const a=this.grid.query(o,r,n,s).concat(this.ignoredGrid.query(o,r,n,s)),l={},c={};for(const t of a){const o=t.key;if(void 0===l[o.bucketInstanceId]&&(l[o.bucketInstanceId]={}),l[o.bucketInstanceId][o.featureIndex])continue;const r=[new e.Point(t.x1,t.y1),new e.Point(t.x2,t.y1),new e.Point(t.x2,t.y2),new e.Point(t.x1,t.y2)];e.polygonIntersectsPolygon(i,r)&&(l[o.bucketInstanceId][o.featureIndex]=!0,void 0===c[o.bucketInstanceId]&&(c[o.bucketInstanceId]=[]),c[o.bucketInstanceId].push(o.featureIndex));}return c}insertCollisionBox(e,t,i,o,r){(t?this.ignoredGrid:this.grid).insert({bucketInstanceId:i,featureIndex:o,collisionGroupID:r},e[0],e[1],e[2],e[3]);}insertCollisionCircles(e,t,i,o,r){const n=t?this.ignoredGrid:this.grid,s={bucketInstanceId:i,featureIndex:o,collisionGroupID:r};for(let t=0;t<e.length;t+=4)n.insertCircle(s,e[t],e[t+1],e[t+2]);}projectAndGetPerspectiveRatio(t,i,o,r,n,s,a){const l=[i,o,r,1];let c=!1;if(r||this.transform.pitch>0){if(e.transformMat4$1(l,l,t),this.fogState&&n&&"globe"!==a.name){const t=function(t,i,o,r,n,s){const a=s.calculateFogTileMatrix(n),l=[i,o,r];return e.transformMat4(l,l,a),C(t,l,s.pitch,s._fov)}(this.fogState,i,o,r,n.toUnwrapped(),this.transform);c=t>.9;}}else pt(l,l,t);const h=l[3];return {point:new e.Point((l[0]/h+1)/2*this.transform.width+mt,(-l[1]/h+1)/2*this.transform.height+mt),perspectiveRatio:Math.min(.5+this.transform.getCameraToCenterDistance(a)/h*.5,1.5),signedDistanceFromCamera:h,occluded:s&&l[2]>h||c}}isOffscreen(e,t,i,o){return i<mt||e>=this.screenRightBoundary||o<mt||t>this.screenBottomBoundary}isInsideGrid(e,t,i,o){return i>=0&&e<this.gridRightBoundary&&o>=0&&t<this.gridBottomBoundary}getViewportMatrix(){const t=e.identity([]);return e.translate(t,t,[-100,-100,0]),t}}function gt(t,i,o){const r=i.createTileMatrix(t,t.worldSize,o.toUnwrapped());return e.multiply(new Float32Array(16),t.projMatrix,r)}function vt(e,t,i){if(t.projection.name===i.projection.name)return e.projMatrix;const o=i.clone();return o.setProjection(t.projection),gt(o,t.getProjection(),e)}function xt(e,t,i){return t.name===i.projection.name?e.projMatrix:gt(i,t,e)}class yt{constructor(e,t,i,o){this.opacity=e?Math.max(0,Math.min(1,e.opacity+(e.placed?t:-t))):o&&i?1:0,this.placed=i;}isHidden(){return 0===this.opacity&&!this.placed}}class bt{constructor(e,t,i,o,r,n=!1){this.text=new yt(e?e.text:null,t,i,r),this.icon=new yt(e?e.icon:null,t,o,r),this.clipped=n;}isHidden(){return this.text.isHidden()&&this.icon.isHidden()}}class wt{constructor(e,t,i,o=!1){this.text=e,this.icon=t,this.skipFade=i,this.clipped=o;}}class Tt{constructor(){this.invProjMatrix=e.create(),this.viewportMatrix=e.create(),this.circles=[];}}class Et{constructor(e,t,i,o,r){this.bucketInstanceId=e,this.featureIndex=t,this.sourceLayerIndex=i,this.bucketIndex=o,this.tileID=r;}}class Ct{constructor(e){this.crossSourceCollisions=e,this.maxGroupID=0,this.collisionGroups={};}get(e){if(this.crossSourceCollisions)return {ID:0,predicate:null};if(!this.collisionGroups[e]){const t=++this.maxGroupID;this.collisionGroups[e]={ID:t,predicate:e=>e.collisionGroupID===t};}return this.collisionGroups[e]}}function Mt(t,i,o,r,n){const{horizontalAlign:s,verticalAlign:a}=e.getAnchorAlignment(t),l=-(s-.5)*i,c=-(a-.5)*o,h=e.evaluateVariableOffset(t,r);return new e.Point(l+h[0]*n,c+h[1]*n)}function It(t,i,o,r,n){const s=new e.Point(t,i);return o&&s._rotate(r?n:-n),s}class Pt{constructor(e,t,i,o,r){this.transform=e.clone(),this.projection=e.projection.name,this.collisionIndex=new ft(this.transform,r),this.placements={},this.opacities={},this.variableOffsets={},this.stale=!1,this.commitTime=0,this.fadeDuration=t,this.retainedQueryData={},this.collisionGroups=new Ct(i),this.collisionCircleArrays={},this.prevPlacement=o,o&&(o.prevPlacement=void 0),this.placedOrientations={};}getBucketParts(t,i,o,r){const n=o.getBucket(i),s=o.latestFeatureIndex;if(!n||!s||i.id!==n.layerIds[0])return;const a=n.layers[0].layout,l=o.collisionBoxArray,c=Math.pow(2,this.transform.zoom-o.tileID.overscaledZ),h=o.tileSize/e.EXTENT,u=o.tileID.toUnwrapped();this.transform.setProjection(n.projection);const _=(d=o.tileID,p=n.getProjection(),m=this.transform,p.name===this.projection?m.calculateProjMatrix(d.toUnwrapped()):gt(m,p,d));var d,p,m;const f="map"===a.get("text-pitch-alignment"),g="map"===a.get("text-rotation-alignment");i.compileFilter();const v=i.dynamicFilter(),x=i.dynamicFilterNeedsFeature(),y=this.transform.calculatePixelsToTileUnitsMatrix(o),b=tt(_,o.tileID.canonical,f,g,this.transform,n.getProjection(),y);let w=null;if(f){const t=it(_,o.tileID.canonical,f,g,this.transform,n.getProjection(),y);w=e.multiply([],this.transform.labelPlaneMatrix,t);}let T=null;v&&o.latestFeatureIndex&&(T={unwrappedTileID:u,dynamicFilter:v,dynamicFilterNeedsFeature:x,featureIndex:o.latestFeatureIndex}),this.retainedQueryData[n.bucketInstanceId]=new Et(n.bucketInstanceId,s,n.sourceLayerIndex,n.index,o.tileID);const E={bucket:n,layout:a,posMatrix:_,textLabelPlaneMatrix:b,labelToScreenMatrix:w,clippingData:T,scale:c,textPixelRatio:h,holdingForFade:o.holdingForFade(),collisionBoxArray:l,partiallyEvaluatedTextSize:e.evaluateSizeForZoom(n.textSizeData,this.transform.zoom),partiallyEvaluatedIconSize:e.evaluateSizeForZoom(n.iconSizeData,this.transform.zoom),collisionGroup:this.collisionGroups.get(n.sourceID)};if(r)for(const e of n.sortKeyRanges){const{sortKey:i,symbolInstanceStart:o,symbolInstanceEnd:r}=e;t.push({sortKey:i,symbolInstanceStart:o,symbolInstanceEnd:r,parameters:E});}else t.push({symbolInstanceStart:0,symbolInstanceEnd:n.symbolInstances.length,parameters:E});}attemptAnchorPlacement(e,t,i,o,r,n,s,a,l,c,h,u,_,d,p,m,f,g){const{textOffset0:v,textOffset1:x,crossTileID:y}=u,b=[v,x],w=Mt(e,i,o,b,r),T=this.collisionIndex.placeCollisionBox(d,r,t,It(w.x,w.y,n,s,this.transform.angle),h,a,l,c.predicate);if(m){const e=d.getSymbolInstanceIconSize(g,this.transform.zoom,u.placedIconSymbolIndex);if(0===this.collisionIndex.placeCollisionBox(d,e,m,It(w.x,w.y,n,s,this.transform.angle),h,a,l,c.predicate).box.length)return}if(T.box.length>0){let t;return this.prevPlacement&&this.prevPlacement.variableOffsets[y]&&this.prevPlacement.placements[y]&&this.prevPlacement.placements[y].text&&(t=this.prevPlacement.variableOffsets[y].anchor),this.variableOffsets[y]={textOffset:b,width:i,height:o,anchor:e,textScale:r,prevAnchor:t},this.markUsedJustification(d,e,u,p),d.allowVerticalPlacement&&(this.markUsedOrientation(d,p,u),this.placedOrientations[y]=p),{shift:w,placedGlyphBoxes:T}}}placeLayerBucketPart(t,i,o,r){const{bucket:n,layout:s,posMatrix:a,textLabelPlaneMatrix:l,labelToScreenMatrix:c,clippingData:h,textPixelRatio:u,holdingForFade:_,collisionBoxArray:d,partiallyEvaluatedTextSize:p,partiallyEvaluatedIconSize:m,collisionGroup:f}=t.parameters,g=s.get("text-optional"),v=s.get("icon-optional"),x=s.get("text-allow-overlap"),y=s.get("icon-allow-overlap"),b="map"===s.get("text-rotation-alignment"),w="map"===s.get("text-pitch-alignment"),T="none"!==s.get("icon-text-fit"),E="viewport-y"===s.get("symbol-z-order");this.transform.setProjection(n.projection);let C=x&&(y||!n.hasIconData()||v),M=y&&(x||!n.hasTextData()||g);!n.collisionArrays&&d&&n.deserializeCollisionBoxes(d),o&&r&&n.updateCollisionDebugBuffers(this.transform.zoom,d);const I=(t,r,d)=>{const{crossTileID:E,numVerticalGlyphVertices:I}=t;if(h){const o={zoom:this.transform.zoom,pitch:this.transform.pitch};let r=null;if(h.dynamicFilterNeedsFeature){const e=this.retainedQueryData[n.bucketInstanceId];r=h.featureIndex.loadFeature({featureIndex:t.featureIndex,bucketIndex:e.bucketIndex,sourceLayerIndex:e.sourceLayerIndex,layoutVertexArrayOffset:0});}if(!(0, h.dynamicFilter)(o,r,this.retainedQueryData[n.bucketInstanceId].tileID.canonical,new e.Point(t.tileAnchorX,t.tileAnchorY),this.transform.calculateDistanceTileData(h.unwrappedTileID)))return this.placements[E]=new wt(!1,!1,!1,!0),void i.add(E)}if(i.has(E))return;if(_)return void(this.placements[E]=new wt(!1,!1,!1));let P=!1,S=!1,D=!0,L=!1,A=!1,z=null,R={box:null,offscreen:null,occluded:null},O={box:null,offscreen:null,occluded:null},B=null,k=null,F=null,U=0,N=0,j=0;d.textFeatureIndex?U=d.textFeatureIndex:t.useRuntimeCollisionCircles&&(U=t.featureIndex),d.verticalTextFeatureIndex&&(N=d.verticalTextFeatureIndex);const G=e=>{e.tileID=this.retainedQueryData[n.bucketInstanceId].tileID;const t=this.transform.elevation;(t||e.elevation)&&(e.elevation=t?t.getAtTileOffset(e.tileID,e.tileAnchorX,e.tileAnchorY):0);},Z=d.textBox;if(Z){G(Z);const i=i=>{let o=e.WritingMode.horizontal;if(n.allowVerticalPlacement&&!i&&this.prevPlacement){const e=this.prevPlacement.placedOrientations[E];e&&(this.placedOrientations[E]=e,o=e,this.markUsedOrientation(n,o,t));}return o},o=(t,i)=>{if(n.allowVerticalPlacement&&I>0&&d.verticalTextBox){for(const o of n.writingModes)if(o===e.WritingMode.vertical?(R=i(),O=R):R=t(),R&&R.box&&R.box.length)break}else R=t();};if(s.get("text-variable-anchor")){let l=s.get("text-variable-anchor");if(this.prevPlacement&&this.prevPlacement.variableOffsets[E]){const e=this.prevPlacement.variableOffsets[E];l.indexOf(e.anchor)>0&&(l=l.filter((t=>t!==e.anchor)),l.unshift(e.anchor));}const c=(e,i,o)=>{const s=n.getSymbolInstanceTextSize(p,t,this.transform.zoom,r),c=(e.x2-e.x1)*s+2*e.padding,h=(e.y2-e.y1)*s+2*e.padding,_=T&&!y?i:null;_&&G(_);let d={box:[],offscreen:!1,occluded:!1};const g=x?2*l.length:l.length;for(let i=0;i<g;++i){const g=this.attemptAnchorPlacement(l[i%l.length],e,c,h,s,b,w,u,a,f,i>=l.length,t,r,n,o,_,p,m);if(g&&(d=g.placedGlyphBoxes,d&&d.box&&d.box.length)){P=!0,z=g.shift;break}}return d};o((()=>c(Z,d.iconBox,e.WritingMode.horizontal)),(()=>{const t=d.verticalTextBox;return t&&G(t),n.allowVerticalPlacement&&!(R&&R.box&&R.box.length)&&I>0&&t?c(t,d.verticalIconBox,e.WritingMode.vertical):{box:null,offscreen:null,occluded:null}})),R&&(P=R.box,D=R.offscreen,L=R.occluded);const h=i(!(!R||!R.box));if(!P&&this.prevPlacement){const e=this.prevPlacement.variableOffsets[E];e&&(this.variableOffsets[E]=e,this.markUsedJustification(n,e.anchor,t,h));}}else {const s=(i,o)=>{const s=n.getSymbolInstanceTextSize(p,t,this.transform.zoom,r),l=this.collisionIndex.placeCollisionBox(n,s,i,new e.Point(0,0),x,u,a,f.predicate);return l&&l.box&&l.box.length&&(this.markUsedOrientation(n,o,t),this.placedOrientations[E]=o),l};o((()=>s(Z,e.WritingMode.horizontal)),(()=>{const t=d.verticalTextBox;return n.allowVerticalPlacement&&I>0&&t?(G(t),s(t,e.WritingMode.vertical)):{box:null,offscreen:null,occluded:null}})),i(!!(R&&R.box&&R.box.length));}}if(B=R,P=B&&B.box&&B.box.length>0,D=B&&B.offscreen,L=B&&B.occluded,t.useRuntimeCollisionCircles){const i=n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex>=0?t.centerJustifiedTextSymbolIndex:t.verticalPlacedTextSymbolIndex),r=e.evaluateSizeForFeature(n.textSizeData,p,i),h=s.get("text-padding");k=this.collisionIndex.placeCollisionCircles(n,x,i,n.lineVertexArray,n.glyphOffsetArray,r,a,l,c,o,w,f.predicate,t.collisionCircleDiameter*r/e.ONE_EM,h,this.retainedQueryData[n.bucketInstanceId].tileID),P=x||k.circles.length>0&&!k.collisionDetected,D=D&&k.offscreen,L=k.occluded;}if(d.iconFeatureIndex&&(j=d.iconFeatureIndex),d.iconBox){const i=i=>{G(i);const o=T&&z?It(z.x,z.y,b,w,this.transform.angle):new e.Point(0,0),r=n.getSymbolInstanceIconSize(m,this.transform.zoom,t.placedIconSymbolIndex);return this.collisionIndex.placeCollisionBox(n,r,i,o,y,u,a,f.predicate)};O&&O.box&&O.box.length&&d.verticalIconBox?(F=i(d.verticalIconBox),S=F.box.length>0):(F=i(d.iconBox),S=F.box.length>0),D=D&&F.offscreen,A=F.occluded;}const V=g||0===t.numHorizontalGlyphVertices&&0===I,W=v||0===t.numIconVertices;if(V||W?W?V||(S=S&&P):P=S&&P:S=P=S&&P,P&&B&&B.box&&this.collisionIndex.insertCollisionBox(B.box,s.get("text-ignore-placement"),n.bucketInstanceId,O&&O.box&&N?N:U,f.ID),S&&F&&this.collisionIndex.insertCollisionBox(F.box,s.get("icon-ignore-placement"),n.bucketInstanceId,j,f.ID),k&&(P&&this.collisionIndex.insertCollisionCircles(k.circles,s.get("text-ignore-placement"),n.bucketInstanceId,U,f.ID),o)){const e=n.bucketInstanceId;let t=this.collisionCircleArrays[e];void 0===t&&(t=this.collisionCircleArrays[e]=new Tt);for(let e=0;e<k.circles.length;e+=4)t.circles.push(k.circles[e+0]),t.circles.push(k.circles[e+1]),t.circles.push(k.circles[e+2]),t.circles.push(k.collisionDetected?1:0);}const X="globe"!==n.projection.name;C=C&&(X||!L),M=M&&(X||!A),this.placements[E]=new wt(P||C,S||M,D||n.justReloaded),i.add(E);};if(E){const e=n.getSortedSymbolIndexes(this.transform.angle);for(let t=e.length-1;t>=0;--t){const i=e[t];I(n.symbolInstances.get(i),i,n.collisionArrays[i]);}}else for(let e=t.symbolInstanceStart;e<t.symbolInstanceEnd;e++)I(n.symbolInstances.get(e),e,n.collisionArrays[e]);if(o&&n.bucketInstanceId in this.collisionCircleArrays){const t=this.collisionCircleArrays[n.bucketInstanceId];e.invert(t.invProjMatrix,a),t.viewportMatrix=this.collisionIndex.getViewportMatrix();}n.justReloaded=!1;}markUsedJustification(t,i,o,r){const{leftJustifiedTextSymbolIndex:n,centerJustifiedTextSymbolIndex:s,rightJustifiedTextSymbolIndex:a,verticalPlacedTextSymbolIndex:l,crossTileID:c}=o,h=e.getAnchorJustification(i),u=r===e.WritingMode.vertical?l:"left"===h?n:"center"===h?s:"right"===h?a:-1;n>=0&&(t.text.placedSymbolArray.get(n).crossTileID=u>=0&&n!==u?0:c),s>=0&&(t.text.placedSymbolArray.get(s).crossTileID=u>=0&&s!==u?0:c),a>=0&&(t.text.placedSymbolArray.get(a).crossTileID=u>=0&&a!==u?0:c),l>=0&&(t.text.placedSymbolArray.get(l).crossTileID=u>=0&&l!==u?0:c);}markUsedOrientation(t,i,o){const r=i===e.WritingMode.horizontal||i===e.WritingMode.horizontalOnly?i:0,n=i===e.WritingMode.vertical?i:0,{leftJustifiedTextSymbolIndex:s,centerJustifiedTextSymbolIndex:a,rightJustifiedTextSymbolIndex:l,verticalPlacedTextSymbolIndex:c}=o,h=t.text.placedSymbolArray;s>=0&&(h.get(s).placedOrientation=r),a>=0&&(h.get(a).placedOrientation=r),l>=0&&(h.get(l).placedOrientation=r),c>=0&&(h.get(c).placedOrientation=n);}commit(e){this.commitTime=e,this.zoomAtLastRecencyCheck=this.transform.zoom;const t=this.prevPlacement;let i=!1;this.prevZoomAdjustment=t?t.zoomAdjustment(this.transform.zoom):0;const o=t?t.symbolFadeChange(e):1,r=t?t.opacities:{},n=t?t.variableOffsets:{},s=t?t.placedOrientations:{};for(const e in this.placements){const t=this.placements[e],n=r[e];n?(this.opacities[e]=new bt(n,o,t.text,t.icon,null,t.clipped),i=i||t.text!==n.text.placed||t.icon!==n.icon.placed):(this.opacities[e]=new bt(null,o,t.text,t.icon,t.skipFade,t.clipped),i=i||t.text||t.icon);}for(const e in r){const t=r[e];if(!this.opacities[e]){const r=new bt(t,o,!1,!1);r.isHidden()||(this.opacities[e]=r,i=i||t.text.placed||t.icon.placed);}}for(const e in n)this.variableOffsets[e]||!this.opacities[e]||this.opacities[e].isHidden()||(this.variableOffsets[e]=n[e]);for(const e in s)this.placedOrientations[e]||!this.opacities[e]||this.opacities[e].isHidden()||(this.placedOrientations[e]=s[e]);i?this.lastPlacementChangeTime=e:"number"!=typeof this.lastPlacementChangeTime&&(this.lastPlacementChangeTime=t?t.lastPlacementChangeTime:e);}updateLayerOpacities(e,t){const i=new Set;for(const o of t){const t=o.getBucket(e);t&&o.latestFeatureIndex&&e.id===t.layerIds[0]&&this.updateBucketOpacities(t,i,o.collisionBoxArray);}}updateBucketOpacities(t,i,o){t.hasTextData()&&t.text.opacityVertexArray.clear(),t.hasIconData()&&t.icon.opacityVertexArray.clear(),t.hasIconCollisionBoxData()&&t.iconCollisionBox.collisionVertexArray.clear(),t.hasTextCollisionBoxData()&&t.textCollisionBox.collisionVertexArray.clear();const r=t.layers[0].layout,n=!!t.layers[0].dynamicFilter(),s=new bt(null,0,!1,!1,!0),a=r.get("text-allow-overlap"),l=r.get("icon-allow-overlap"),c=r.get("text-variable-anchor"),h="map"===r.get("text-rotation-alignment"),u="map"===r.get("text-pitch-alignment"),_="none"!==r.get("icon-text-fit"),d=new bt(null,0,a&&(l||!t.hasIconData()||r.get("icon-optional")),l&&(a||!t.hasTextData()||r.get("text-optional")),!0);!t.collisionArrays&&o&&(t.hasIconCollisionBoxData()||t.hasTextCollisionBoxData())&&t.deserializeCollisionBoxes(o);const p=(e,t,i)=>{for(let o=0;o<t/4;o++)e.opacityVertexArray.emplaceBack(i);};let m=0;for(let o=0;o<t.symbolInstances.length;o++){const r=t.symbolInstances.get(o),{numHorizontalGlyphVertices:a,numVerticalGlyphVertices:l,crossTileID:f,numIconVertices:g}=r,v=i.has(f);let x=this.opacities[f];v?x=s:x||(x=d,this.opacities[f]=x),i.add(f);const y=a>0||l>0,b=g>0,w=this.placedOrientations[f],T=w===e.WritingMode.vertical,E=w===e.WritingMode.horizontal||w===e.WritingMode.horizontalOnly;if(!y&&!b||x.isHidden()||m++,y){const e=kt(x.text);p(t.text,a,T?Ft:e),p(t.text,l,E?Ft:e);const i=x.text.isHidden(),{leftJustifiedTextSymbolIndex:o,centerJustifiedTextSymbolIndex:n,rightJustifiedTextSymbolIndex:s,verticalPlacedTextSymbolIndex:c}=r,h=t.text.placedSymbolArray,u=i||T?1:0;o>=0&&(h.get(o).hidden=u),n>=0&&(h.get(n).hidden=u),s>=0&&(h.get(s).hidden=u),c>=0&&(h.get(c).hidden=i||E?1:0);const _=this.variableOffsets[f];_&&this.markUsedJustification(t,_.anchor,r,w);const d=this.placedOrientations[f];d&&(this.markUsedJustification(t,"left",r,d),this.markUsedOrientation(t,d,r));}if(b){const e=kt(x.icon),{placedIconSymbolIndex:i,verticalPlacedIconSymbolIndex:o}=r,n=t.icon.placedSymbolArray,s=x.icon.isHidden()?1:0;i>=0&&(p(t.icon,g,T?Ft:e),n.get(i).hidden=s),o>=0&&(p(t.icon,r.numVerticalIconVertices,E?Ft:e),n.get(o).hidden=s);}if(t.hasIconCollisionBoxData()||t.hasTextCollisionBoxData()){const i=t.collisionArrays[o];if(i){let o=new e.Point(0,0),r=!0;if(i.textBox||i.verticalTextBox){if(c){const e=this.variableOffsets[f];e?(o=Mt(e.anchor,e.width,e.height,e.textOffset,e.textScale),h&&o._rotate(u?this.transform.angle:-this.transform.angle)):r=!1;}n&&(r=!x.clipped),i.textBox&&St(t.textCollisionBox.collisionVertexArray,x.text.placed,!r||T,o.x,o.y),i.verticalTextBox&&St(t.textCollisionBox.collisionVertexArray,x.text.placed,!r||E,o.x,o.y);}const s=r&&Boolean(!E&&i.verticalIconBox);i.iconBox&&St(t.iconCollisionBox.collisionVertexArray,x.icon.placed,s,_?o.x:0,_?o.y:0),i.verticalIconBox&&St(t.iconCollisionBox.collisionVertexArray,x.icon.placed,!s,_?o.x:0,_?o.y:0);}}}if(t.fullyClipped=0===m,t.sortFeatures(this.transform.angle),this.retainedQueryData[t.bucketInstanceId]&&(this.retainedQueryData[t.bucketInstanceId].featureSortOrder=t.featureSortOrder),t.hasTextData()&&t.text.opacityVertexBuffer&&t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray),t.hasIconData()&&t.icon.opacityVertexBuffer&&t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray),t.hasIconCollisionBoxData()&&t.iconCollisionBox.collisionVertexBuffer&&t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray),t.hasTextCollisionBoxData()&&t.textCollisionBox.collisionVertexBuffer&&t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray),t.bucketInstanceId in this.collisionCircleArrays){const e=this.collisionCircleArrays[t.bucketInstanceId];t.placementInvProjMatrix=e.invProjMatrix,t.placementViewportMatrix=e.viewportMatrix,t.collisionCircleArray=e.circles,delete this.collisionCircleArrays[t.bucketInstanceId];}}symbolFadeChange(e){return 0===this.fadeDuration?1:(e-this.commitTime)/this.fadeDuration+this.prevZoomAdjustment}zoomAdjustment(e){return Math.max(0,(this.transform.zoom-e)/1.5)}hasTransitions(e){return this.stale||e-this.lastPlacementChangeTime<this.fadeDuration}stillRecent(e,t){const i=this.zoomAtLastRecencyCheck===t?1-this.zoomAdjustment(t):1;return this.zoomAtLastRecencyCheck=t,this.commitTime+this.fadeDuration*i>e}setStale(){this.stale=!0;}}function St(e,t,i,o,r){e.emplaceBack(t?1:0,i?1:0,o||0,r||0),e.emplaceBack(t?1:0,i?1:0,o||0,r||0),e.emplaceBack(t?1:0,i?1:0,o||0,r||0),e.emplaceBack(t?1:0,i?1:0,o||0,r||0);}const Dt=Math.pow(2,25),Lt=Math.pow(2,24),At=Math.pow(2,17),zt=Math.pow(2,16),Rt=Math.pow(2,9),Ot=Math.pow(2,8),Bt=Math.pow(2,1);function kt(e){if(0===e.opacity&&!e.placed)return 0;if(1===e.opacity&&e.placed)return 4294967295;const t=e.placed?1:0,i=Math.floor(127*e.opacity);return i*Dt+t*Lt+i*At+t*zt+i*Rt+t*Ot+i*Bt+t}const Ft=0;class Ut{constructor(e){this._sortAcrossTiles="viewport-y"!==e.layout.get("symbol-z-order")&&void 0!==e.layout.get("symbol-sort-key").constantOr(1),this._currentTileIndex=0,this._currentPartIndex=0,this._seenCrossTileIDs=new Set,this._bucketParts=[];}continuePlacement(e,t,i,o,r){const n=this._bucketParts;for(;this._currentTileIndex<e.length;)if(t.getBucketParts(n,o,e[this._currentTileIndex],this._sortAcrossTiles),this._currentTileIndex++,r())return !0;for(this._sortAcrossTiles&&(this._sortAcrossTiles=!1,n.sort(((e,t)=>e.sortKey-t.sortKey)));this._currentPartIndex<n.length;){const e=n[this._currentPartIndex];if(t.placeLayerBucketPart(e,this._seenCrossTileIDs,i,0===e.symbolInstanceStart),this._currentPartIndex++,r())return !0}return !1}}class Nt{constructor(e,t,i,o,r,n,s,a){this.placement=new Pt(e,r,n,s,a),this._currentPlacementIndex=t.length-1,this._forceFullPlacement=i,this._showCollisionBoxes=o,this._done=!1;}isDone(){return this._done}continuePlacement(t,i,o){const r=e.exported.now(),n=()=>{const t=e.exported.now()-r;return !this._forceFullPlacement&&t>2};for(;this._currentPlacementIndex>=0;){const e=i[t[this._currentPlacementIndex]],r=this.placement.collisionIndex.transform.zoom;if("symbol"===e.type&&(!e.minzoom||e.minzoom<=r)&&(!e.maxzoom||e.maxzoom>r)){if(this._inProgressLayer||(this._inProgressLayer=new Ut(e)),this._inProgressLayer.continuePlacement(o[e.source],this.placement,this._showCollisionBoxes,e,n))return;delete this._inProgressLayer;}this._currentPlacementIndex--;}this._done=!0;}commit(e){return this.placement.commit(e),this.placement}}const jt=512/e.EXTENT/2;class Gt{constructor(t,i,o){this.tileID=t,this.bucketInstanceId=o,this.index=new e.KDBush(i.length,16,Int32Array),this.keys=[],this.crossTileIDs=[];const r=t.canonical.x*e.EXTENT,n=t.canonical.y*e.EXTENT;for(let e=0;e<i.length;e++){const{key:t,crossTileID:o,tileAnchorX:s,tileAnchorY:a}=i.get(e),l=Math.floor((r+s)*jt),c=Math.floor((n+a)*jt);this.index.add(l,c),this.keys.push(t),this.crossTileIDs.push(o);}this.index.finish();}findMatches(t,i,o){const r=this.tileID.canonical.z<i.canonical.z?1:Math.pow(2,this.tileID.canonical.z-i.canonical.z),n=jt/Math.pow(2,i.canonical.z-this.tileID.canonical.z),s=i.canonical.x*e.EXTENT,a=i.canonical.y*e.EXTENT;for(let e=0;e<t.length;e++){const i=t.get(e);if(i.crossTileID)continue;const{key:l,tileAnchorX:c,tileAnchorY:h}=i,u=Math.floor((s+c)*n),_=Math.floor((a+h)*n),d=this.index.range(u-r,_-r,u+r,_+r);for(const e of d){const t=this.crossTileIDs[e];if(this.keys[e]===l&&!o.has(t)){o.add(t),i.crossTileID=t;break}}}}}class Zt{constructor(){this.maxCrossTileID=0;}generate(){return ++this.maxCrossTileID}}class Vt{constructor(){this.indexes={},this.usedCrossTileIDs={},this.lng=0;}handleWrapJump(e){const t=Math.round((e-this.lng)/360);if(0!==t)for(const e in this.indexes){const i=this.indexes[e],o={};for(const e in i){const r=i[e];r.tileID=r.tileID.unwrapTo(r.tileID.wrap+t),o[r.tileID.key]=r;}this.indexes[e]=o;}this.lng=e;}addBucket(e,t,i){if(this.indexes[e.overscaledZ]&&this.indexes[e.overscaledZ][e.key]){if(this.indexes[e.overscaledZ][e.key].bucketInstanceId===t.bucketInstanceId)return !1;this.removeBucketCrossTileIDs(e.overscaledZ,this.indexes[e.overscaledZ][e.key]);}for(let e=0;e<t.symbolInstances.length;e++)t.symbolInstances.get(e).crossTileID=0;this.usedCrossTileIDs[e.overscaledZ]||(this.usedCrossTileIDs[e.overscaledZ]=new Set);const o=this.usedCrossTileIDs[e.overscaledZ];for(const i in this.indexes){const r=this.indexes[i];if(Number(i)>e.overscaledZ)for(const i in r){const n=r[i];n.tileID.isChildOf(e)&&n.findMatches(t.symbolInstances,e,o);}else {const n=r[e.scaledTo(Number(i)).key];n&&n.findMatches(t.symbolInstances,e,o);}}for(let e=0;e<t.symbolInstances.length;e++){const r=t.symbolInstances.get(e);r.crossTileID||(r.crossTileID=i.generate(),o.add(r.crossTileID));}return void 0===this.indexes[e.overscaledZ]&&(this.indexes[e.overscaledZ]={}),this.indexes[e.overscaledZ][e.key]=new Gt(e,t.symbolInstances,t.bucketInstanceId),!0}removeBucketCrossTileIDs(e,t){for(const i of t.crossTileIDs)this.usedCrossTileIDs[e].delete(i);}removeStaleBuckets(e){let t=!1;for(const i in this.indexes){const o=this.indexes[i];for(const r in o)e[o[r].bucketInstanceId]||(this.removeBucketCrossTileIDs(i,o[r]),delete o[r],t=!0);}return t}}class Wt{constructor(){this.layerIndexes={},this.crossTileIDs=new Zt,this.maxBucketInstanceId=0,this.bucketsInCurrentPlacement={};}addLayer(e,t,i,o){let r=this.layerIndexes[e.id];void 0===r&&(r=this.layerIndexes[e.id]=new Vt);let n=!1;const s={};"globe"!==o.name&&r.handleWrapJump(i);for(const i of t){const t=i.getBucket(e);t&&e.id===t.layerIds[0]&&(t.bucketInstanceId||(t.bucketInstanceId=++this.maxBucketInstanceId),r.addBucket(i.tileID,t,this.crossTileIDs)&&(n=!0),s[t.bucketInstanceId]=!0);}return r.removeStaleBuckets(s)&&(n=!0),n}pruneUnusedLayers(e){const t={};e.forEach((e=>{t[e]=!0;}));for(const e in this.layerIndexes)t[e]||delete this.layerIndexes[e];}}const Xt=(t,i)=>e.emitValidationErrors(t,i&&i.filter((e=>"source.canvas"!==e.identifier))),qt=e.pick(Ge,["addLayer","removeLayer","setPaintProperty","setLayoutProperty","setFilter","addSource","removeSource","setLayerZoomRange","setLight","setTransition","setGeoJSONSourceData","setTerrain","setFog","setProjection"]),$t=e.pick(Ge,["setCenter","setZoom","setBearing","setPitch"]),Ht={version:8,layers:[],sources:{}},Yt={fill:!0,line:!0,background:!0,hillshade:!0,raster:!0};class Kt extends e.Evented{constructor(t,i={}){super(),this.map=t,this.dispatcher=new S(Ue(),this),this.imageManager=new y,this.imageManager.setEventedParent(this),this.glyphManager=new e.GlyphManager(t._requestManager,i.localFontFamily?e.LocalGlyphMode.all:i.localIdeographFontFamily?e.LocalGlyphMode.ideographs:e.LocalGlyphMode.none,i.localFontFamily||i.localIdeographFontFamily),this.crossTileSymbolIndex=new Wt,this._layers={},this._num3DLayers=0,this._numSymbolLayers=0,this._numCircleLayers=0,this._serializedLayers={},this._sourceCaches={},this._otherSourceCaches={},this._symbolSourceCaches={},this._loaded=!1,this._availableImages=[],this._order=[],this._drapedFirstOrder=[],this._markersNeedUpdate=!1,this._resetUpdates(),this.dispatcher.broadcast("setReferrer",e.getReferrer());const o=this;this._rtlTextPluginCallback=Kt.registerForPluginStateChange((t=>{o.dispatcher.broadcast("syncRTLPluginState",{pluginStatus:t.pluginStatus,pluginURL:t.pluginURL},((t,i)=>{if(e.triggerPluginCompletionEvent(t),i&&i.every((e=>e)))for(const e in o._sourceCaches){const t=o._sourceCaches[e],i=t.getSource().type;"vector"!==i&&"geojson"!==i||t.reload();}}));})),this.on("data",(e=>{if("source"!==e.dataType||"metadata"!==e.sourceDataType)return;const t=this.getSource(e.sourceId);if(t&&t.vectorLayerIds)for(const e in this._layers){const i=this._layers[e];i.source===t.id&&this._validateLayer(i);}}));}loadURL(t,i={}){this.fire(new e.Event("dataloading",{dataType:"style"}));const o="boolean"==typeof i.validate?i.validate:!e.isMapboxURL(t);t=this.map._requestManager.normalizeStyleURL(t,i.accessToken);const r=this.map._requestManager.transformRequest(t,e.ResourceType.Style);this._request=e.getJSON(r,((t,i)=>{this._request=null,t?this.fire(new e.ErrorEvent(t)):i&&this._load(i,o);}));}loadJSON(t,i={}){this.fire(new e.Event("dataloading",{dataType:"style"})),this._request=e.exported.frame((()=>{this._request=null,this._load(t,!1!==i.validate);}));}loadEmpty(){this.fire(new e.Event("dataloading",{dataType:"style"})),this._load(Ht,!1);}_updateLayerCount(e,t){const i=t?1:-1;e.is3D()&&(this._num3DLayers+=i),"circle"===e.type&&(this._numCircleLayers+=i),"symbol"===e.type&&(this._numSymbolLayers+=i);}_load(t,i){if(i&&Xt(this,e.validateStyle(t)))return;this._loaded=!0,this.stylesheet=e.clone$1(t),this._updateMapProjection();for(const e in t.sources)this.addSource(e,t.sources[e],{validate:!1});this._changed=!1,t.sprite?this._loadSprite(t.sprite):(this.imageManager.setLoaded(!0),this.dispatcher.broadcast("spriteLoaded",!0)),this.glyphManager.setURL(t.glyphs);const o=je(this.stylesheet.layers);this._order=o.map((e=>e.id)),this._layers={},this._serializedLayers={};for(const t of o){const i=e.createStyleLayer(t);i.setEventedParent(this,{layer:{id:i.id}}),this._layers[i.id]=i,this._serializedLayers[i.id]=i.serialize(),this._updateLayerCount(i,!0);}this.dispatcher.broadcast("setLayers",this._serializeLayers(this._order)),this.light=new w(this.stylesheet.light),this.stylesheet.terrain&&!this.terrainSetForDrapingOnly()&&this._createTerrain(this.stylesheet.terrain,1),this.stylesheet.fog&&this._createFog(this.stylesheet.fog),this._updateDrapeFirstLayers(),this.fire(new e.Event("data",{dataType:"style"})),this.fire(new e.Event("style.load"));}terrainSetForDrapingOnly(){return !!this.terrain&&0===this.terrain.drapeRenderMode}setProjection(e){e?this.stylesheet.projection=e:delete this.stylesheet.projection,this._updateMapProjection();}applyProjectionUpdate(){this._loaded&&(this.dispatcher.broadcast("setProjection",this.map.transform.projectionOptions),this.map.transform.projection.requiresDraping?this.getTerrain()||this.stylesheet.terrain||this.setTerrainForDraping():this.terrainSetForDrapingOnly()&&this.setTerrain(null));}_updateMapProjection(){this.map._useExplicitProjection?this.applyProjectionUpdate():this.map._prioritizeAndUpdateProjection(null,this.stylesheet.projection);}_loadSprite(t){this._spriteRequest=function(t,i,o){let r,n,s;const a=e.exported.devicePixelRatio>1?"@2x":"";let l=e.getJSON(i.transformRequest(i.normalizeSpriteURL(t,a,".json"),e.ResourceType.SpriteJSON),((e,t)=>{l=null,s||(s=e,r=t,h());})),c=e.getImage(i.transformRequest(i.normalizeSpriteURL(t,a,".png"),e.ResourceType.SpriteImage),((e,t)=>{c=null,s||(s=e,n=t,h());}));function h(){if(s)o(s);else if(r&&n){const t=e.exported.getImageData(n),i={};for(const o in r){const{width:n,height:s,x:a,y:l,sdf:c,pixelRatio:h,stretchX:u,stretchY:_,content:d}=r[o],p=new e.RGBAImage({width:n,height:s});e.RGBAImage.copy(t,p,{x:a,y:l},{x:0,y:0},{width:n,height:s}),i[o]={data:p,pixelRatio:h,sdf:c,stretchX:u,stretchY:_,content:d};}o(null,i);}}return {cancel(){l&&(l.cancel(),l=null),c&&(c.cancel(),c=null);}}}(t,this.map._requestManager,((t,i)=>{if(this._spriteRequest=null,t)this.fire(new e.ErrorEvent(t));else if(i)for(const e in i)this.imageManager.addImage(e,i[e]);this.imageManager.setLoaded(!0),this._availableImages=this.imageManager.listImages(),this.dispatcher.broadcast("setImages",this._availableImages),this.dispatcher.broadcast("spriteLoaded",!0),this.fire(new e.Event("data",{dataType:"style"}));}));}_validateLayer(t){const i=this.getSource(t.source);if(!i)return;const o=t.sourceLayer;o&&("geojson"===i.type||i.vectorLayerIds&&-1===i.vectorLayerIds.indexOf(o))&&this.fire(new e.ErrorEvent(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t.id}"`)));}loaded(){if(!this._loaded)return !1;if(Object.keys(this._updatedSources).length)return !1;for(const e in this._sourceCaches)if(!this._sourceCaches[e].loaded())return !1;return !!this.imageManager.isLoaded()}_serializeLayers(e){const t=[];for(const i of e){const e=this._layers[i];"custom"!==e.type&&t.push(e.serialize());}return t}hasTransitions(){if(this.light&&this.light.hasTransition())return !0;if(this.fog&&this.fog.hasTransition())return !0;for(const e in this._sourceCaches)if(this._sourceCaches[e].hasTransition())return !0;for(const e in this._layers)if(this._layers[e].hasTransition())return !0;return !1}get order(){return this.map._optimizeForTerrain&&this.terrain?this._drapedFirstOrder:this._order}isLayerDraped(e){return !!this.terrain&&("function"==typeof e.isLayerDraped?e.isLayerDraped():Yt[e.type])}_checkLoaded(){if(!this._loaded)throw new Error("Style is not done loading")}update(t){if(!this._loaded)return;const i=this._changed;if(this._changed){const e=Object.keys(this._updatedLayers),i=Object.keys(this._removedLayers);(e.length||i.length)&&this._updateWorkerLayers(e,i);for(const e in this._updatedSources){const t=this._updatedSources[e];"reload"===t?this._reloadSource(e):"clear"===t&&this._clearSource(e);}this._updateTilesForChangedImages();for(const e in this._updatedPaintProps)this._layers[e].updateTransitions(t);this.light.updateTransitions(t),this.fog&&this.fog.updateTransitions(t),this._resetUpdates();}const o={};for(const e in this._sourceCaches){const t=this._sourceCaches[e];o[e]=t.used,t.used=!1;}for(const e of this._order){const i=this._layers[e];if(i.recalculate(t,this._availableImages),!i.isHidden(t.zoom)){const e=this._getLayerSourceCache(i);e&&(e.used=!0);}const o=this.map.painter;if(o){const e=i.getProgramIds();if(!e)continue;const r=i.getProgramConfiguration(t.zoom);for(const t of e)o.useProgram(t,r);}}for(const t in o){const i=this._sourceCaches[t];o[t]!==i.used&&i.getSource().fire(new e.Event("data",{sourceDataType:"visibility",dataType:"source",sourceId:i.getSource().id}));}this.light.recalculate(t),this.terrain&&this.terrain.recalculate(t),this.fog&&this.fog.recalculate(t),this.z=t.zoom,this._markersNeedUpdate&&(this._updateMarkersOpacity(),this._markersNeedUpdate=!1),i&&this.fire(new e.Event("data",{dataType:"style"}));}_updateTilesForChangedImages(){const e=Object.keys(this._changedImages);if(e.length){for(const t in this._sourceCaches)this._sourceCaches[t].reloadTilesForDependencies(["icons","patterns"],e);this._changedImages={};}}_updateWorkerLayers(e,t){this.dispatcher.broadcast("updateLayers",{layers:this._serializeLayers(e),removedIds:t});}_resetUpdates(){this._changed=!1,this._updatedLayers={},this._removedLayers={},this._updatedSources={},this._updatedPaintProps={},this._changedImages={};}setState(i){if(this._checkLoaded(),Xt(this,e.validateStyle(i)))return !1;(i=e.clone$1(i)).layers=je(i.layers);const o=function(e,i){if(!e)return [{command:Ge.setStyle,args:[i]}];let o=[];try{if(!t(e.version,i.version))return [{command:Ge.setStyle,args:[i]}];t(e.center,i.center)||o.push({command:Ge.setCenter,args:[i.center]}),t(e.zoom,i.zoom)||o.push({command:Ge.setZoom,args:[i.zoom]}),t(e.bearing,i.bearing)||o.push({command:Ge.setBearing,args:[i.bearing]}),t(e.pitch,i.pitch)||o.push({command:Ge.setPitch,args:[i.pitch]}),t(e.sprite,i.sprite)||o.push({command:Ge.setSprite,args:[i.sprite]}),t(e.glyphs,i.glyphs)||o.push({command:Ge.setGlyphs,args:[i.glyphs]}),t(e.transition,i.transition)||o.push({command:Ge.setTransition,args:[i.transition]}),t(e.light,i.light)||o.push({command:Ge.setLight,args:[i.light]}),t(e.fog,i.fog)||o.push({command:Ge.setFog,args:[i.fog]}),t(e.projection,i.projection)||o.push({command:Ge.setProjection,args:[i.projection]});const r={},n=[];!function(e,i,o,r){let n;for(n in i=i||{},e=e||{})e.hasOwnProperty(n)&&(i.hasOwnProperty(n)||Ve(n,o,r));for(n in i){if(!i.hasOwnProperty(n))continue;const s=i[n];e.hasOwnProperty(n)?t(e[n],s)||("geojson"===e[n].type&&"geojson"===s.type&&Xe(e,i,n)?o.push({command:Ge.setGeoJSONSourceData,args:[n,s.data]}):We(n,i,o,r)):Ze(n,i,o);}}(e.sources,i.sources,n,r);const s=[];e.layers&&e.layers.forEach((e=>{e.source&&r[e.source]?o.push({command:Ge.removeLayer,args:[e.id]}):s.push(e);}));let a=e.terrain;a&&r[a.source]&&(o.push({command:Ge.setTerrain,args:[void 0]}),a=void 0),o=o.concat(n),t(a,i.terrain)||o.push({command:Ge.setTerrain,args:[i.terrain]}),function(e,i,o){i=i||[];const r=(e=e||[]).map($e),n=i.map($e),s=e.reduce(He,{}),a=i.reduce(He,{}),l=r.slice(),c=Object.create(null);let h,u,_,d,p,m,f;for(h=0,u=0;h<r.length;h++)_=r[h],a.hasOwnProperty(_)?u++:(o.push({command:Ge.removeLayer,args:[_]}),l.splice(l.indexOf(_,u),1));for(h=0,u=0;h<n.length;h++)_=n[n.length-1-h],l[l.length-1-h]!==_&&(s.hasOwnProperty(_)?(o.push({command:Ge.removeLayer,args:[_]}),l.splice(l.lastIndexOf(_,l.length-u),1)):u++,m=l[l.length-h],o.push({command:Ge.addLayer,args:[a[_],m]}),l.splice(l.length-h,0,_),c[_]=!0);for(h=0;h<n.length;h++)if(_=n[h],d=s[_],p=a[_],!c[_]&&!t(d,p))if(t(d.source,p.source)&&t(d["source-layer"],p["source-layer"])&&t(d.type,p.type)){for(f in qe(d.layout,p.layout,o,_,null,Ge.setLayoutProperty),qe(d.paint,p.paint,o,_,null,Ge.setPaintProperty),t(d.filter,p.filter)||o.push({command:Ge.setFilter,args:[_,p.filter]}),t(d.minzoom,p.minzoom)&&t(d.maxzoom,p.maxzoom)||o.push({command:Ge.setLayerZoomRange,args:[_,p.minzoom,p.maxzoom]}),d)d.hasOwnProperty(f)&&"layout"!==f&&"paint"!==f&&"filter"!==f&&"metadata"!==f&&"minzoom"!==f&&"maxzoom"!==f&&(0===f.indexOf("paint.")?qe(d[f],p[f],o,_,f.slice(6),Ge.setPaintProperty):t(d[f],p[f])||o.push({command:Ge.setLayerProperty,args:[_,f,p[f]]}));for(f in p)p.hasOwnProperty(f)&&!d.hasOwnProperty(f)&&"layout"!==f&&"paint"!==f&&"filter"!==f&&"metadata"!==f&&"minzoom"!==f&&"maxzoom"!==f&&(0===f.indexOf("paint.")?qe(d[f],p[f],o,_,f.slice(6),Ge.setPaintProperty):t(d[f],p[f])||o.push({command:Ge.setLayerProperty,args:[_,f,p[f]]}));}else o.push({command:Ge.removeLayer,args:[_]}),m=l[l.lastIndexOf(_)+1],o.push({command:Ge.addLayer,args:[p,m]});}(s,i.layers,o);}catch(e){console.warn("Unable to compute style diff:",e),o=[{command:Ge.setStyle,args:[i]}];}return o}(this.serialize(),i).filter((e=>!(e.command in $t)));if(0===o.length)return !1;const r=o.filter((e=>!(e.command in qt)));if(r.length>0)throw new Error(`Unimplemented: ${r.map((e=>e.command)).join(", ")}.`);return o.forEach((e=>{"setTransition"!==e.command&&"setProjection"!==e.command&&this[e.command].apply(this,e.args);})),this.stylesheet=i,this._updateMapProjection(),!0}addImage(t,i){return this.getImage(t)?this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))):(this.imageManager.addImage(t,i),this._afterImageUpdated(t),this)}updateImage(e,t){this.imageManager.updateImage(e,t);}getImage(e){return this.imageManager.getImage(e)}removeImage(t){return this.getImage(t)?(this.imageManager.removeImage(t),this._afterImageUpdated(t),this):this.fire(new e.ErrorEvent(new Error("No image with this name exists.")))}_afterImageUpdated(t){this._availableImages=this.imageManager.listImages(),this._changedImages[t]=!0,this._changed=!0,this.dispatcher.broadcast("setImages",this._availableImages),this.fire(new e.Event("data",{dataType:"style"}));}listImages(){return this._checkLoaded(),this._availableImages.slice()}addSource(t,i,o={}){if(this._checkLoaded(),void 0!==this.getSource(t))throw new Error("There is already a source with this ID");if(!i.type)throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);if(["vector","raster","geojson","video","image"].indexOf(i.type)>=0&&this._validate(e.validateSource,`sources.${t}`,i,null,o))return;this.map&&this.map._collectResourceTiming&&(i.collectResourceTiming=!0);const r=De(t,i,this.dispatcher,this);r.setEventedParent(this,(()=>({isSourceLoaded:this._isSourceCacheLoaded(t),source:r.serialize(),sourceId:t})));const n=i=>{const o=(i?"symbol:":"other:")+t,n=this._sourceCaches[o]=new e.SourceCache(o,r,i);(i?this._symbolSourceCaches:this._otherSourceCaches)[t]=n,n.style=this,n.onAdd(this.map);};n(!1),"vector"!==i.type&&"geojson"!==i.type||n(!0),r.onAdd&&r.onAdd(this.map),this._changed=!0;}removeSource(t){this._checkLoaded();const i=this.getSource(t);if(!i)throw new Error("There is no source with this ID");for(const i in this._layers)if(this._layers[i].source===t)return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${i}" is using it.`)));if(this.terrain&&this.terrain.get().source===t)return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));const o=this._getSourceCaches(t);for(const t of o)delete this._sourceCaches[t.id],delete this._updatedSources[t.id],t.fire(new e.Event("data",{sourceDataType:"metadata",dataType:"source",sourceId:t.getSource().id})),t.setEventedParent(null),t.clearTiles();return delete this._otherSourceCaches[t],delete this._symbolSourceCaches[t],i.setEventedParent(null),i.onRemove&&i.onRemove(this.map),this._changed=!0,this}setGeoJSONSourceData(e,t){this._checkLoaded(),this.getSource(e).setData(t),this._changed=!0;}getSource(e){const t=this._getSourceCache(e);return t&&t.getSource()}_getSources(){const e=[];for(const t in this._otherSourceCaches){const i=this._getSourceCache(t);i&&e.push(i.getSource());}return e}addLayer(t,i,o={}){this._checkLoaded();const r=t.id;if(this.getLayer(r))return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));let n;if("custom"===t.type){if(Xt(this,e.validateCustomStyleLayer(t)))return;n=e.createStyleLayer(t);}else {if("object"==typeof t.source&&(this.addSource(r,t.source),t=e.clone$1(t),t=e.extend(t,{source:r})),this._validate(e.validateLayer,`layers.${r}`,t,{arrayIndex:-1},o))return;n=e.createStyleLayer(t),this._validateLayer(n),n.setEventedParent(this,{layer:{id:r}}),this._serializedLayers[n.id]=n.serialize(),this._updateLayerCount(n,!0);}const s=i?this._order.indexOf(i):this._order.length;if(i&&-1===s)return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));this._order.splice(s,0,r),this._layerOrderChanged=!0,this._layers[r]=n;const a=this._getLayerSourceCache(n);if(this._removedLayers[r]&&n.source&&a&&"custom"!==n.type){const e=this._removedLayers[r];delete this._removedLayers[r],e.type!==n.type?this._updatedSources[n.source]="clear":(this._updatedSources[n.source]="reload",a.pause());}this._updateLayer(n),n.onAdd&&n.onAdd(this.map),this._updateDrapeFirstLayers();}moveLayer(t,i){if(this._checkLoaded(),this._changed=!0,!this._layers[t])return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));if(t===i)return;const o=this._order.indexOf(t);this._order.splice(o,1);const r=i?this._order.indexOf(i):this._order.length;i&&-1===r?this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))):(this._order.splice(r,0,t),this._layerOrderChanged=!0,this._updateDrapeFirstLayers());}removeLayer(t){this._checkLoaded();const i=this._layers[t];if(!i)return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));i.setEventedParent(null),this._updateLayerCount(i,!1);const o=this._order.indexOf(t);this._order.splice(o,1),this._layerOrderChanged=!0,this._changed=!0,this._removedLayers[t]=i,delete this._layers[t],delete this._serializedLayers[t],delete this._updatedLayers[t],delete this._updatedPaintProps[t],i.onRemove&&i.onRemove(this.map),this._updateDrapeFirstLayers();}getLayer(e){return this._layers[e]}hasLayer(e){return e in this._layers}hasLayerType(e){for(const t in this._layers)if(this._layers[t].type===e)return !0;return !1}setLayerZoomRange(t,i,o){this._checkLoaded();const r=this.getLayer(t);r?r.minzoom===i&&r.maxzoom===o||(null!=i&&(r.minzoom=i),null!=o&&(r.maxzoom=o),this._updateLayer(r)):this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)));}setFilter(i,o,r={}){this._checkLoaded();const n=this.getLayer(i);if(n){if(!t(n.filter,o))return null==o?(n.filter=void 0,void this._updateLayer(n)):void(this._validate(e.validateFilter,`layers.${n.id}.filter`,o,{layerType:n.type},r)||(n.filter=e.clone$1(o),this._updateLayer(n)))}else this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));}getFilter(t){const i=this.getLayer(t);return i&&e.clone$1(i.filter)}setLayoutProperty(i,o,r,n={}){this._checkLoaded();const s=this.getLayer(i);s?t(s.getLayoutProperty(o),r)||(s.setLayoutProperty(o,r,n),this._updateLayer(s)):this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));}getLayoutProperty(t,i){const o=this.getLayer(t);if(o)return o.getLayoutProperty(i);this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)));}setPaintProperty(i,o,r,n={}){this._checkLoaded();const s=this.getLayer(i);s?t(s.getPaintProperty(o),r)||(s.setPaintProperty(o,r,n)&&this._updateLayer(s),this._changed=!0,this._updatedPaintProps[i]=!0):this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));}getPaintProperty(e,t){const i=this.getLayer(e);return i&&i.getPaintProperty(t)}setFeatureState(t,i){this._checkLoaded();const o=t.source,r=t.sourceLayer,n=this.getSource(o);if(!n)return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));const s=n.type;if("geojson"===s&&r)return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));if("vector"===s&&!r)return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));void 0===t.id&&this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));const a=this._getSourceCaches(o);for(const e of a)e.setFeatureState(r,t.id,i);}removeFeatureState(t,i){this._checkLoaded();const o=t.source,r=this.getSource(o);if(!r)return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));const n=r.type,s="vector"===n?t.sourceLayer:void 0;if("vector"===n&&!s)return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));if(i&&"string"!=typeof t.id&&"number"!=typeof t.id)return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));const a=this._getSourceCaches(o);for(const e of a)e.removeFeatureState(s,t.id,i);}getFeatureState(t){this._checkLoaded();const i=t.source,o=t.sourceLayer,r=this.getSource(i);if(r){if("vector"!==r.type||o)return void 0===t.id&&this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))),this._getSourceCaches(i)[0].getFeatureState(o,t.id);this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));}getTransition(){return e.extend({duration:300,delay:0},this.stylesheet&&this.stylesheet.transition)}serialize(){const t={};for(const e in this._sourceCaches){const i=this._sourceCaches[e].getSource();t[i.id]||(t[i.id]=i.serialize());}return e.filterObject({version:this.stylesheet.version,name:this.stylesheet.name,metadata:this.stylesheet.metadata,light:this.stylesheet.light,terrain:this.getTerrain()||void 0,fog:this.stylesheet.fog,center:this.stylesheet.center,zoom:this.stylesheet.zoom,bearing:this.stylesheet.bearing,pitch:this.stylesheet.pitch,sprite:this.stylesheet.sprite,glyphs:this.stylesheet.glyphs,transition:this.stylesheet.transition,projection:this.stylesheet.projection,sources:t,layers:this._serializeLayers(this._order)},(e=>void 0!==e))}_updateLayer(e){this._updatedLayers[e.id]=!0;const t=this._getLayerSourceCache(e);e.source&&!this._updatedSources[e.source]&&t&&"raster"!==t.getSource().type&&(this._updatedSources[e.source]="reload",t.pause()),this._changed=!0,e.invalidateCompiledFilter();}_flattenAndSortRenderedFeatures(e){const t=e=>"fill-extrusion"===this._layers[e].type,i={},o=[];for(let r=this._order.length-1;r>=0;r--){const n=this._order[r];if(t(n)){i[n]=r;for(const t of e){const e=t[n];if(e)for(const t of e)o.push(t);}}}o.sort(((e,t)=>t.intersectionZ-e.intersectionZ));const r=[];for(let n=this._order.length-1;n>=0;n--){const s=this._order[n];if(t(s))for(let e=o.length-1;e>=0;e--){const t=o[e].feature;if(i[t.layer.id]<n)break;r.push(t),o.pop();}else for(const t of e){const e=t[s];if(e)for(const t of e)r.push(t.feature);}}return r}queryRenderedFeatures(t,i,o){i&&i.filter&&this._validate(e.validateFilter,"queryRenderedFeatures.filter",i.filter,null,i);const r={};if(i&&i.layers){if(!Array.isArray(i.layers))return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))),[];for(const t of i.layers){const i=this._layers[t];if(!i)return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))),[];r[i.source]=!0;}}const n=[];i.availableImages=this._availableImages;const s=i&&i.layers?i.layers.some((e=>{const t=this.getLayer(e);return t&&t.is3D()})):this.has3DLayers(),a=L.createFromScreenPoints(t,o);for(const e in this._sourceCaches){const t=this._sourceCaches[e].getSource().id;i.layers&&!r[t]||n.push(Ae(this._sourceCaches[e],this._layers,this._serializedLayers,a,i,o,s,!!this.map._showQueryGeometry));}return this.placement&&n.push(function(e,t,i,o,r,n,s){const a={},l=n.queryRenderedSymbols(o),c=[];for(const e of Object.keys(l).map(Number))c.push(s[e]);c.sort(Re);for(const i of c){const o=i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId],t,i.bucketIndex,i.sourceLayerIndex,r.filter,r.layers,r.availableImages,e);for(const e in o){const t=a[e]=a[e]||[],r=o[e];r.sort(((e,t)=>{const o=i.featureSortOrder;if(o){const i=o.indexOf(e.featureIndex);return o.indexOf(t.featureIndex)-i}return t.featureIndex-e.featureIndex}));for(const e of r)t.push(e);}}for(const t in a)a[t].forEach((o=>{const r=o.feature,n=i(e[t]);if(!n)return;const s=n.getFeatureState(r.layer["source-layer"],r.id);r.source=r.layer.source,r.layer["source-layer"]&&(r.sourceLayer=r.layer["source-layer"]),r.state=s;}));return a}(this._layers,this._serializedLayers,this._getLayerSourceCache.bind(this),a.screenGeometry,i,this.placement.collisionIndex,this.placement.retainedQueryData)),this._flattenAndSortRenderedFeatures(n)}querySourceFeatures(t,i){i&&i.filter&&this._validate(e.validateFilter,"querySourceFeatures.filter",i.filter,null,i);const o=this._getSourceCaches(t);let r=[];for(const e of o)r=r.concat(ze(e,i));return r}addSourceType(e,t,i){return Kt.getSourceType(e)?i(new Error(`A source type called "${e}" already exists.`)):(Kt.setSourceType(e,t),t.workerSourceURL?void this.dispatcher.broadcast("loadWorkerSource",{name:e,url:t.workerSourceURL},i):i(null,null))}getLight(){return this.light.getLight()}setLight(e,i={}){this._checkLoaded();const o=this.light.getLight();let r=!1;for(const i in e)if(!t(e[i],o[i])){r=!0;break}if(!r)return;const n=this._setTransitionParameters({duration:300,delay:0});this.light.setLight(e,i),this.light.updateTransitions(n);}getTerrain(){return this.terrain&&1===this.terrain.drapeRenderMode?this.terrain.get():null}setTerrainForDraping(){this.setTerrain({source:"",exaggeration:0},0);}setTerrain(i,o=1){if(this._checkLoaded(),!i)return delete this.terrain,delete this.stylesheet.terrain,this.dispatcher.broadcast("enableTerrain",!1),this._force3DLayerUpdate(),void(this._markersNeedUpdate=!0);let r=i;if(1===o){if("object"==typeof r.source){const t="terrain-dem-src";this.addSource(t,r.source),r=e.clone$1(r),r=e.extend(r,{source:t});}if(this._validate(e.validateTerrain,"terrain",r))return}if(!this.terrain||this.terrain&&o!==this.terrain.drapeRenderMode){if(!r)return;this._createTerrain(r,o);}else {const i=this.terrain,o=i.get();for(const t of Object.keys(e.spec.terrain))!r.hasOwnProperty(t)&&e.spec.terrain[t].default&&(r[t]=e.spec.terrain[t].default);for(const e in r)if(!t(r[e],o[e])){i.set(r),this.stylesheet.terrain=r;const e=this._setTransitionParameters({duration:0});i.updateTransitions(e);break}}this._updateDrapeFirstLayers(),this._markersNeedUpdate=!0;}_createFog(e){const t=this.fog=new P(e,this.map.transform);this.stylesheet.fog=e;const i=this._setTransitionParameters({duration:0});t.updateTransitions(i);}_updateMarkersOpacity(){0!==this.map._markers.length&&this.map._requestDomTask((()=>{for(const e of this.map._markers)e._evaluateOpacity();}));}getFog(){return this.fog?this.fog.get():null}setFog(e){if(this._checkLoaded(),!e)return delete this.fog,delete this.stylesheet.fog,void(this._markersNeedUpdate=!0);if(this.fog){const i=this.fog,o=i.get();0===Object.keys(e).length&&i.set(e);for(const r in e)if(!t(e[r],o[r])){i.set(e),this.stylesheet.fog=e;const t=this._setTransitionParameters({duration:0});i.updateTransitions(t);break}}else this._createFog(e);this._markersNeedUpdate=!0;}_setTransitionParameters(t){return {now:e.exported.now(),transition:e.extend(t,this.stylesheet.transition)}}_updateDrapeFirstLayers(){if(!this.map._optimizeForTerrain||!this.terrain)return;const e=this._order.filter((e=>this.isLayerDraped(this._layers[e]))),t=this._order.filter((e=>!this.isLayerDraped(this._layers[e])));this._drapedFirstOrder=[],this._drapedFirstOrder.push(...e),this._drapedFirstOrder.push(...t);}_createTerrain(e,t){const i=this.terrain=new E(e,t);this.stylesheet.terrain=e,this.dispatcher.broadcast("enableTerrain",!this.terrainSetForDrapingOnly()),this._force3DLayerUpdate();const o=this._setTransitionParameters({duration:0});i.updateTransitions(o);}_force3DLayerUpdate(){for(const e in this._layers){const t=this._layers[e];"fill-extrusion"===t.type&&this._updateLayer(t);}}_forceSymbolLayerUpdate(){for(const e in this._layers){const t=this._layers[e];"symbol"===t.type&&this._updateLayer(t);}}_validate(t,i,o,r,n={}){return (!n||!1!==n.validate)&&Xt(this,t.call(e.validateStyle,e.extend({key:i,style:this.serialize(),value:o,styleSpec:e.spec},r)))}_remove(){this._request&&(this._request.cancel(),this._request=null),this._spriteRequest&&(this._spriteRequest.cancel(),this._spriteRequest=null),e.evented.off("pluginStateChange",this._rtlTextPluginCallback);for(const e in this._layers)this._layers[e].setEventedParent(null);for(const e in this._sourceCaches)this._sourceCaches[e].clearTiles(),this._sourceCaches[e].setEventedParent(null);this.imageManager.setEventedParent(null),this.setEventedParent(null),this.dispatcher.remove();}_clearSource(e){const t=this._getSourceCaches(e);for(const e of t)e.clearTiles();}_reloadSource(e){const t=this._getSourceCaches(e);for(const e of t)e.resume(),e.reload();}_reloadSources(){for(const e of this._getSources())e.reload&&e.reload();}_updateSources(e){for(const t in this._sourceCaches)this._sourceCaches[t].update(e);}_generateCollisionBoxes(){for(const e in this._sourceCaches){const t=this._sourceCaches[e];t.resume(),t.reload();}}_updatePlacement(t,i,o,r,n=!1){let s=!1,a=!1;const l={};for(const e of this._order){const i=this._layers[e];if("symbol"!==i.type)continue;if(!l[i.source]){const e=this._getLayerSourceCache(i);if(!e)continue;l[i.source]=e.getRenderableIds(!0).map((t=>e.getTileByID(t))).sort(((e,t)=>t.tileID.overscaledZ-e.tileID.overscaledZ||(e.tileID.isLessThan(t.tileID)?-1:1)));}const o=this.crossTileSymbolIndex.addLayer(i,l[i.source],t.center.lng,t.projection);s=s||o;}if(this.crossTileSymbolIndex.pruneUnusedLayers(this._order),n=n||this._layerOrderChanged||0===o,this._layerOrderChanged&&this.fire(new e.Event("neworder")),(n||!this.pauseablePlacement||this.pauseablePlacement.isDone()&&!this.placement.stillRecent(e.exported.now(),t.zoom))&&(this.pauseablePlacement=new Nt(t,this._order,n,i,o,r,this.placement,this.fog&&t.projection.supportsFog?this.fog.state:null),this._layerOrderChanged=!1),this.pauseablePlacement.isDone()?this.placement.setStale():(this.pauseablePlacement.continuePlacement(this._order,this._layers,l),this.pauseablePlacement.isDone()&&(this.placement=this.pauseablePlacement.commit(e.exported.now()),a=!0),s&&this.pauseablePlacement.placement.setStale()),a||s)for(const e of this._order){const t=this._layers[e];"symbol"===t.type&&this.placement.updateLayerOpacities(t,l[t.source]);}return !this.pauseablePlacement.isDone()||this.placement.hasTransitions(e.exported.now())}_releaseSymbolFadeTiles(){for(const e in this._sourceCaches)this._sourceCaches[e].releaseSymbolFadeTiles();}getImages(e,t,i){this.imageManager.getImages(t.icons,i),this._updateTilesForChangedImages();const o=e=>{e&&e.setDependencies(t.tileID.key,t.type,t.icons);};o(this._otherSourceCaches[t.source]),o(this._symbolSourceCaches[t.source]);}getGlyphs(e,t,i){this.glyphManager.getGlyphs(t.stacks,i);}getResource(t,i,o){return e.makeRequest(i,o)}_getSourceCache(e){return this._otherSourceCaches[e]}_getLayerSourceCache(e){return "symbol"===e.type?this._symbolSourceCaches[e.source]:this._otherSourceCaches[e.source]}_getSourceCaches(e){const t=[];return this._otherSourceCaches[e]&&t.push(this._otherSourceCaches[e]),this._symbolSourceCaches[e]&&t.push(this._symbolSourceCaches[e]),t}_isSourceCacheLoaded(t){const i=this._getSourceCaches(t);return 0===i.length?(this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))),!1):i.every((e=>e.loaded()))}has3DLayers(){return this._num3DLayers>0}hasSymbolLayers(){return this._numSymbolLayers>0}hasCircleLayers(){return this._numCircleLayers>0}_clearWorkerCaches(){this.dispatcher.broadcast("clearCaches");}destroy(){this._clearWorkerCaches(),this.terrainSetForDrapingOnly()&&(delete this.terrain,delete this.stylesheet.terrain);}}Kt.getSourceType=function(e){return Se[e]},Kt.setSourceType=function(e,t){Se[e]=t;},Kt.registerForPluginStateChange=e.registerForPluginStateChange;var Jt="\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0",Qt="attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",ei="\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",ti="#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",ii="#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";let oi={},ri={};const ni=[];hi(Jt,ni),hi(ei,ni),hi(ti,ni),hi(ii,ni),oi=ui("",ei),ri=ui(ii,ti);const si=ui("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}","\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."),ai=Jt,li="\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";var ci={background:ui("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),backgroundPattern:ui("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),circle:ui("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),clippingMask:ui("void main() {gl_FragColor=vec4(1.0);}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),heatmap:ui("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),heatmapTexture:ui("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}","attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),collisionBox:ui("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}","attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),collisionCircle:ui("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}","attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),debug:ui("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}","attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),fill:ui("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),fillOutline:ui("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),fillOutlinePattern:ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),fillPattern:ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),fillExtrusion:ui("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),fillExtrusionPattern:ui("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),hillshadePrepare:ui("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),hillshade:ui("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),line:ui("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),linePattern:ui("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),raster:ui("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),symbolIcon:ui("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),symbolSDF:ui("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),symbolTextAndIcon:ui("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),terrainRaster:ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),terrainDepth:ui("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}","uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),skybox:ui("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",Qt),skyboxGradient:ui("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",Qt),skyboxCapture:ui("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}","attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),globeRaster:ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),globeAtmosphere:ui("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}","attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}")};function hi(e,t){const i=e.replace(/\s*\/\/[^\n]*\n/g,"\n").split("\n");for(let e of i)if(e=e.trim(),"#"===e[0]&&e.includes("if")&&!e.includes("endif")){e=e.replace("#","").replace(/ifdef|ifndef|elif|if/g,"").replace(/!|defined|\(|\)|\|\||&&/g,"").replace(/\s+/g," ").trim();const i=e.split(" ");for(const e of i)t.includes(e)||t.push(e);}}function ui(e,t){const i=/#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,o=t.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g),r={},n=[...ni];return hi(e,n),hi(t,n),{fragmentSource:e=e.replace(i,((e,t,i,o,n)=>(r[n]=!0,"define"===t?`\n#ifndef HAS_UNIFORM_u_${n}\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n`:`\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = u_${n};\n#endif\n`))),vertexSource:t=t.replace(i,((e,t,i,o,n)=>{const s="float"===o?"vec2":"vec4",a=n.match(/color/)?"color":s;return r[n]?"define"===t?`\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n`:"vec4"===a?`\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`:`\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`:"define"===t?`\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n`:"vec4"===a?`\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`:`\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`})),staticAttributes:o,usedDefines:n}}class _i{constructor(){this.boundProgram=null,this.boundLayoutVertexBuffer=null,this.boundPaintVertexBuffers=[],this.boundIndexBuffer=null,this.boundVertexOffset=null,this.boundDynamicVertexBuffers=[],this.vao=null;}bind(e,t,i,o,r,n,s){this.context=e;let a=this.boundPaintVertexBuffers.length!==o.length;for(let e=0;!a&&e<o.length;e++)this.boundPaintVertexBuffers[e]!==o[e]&&(a=!0);let l=this.boundDynamicVertexBuffers.length!==s.length;for(let e=0;!l&&e<s.length;e++)this.boundDynamicVertexBuffers[e]!==s[e]&&(l=!0);if(!e.extVertexArrayObject||!this.vao||this.boundProgram!==t||this.boundLayoutVertexBuffer!==i||a||l||this.boundIndexBuffer!==r||this.boundVertexOffset!==n)this.freshBind(t,i,o,r,n,s);else {e.bindVertexArrayOES.set(this.vao);for(const e of s)e&&e.bind();r&&r.dynamicDraw&&r.bind();}}freshBind(e,t,i,o,r,n){let s;const a=e.numAttributes,l=this.context,c=l.gl;if(l.extVertexArrayObject)this.vao&&this.destroy(),this.vao=l.extVertexArrayObject.createVertexArrayOES(),l.bindVertexArrayOES.set(this.vao),s=0,this.boundProgram=e,this.boundLayoutVertexBuffer=t,this.boundPaintVertexBuffers=i,this.boundIndexBuffer=o,this.boundVertexOffset=r,this.boundDynamicVertexBuffers=n;else {s=l.currentNumAttributes||0;for(let e=a;e<s;e++)c.disableVertexAttribArray(e);}t.enableAttributes(c,e),t.bind(),t.setVertexAttribPointers(c,e,r);for(const t of i)t.enableAttributes(c,e),t.bind(),t.setVertexAttribPointers(c,e,r);for(const t of n)t&&(t.enableAttributes(c,e),t.bind(),t.setVertexAttribPointers(c,e,r));o&&o.bind(),l.currentNumAttributes=a;}destroy(){this.vao&&(this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),this.vao=null);}}function di(t,i){const o=Math.pow(2,i.canonical.z),r=i.canonical.y;return [new e.MercatorCoordinate(0,r/o).toLngLat().lat,new e.MercatorCoordinate(0,(r+1)/o).toLngLat().lat]}function pi(t,i,o,r,n,s,a){const l=t.context,c=l.gl,h=o.fbo;if(!h)return;t.prepareDrawTile();const u=t.useProgram("hillshade");l.activeTexture.set(c.TEXTURE0),c.bindTexture(c.TEXTURE_2D,h.colorAttachment.get());const _=((e,t,i,o)=>{const r=i.paint.get("hillshade-shadow-color"),n=i.paint.get("hillshade-highlight-color"),s=i.paint.get("hillshade-accent-color");let a=i.paint.get("hillshade-illumination-direction")*(Math.PI/180);"viewport"===i.paint.get("hillshade-illumination-anchor")&&(a-=e.transform.angle);const l=!e.options.moving;return {u_matrix:o||e.transform.calculateProjMatrix(t.tileID.toUnwrapped(),l),u_image:0,u_latrange:di(0,t.tileID),u_light:[i.paint.get("hillshade-exaggeration"),a],u_shadow:r,u_highlight:n,u_accent:s}})(t,o,r,t.terrain?i.projMatrix:null);t.prepareDrawProgram(l,u,i.toUnwrapped());const{tileBoundsBuffer:d,tileBoundsIndexBuffer:p,tileBoundsSegments:m}=t.getTileBoundsBuffers(o);u.draw(l,c.TRIANGLES,n,s,a,e.CullFaceMode.disabled,_,r.id,d,p,m);}function mi(t,i,o){if(!i.needsDEMTextureUpload)return;const r=t.context,n=r.gl;r.pixelStoreUnpackPremultiplyAlpha.set(!1),i.demTexture=i.demTexture||t.getTileTexture(o.stride);const s=o.getPixels();i.demTexture?i.demTexture.update(s,{premultiply:!1}):i.demTexture=new e.Texture(r,s,n.RGBA,{premultiply:!1}),i.needsDEMTextureUpload=!1;}function fi(t,i,o,r,n,s){const a=t.context,l=a.gl;if(!i.dem)return;const c=i.dem;if(a.activeTexture.set(l.TEXTURE1),mi(t,i,c),!i.demTexture)return;i.demTexture.bind(l.NEAREST,l.CLAMP_TO_EDGE);const h=c.dim;a.activeTexture.set(l.TEXTURE0);let u=i.fbo;if(!u){const t=new e.Texture(a,{width:h,height:h,data:null},l.RGBA);t.bind(l.LINEAR,l.CLAMP_TO_EDGE),u=i.fbo=a.createFramebuffer(h,h,!0),u.colorAttachment.set(t.texture);}a.bindFramebuffer.set(u.framebuffer),a.viewport.set([0,0,h,h]);const{tileBoundsBuffer:_,tileBoundsIndexBuffer:d,tileBoundsSegments:p}=t.getMercatorTileBoundsBuffers();t.useProgram("hillshadePrepare").draw(a,l.TRIANGLES,r,n,s,e.CullFaceMode.disabled,((t,i)=>{const o=i.stride,r=e.create();return e.ortho(r,0,e.EXTENT,-e.EXTENT,0,0,1),e.translate(r,r,[0,-e.EXTENT,0]),{u_matrix:r,u_image:1,u_dimension:[o,o],u_zoom:t.overscaledZ,u_unpack:i.unpackVector}})(i.tileID,c),o.id,_,d,p),i.needsHillshadePrepare=!1;}const gi=t=>({u_matrix:new e.UniformMatrix4f(t),u_image0:new e.Uniform1i(t),u_skirt_height:new e.Uniform1f(t)}),vi=(e,t)=>({u_matrix:e,u_image0:0,u_skirt_height:t}),xi=(e,t,i,o,r,n,s,a,l,c,h,u,_,d,p)=>({u_proj_matrix:Float32Array.from(e),u_globe_matrix:t,u_normalize_matrix:Float32Array.from(o),u_merc_matrix:i,u_zoom_transition:r,u_merc_center:n,u_image0:0,u_frustum_tl:s,u_frustum_tr:a,u_frustum_br:l,u_frustum_bl:c,u_globe_pos:h,u_globe_radius:u,u_viewport:_,u_grid_matrix:p?Float32Array.from(p):new Float32Array(9),u_skirt_height:d});function yi(e,t){return null!=e&&null!=t&&!(!e.hasData()||!t.hasData())&&null!=e.demTexture&&null!=t.demTexture&&e.tileID.key!==t.tileID.key}const bi=new class{constructor(){this.operations={};}newMorphing(e,t,i,o,r){if(e in this.operations){const t=this.operations[e];t.to.tileID.key!==i.tileID.key&&(t.queued=i);}else this.operations[e]={startTime:o,phase:0,duration:r,from:t,to:i,queued:null};}getMorphValuesForProxy(e){if(!(e in this.operations))return null;const t=this.operations[e];return {from:t.from,to:t.to,phase:t.phase}}update(e){for(const t in this.operations){const i=this.operations[t];for(i.phase=(e-i.startTime)/i.duration;i.phase>=1||!this._validOp(i);)if(!this._nextOp(i,e)){delete this.operations[t];break}}}_nextOp(e,t){return !!e.queued&&(e.from=e.to,e.to=e.queued,e.queued=null,e.phase=0,e.startTime=t,!0)}_validOp(e){return e.from.hasData()&&e.to.hasData()}},wi={0:null,1:"TERRAIN_VERTEX_MORPHING",2:"TERRAIN_WIREFRAME"};function Ti(e){return 6*Math.pow(1.5,22-e)}function Ei(e,t){const i=1<<e.z;return !t&&(0===e.x||e.x===i-1)||0===e.y||e.y===i-1}const Ci=e=>({u_matrix:e});function Mi(t,i,o,r,n){if(n>0){const s=e.exported.now(),a=(s-t.timeAdded)/n,l=i?(s-i.timeAdded)/n:-1,c=o.getSource(),h=r.coveringZoomLevel({tileSize:c.tileSize,roundZoom:c.roundZoom}),u=!i||Math.abs(i.tileID.overscaledZ-h)>Math.abs(t.tileID.overscaledZ-h),_=u&&t.refreshedUponExpiration?1:e.clamp(u?a:1-l,0,1);return t.refreshedUponExpiration&&a>=1&&(t.refreshedUponExpiration=!1),i?{opacity:1,mix:1-_}:{opacity:_,mix:0}}return {opacity:1,mix:0}}class Ii extends e.SourceCache{constructor(e){const t={type:"raster-dem",maxzoom:e.transform.maxZoom},i=new S(Ue(),null),o=De("mock-dem",t,i,e.style);super("mock-dem",o,!1),o.setEventedParent(this),this._sourceLoaded=!0;}_loadTile(e,t){e.state="loaded",t(null);}}class Pi extends e.SourceCache{constructor(e){const t=De("proxy",{type:"geojson",maxzoom:e.transform.maxZoom},new S(Ue(),null),e.style);super("proxy",t,!1),t.setEventedParent(this),this.map=this.getSource().map=e,this.used=this._sourceLoaded=!0,this.renderCache=[],this.renderCachePool=[],this.proxyCachedFBO={};}update(t,i,o){if(t.freezeTileCoverage)return;this.transform=t;const r=t.coveringTiles({tileSize:this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom,reparseOverscaled:this._source.reparseOverscaled}).reduce(((i,o)=>{if(i[o.key]="",!this._tiles[o.key]){const i=new e.Tile(o,this._source.tileSize*o.overscaleFactor(),t.tileZoom);i.state="loaded",this._tiles[o.key]=i;}return i}),{});for(const e in this._tiles)e in r||(this.freeFBO(e),this._tiles[e].unloadVectorData(),delete this._tiles[e]);}freeFBO(e){const t=this.proxyCachedFBO[e];if(void 0!==t){const i=Object.values(t);this.renderCachePool.push(...i),delete this.proxyCachedFBO[e];}}deallocRenderCache(){this.renderCache.forEach((e=>e.fb.destroy())),this.renderCache=[],this.renderCachePool=[],this.proxyCachedFBO={};}}class Si extends e.OverscaledTileID{constructor(e,t,i){super(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y),this.proxyTileKey=t,this.projMatrix=i;}}class Di extends e.Elevation{constructor(t,i){super(),this.painter=t,this.terrainTileForTile={},this.prevTerrainTileForTile={};const[o,r,n]=function(t){const i=new e.StructArrayLayout2i4,o=new e.StructArrayLayout3ui6,r=131;i.reserve(17161),o.reserve(33800);const n=e.EXTENT/128,s=e.EXTENT+n/2,a=s+n;for(let t=-n;t<a;t+=n)for(let o=-n;o<a;o+=n){const r=o<0||o>s||t<0||t>s?24575:0,n=e.clamp(Math.round(o),0,e.EXTENT),a=e.clamp(Math.round(t),0,e.EXTENT);i.emplaceBack(n+r,a);}const l=(e,t)=>{const i=t*r+e;o.emplaceBack(i+1,i,i+r),o.emplaceBack(i+r,i+r+1,i+1);};for(let e=1;e<129;e++)for(let t=1;t<129;t++)l(t,e);return [0,129].forEach((e=>{for(let t=0;t<130;t++)l(t,e),l(e,t);})),[i,o,32768]}(),s=t.context;this.gridBuffer=s.createVertexBuffer(o,e.posAttributes.members),this.gridIndexBuffer=s.createIndexBuffer(r),this.gridSegments=e.SegmentVector.simpleSegment(0,0,o.length,r.length),this.gridNoSkirtSegments=e.SegmentVector.simpleSegment(0,0,o.length,n),this.proxyCoords=[],this.proxiedCoords={},this._visibleDemTiles=[],this._drapedRenderBatches=[],this._sourceTilesOverlap={},this.proxySourceCache=new Pi(i.map),this.orthoMatrix=e.create(),e.ortho(this.orthoMatrix,"globe"===this.painter.transform.projection.name?.015:0,e.EXTENT,0,e.EXTENT,0,1);const a=s.gl;this._overlapStencilMode=new e.StencilMode({func:a.GEQUAL,mask:255},0,255,a.KEEP,a.KEEP,a.REPLACE),this._previousZoom=t.transform.zoom,this.pool=[],this._findCoveringTileCache={},this._tilesDirty={},this.style=i,this._useVertexMorphing=!0,this._exaggeration=1,this._mockSourceCache=new Ii(i.map);}set style(e){e.on("data",this._onStyleDataEvent.bind(this)),e.on("neworder",this._checkRenderCacheEfficiency.bind(this)),this._style=e,this._checkRenderCacheEfficiency(),this._style.map.on("moveend",(()=>{this._clearLineLayersFromRenderCache();}));}update(t,i,o){if(t&&t.terrain){this._style!==t&&(this.style=t),this.enabled=!0;const r=t.terrain.properties;this.sourceCache=0===t.terrain.drapeRenderMode?this._mockSourceCache:t._getSourceCache(r.get("source")),this._exaggeration=r.get("exaggeration");const n=()=>{this.sourceCache.used&&e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);const t=this.getScaledDemTileSize();this.sourceCache.update(i,t,!0),this.resetTileLookupCache(this.sourceCache.id);};this.sourceCache.usedForTerrain||(this.resetTileLookupCache(this.sourceCache.id),this.sourceCache.usedForTerrain=!0,n(),this._initializing=!0),n(),i.updateElevation(!0,o),this.resetTileLookupCache(this.proxySourceCache.id),this.proxySourceCache.update(i),this._emptyDEMTextureDirty=!0;}else this._disable();}resetTileLookupCache(e){this._findCoveringTileCache[e]={};}getScaledDemTileSize(){return this.sourceCache.getSource().tileSize/128*this.proxySourceCache.getSource().tileSize}_checkRenderCacheEfficiency(){const t=this.renderCacheEfficiency(this._style);this._style.map._optimizeForTerrain||100!==t.efficiency&&e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);}_onStyleDataEvent(e){e.coord&&"source"===e.dataType?this._clearRenderCacheForTile(e.sourceCacheId,e.coord):"style"===e.dataType&&(this._invalidateRenderCache=!0);}_disable(){if(this.enabled&&(this.enabled=!1,this._sharedDepthStencil=void 0,this.proxySourceCache.deallocRenderCache(),this._style))for(const e in this._style._sourceCaches)this._style._sourceCaches[e].usedForTerrain=!1;}destroy(){this._disable(),this._emptyDEMTexture&&this._emptyDEMTexture.destroy(),this._emptyDepthBufferTexture&&this._emptyDepthBufferTexture.destroy(),this.pool.forEach((e=>e.fb.destroy())),this.pool=[],this._depthFBO&&(this._depthFBO.destroy(),this._depthFBO=void 0,this._depthTexture=void 0);}_source(){return this.enabled?this.sourceCache:null}isUsingMockSource(){return this.sourceCache===this._mockSourceCache}exaggeration(){return this._exaggeration}get visibleDemTiles(){return this._visibleDemTiles}get drapeBufferSize(){const e=2*this.proxySourceCache.getSource().tileSize;return [e,e]}set useVertexMorphing(e){this._useVertexMorphing=e;}updateTileBinding(t){if(!this.enabled)return;this.prevTerrainTileForTile=this.terrainTileForTile;const i=this.proxySourceCache,o=this.painter.transform;this._initializing&&(this._initializing=0===o._centerAltitude&&-1===this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o.center),-1),this._emptyDEMTextureDirty=!this._initializing);const r=this.proxyCoords=i.getIds().map((e=>{const t=i.getTileByID(e).tileID;return t.projMatrix=o.calculateProjMatrix(t.toUnwrapped()),t}));!function(t,i){const o=i.transform.pointCoordinate(i.transform.getCameraPoint()),r=new e.Point(o.x,o.y);t.sort(((t,i)=>{if(i.overscaledZ-t.overscaledZ)return i.overscaledZ-t.overscaledZ;const o=new e.Point(t.canonical.x+(1<<t.canonical.z)*t.wrap,t.canonical.y),n=new e.Point(i.canonical.x+(1<<i.canonical.z)*i.wrap,i.canonical.y),s=r.mult(1<<t.canonical.z);return s.x-=.5,s.y-=.5,s.distSqr(o)-s.distSqr(n)}));}(r,this.painter),this._previousZoom=o.zoom;const n=this.proxyToSource||{};this.proxyToSource={},r.forEach((e=>{this.proxyToSource[e.key]={};})),this.terrainTileForTile={};const s=this._style._sourceCaches;for(const e in s){const i=s[e];if(!i.used)continue;if(i!==this.sourceCache&&this.resetTileLookupCache(i.id),this._setupProxiedCoordsForOrtho(i,t[e],n),i.usedForTerrain)continue;const o=t[e];i.getSource().reparseOverscaled&&this._assignTerrainTiles(o);}this.proxiedCoords[i.id]=r.map((e=>new Si(e,e.key,this.orthoMatrix))),this._assignTerrainTiles(r),this._prepareDEMTextures(),this._setupDrapedRenderBatches(),this._initFBOPool(),this._setupRenderCache(n),this.renderingToTexture=!1,this._updateTimestamp=e.exported.now();const a={};this._visibleDemTiles=[];for(const e of this.proxyCoords){const t=this.terrainTileForTile[e.key];if(!t)continue;const i=t.tileID.key;i in a||(this._visibleDemTiles.push(t),a[i]=i);}}_assignTerrainTiles(e){this._initializing||e.forEach((e=>{if(this.terrainTileForTile[e.key])return;const t=this._findTileCoveringTileID(e,this.sourceCache);t&&(this.terrainTileForTile[e.key]=t);}));}_prepareDEMTextures(){const e=this.painter.context,t=e.gl;for(const i in this.terrainTileForTile){const o=this.terrainTileForTile[i],r=o.dem;!r||o.demTexture&&!o.needsDEMTextureUpload||(e.activeTexture.set(t.TEXTURE1),mi(this.painter,o,r));}}_prepareDemTileUniforms(e,t,i,o){if(!t||null==t.demTexture)return !1;const r=e.tileID.canonical,n=Math.pow(2,t.tileID.canonical.z-r.z),s=o||"";return i[`u_dem_tl${s}`]=[r.x*n%1,r.y*n%1],i[`u_dem_scale${s}`]=n,!0}get emptyDEMTexture(){return !this._emptyDEMTextureDirty&&this._emptyDEMTexture?this._emptyDEMTexture:this._updateEmptyDEMTexture()}get emptyDepthBufferTexture(){const t=this.painter.context,i=t.gl;if(!this._emptyDepthBufferTexture){const o=new e.RGBAImage({width:1,height:1},Uint8Array.of(255,255,255,255));this._emptyDepthBufferTexture=new e.Texture(t,o,i.RGBA,{premultiply:!1});}return this._emptyDepthBufferTexture}_getLoadedAreaMinimum(){let e=0;const t=this._visibleDemTiles.reduce(((t,i)=>{if(!i.dem)return t;const o=i.dem.tree.minimums[0];return o>0&&e++,t+o}),0);return e?t/e:0}_updateEmptyDEMTexture(){const t=this.painter.context,i=t.gl;t.activeTexture.set(i.TEXTURE2);const o=this._getLoadedAreaMinimum(),r=new e.RGBAImage({width:1,height:1},new Uint8Array(e.DEMData.pack(o,this.sourceCache.getSource().encoding)));this._emptyDEMTextureDirty=!1;let n=this._emptyDEMTexture;return n?n.update(r,{premultiply:!1}):n=this._emptyDEMTexture=new e.Texture(t,r,i.RGBA,{premultiply:!1}),n}setupElevationDraw(t,i,o){const r=this.painter.context,n=r.gl,s=(a=this.sourceCache.getSource().encoding,{u_dem:2,u_dem_prev:4,u_dem_unpack:e.DEMData.getUnpackVector(a),u_dem_tl:[0,0],u_dem_tl_prev:[0,0],u_dem_scale:0,u_dem_scale_prev:0,u_dem_size:0,u_dem_lerp:1,u_depth:3,u_depth_size_inv:[0,0],u_exaggeration:0});var a;s.u_dem_size=this.sourceCache.getSource().tileSize,s.u_exaggeration=this.exaggeration();let l=null,c=null,h=1;if(o&&o.morphing&&this._useVertexMorphing){const e=o.morphing.srcDemTile,i=o.morphing.dstDemTile;h=o.morphing.phase,e&&i&&(this._prepareDemTileUniforms(t,e,s,"_prev")&&(c=e),this._prepareDemTileUniforms(t,i,s)&&(l=i));}if(c&&l?(r.activeTexture.set(n.TEXTURE2),l.demTexture.bind(n.NEAREST,n.CLAMP_TO_EDGE,n.NEAREST),r.activeTexture.set(n.TEXTURE4),c.demTexture.bind(n.NEAREST,n.CLAMP_TO_EDGE,n.NEAREST),s.u_dem_lerp=h):(l=this.terrainTileForTile[t.tileID.key],r.activeTexture.set(n.TEXTURE2),(this._prepareDemTileUniforms(t,l,s)?l.demTexture:this.emptyDEMTexture).bind(n.NEAREST,n.CLAMP_TO_EDGE)),r.activeTexture.set(n.TEXTURE3),o&&o.useDepthForOcclusion?(this._depthTexture&&this._depthTexture.bind(n.NEAREST,n.CLAMP_TO_EDGE),this._depthFBO&&(s.u_depth_size_inv=[1/this._depthFBO.width,1/this._depthFBO.height])):(this.emptyDepthBufferTexture.bind(n.NEAREST,n.CLAMP_TO_EDGE),s.u_depth_size_inv=[1,1]),o&&o.useMeterToDem&&l){const t=(1<<l.tileID.canonical.z)*e.mercatorZfromAltitude(1,this.painter.transform.center.lat)*this.sourceCache.getSource().tileSize;s.u_meter_to_dem=t;}if(o&&o.labelPlaneMatrixInv&&(s.u_label_plane_matrix_inv=o.labelPlaneMatrixInv),i.setTerrainUniformValues(r,s),"globe"===this.painter.transform.projection.name){const e=this.globeUniformValues(this.painter.transform,t.tileID.canonical,o&&o.useDenormalizedUpVectorScale);i.setGlobeUniformValues(r,e);}}globeUniformValues(t,i,o){const r=t.projection;return {u_tile_tl_up:r.upVector(i,0,0),u_tile_tr_up:r.upVector(i,e.EXTENT,0),u_tile_br_up:r.upVector(i,e.EXTENT,e.EXTENT),u_tile_bl_up:r.upVector(i,0,e.EXTENT),u_tile_up_scale:o?e.globeMetersToEcef(1):r.upVectorScale(i,t.center.lat,t.worldSize).metersToTile}}renderToBackBuffer(t){const i=this.painter,o=this.painter.context;0!==t.length&&(o.bindFramebuffer.set(null),o.viewport.set([0,0,i.width,i.height]),i.gpuTimingDeferredRenderStart(),this.renderingToTexture=!1,function(t,i,o,r,n){if("globe"===t.transform.projection.name)!function(t,i,o,r,n){const s=t.context,a=s.gl;let l,c;const h=t.options.showTerrainWireframe?2:0,u=t.transform,_=e.globeUseCustomAntiAliasing(t,s,u),d=(e,i)=>{if(c===e)return;const o=[wi[e],"PROJECTION_GLOBE_VIEW"];_&&o.push("CUSTOM_ANTIALIASING"),i&&o.push(wi[h]),l=t.useProgram("globeRaster",null,o),c=e;},p=t.colorModeForRenderPass(),m=new e.DepthMode(a.LEQUAL,e.DepthMode.ReadWrite,t.depthRangeFor3D);bi.update(n);const f=e.calculateGlobeMercatorMatrix(u),g=[e.mercatorXfromLng(u.center.lng),e.mercatorYfromLat(u.center.lat)],v=h?[!1,!0]:[!1],x=t.globeSharedBuffers,y=[u.width*e.exported.devicePixelRatio,u.height*e.exported.devicePixelRatio],b=Float32Array.from(u.globeMatrix),w={useDenormalizedUpVectorScale:!0};if(v.forEach((h=>{const u=t.transform,_=Ti(u.zoom)*i.exaggeration();c=-1;const v=h?a.LINES:a.TRIANGLES;for(const c of r){const r=o.getTile(c),T=e.StencilMode.disabled,E=i.prevTerrainTileForTile[c.key],C=i.terrainTileForTile[c.key];yi(E,C)&&bi.newMorphing(c.key,E,C,n,250),s.activeTexture.set(a.TEXTURE0),r.texture.bind(a.LINEAR,a.CLAMP_TO_EDGE);const M=bi.getMorphValuesForProxy(c.key),I=M?1:0;M&&e.extend$1(w,{morphing:{srcDemTile:M.from,dstDemTile:M.to,phase:e.easeCubicInOut(M.phase)}});const P=e.tileCornersToBounds(c.canonical),S=e.getLatitudinalLod(P.getCenter().lat),D=e.getGridMatrix(c.canonical,P,S,u.worldSize/u._pixelsPerMercatorPixel),L=e.globeNormalizeECEF(e.globeTileBounds(c.canonical)),A=xi(u.projMatrix,b,f,L,e.globeToMercatorTransition(u.zoom),g,u.frustumCorners.TL,u.frustumCorners.TR,u.frustumCorners.BR,u.frustumCorners.BL,u.globeCenterInViewSpace,u.globeRadius,y,_,D);if(d(I,h),i.setupElevationDraw(r,l,w),t.prepareDrawProgram(s,l,c.toUnwrapped()),x){const[i,o,r]=h?x.getWirefameBuffers(t.context,S):x.getGridBuffers(S,0!==_);l.draw(s,v,m,T,p,e.CullFaceMode.backCCW,A,"globe_raster",i,o,r);}}})),x){const n=["GLOBE_POLES","PROJECTION_GLOBE_VIEW"];_&&n.push("CUSTOM_ANTIALIASING"),l=t.useProgram("globeRaster",null,n);for(const n of r){const{x:r,y:c,z:h}=n.canonical,_=0===c,d=c===(1<<h)-1,[f,v,b,T]=x.getPoleBuffers(h);if(T&&(_||d)){const c=o.getTile(n);s.activeTexture.set(a.TEXTURE0),c.texture.bind(a.LINEAR,a.CLAMP_TO_EDGE);let x=e.globePoleMatrixForTile(h,r,u);const E=e.globeNormalizeECEF(e.globeTileBounds(n.canonical)),C=(t,i)=>t.draw(s,a.TRIANGLES,m,e.StencilMode.disabled,p,e.CullFaceMode.disabled,xi(u.projMatrix,x,x,E,0,g,u.frustumCorners.TL,u.frustumCorners.TR,u.frustumCorners.BR,u.frustumCorners.BL,u.globeCenterInViewSpace,u.globeRadius,y,0),"globe_pole_raster",i,b,T);i.setupElevationDraw(c,l,w),t.prepareDrawProgram(s,l,n.toUnwrapped()),_&&C(l,f),d&&(x=e.scale(e.create(),x,[1,-1,1]),C(l,v));}}}}(t,i,o,r,n);else {const s=t.context,a=s.gl;let l,c;const h=t.options.showTerrainWireframe?2:0,u=(e,i)=>{if(c===e)return;const o=[wi[e]];i&&o.push(wi[h]),l=t.useProgram("terrainRaster",null,o),c=e;},_=t.colorModeForRenderPass(),d=new e.DepthMode(a.LEQUAL,e.DepthMode.ReadWrite,t.depthRangeFor3D);bi.update(n);const p=t.transform,m=Ti(p.zoom)*i.exaggeration();(h?[!1,!0]:[!1]).forEach((h=>{c=-1;const f=h?a.LINES:a.TRIANGLES,[g,v]=h?i.getWirefameBuffer():[i.gridIndexBuffer,i.gridSegments];for(const c of r){const r=o.getTile(c),x=e.StencilMode.disabled,y=i.prevTerrainTileForTile[c.key],b=i.terrainTileForTile[c.key];yi(y,b)&&bi.newMorphing(c.key,y,b,n,250),s.activeTexture.set(a.TEXTURE0),r.texture.bind(a.LINEAR,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST);const w=bi.getMorphValuesForProxy(c.key),T=w?1:0;let E;w&&(E={morphing:{srcDemTile:w.from,dstDemTile:w.to,phase:e.easeCubicInOut(w.phase)}});const C=vi(c.projMatrix,Ei(c.canonical,p.renderWorldCopies)?m/10:m);u(T,h),i.setupElevationDraw(r,l,E),t.prepareDrawProgram(s,l,c.toUnwrapped()),l.draw(s,f,d,x,_,e.CullFaceMode.backCCW,C,"terrain_raster",i.gridBuffer,g,v);}}));}}(i,this,this.proxySourceCache,t,this._updateTimestamp),this.renderingToTexture=!0,i.gpuTimingDeferredRenderEnd(),t.splice(0,t.length));}renderBatch(t){if(0===this._drapedRenderBatches.length)return t+1;this.renderingToTexture=!0;const i=this.painter,o=this.painter.context,r=this.proxySourceCache,n=this.proxiedCoords[r.id],s=this._drapedRenderBatches.shift(),a=[],l=i.style.order;let c=0;for(const h of n){const n=r.getTileByID(h.proxyTileKey),u=r.proxyCachedFBO[h.key]?r.proxyCachedFBO[h.key][t]:void 0,_=void 0!==u?r.renderCache[u]:this.pool[c++],d=void 0!==u;if(n.texture=_.tex,d&&!_.dirty){a.push(n.tileID);continue}let p;o.bindFramebuffer.set(_.fb.framebuffer),this.renderedToTile=!1,_.dirty&&(o.clear({color:e.Color.transparent,stencil:0}),_.dirty=!1);for(let e=s.start;e<=s.end;++e){const t=i.style._layers[l[e]];if(t.isHidden(i.transform.zoom))continue;const r=i.style._getLayerSourceCache(t),n=r?this.proxyToSource[h.key][r.id]:[h];if(!n)continue;const s=n;o.viewport.set([0,0,_.fb.width,_.fb.height]),p!==(r?r.id:null)&&(this._setupStencil(_,n,t,r),p=r?r.id:null),i.renderLayer(i,r,t,s);}this.renderedToTile?(_.dirty=!0,a.push(n.tileID)):d||--c,5===c&&(c=0,this.renderToBackBuffer(a));}return this.renderToBackBuffer(a),this.renderingToTexture=!1,o.bindFramebuffer.set(null),o.viewport.set([0,0,i.width,i.height]),s.end+1}postRender(){}renderCacheEfficiency(e){const t=e.order.length;if(0===t)return {efficiency:100};let i,o=0,r=0,n=!1;for(let s=0;s<t;++s){const t=e._layers[e.order[s]];this._style.isLayerDraped(t)?(n&&++o,++r):n||(n=!0,i=t.id);}return 0===r?{efficiency:100}:{efficiency:100*(1-o/r),firstUndrapedLayer:i}}getMinElevationBelowMSL(){let e=0;return this._visibleDemTiles.filter((e=>e.dem)).forEach((t=>{e=Math.min(e,t.dem.tree.minimums[0]);})),0===e?e:(e-30)*this._exaggeration}raycast(e,t,i){if(!this._visibleDemTiles)return null;const o=this._visibleDemTiles.filter((e=>e.dem)).map((o=>{const r=o.tileID,n=1<<r.overscaledZ,{x:s,y:a}=r.canonical,l=s/n,c=(s+1)/n,h=a/n,u=(a+1)/n;return {minx:l,miny:h,maxx:c,maxy:u,t:o.dem.tree.raycastRoot(l,h,c,u,e,t,i),tile:o}}));o.sort(((e,t)=>(null!==e.t?e.t:Number.MAX_VALUE)-(null!==t.t?t.t:Number.MAX_VALUE)));for(const r of o){if(null==r.t)return null;const o=r.tile.dem.tree.raycast(r.minx,r.miny,r.maxx,r.maxy,e,t,i);if(null!=o)return o}return null}_createFBO(){const t=this.painter.context,i=t.gl,o=this.drapeBufferSize;t.activeTexture.set(i.TEXTURE0);const r=new e.Texture(t,{width:o[0],height:o[1],data:null},i.RGBA);r.bind(i.LINEAR,i.CLAMP_TO_EDGE);const n=t.createFramebuffer(o[0],o[1],!1);return n.colorAttachment.set(r.texture),n.depthAttachment=new we(t,n.framebuffer),void 0===this._sharedDepthStencil?(this._sharedDepthStencil=t.createRenderbuffer(t.gl.DEPTH_STENCIL,o[0],o[1]),this._stencilRef=0,n.depthAttachment.set(this._sharedDepthStencil),t.clear({stencil:0})):n.depthAttachment.set(this._sharedDepthStencil),t.extTextureFilterAnisotropic&&!t.extTextureFilterAnisotropicForceOff&&i.texParameterf(i.TEXTURE_2D,t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,t.extTextureFilterAnisotropicMax),{fb:n,tex:r,dirty:!1}}_initFBOPool(){for(;this.pool.length<Math.min(5,this.proxyCoords.length);)this.pool.push(this._createFBO());}_shouldDisableRenderCache(){if(this._style.light&&this._style.light.hasTransition())return !0;for(const e in this._style._sourceCaches)if(this._style._sourceCaches[e].hasTransition())return !0;return this._style.order.some((e=>{const t=this._style._layers[e],i=t.isHidden(this.painter.transform.zoom);return "custom"===t.type?!i&&t.shouldRedrape():!i&&t.hasTransition()}))}_clearLineLayersFromRenderCache(){let t=!1;for(const e of this._style._getSources())if(e instanceof Ce){t=!0;break}if(!t)return;const i={};for(let t=0;t<this._style.order.length;++t){const o=this._style._layers[this._style.order[t]],r=this._style._getLayerSourceCache(o);if(r&&!i[r.id]&&!o.isHidden(this.painter.transform.zoom)&&"line"===o.type&&o.widthExpression()instanceof e.ZoomDependentExpression){i[r.id]=!0;for(const e of this.proxyCoords){const t=this.proxyToSource[e.key][r.id];if(t)for(const e of t)this._clearRenderCacheForTile(r.id,e);}}}}_clearRasterLayersFromRenderCache(){let e=!1;for(const t in this._style._sourceCaches)if(this._style._sourceCaches[t]._source instanceof Me){e=!0;break}if(!e)return;const t={};for(let e=0;e<this._style.order.length;++e){const i=this._style._layers[this._style.order[e]],o=this._style._getLayerSourceCache(i);if(!o||t[o.id])continue;if(i.isHidden(this.painter.transform.zoom)||"raster"!==i.type)continue;const r=i.paint.get("raster-fade-duration");for(const e of this.proxyCoords){const t=this.proxyToSource[e.key][o.id];if(t)for(const e of t){const t=Mi(o.getTile(e),o.findLoadedParent(e,0),o,this.painter.transform,r);(1!==t.opacity||0!==t.mix)&&this._clearRenderCacheForTile(o.id,e);}}}}_setupDrapedRenderBatches(){const e=this._style.order,t=e.length;if(0===t)return;const i=[];let o,r=0,n=this._style._layers[e[r]];for(;!this._style.isLayerDraped(n)&&n.isHidden(this.painter.transform.zoom)&&++r<t;)n=this._style._layers[e[r]];for(;r<t;++r){const t=this._style._layers[e[r]];t.isHidden(this.painter.transform.zoom)||(this._style.isLayerDraped(t)?void 0===o&&(o=r):void 0!==o&&(i.push({start:o,end:r-1}),o=void 0));}void 0!==o&&i.push({start:o,end:r-1}),this._drapedRenderBatches=i;}_setupRenderCache(e){const t=this.proxySourceCache;if(this._shouldDisableRenderCache()||this._invalidateRenderCache){if(this._invalidateRenderCache=!1,t.renderCache.length>t.renderCachePool.length){const e=Object.values(t.proxyCachedFBO);t.proxyCachedFBO={};for(let i=0;i<e.length;++i){const o=Object.values(e[i]);t.renderCachePool.push(...o);}}return}this._clearRasterLayersFromRenderCache();const i=this.proxyCoords,o=this._tilesDirty;for(let r=i.length-1;r>=0;r--){const n=i[r];if(t.getTileByID(n.key),void 0!==t.proxyCachedFBO[n.key]){const i=e[n.key],r=this.proxyToSource[n.key];let s=0;for(const e in r){const t=r[e],n=i[e];if(!n||n.length!==t.length||t.some(((t,i)=>t!==n[i]||o[e]&&o[e].hasOwnProperty(t.key)))){s=-1;break}++s;}for(const e in t.proxyCachedFBO[n.key])t.renderCache[t.proxyCachedFBO[n.key][e]].dirty=s<0||s!==Object.values(i).length;}}const r=[...this._drapedRenderBatches];r.sort(((e,t)=>t.end-t.start-(e.end-e.start)));for(const e of r)for(const o of i){if(t.proxyCachedFBO[o.key])continue;let i=t.renderCachePool.pop();void 0===i&&t.renderCache.length<50&&(i=t.renderCache.length,t.renderCache.push(this._createFBO())),void 0!==i&&(t.proxyCachedFBO[o.key]={},t.proxyCachedFBO[o.key][e.start]=i,t.renderCache[i].dirty=!0);}this._tilesDirty={};}_setupStencil(e,t,i,o){if(!o||!this._sourceTilesOverlap[o.id])return void(this._overlapStencilType&&(this._overlapStencilType=!1));const r=this.painter.context,n=r.gl;if(t.length<=1)return void(this._overlapStencilType=!1);let s;if(i.isTileClipped())s=t.length,this._overlapStencilMode.test={func:n.EQUAL,mask:255},this._overlapStencilType="Clip";else {if(!(t[0].overscaledZ>t[t.length-1].overscaledZ))return void(this._overlapStencilType=!1);s=1,this._overlapStencilMode.test={func:n.GREATER,mask:255},this._overlapStencilType="Mask";}this._stencilRef+s>255&&(r.clear({stencil:0}),this._stencilRef=0),this._stencilRef+=s,this._overlapStencilMode.ref=this._stencilRef,i.isTileClipped()&&this._renderTileClippingMasks(t,this._overlapStencilMode.ref);}clipOrMaskOverlapStencilType(){return "Clip"===this._overlapStencilType||"Mask"===this._overlapStencilType}stencilModeForRTTOverlap(t){return this.renderingToTexture&&this._overlapStencilType?("Clip"===this._overlapStencilType&&(this._overlapStencilMode.ref=this.painter._tileClippingMaskIDs[t.key]),this._overlapStencilMode):e.StencilMode.disabled}_renderTileClippingMasks(t,i){const o=this.painter,r=this.painter.context,n=r.gl;o._tileClippingMaskIDs={},r.setColorMode(e.ColorMode.disabled),r.setDepthMode(e.DepthMode.disabled);const s=o.useProgram("clippingMask");for(const a of t){const t=o._tileClippingMaskIDs[a.key]=--i;s.draw(r,n.TRIANGLES,e.DepthMode.disabled,new e.StencilMode({func:n.ALWAYS,mask:0},t,255,n.KEEP,n.KEEP,n.REPLACE),e.ColorMode.disabled,e.CullFaceMode.disabled,Ci(a.projMatrix),"$clipping",o.tileExtentBuffer,o.quadTriangleIndexBuffer,o.tileExtentSegments);}}pointCoordinate(t){const i=this.painter.transform;if(t.x<0||t.x>i.width||t.y<0||t.y>i.height)return null;const o=[t.x,t.y,1,1];e.transformMat4$1(o,o,i.pixelMatrixInverse),e.scale$1(o,o,1/o[3]),o[0]/=i.worldSize,o[1]/=i.worldSize;const r=i._camera.position,n=e.mercatorZfromAltitude(1,i.center.lat),s=[r[0],r[1],r[2]/n,0],a=e.subtract([],o.slice(0,3),s);e.normalize(a,a);const l=this.raycast(s,a,this._exaggeration);return null!==l&&l?(e.scaleAndAdd(s,s,a,l),s[3]=s[2],s[2]*=n,s):null}drawDepth(){const t=this.painter,i=t.context,o=this.proxySourceCache,r=Math.ceil(t.width),n=Math.ceil(t.height);if(!this._depthFBO||this._depthFBO.width===r&&this._depthFBO.height===n||(this._depthFBO.destroy(),this._depthFBO=void 0,this._depthTexture=void 0),!this._depthFBO){const t=i.gl,o=i.createFramebuffer(r,n,!0);i.activeTexture.set(t.TEXTURE0);const s=new e.Texture(i,{width:r,height:n,data:null},t.RGBA);s.bind(t.NEAREST,t.CLAMP_TO_EDGE),o.colorAttachment.set(s.texture);const a=i.createRenderbuffer(i.gl.DEPTH_COMPONENT16,r,n);o.depthAttachment.set(a),this._depthFBO=o,this._depthTexture=s;}i.bindFramebuffer.set(this._depthFBO.framebuffer),i.viewport.set([0,0,r,n]),function(t,i,o,r){if("globe"===t.transform.projection.name)return;const n=t.context,s=n.gl;n.clear({depth:1});const a=t.useProgram("terrainDepth"),l=new e.DepthMode(s.LESS,e.DepthMode.ReadWrite,t.depthRangeFor3D);for(const t of r){const r=o.getTile(t),c=vi(t.projMatrix,0);i.setupElevationDraw(r,a),a.draw(n,s.TRIANGLES,l,e.StencilMode.disabled,e.ColorMode.unblended,e.CullFaceMode.backCCW,c,"terrain_depth",i.gridBuffer,i.gridIndexBuffer,i.gridNoSkirtSegments);}}(t,this,o,this.proxyCoords);}_setupProxiedCoordsForOrtho(e,t,i){if(e.getSource()instanceof Pe)return this._setupProxiedCoordsForImageSource(e,t,i);this._findCoveringTileCache[e.id]=this._findCoveringTileCache[e.id]||{};const o=this.proxiedCoords[e.id]=[],r=this.proxyCoords;for(let t=0;t<r.length;t++){const n=r[t],s=this._findTileCoveringTileID(n,e);if(s){const t=this._createProxiedId(n,s,i[n.key]&&i[n.key][e.id]);o.push(t),this.proxyToSource[n.key][e.id]=[t];}}let n=!1;for(let r=0;r<t.length;r++){const s=e.getTile(t[r]);if(!s||!s.hasData())continue;const a=this._findTileCoveringTileID(s.tileID,this.proxySourceCache);if(a&&a.tileID.canonical.z!==s.tileID.canonical.z){const t=this.proxyToSource[a.tileID.key][e.id],r=this._createProxiedId(a.tileID,s,i[a.tileID.key]&&i[a.tileID.key][e.id]);t?t.splice(t.length-1,0,r):this.proxyToSource[a.tileID.key][e.id]=[r],o.push(r),n=!0;}}this._sourceTilesOverlap[e.id]=n;}_setupProxiedCoordsForImageSource(t,i,o){if(!t.getSource().loaded())return;const r=this.proxiedCoords[t.id]=[],n=this.proxyCoords,s=t.getSource(),a=new e.Point(s.tileID.x,s.tileID.y)._div(1<<s.tileID.z),l=s.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce(((e,t)=>(e.min.x=Math.min(e.min.x,t.x-a.x),e.min.y=Math.min(e.min.y,t.y-a.y),e.max.x=Math.max(e.max.x,t.x-a.x),e.max.y=Math.max(e.max.y,t.y-a.y),e)),{min:new e.Point(Number.MAX_VALUE,Number.MAX_VALUE),max:new e.Point(-Number.MAX_VALUE,-Number.MAX_VALUE)}),c=(t,i)=>{const o=t.wrap+t.canonical.x/(1<<t.canonical.z),r=t.canonical.y/(1<<t.canonical.z),n=e.EXTENT/(1<<t.canonical.z),s=i.wrap+i.canonical.x/(1<<i.canonical.z),a=i.canonical.y/(1<<i.canonical.z);return o+n<s+l.min.x||o>s+l.max.x||r+n<a+l.min.y||r>a+l.max.y};for(let e=0;e<n.length;e++){const s=n[e];for(let e=0;e<i.length;e++){const n=t.getTile(i[e]);if(!n||!n.hasData())continue;if(c(s,n.tileID))continue;const a=this._createProxiedId(s,n,o[s.key]&&o[s.key][t.id]),l=this.proxyToSource[s.key][t.id];l?l.push(a):this.proxyToSource[s.key][t.id]=[a],r.push(a);}}}_createProxiedId(t,i,o){let r=this.orthoMatrix;if(o){const e=o.find((e=>e.key===i.tileID.key));if(e)return e}if(i.tileID.key!==t.key){const o=t.canonical.z-i.tileID.canonical.z;let n,s,a;r=e.create();const l=i.tileID.wrap-t.wrap<<t.overscaledZ;o>0?(n=e.EXTENT>>o,s=n*((i.tileID.canonical.x<<o)-t.canonical.x+l),a=n*((i.tileID.canonical.y<<o)-t.canonical.y)):(n=e.EXTENT<<-o,s=e.EXTENT*(i.tileID.canonical.x-(t.canonical.x+l<<-o)),a=e.EXTENT*(i.tileID.canonical.y-(t.canonical.y<<-o))),e.ortho(r,0,n,0,n,0,1),e.translate(r,r,[s,a,0]);}return new Si(i.tileID,t.key,r)}_findTileCoveringTileID(t,i){let o=i.getTile(t);if(o&&o.hasData())return o;const r=this._findCoveringTileCache[i.id],n=r[t.key];if(o=n?i.getTileByID(n):null,o&&o.hasData()||null===n)return o;let s=o?o.tileID:t,a=s.overscaledZ;const l=i.getSource().minzoom,c=[];if(!n){const r=i.getSource().maxzoom;if(t.canonical.z>=r){const o=t.canonical.z-r;i.getSource().reparseOverscaled?(a=Math.max(t.canonical.z+2,i.transform.tileZoom),s=new e.OverscaledTileID(a,t.wrap,r,t.canonical.x>>o,t.canonical.y>>o)):0!==o&&(a=r,s=new e.OverscaledTileID(a,t.wrap,r,t.canonical.x>>o,t.canonical.y>>o));}s.key!==t.key&&(c.push(s.key),o=i.getTile(s));}const h=e=>{c.forEach((t=>{r[t]=e;})),c.length=0;};for(a-=1;a>=l&&(!o||!o.hasData());a--){o&&h(o.tileID.key);const e=s.calculateScaledKey(a);if(o=i.getTileByID(e),o&&o.hasData())break;const t=r[e];if(null===t)break;void 0===t?c.push(e):o=i.getTileByID(t);}return h(o?o.tileID.key:null),o&&o.hasData()?o:null}findDEMTileFor(e){return this.enabled?this._findTileCoveringTileID(e,this.sourceCache):null}prepareDrawTile(){this.renderedToTile=!0;}_clearRenderCacheForTile(e,t){let i=this._tilesDirty[e];i||(i=this._tilesDirty[e]={}),i[t.key]=!0;}getWirefameBuffer(){if(!this.wireframeSegments){const t=function(t){let i=0;const o=new e.StructArrayLayout2ui4,r=131;for(let e=1;e<129;e++){for(let t=1;t<129;t++)i=e*r+t,o.emplaceBack(i,i+1),o.emplaceBack(i,i+r),o.emplaceBack(i+1,i+r),128===e&&o.emplaceBack(i+r,i+r+1);o.emplaceBack(i+1,i+1+r);}return o}();this.wireframeIndexBuffer=this.painter.context.createIndexBuffer(t),this.wireframeSegments=e.SegmentVector.simpleSegment(0,0,this.gridBuffer.length,t.length);}return [this.wireframeIndexBuffer,this.wireframeSegments]}}class Li{static cacheKey(e,t,i,o){let r=`${t}${o?o.cacheKey:""}`;for(const t of i)e.usedDefines.includes(t)&&(r+=`/${t}`);return r}constructor(t,i,o,r,n,s){const a=t.gl;this.program=a.createProgram();const l=function(e){const t=[];for(let i=0;i<e.length;i++){if(null===e[i])continue;const o=e[i].split(" ");t.push(o.pop());}return t}(o.staticAttributes),c=r?r.getBinderAttributes():[],h=l.concat(c);let u=r?r.defines():[];u=u.concat(s.map((e=>`#define ${e}`)));const _=t.isWebGL2?"#version 300 es\n":"",d=_+u.concat(t.extStandardDerivatives&&0===_.length?"#extension GL_OES_standard_derivatives : enable\n".concat(li):li,li,ai,si.fragmentSource,ri.fragmentSource,o.fragmentSource).join("\n"),p=_+u.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif",ai,si.vertexSource,ri.vertexSource,oi.vertexSource,o.vertexSource).join("\n"),m=a.createShader(a.FRAGMENT_SHADER);if(a.isContextLost())return void(this.failedToCreate=!0);a.shaderSource(m,d),a.compileShader(m),a.attachShader(this.program,m);const f=a.createShader(a.VERTEX_SHADER);if(a.isContextLost())this.failedToCreate=!0;else {a.shaderSource(f,p),a.compileShader(f),a.attachShader(this.program,f),this.attributes={},this.numAttributes=h.length;for(let e=0;e<this.numAttributes;e++)h[e]&&(a.bindAttribLocation(this.program,e,h[e]),this.attributes[h[e]]=e);a.linkProgram(this.program),a.deleteShader(f),a.deleteShader(m),this.fixedUniforms=n(t),this.binderUniforms=r?r.getUniforms(t):[],s.includes("TERRAIN")&&(this.terrainUniforms=(t=>({u_dem:new e.Uniform1i(t),u_dem_prev:new e.Uniform1i(t),u_dem_unpack:new e.Uniform4f(t),u_dem_tl:new e.Uniform2f(t),u_dem_scale:new e.Uniform1f(t),u_dem_tl_prev:new e.Uniform2f(t),u_dem_scale_prev:new e.Uniform1f(t),u_dem_size:new e.Uniform1f(t),u_dem_lerp:new e.Uniform1f(t),u_exaggeration:new e.Uniform1f(t),u_depth:new e.Uniform1i(t),u_depth_size_inv:new e.Uniform2f(t),u_meter_to_dem:new e.Uniform1f(t),u_label_plane_matrix_inv:new e.UniformMatrix4f(t)}))(t)),s.includes("GLOBE")&&(this.globeUniforms=(t=>({u_tile_tl_up:new e.Uniform3f(t),u_tile_tr_up:new e.Uniform3f(t),u_tile_br_up:new e.Uniform3f(t),u_tile_bl_up:new e.Uniform3f(t),u_tile_up_scale:new e.Uniform1f(t)}))(t)),s.includes("FOG")&&(this.fogUniforms=(t=>({u_fog_matrix:new e.UniformMatrix4f(t),u_fog_range:new e.Uniform2f(t),u_fog_color:new e.Uniform4f(t),u_fog_horizon_blend:new e.Uniform1f(t),u_fog_temporal_offset:new e.Uniform1f(t),u_frustum_tl:new e.Uniform3f(t),u_frustum_tr:new e.Uniform3f(t),u_frustum_br:new e.Uniform3f(t),u_frustum_bl:new e.Uniform3f(t),u_globe_pos:new e.Uniform3f(t),u_globe_radius:new e.Uniform1f(t),u_globe_transition:new e.Uniform1f(t),u_is_globe:new e.Uniform1i(t),u_viewport:new e.Uniform2f(t)}))(t));}}setTerrainUniformValues(e,t){if(!this.terrainUniforms)return;const i=this.terrainUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e]&&i[e].set(this.program,e,t[e]);}}setGlobeUniformValues(e,t){if(!this.globeUniforms)return;const i=this.globeUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e]&&i[e].set(this.program,e,t[e]);}}setFogUniformValues(e,t){if(!this.fogUniforms)return;const i=this.fogUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e].set(this.program,e,t[e]);}}draw(e,t,i,o,r,n,s,a,l,c,h,u,_,d,p){const m=e.gl;if(this.failedToCreate)return;e.program.set(this.program),e.setDepthMode(i),e.setStencilMode(o),e.setColorMode(r),e.setCullFace(n);for(const e of Object.keys(this.fixedUniforms))this.fixedUniforms[e].set(this.program,e,s[e]);d&&d.setUniforms(this.program,e,this.binderUniforms,u,{zoom:_});const f={[m.LINES]:2,[m.TRIANGLES]:3,[m.LINE_STRIP]:1}[t];for(const i of h.get()){const o=i.vaos||(i.vaos={});(o[a]||(o[a]=new _i)).bind(e,this,l,d?d.getPaintVertexBuffers():[],c,i.vertexOffset,p||[]),m.drawElements(t,i.primitiveLength*f,m.UNSIGNED_SHORT,i.primitiveOffset*f*2);}}}function Ai(e,t){const i=Math.pow(2,t.tileID.overscaledZ),o=t.tileSize*Math.pow(2,e.transform.tileZoom)/i,r=o*(t.tileID.canonical.x+t.tileID.wrap*i),n=o*t.tileID.canonical.y;return {u_image:0,u_texsize:t.imageAtlasTexture.size,u_tile_units_to_pixels:1/D(t,1,e.transform.tileZoom),u_pixel_coord_upper:[r>>16,n>>16],u_pixel_coord_lower:[65535&r,65535&n]}}const zi=e.create(),Ri=(t,i,o,r,n,s,a,l,c,h,u)=>{const _=i.style.light,d=_.properties.get("position"),p=[d.x,d.y,d.z],m=e.create$1();"viewport"===_.properties.get("anchor")&&(e.fromRotation(m,-i.transform.angle),e.transformMat3(p,p,m));const f=_.properties.get("color"),g=i.transform,v={u_matrix:t,u_lightpos:p,u_lightintensity:_.properties.get("intensity"),u_lightcolor:[f.r,f.g,f.b],u_vertical_gradient:+o,u_opacity:r,u_tile_id:[0,0,0],u_zoom_transition:0,u_inv_rot_matrix:zi,u_merc_center:[0,0],u_up_dir:[0,0,0],u_height_lift:0,u_ao:n,u_edge_radius:s};return "globe"===g.projection.name&&(v.u_tile_id=[a.canonical.x,a.canonical.y,1<<a.canonical.z],v.u_zoom_transition=c,v.u_inv_rot_matrix=u,v.u_merc_center=h,v.u_up_dir=g.projection.upVector(new e.CanonicalTileID(0,0,0),h[0]*e.EXTENT,h[1]*e.EXTENT),v.u_height_lift=l),v},Oi=(t,i,o,r,n,s,a,l,c,h,u,_)=>{const d=Ri(t,i,o,r,n,s,a,c,h,u,_),p={u_height_factor:-Math.pow(2,a.overscaledZ)/l.tileSize/8};return e.extend(d,Ai(i,l),p)},Bi=e=>({u_matrix:e}),ki=(t,i,o)=>e.extend(Bi(t),Ai(i,o)),Fi=(e,t)=>({u_matrix:e,u_world:t}),Ui=(t,i,o,r)=>e.extend(ki(t,i,o),{u_world:r}),Ni=e.create(),ji=(t,i,o,r,n,s)=>{const a=t.transform,l="globe"===a.projection.name;let c;if("map"===s.paint.get("circle-pitch-alignment"))if(l){const t=e.globePixelsToTileUnits(a.zoom,i.canonical)*a._pixelsPerMercatorPixel;c=Float32Array.from([t,0,0,t]);}else c=a.calculatePixelsToTileUnitsMatrix(o);else c=new Float32Array([a.pixelsToGLUnits[0],0,0,a.pixelsToGLUnits[1]]);const h={u_camera_to_center_distance:a.cameraToCenterDistance,u_matrix:t.translatePosMatrix(i.projMatrix,o,s.paint.get("circle-translate"),s.paint.get("circle-translate-anchor")),u_device_pixel_ratio:e.exported.devicePixelRatio,u_extrude_scale:c,u_inv_rot_matrix:Ni,u_merc_center:[0,0],u_tile_id:[0,0,0],u_zoom_transition:0,u_up_dir:[0,0,0]};if(l){h.u_inv_rot_matrix=r,h.u_merc_center=n,h.u_tile_id=[i.canonical.x,i.canonical.y,1<<i.canonical.z],h.u_zoom_transition=e.globeToMercatorTransition(a.zoom);const t=n[0]*e.EXTENT,o=n[1]*e.EXTENT;h.u_up_dir=a.projection.upVector(new e.CanonicalTileID(0,0,0),t,o);}return h},Gi=e=>{const t=[];return "map"===e.paint.get("circle-pitch-alignment")&&t.push("PITCH_WITH_MAP"),"map"===e.paint.get("circle-pitch-scale")&&t.push("SCALE_WITH_MAP"),t},Zi=(t,i,o,r)=>{const n=e.EXTENT/o.tileSize;return {u_matrix:t,u_camera_to_center_distance:i.getCameraToCenterDistance(r),u_extrude_scale:[i.pixelsToGLUnits[0]/n,i.pixelsToGLUnits[1]/n]}},Vi=(e,t,i=1)=>({u_matrix:e,u_color:t,u_overlay:0,u_overlay_scale:i}),Wi=e.create(),Xi=(t,i,o,r,n,s,a)=>{const l=t.transform,c="globe"===l.projection.name,h=c?e.globePixelsToTileUnits(l.zoom,i.canonical)*l._pixelsPerMercatorPixel:D(o,1,s),u={u_matrix:i.projMatrix,u_extrude_scale:h,u_intensity:a,u_inv_rot_matrix:Wi,u_merc_center:[0,0],u_tile_id:[0,0,0],u_zoom_transition:0,u_up_dir:[0,0,0]};if(c){u.u_inv_rot_matrix=r,u.u_merc_center=n,u.u_tile_id=[i.canonical.x,i.canonical.y,1<<i.canonical.z],u.u_zoom_transition=e.globeToMercatorTransition(l.zoom);const t=n[0]*e.EXTENT,o=n[1]*e.EXTENT;u.u_up_dir=l.projection.upVector(new e.CanonicalTileID(0,0,0),t,o);}return u},qi=(e,t,i,o,r,n,s)=>{const a=e.transform,l=a.calculatePixelsToTileUnitsMatrix(t);return {u_matrix:Yi(e,t,i,o),u_pixels_to_tile_units:l,u_device_pixel_ratio:n,u_units_to_pixels:[1/a.pixelsToGLUnits[0],1/a.pixelsToGLUnits[1]],u_dash_image:0,u_gradient_image:1,u_image_height:r,u_texsize:Ki(i)?t.lineAtlasTexture.size:[0,0],u_tile_units_to_pixels:Hi(t,e.transform),u_alpha_discard_threshold:0,u_trim_offset:s}},$i=(e,t,i,o,r)=>{const n=e.transform;return {u_matrix:Yi(e,t,i,o),u_texsize:t.imageAtlasTexture.size,u_pixels_to_tile_units:n.calculatePixelsToTileUnitsMatrix(t),u_device_pixel_ratio:r,u_image:0,u_tile_units_to_pixels:Hi(t,n),u_units_to_pixels:[1/n.pixelsToGLUnits[0],1/n.pixelsToGLUnits[1]],u_alpha_discard_threshold:0}};function Hi(e,t){return 1/D(e,1,t.tileZoom)}function Yi(e,t,i,o){return e.translatePosMatrix(o||t.tileID.projMatrix,t,i.paint.get("line-translate"),i.paint.get("line-translate-anchor"))}function Ki(e){const t=e.paint.get("line-dasharray").value;return t.value||"constant"!==t.kind}const Ji=(e,t,i,o,r,n)=>{return {u_matrix:e,u_tl_parent:t,u_scale_parent:i,u_fade_t:o.mix,u_opacity:o.opacity*r.paint.get("raster-opacity"),u_image0:0,u_image1:1,u_brightness_low:r.paint.get("raster-brightness-min"),u_brightness_high:r.paint.get("raster-brightness-max"),u_saturation_factor:(a=r.paint.get("raster-saturation"),a>0?1-1/(1.001-a):-a),u_contrast_factor:(s=r.paint.get("raster-contrast"),s>0?1/(1-s):1+s),u_spin_weights:Qi(r.paint.get("raster-hue-rotate")),u_perspective_transform:n};var s,a;};function Qi(e){e*=Math.PI/180;const t=Math.sin(e),i=Math.cos(e);return [(2*i+1)/3,(-Math.sqrt(3)*t-i+1)/3,(Math.sqrt(3)*t-i+1)/3]}const eo=e.create(),to=(t,i,o,r,n,s,a,l,c,h,u,_,d,p,m,f)=>{const g=n.transform,v={u_is_size_zoom_constant:+("constant"===t||"source"===t),u_is_size_feature_constant:+("constant"===t||"camera"===t),u_size_t:i?i.uSizeT:0,u_size:i?i.uSize:0,u_camera_to_center_distance:g.cameraToCenterDistance,u_rotate_symbol:+o,u_aspect_ratio:g.width/g.height,u_fade_change:n.options.fadeDuration?n.symbolFadeChange:1,u_matrix:s,u_label_plane_matrix:a,u_coord_matrix:l,u_is_text:+c,u_pitch_with_map:+r,u_texsize:h,u_texture:0,u_tile_id:[0,0,0],u_zoom_transition:0,u_inv_rot_matrix:eo,u_merc_center:[0,0],u_camera_forward:[0,0,0],u_ecef_origin:[0,0,0],u_tile_matrix:eo,u_up_vector:[0,-1,0]};return "globe"===f.name&&(v.u_tile_id=[u.canonical.x,u.canonical.y,1<<u.canonical.z],v.u_zoom_transition=_,v.u_inv_rot_matrix=p,v.u_merc_center=d,v.u_camera_forward=g._camera.forward(),v.u_ecef_origin=e.globeECEFOrigin(g.globeMatrix,u.toUnwrapped()),v.u_tile_matrix=Float32Array.from(g.globeMatrix),v.u_up_vector=m),v},io=(t,i,o,r,n,s,a,l,c,h,u,_,d,p,m,f,g)=>e.extend(to(t,i,o,r,n,s,a,l,c,h,_,d,p,m,f,g),{u_gamma_scale:r?n.transform.cameraToCenterDistance*Math.cos(n.terrain?0:n.transform._pitch):1,u_device_pixel_ratio:e.exported.devicePixelRatio,u_is_halo:+u}),oo=(t,i,o,r,n,s,a,l,c,h,u,_,d,p,m,f)=>e.extend(io(t,i,o,r,n,s,a,l,!0,c,!0,u,_,d,p,m,f),{u_texsize_icon:h,u_texture_icon:1}),ro=(e,t,i)=>({u_matrix:e,u_opacity:t,u_color:i}),no=(t,i,o,r,n)=>e.extend(function(e,t,i){const o=t.imageManager.getPattern(e.toString()),{width:r,height:n}=t.imageManager.getPixelSize(),s=Math.pow(2,i.tileID.overscaledZ),a=i.tileSize*Math.pow(2,t.transform.tileZoom)/s,l=a*(i.tileID.canonical.x+i.tileID.wrap*s),c=a*i.tileID.canonical.y;return {u_image:0,u_pattern_tl:o.tl,u_pattern_br:o.br,u_texsize:[r,n],u_pattern_size:o.displaySize,u_tile_units_to_pixels:1/D(i,1,t.transform.tileZoom),u_pixel_coord_upper:[l>>16,c>>16],u_pixel_coord_lower:[65535&l,65535&c]}}(r,o,n),{u_matrix:t,u_opacity:i}),so={fillExtrusion:t=>({u_matrix:new e.UniformMatrix4f(t),u_lightpos:new e.Uniform3f(t),u_lightintensity:new e.Uniform1f(t),u_lightcolor:new e.Uniform3f(t),u_vertical_gradient:new e.Uniform1f(t),u_opacity:new e.Uniform1f(t),u_edge_radius:new e.Uniform1f(t),u_ao:new e.Uniform2f(t),u_tile_id:new e.Uniform3f(t),u_zoom_transition:new e.Uniform1f(t),u_inv_rot_matrix:new e.UniformMatrix4f(t),u_merc_center:new e.Uniform2f(t),u_up_dir:new e.Uniform3f(t),u_height_lift:new e.Uniform1f(t)}),fillExtrusionPattern:t=>({u_matrix:new e.UniformMatrix4f(t),u_lightpos:new e.Uniform3f(t),u_lightintensity:new e.Uniform1f(t),u_lightcolor:new e.Uniform3f(t),u_vertical_gradient:new e.Uniform1f(t),u_height_factor:new e.Uniform1f(t),u_edge_radius:new e.Uniform1f(t),u_ao:new e.Uniform2f(t),u_tile_id:new e.Uniform3f(t),u_zoom_transition:new e.Uniform1f(t),u_inv_rot_matrix:new e.UniformMatrix4f(t),u_merc_center:new e.Uniform2f(t),u_up_dir:new e.Uniform3f(t),u_height_lift:new e.Uniform1f(t),u_image:new e.Uniform1i(t),u_texsize:new e.Uniform2f(t),u_pixel_coord_upper:new e.Uniform2f(t),u_pixel_coord_lower:new e.Uniform2f(t),u_tile_units_to_pixels:new e.Uniform1f(t),u_opacity:new e.Uniform1f(t)}),fill:t=>({u_matrix:new e.UniformMatrix4f(t)}),fillPattern:t=>({u_matrix:new e.UniformMatrix4f(t),u_image:new e.Uniform1i(t),u_texsize:new e.Uniform2f(t),u_pixel_coord_upper:new e.Uniform2f(t),u_pixel_coord_lower:new e.Uniform2f(t),u_tile_units_to_pixels:new e.Uniform1f(t)}),fillOutline:t=>({u_matrix:new e.UniformMatrix4f(t),u_world:new e.Uniform2f(t)}),fillOutlinePattern:t=>({u_matrix:new e.UniformMatrix4f(t),u_world:new e.Uniform2f(t),u_image:new e.Uniform1i(t),u_texsize:new e.Uniform2f(t),u_pixel_coord_upper:new e.Uniform2f(t),u_pixel_coord_lower:new e.Uniform2f(t),u_tile_units_to_pixels:new e.Uniform1f(t)}),circle:t=>({u_camera_to_center_distance:new e.Uniform1f(t),u_extrude_scale:new e.UniformMatrix2f(t),u_device_pixel_ratio:new e.Uniform1f(t),u_matrix:new e.UniformMatrix4f(t),u_inv_rot_matrix:new e.UniformMatrix4f(t),u_merc_center:new e.Uniform2f(t),u_tile_id:new e.Uniform3f(t),u_zoom_transition:new e.Uniform1f(t),u_up_dir:new e.Uniform3f(t)}),collisionBox:t=>({u_matrix:new e.UniformMatrix4f(t),u_camera_to_center_distance:new e.Uniform1f(t),u_extrude_scale:new e.Uniform2f(t)}),collisionCircle:t=>({u_matrix:new e.UniformMatrix4f(t),u_inv_matrix:new e.UniformMatrix4f(t),u_camera_to_center_distance:new e.Uniform1f(t),u_viewport_size:new e.Uniform2f(t)}),debug:t=>({u_color:new e.UniformColor(t),u_matrix:new e.UniformMatrix4f(t),u_overlay:new e.Uniform1i(t),u_overlay_scale:new e.Uniform1f(t)}),clippingMask:t=>({u_matrix:new e.UniformMatrix4f(t)}),heatmap:t=>({u_extrude_scale:new e.Uniform1f(t),u_intensity:new e.Uniform1f(t),u_matrix:new e.UniformMatrix4f(t),u_inv_rot_matrix:new e.UniformMatrix4f(t),u_merc_center:new e.Uniform2f(t),u_tile_id:new e.Uniform3f(t),u_zoom_transition:new e.Uniform1f(t),u_up_dir:new e.Uniform3f(t)}),heatmapTexture:t=>({u_image:new e.Uniform1i(t),u_color_ramp:new e.Uniform1i(t),u_opacity:new e.Uniform1f(t)}),hillshade:t=>({u_matrix:new e.UniformMatrix4f(t),u_image:new e.Uniform1i(t),u_latrange:new e.Uniform2f(t),u_light:new e.Uniform2f(t),u_shadow:new e.UniformColor(t),u_highlight:new e.UniformColor(t),u_accent:new e.UniformColor(t)}),hillshadePrepare:t=>({u_matrix:new e.UniformMatrix4f(t),u_image:new e.Uniform1i(t),u_dimension:new e.Uniform2f(t),u_zoom:new e.Uniform1f(t),u_unpack:new e.Uniform4f(t)}),line:t=>({u_matrix:new e.UniformMatrix4f(t),u_pixels_to_tile_units:new e.UniformMatrix2f(t),u_device_pixel_ratio:new e.Uniform1f(t),u_units_to_pixels:new e.Uniform2f(t),u_dash_image:new e.Uniform1i(t),u_gradient_image:new e.Uniform1i(t),u_image_height:new e.Uniform1f(t),u_texsize:new e.Uniform2f(t),u_tile_units_to_pixels:new e.Uniform1f(t),u_alpha_discard_threshold:new e.Uniform1f(t),u_trim_offset:new e.Uniform2f(t)}),linePattern:t=>({u_matrix:new e.UniformMatrix4f(t),u_texsize:new e.Uniform2f(t),u_pixels_to_tile_units:new e.UniformMatrix2f(t),u_device_pixel_ratio:new e.Uniform1f(t),u_image:new e.Uniform1i(t),u_units_to_pixels:new e.Uniform2f(t),u_tile_units_to_pixels:new e.Uniform1f(t),u_alpha_discard_threshold:new e.Uniform1f(t)}),raster:t=>({u_matrix:new e.UniformMatrix4f(t),u_tl_parent:new e.Uniform2f(t),u_scale_parent:new e.Uniform1f(t),u_fade_t:new e.Uniform1f(t),u_opacity:new e.Uniform1f(t),u_image0:new e.Uniform1i(t),u_image1:new e.Uniform1i(t),u_brightness_low:new e.Uniform1f(t),u_brightness_high:new e.Uniform1f(t),u_saturation_factor:new e.Uniform1f(t),u_contrast_factor:new e.Uniform1f(t),u_spin_weights:new e.Uniform3f(t),u_perspective_transform:new e.Uniform2f(t)}),symbolIcon:t=>({u_is_size_zoom_constant:new e.Uniform1i(t),u_is_size_feature_constant:new e.Uniform1i(t),u_size_t:new e.Uniform1f(t),u_size:new e.Uniform1f(t),u_camera_to_center_distance:new e.Uniform1f(t),u_rotate_symbol:new e.Uniform1i(t),u_aspect_ratio:new e.Uniform1f(t),u_fade_change:new e.Uniform1f(t),u_matrix:new e.UniformMatrix4f(t),u_label_plane_matrix:new e.UniformMatrix4f(t),u_coord_matrix:new e.UniformMatrix4f(t),u_is_text:new e.Uniform1i(t),u_pitch_with_map:new e.Uniform1i(t),u_texsize:new e.Uniform2f(t),u_tile_id:new e.Uniform3f(t),u_zoom_transition:new e.Uniform1f(t),u_inv_rot_matrix:new e.UniformMatrix4f(t),u_merc_center:new e.Uniform2f(t),u_camera_forward:new e.Uniform3f(t),u_tile_matrix:new e.UniformMatrix4f(t),u_up_vector:new e.Uniform3f(t),u_ecef_origin:new e.Uniform3f(t),u_texture:new e.Uniform1i(t)}),symbolSDF:t=>({u_is_size_zoom_constant:new e.Uniform1i(t),u_is_size_feature_constant:new e.Uniform1i(t),u_size_t:new e.Uniform1f(t),u_size:new e.Uniform1f(t),u_camera_to_center_distance:new e.Uniform1f(t),u_rotate_symbol:new e.Uniform1i(t),u_aspect_ratio:new e.Uniform1f(t),u_fade_change:new e.Uniform1f(t),u_matrix:new e.UniformMatrix4f(t),u_label_plane_matrix:new e.UniformMatrix4f(t),u_coord_matrix:new e.UniformMatrix4f(t),u_is_text:new e.Uniform1i(t),u_pitch_with_map:new e.Uniform1i(t),u_texsize:new e.Uniform2f(t),u_texture:new e.Uniform1i(t),u_gamma_scale:new e.Uniform1f(t),u_device_pixel_ratio:new e.Uniform1f(t),u_tile_id:new e.Uniform3f(t),u_zoom_transition:new e.Uniform1f(t),u_inv_rot_matrix:new e.UniformMatrix4f(t),u_merc_center:new e.Uniform2f(t),u_camera_forward:new e.Uniform3f(t),u_tile_matrix:new e.UniformMatrix4f(t),u_up_vector:new e.Uniform3f(t),u_ecef_origin:new e.Uniform3f(t),u_is_halo:new e.Uniform1i(t)}),symbolTextAndIcon:t=>({u_is_size_zoom_constant:new e.Uniform1i(t),u_is_size_feature_constant:new e.Uniform1i(t),u_size_t:new e.Uniform1f(t),u_size:new e.Uniform1f(t),u_camera_to_center_distance:new e.Uniform1f(t),u_rotate_symbol:new e.Uniform1i(t),u_aspect_ratio:new e.Uniform1f(t),u_fade_change:new e.Uniform1f(t),u_matrix:new e.UniformMatrix4f(t),u_label_plane_matrix:new e.UniformMatrix4f(t),u_coord_matrix:new e.UniformMatrix4f(t),u_is_text:new e.Uniform1i(t),u_pitch_with_map:new e.Uniform1i(t),u_texsize:new e.Uniform2f(t),u_texsize_icon:new e.Uniform2f(t),u_texture:new e.Uniform1i(t),u_texture_icon:new e.Uniform1i(t),u_gamma_scale:new e.Uniform1f(t),u_device_pixel_ratio:new e.Uniform1f(t),u_is_halo:new e.Uniform1i(t)}),background:t=>({u_matrix:new e.UniformMatrix4f(t),u_opacity:new e.Uniform1f(t),u_color:new e.UniformColor(t)}),backgroundPattern:t=>({u_matrix:new e.UniformMatrix4f(t),u_opacity:new e.Uniform1f(t),u_image:new e.Uniform1i(t),u_pattern_tl:new e.Uniform2f(t),u_pattern_br:new e.Uniform2f(t),u_texsize:new e.Uniform2f(t),u_pattern_size:new e.Uniform2f(t),u_pixel_coord_upper:new e.Uniform2f(t),u_pixel_coord_lower:new e.Uniform2f(t),u_tile_units_to_pixels:new e.Uniform1f(t)}),terrainRaster:gi,terrainDepth:gi,skybox:t=>({u_matrix:new e.UniformMatrix4f(t),u_sun_direction:new e.Uniform3f(t),u_cubemap:new e.Uniform1i(t),u_opacity:new e.Uniform1f(t),u_temporal_offset:new e.Uniform1f(t)}),skyboxGradient:t=>({u_matrix:new e.UniformMatrix4f(t),u_color_ramp:new e.Uniform1i(t),u_center_direction:new e.Uniform3f(t),u_radius:new e.Uniform1f(t),u_opacity:new e.Uniform1f(t),u_temporal_offset:new e.Uniform1f(t)}),skyboxCapture:t=>({u_matrix_3f:new e.UniformMatrix3f(t),u_sun_direction:new e.Uniform3f(t),u_sun_intensity:new e.Uniform1f(t),u_color_tint_r:new e.Uniform4f(t),u_color_tint_m:new e.Uniform4f(t),u_luminance:new e.Uniform1f(t)}),globeRaster:t=>({u_proj_matrix:new e.UniformMatrix4f(t),u_globe_matrix:new e.UniformMatrix4f(t),u_normalize_matrix:new e.UniformMatrix4f(t),u_merc_matrix:new e.UniformMatrix4f(t),u_zoom_transition:new e.Uniform1f(t),u_merc_center:new e.Uniform2f(t),u_image0:new e.Uniform1i(t),u_grid_matrix:new e.UniformMatrix3f(t),u_skirt_height:new e.Uniform1f(t),u_frustum_tl:new e.Uniform3f(t),u_frustum_tr:new e.Uniform3f(t),u_frustum_br:new e.Uniform3f(t),u_frustum_bl:new e.Uniform3f(t),u_globe_pos:new e.Uniform3f(t),u_globe_radius:new e.Uniform1f(t),u_viewport:new e.Uniform2f(t)}),globeAtmosphere:t=>({u_frustum_tl:new e.Uniform3f(t),u_frustum_tr:new e.Uniform3f(t),u_frustum_br:new e.Uniform3f(t),u_frustum_bl:new e.Uniform3f(t),u_horizon:new e.Uniform1f(t),u_transition:new e.Uniform1f(t),u_fadeout_range:new e.Uniform1f(t),u_color:new e.Uniform4f(t),u_high_color:new e.Uniform4f(t),u_space_color:new e.Uniform4f(t),u_star_intensity:new e.Uniform1f(t),u_star_density:new e.Uniform1f(t),u_star_size:new e.Uniform1f(t),u_temporal_offset:new e.Uniform1f(t),u_horizon_angle:new e.Uniform1f(t),u_rotation_matrix:new e.UniformMatrix4f(t)})};let ao;function lo(t,i,o,r,n,s,a){const l=t.context,c=l.gl,h=t.transform,u=t.useProgram("collisionBox"),_=[];let d=0,p=0;for(let m=0;m<r.length;m++){const f=r[m],g=i.getTile(f),v=g.getBucket(o);if(!v)continue;const x=vt(f,v,h);let y=x;0===n[0]&&0===n[1]||(y=t.translatePosMatrix(x,g,n,s));const b=a?v.textCollisionBox:v.iconCollisionBox,w=v.collisionCircleArray;if(w.length>0){const t=e.create(),i=y;e.mul(t,v.placementInvProjMatrix,h.glCoordMatrix),e.mul(t,t,v.placementViewportMatrix),_.push({circleArray:w,circleOffset:p,transform:i,invTransform:t,projection:v.getProjection()}),d+=w.length/4,p=d;}b&&(t.terrain&&t.terrain.setupElevationDraw(g,u),u.draw(l,c.LINES,e.DepthMode.disabled,e.StencilMode.disabled,t.colorModeForRenderPass(),e.CullFaceMode.disabled,Zi(y,h,g,v.getProjection()),o.id,b.layoutVertexBuffer,b.indexBuffer,b.segments,null,h.zoom,null,[b.collisionVertexBuffer,b.collisionVertexBufferExt]));}if(!a||!_.length)return;const m=t.useProgram("collisionCircle"),f=new e.StructArrayLayout2f1f2i16;f.resize(4*d),f._trim();let g=0;for(const e of _)for(let t=0;t<e.circleArray.length/4;t++){const i=4*t,o=e.circleArray[i+0],r=e.circleArray[i+1],n=e.circleArray[i+2],s=e.circleArray[i+3];f.emplace(g++,o,r,n,s,0),f.emplace(g++,o,r,n,s,1),f.emplace(g++,o,r,n,s,2),f.emplace(g++,o,r,n,s,3);}(!ao||ao.length<2*d)&&(ao=function(t){const i=2*t,o=new e.StructArrayLayout3ui6;o.resize(i),o._trim();for(let e=0;e<i;e++){const t=6*e;o.uint16[t+0]=4*e+0,o.uint16[t+1]=4*e+1,o.uint16[t+2]=4*e+2,o.uint16[t+3]=4*e+2,o.uint16[t+4]=4*e+3,o.uint16[t+5]=4*e+0;}return o}(d));const v=l.createIndexBuffer(ao,!0),x=l.createVertexBuffer(f,e.collisionCircleLayout.members,!0);for(const i of _){const r={u_matrix:i.transform,u_inv_matrix:i.invTransform,u_camera_to_center_distance:(y=h).getCameraToCenterDistance(i.projection),u_viewport_size:[y.width,y.height]};m.draw(l,c.TRIANGLES,e.DepthMode.disabled,e.StencilMode.disabled,t.colorModeForRenderPass(),e.CullFaceMode.disabled,r,o.id,x,v,e.SegmentVector.simpleSegment(0,2*i.circleOffset,i.circleArray.length,i.circleArray.length/2),null,h.zoom);}var y;x.destroy(),v.destroy();}const co=e.create();function ho({width:t,height:i,anchor:o,textOffset:r,textScale:n},s){const{horizontalAlign:a,verticalAlign:l}=e.getAnchorAlignment(o),c=-(a-.5)*t,h=-(l-.5)*i,u=e.evaluateVariableOffset(o,r);return new e.Point((c/n+u[0])*s,(h/n+u[1])*s)}function uo(t,i,o,r,n,s,a,l,c,h,u){const _=t.text.placedSymbolArray,d=t.text.dynamicLayoutVertexArray,p=t.icon.dynamicLayoutVertexArray,m={},f=t.getProjection(),g=xt(l,f,s),v=s.elevation,x=f.upVectorScale(l.canonical,s.center.lat,s.worldSize).metersToTile;d.clear();for(let p=0;p<_.length;p++){const y=_.get(p),{tileAnchorX:b,tileAnchorY:w,numGlyphs:T}=y,E=y.hidden||!y.crossTileID||t.allowVerticalPlacement&&!y.placedOrientation?null:r[y.crossTileID];if(E){let r=0,_=0,p=0;if(v){const e=v?v.getAtTileOffset(l,b,w):0,[t,i,o]=f.upVector(l.canonical,b,w);r=e*t*x,_=e*i*x,p=e*o*x;}let[C,M,I,P]=ot(y.projectedAnchorX+r,y.projectedAnchorY+_,y.projectedAnchorZ+p,o?g:a);const S=rt(s.getCameraToCenterDistance(f),P);let D=n.evaluateSizeForFeature(t.textSizeData,h,y)*S/e.ONE_EM;o&&(D*=t.tilePixelRatio/c);const L=ho(E,D);o?(({x:C,y:M,z:I}=f.projectTilePoint(b+L.x,w+L.y,l.canonical)),[C,M,I]=ot(C+r,M+_,I+p,a)):(i&&L._rotate(-s.angle),C+=L.x,M+=L.y,I=0);const A=t.allowVerticalPlacement&&y.placedOrientation===e.WritingMode.vertical?Math.PI/2:0;for(let t=0;t<T;t++)e.addDynamicAttributes(d,C,M,I,A);u&&y.associatedIconIndex>=0&&(m[y.associatedIconIndex]={x:C,y:M,z:I,angle:A});}else dt(T,d);}if(u){p.clear();const i=t.icon.placedSymbolArray;for(let t=0;t<i.length;t++){const o=i.get(t),{numGlyphs:r}=o,n=m[t];if(o.hidden||!n)dt(r,p);else {const{x:t,y:i,z:o,angle:s}=n;for(let n=0;n<r;n++)e.addDynamicAttributes(p,t,i,o,s);}}t.icon.dynamicLayoutVertexBuffer.updateData(p);}t.text.dynamicLayoutVertexBuffer.updateData(d);}function _o(e,t,i){return i.iconsInText&&t?"symbolTextAndIcon":e?"symbolSDF":"symbolIcon"}function po(t,i,o,r,n,s,a,l,c,h,u,_){const d=t.context,p=d.gl,m=t.transform,f="map"===l,g="map"===c,v=f&&"point"!==o.layout.get("symbol-placement"),x=f&&!g&&!v,y=void 0!==o.layout.get("symbol-sort-key").constantOr(1);let b=!1;const w=t.depthModeForSublayer(0,e.DepthMode.ReadOnly),T=[e.mercatorXfromLng(m.center.lng),e.mercatorYfromLat(m.center.lat)],E=o.layout.get("text-variable-anchor"),C="globe"===m.projection.name,M=[],I=[0,-1,0];let P=I;!C&&!m.mercatorFromTransition||f||(P=function(t){const i=t._camera.getWorldToCamera(t.worldSize,1),o=e.multiply([],i,t.globeMatrix);e.invert(o,o);const r=[0,0,0],n=[0,1,0,0];return e.transformMat4$1(n,n,o),r[0]=n[0],r[1]=n[1],r[2]=n[2],e.normalize(r,r),r}(m));for(const l of r){const r=i.getTile(l),c=r.getBucket(o);if(!c)continue;if("mercator"===c.projection.name&&C)continue;const u=n?c.text:c.icon;if(!u||c.fullyClipped||!u.segments.get().length)continue;const _=u.programConfigurations.get(o.id),d=n||c.sdfIcons,w=n?c.textSizeData:c.iconSizeData,S=g||0!==m.pitch,D=e.evaluateSizeForZoom(w,m.zoom);let L,A,z,R,O=[0,0],B=null;if(n)A=r.glyphAtlasTexture,z=p.LINEAR,L=r.glyphAtlasTexture.size,c.iconsInText&&(O=r.imageAtlasTexture.size,B=r.imageAtlasTexture,R=S||t.options.rotating||t.options.zooming||"composite"===w.kind||"camera"===w.kind?p.LINEAR:p.NEAREST);else {const e=1!==o.layout.get("icon-size").constantOr(0)||c.iconsNeedLinear;A=r.imageAtlasTexture,z=d||t.options.rotating||t.options.zooming||e||S?p.LINEAR:p.NEAREST,L=r.imageAtlasTexture.size;}const k="globe"===c.projection.name,F=k?P:I,U=k?e.globeToMercatorTransition(m.zoom):0,N=xt(l,c.getProjection(),m),j=m.calculatePixelsToTileUnitsMatrix(r),G=et(N,r.tileID.canonical,g,f,m,c.getProjection(),j),Z=t.terrain&&g&&v?e.invert(e.create(),G):co,V=it(N,r.tileID.canonical,g,f,m,c.getProjection(),j),W=E&&c.hasTextData(),X="none"!==o.layout.get("icon-text-fit")&&W&&c.hasIconData();if(v){const e=m.elevation,i=e?e.getAtTileOffsetFunc(l,m.center.lat,m.worldSize,c.getProjection()):null,o=tt(N,r.tileID.canonical,g,f,m,c.getProjection(),j);st(c,N,t,n,o,V,g,h,i,l);}const q=v||n&&E||X,$=t.translatePosMatrix(N,r,s,a),H=q?co:G,Y=t.translatePosMatrix(V,r,s,a,!0),K=c.getProjection().createInversionMatrix(m,l.canonical),J=[];t.terrainRenderModeElevated()&&g&&J.push("PITCH_WITH_MAP_TERRAIN"),k&&J.push("PROJECTION_GLOBE_VIEW"),q&&J.push("PROJECTED_POS_ON_VIEWPORT");const Q=d&&0!==o.paint.get(n?"text-halo-width":"icon-halo-width").constantOr(1);let ee;ee=d?c.iconsInText?oo(w.kind,D,x,g,t,$,H,Y,L,O,l,U,T,K,F,c.getProjection()):io(w.kind,D,x,g,t,$,H,Y,n,L,!0,l,U,T,K,F,c.getProjection()):to(w.kind,D,x,g,t,$,H,Y,n,L,l,U,T,K,F,c.getProjection());const te={program:t.useProgram(_o(d,n,c),_,J),buffers:u,uniformValues:ee,atlasTexture:A,atlasTextureIcon:B,atlasInterpolation:z,atlasInterpolationIcon:R,isSDF:d,hasHalo:Q,tile:r,labelPlaneMatrixInv:Z};if(y&&c.canOverlap){b=!0;const t=u.segments.get();for(const i of t)M.push({segments:new e.SegmentVector([i]),sortKey:i.sortKey,state:te});}else M.push({segments:u.segments,sortKey:0,state:te});}b&&M.sort(((e,t)=>e.sortKey-t.sortKey));for(const e of M){const i=e.state;if(t.terrain&&t.terrain.setupElevationDraw(i.tile,i.program,{useDepthForOcclusion:!C,labelPlaneMatrixInv:i.labelPlaneMatrixInv}),d.activeTexture.set(p.TEXTURE0),i.atlasTexture.bind(i.atlasInterpolation,p.CLAMP_TO_EDGE),i.atlasTextureIcon&&(d.activeTexture.set(p.TEXTURE1),i.atlasTextureIcon&&i.atlasTextureIcon.bind(i.atlasInterpolationIcon,p.CLAMP_TO_EDGE)),i.isSDF){const r=i.uniformValues;i.hasHalo&&(r.u_is_halo=1,mo(i.buffers,e.segments,o,t,i.program,w,u,_,r)),r.u_is_halo=0;}mo(i.buffers,e.segments,o,t,i.program,w,u,_,i.uniformValues);}}function mo(t,i,o,r,n,s,a,l,c){const h=r.context,u=[t.dynamicLayoutVertexBuffer,t.opacityVertexBuffer,t.globeExtVertexBuffer];n.draw(h,h.gl.TRIANGLES,s,a,l,e.CullFaceMode.disabled,c,o.id,t.layoutVertexBuffer,t.indexBuffer,i,o.paint,r.transform.zoom,t.programConfigurations.get(o.id),u);}function fo(t,i,o,r,n,s,a){const l=t.context.gl,c=o.paint.get("fill-pattern"),h=c&&c.constantOr(1);let u,_,d,p,m;a?(_=h&&!o.getPaintProperty("fill-outline-color")?"fillOutlinePattern":"fillOutline",u=l.LINES):(_=h?"fillPattern":"fill",u=l.TRIANGLES);for(const f of r){const r=i.getTile(f);if(h&&!r.patternsLoaded())continue;const g=r.getBucket(o);if(!g)continue;t.prepareDrawTile();const v=g.programConfigurations.get(o.id),x=t.useProgram(_,v);h&&(t.context.activeTexture.set(l.TEXTURE0),r.imageAtlasTexture.bind(l.LINEAR,l.CLAMP_TO_EDGE),v.updatePaintBuffers());const y=c.constantOr(null);if(y&&r.imageAtlas){const e=r.imageAtlas.patternPositions[y.toString()];e&&v.setConstantPatternPositions(e);}const b=t.translatePosMatrix(f.projMatrix,r,o.paint.get("fill-translate"),o.paint.get("fill-translate-anchor"));if(a){p=g.indexBuffer2,m=g.segments2;const e=t.terrain&&t.terrain.renderingToTexture?t.terrain.drapeBufferSize:[l.drawingBufferWidth,l.drawingBufferHeight];d="fillOutlinePattern"===_&&h?Ui(b,t,r,e):Fi(b,e);}else p=g.indexBuffer,m=g.segments,d=h?ki(b,t,r):Bi(b);t.prepareDrawProgram(t.context,x,f.toUnwrapped()),x.draw(t.context,u,n,t.stencilModeForClipping(f),s,e.CullFaceMode.disabled,d,o.id,g.layoutVertexBuffer,p,m,o.paint,t.transform.zoom,v);}}function go(t,i,o,r,n,s,a){const l=t.context,c=l.gl,h=t.transform,u=o.paint.get("fill-extrusion-pattern"),_=u.constantOr(1),d=o.paint.get("fill-extrusion-opacity"),p=[o.paint.get("fill-extrusion-ambient-occlusion-intensity"),o.paint.get("fill-extrusion-ambient-occlusion-radius")],m=o.layout.get("fill-extrusion-edge-radius"),f=m>0&&!o.paint.get("fill-extrusion-rounded-roof"),g=f?0:m,v="globe"===h.projection.name?e.fillExtrusionHeightLift():0,x="globe"===h.projection.name,y=x?e.globeToMercatorTransition(h.zoom):0,b=[e.mercatorXfromLng(h.center.lng),e.mercatorYfromLat(h.center.lat)],w=[];x&&w.push("PROJECTION_GLOBE_VIEW"),p[0]>0&&w.push("FAUX_AO"),f&&w.push("ZERO_ROOF_RADIUS");for(const m of r){const r=i.getTile(m),f=r.getBucket(o);if(!f||f.projection.name!==h.projection.name)continue;const T=f.programConfigurations.get(o.id),E=t.useProgram(_?"fillExtrusionPattern":"fillExtrusion",T,w);if(t.terrain){const e=t.terrain;if(t.style.terrainSetForDrapingOnly())e.setupElevationDraw(r,E,{useMeterToDem:!0});else {if(!f.enableTerrain)continue;if(e.setupElevationDraw(r,E,{useMeterToDem:!0}),vo(l,i,m,f,o,e),!f.centroidVertexBuffer){const e=E.attributes.a_centroid_pos;void 0!==e&&c.vertexAttrib2f(e,0,0);}}}_&&(t.context.activeTexture.set(c.TEXTURE0),r.imageAtlasTexture.bind(c.LINEAR,c.CLAMP_TO_EDGE),T.updatePaintBuffers());const C=u.constantOr(null);if(C&&r.imageAtlas){const e=r.imageAtlas.patternPositions[C.toString()];e&&T.setConstantPatternPositions(e);}const M=t.translatePosMatrix(m.projMatrix,r,o.paint.get("fill-extrusion-translate"),o.paint.get("fill-extrusion-translate-anchor")),I=h.projection.createInversionMatrix(h,m.canonical),P=o.paint.get("fill-extrusion-vertical-gradient"),S=_?Oi(M,t,P,d,p,g,m,r,v,y,b,I):Ri(M,t,P,d,p,g,m,v,y,b,I);t.prepareDrawProgram(l,E,m.toUnwrapped());const D=[];t.terrain&&D.push(f.centroidVertexBuffer),x&&D.push(f.layoutVertexExtBuffer),E.draw(l,l.gl.TRIANGLES,n,s,a,e.CullFaceMode.backCCW,S,o.id,f.layoutVertexBuffer,f.indexBuffer,f.segments,o.paint,t.transform.zoom,T,D);}}function vo(t,i,o,r,n,s){const a=[t=>{let i=t.canonical.x-1,o=t.wrap;return i<0&&(i=(1<<t.canonical.z)-1,o--),new e.OverscaledTileID(t.overscaledZ,o,t.canonical.z,i,t.canonical.y)},t=>{let i=t.canonical.x+1,o=t.wrap;return i===1<<t.canonical.z&&(i=0,o++),new e.OverscaledTileID(t.overscaledZ,o,t.canonical.z,i,t.canonical.y)},t=>new e.OverscaledTileID(t.overscaledZ,t.wrap,t.canonical.z,t.canonical.x,(0===t.canonical.y?1<<t.canonical.z:t.canonical.y)-1),t=>new e.OverscaledTileID(t.overscaledZ,t.wrap,t.canonical.z,t.canonical.x,t.canonical.y===(1<<t.canonical.z)-1?0:t.canonical.y+1)],l=e=>{const t=i.getSource().minzoom,o=e=>{const t=i.getTileByID(e);if(t&&t.hasData())return t.getBucket(n)},r=[0,-1,1];for(const i of r){if(e.overscaledZ+i<t)continue;const r=o(e.calculateScaledKey(e.overscaledZ+i));if(r)return r}},c=[0,0,0],h=(t,i)=>(c[0]=Math.min(t.min.y,i.min.y),c[1]=Math.max(t.max.y,i.max.y),c[2]=e.EXTENT-i.min.x>t.max.x?i.min.x-e.EXTENT:t.max.x,c),u=(t,i)=>(c[0]=Math.min(t.min.x,i.min.x),c[1]=Math.max(t.max.x,i.max.x),c[2]=e.EXTENT-i.min.y>t.max.y?i.min.y-e.EXTENT:t.max.y,c),_=[(e,t)=>h(e,t),(e,t)=>h(t,e),(e,t)=>u(e,t),(e,t)=>u(t,e)],d=new e.Point(0,0);let p,m,f;const g=(t,i,r,n,a)=>{const l=[[n?r:t,n?t:r,0],[n?r:i,n?i:r,0]],c=a<0?e.EXTENT+a:a,h=[n?c:(t+i)/2,n?(t+i)/2:c,0];return 0===r&&a<0||0!==r&&a>0?s.getForTilePoints(f,[h],!0,m):l.push(h),s.getForTilePoints(o,l,!0,p),Math.max(l[0][2],l[1][2],h[2])/s.exaggeration()};for(let t=0;t<4;t++){const i=(t<2?1:5)-t,n=r.borders[t];if(0===n.length)continue;const c=f=a[t](o),h=l(c);if(!(h&&h instanceof e.FillExtrusionBucket&&h.enableTerrain))continue;if(r.borderDoneWithNeighborZ[t]===h.canonical.z&&h.borderDoneWithNeighborZ[i]===r.canonical.z)continue;if(m=s.findDEMTileFor(c),!m||!m.dem)continue;if(!p){const e=s.findDEMTileFor(o);if(!e||!e.dem)return;p=e;}const u=h.borders[i];let v=0;const x=h.borderDoneWithNeighborZ[i]!==r.canonical.z;if(r.canonical.z===h.canonical.z){for(let o=0;o<n.length;o++){const s=r.featuresOnBorder[n[o]],a=s.borders[t];let l;for(;v<u.length&&(l=h.featuresOnBorder[u[v]],!(l.borders[i][1]>a[0]+3));)x&&h.encodeCentroid(void 0,l,!1),v++;if(l&&v<u.length){const o=v;let n=0;for(;!(l.borders[i][0]>a[1]-3)&&(n++,++v!==u.length);)l=h.featuresOnBorder[u[v]];if(l=h.featuresOnBorder[u[o]],s.intersectsCount()>1||l.intersectsCount()>1||1!==n){1!==n&&(v=o),r.encodeCentroid(void 0,s,!1),x&&h.encodeCentroid(void 0,l,!1);continue}const c=_[t](s,l),p=t%2?e.EXTENT-1:0;d.x=g(c[0],Math.min(e.EXTENT-1,c[1]),p,t<2,c[2]),d.y=0,r.encodeCentroid(d,s,!1),x&&h.encodeCentroid(d,l,!1);}else r.encodeCentroid(void 0,s,!1);}r.borderDoneWithNeighborZ[t]=h.canonical.z,r.needsCentroidUpdate=!0,x&&(h.borderDoneWithNeighborZ[i]=r.canonical.z,h.needsCentroidUpdate=!0);}else {for(const e of n)r.encodeCentroid(void 0,r.featuresOnBorder[e],!1);if(x){for(const e of u)h.encodeCentroid(void 0,h.featuresOnBorder[e],!1);h.borderDoneWithNeighborZ[i]=r.canonical.z,h.needsCentroidUpdate=!0;}r.borderDoneWithNeighborZ[t]=h.canonical.z,r.needsCentroidUpdate=!0;}}(r.needsCentroidUpdate||!r.centroidVertexBuffer&&0!==r.centroidVertexArray.length)&&r.uploadCentroid(t);}const xo=new e.Color(1,0,0,1),yo=new e.Color(0,1,0,1),bo=new e.Color(0,0,1,1),wo=new e.Color(1,0,1,1),To=new e.Color(0,1,1,1);function Eo(t,i,o){const r=t.context,n=t.transform,s=r.gl,a="globe"===n.projection.name,l=a?["PROJECTION_GLOBE_VIEW"]:null;let c=o.projMatrix;if(a&&e.globeToMercatorTransition(n.zoom)>0){const t=e.transitionTileAABBinECEF(o.canonical,n),i=e.globeDenormalizeECEF(t);c=e.multiply(new Float32Array(16),n.globeMatrix,i),e.multiply(c,n.projMatrix,c);}const h=t.useProgram("debug",null,l),u=i.getTileByID(o.key);t.terrain&&t.terrain.setupElevationDraw(u,h);const _=e.DepthMode.disabled,d=e.StencilMode.disabled,p=t.colorModeForRenderPass(),m="$debug";r.activeTexture.set(s.TEXTURE0),t.emptyTexture.bind(s.LINEAR,s.CLAMP_TO_EDGE),a?u._makeGlobeTileDebugBuffers(t.context,n):u._makeDebugTileBoundsBuffers(t.context,n.projection);const f=u._tileDebugBuffer||t.debugBuffer,g=u._tileDebugIndexBuffer||t.debugIndexBuffer,v=u._tileDebugSegments||t.debugSegments;h.draw(r,s.LINE_STRIP,_,d,p,e.CullFaceMode.disabled,Vi(c,e.Color.red),m,f,g,v,null,null,null,[u._globeTileDebugBorderBuffer]);const x=u.latestRawTileData,y=Math.floor((x&&x.byteLength||0)/1024),b=i.getTile(o).tileSize,w=512/Math.min(b,512)*(o.overscaledZ/n.zoom)*.5;let T=o.canonical.toString();o.overscaledZ!==o.canonical.z&&(T+=` => ${o.overscaledZ}`),T+=` ${y}kb`,function(e,t){e.initDebugOverlayCanvas();const i=e.debugOverlayCanvas,o=e.context.gl,r=e.debugOverlayCanvas.getContext("2d");r.clearRect(0,0,i.width,i.height),r.shadowColor="white",r.shadowBlur=2,r.lineWidth=1.5,r.strokeStyle="white",r.textBaseline="top",r.font="bold 36px Open Sans, sans-serif",r.fillText(t,5,5),r.strokeText(t,5,5),e.debugOverlayTexture.update(i),e.debugOverlayTexture.bind(o.LINEAR,o.CLAMP_TO_EDGE);}(t,T);const E=u._tileDebugTextBuffer||t.debugBuffer,C=u._tileDebugTextIndexBuffer||t.quadTriangleIndexBuffer,M=u._tileDebugTextSegments||t.debugSegments;h.draw(r,s.TRIANGLES,_,d,e.ColorMode.alphaBlended,e.CullFaceMode.disabled,Vi(c,e.Color.transparent,w),m,E,C,M,null,null,null,[u._globeTileDebugTextBuffer]);}function Co(e,t,i,o){Io(e,0,t+i/2,e.transform.width,i,o);}function Mo(e,t,i,o){Io(e,t-i/2,0,i,e.transform.height,o);}function Io(t,i,o,r,n,s){const a=t.context,l=a.gl;l.enable(l.SCISSOR_TEST),l.scissor(i*e.exported.devicePixelRatio,o*e.exported.devicePixelRatio,r*e.exported.devicePixelRatio,n*e.exported.devicePixelRatio),a.clear({color:s}),l.disable(l.SCISSOR_TEST);}const Po=e.createLayout([{name:"a_pos_3f",components:3,type:"Float32"}]),{members:So}=Po;function Do(e,t,i,o){e.emplaceBack(t,i,o);}class Lo{constructor(t){this.vertexArray=new e.StructArrayLayout3f12,this.indices=new e.StructArrayLayout3ui6,Do(this.vertexArray,-1,-1,1),Do(this.vertexArray,1,-1,1),Do(this.vertexArray,-1,1,1),Do(this.vertexArray,1,1,1),Do(this.vertexArray,-1,-1,-1),Do(this.vertexArray,1,-1,-1),Do(this.vertexArray,-1,1,-1),Do(this.vertexArray,1,1,-1),this.indices.emplaceBack(5,1,3),this.indices.emplaceBack(3,7,5),this.indices.emplaceBack(6,2,0),this.indices.emplaceBack(0,4,6),this.indices.emplaceBack(2,6,7),this.indices.emplaceBack(7,3,2),this.indices.emplaceBack(5,4,0),this.indices.emplaceBack(0,1,5),this.indices.emplaceBack(0,2,3),this.indices.emplaceBack(3,1,0),this.indices.emplaceBack(7,6,4),this.indices.emplaceBack(4,5,7),this.vertexBuffer=t.createVertexBuffer(this.vertexArray,So),this.indexBuffer=t.createIndexBuffer(this.indices),this.segment=e.SegmentVector.simpleSegment(0,0,36,12);}}function Ao(t,i,o,r,n,s){const a=t.gl,l=i.paint.get("sky-atmosphere-color"),c=i.paint.get("sky-atmosphere-halo-color"),h=i.paint.get("sky-atmosphere-sun-intensity"),u=((e,t,i,o,r)=>({u_matrix_3f:e,u_sun_direction:t,u_sun_intensity:i,u_color_tint_r:[o.r,o.g,o.b,o.a],u_color_tint_m:[r.r,r.g,r.b,r.a],u_luminance:5e-5}))(e.fromMat4(e.create$1(),r),n,h,l,c);a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+s,i.skyboxTexture,0),o.draw(t,a.TRIANGLES,e.DepthMode.disabled,e.StencilMode.disabled,e.ColorMode.unblended,e.CullFaceMode.frontCW,u,"skyboxCapture",i.skyboxGeometry.vertexBuffer,i.skyboxGeometry.indexBuffer,i.skyboxGeometry.segment);}const zo=e.createLayout([{type:"Float32",name:"a_pos",components:3},{type:"Float32",name:"a_uv",components:2}]);class Ro{constructor(t){const i=new e.StructArrayLayout5f20;i.emplaceBack(-1,1,1,0,0),i.emplaceBack(1,1,1,1,0),i.emplaceBack(1,-1,1,1,1),i.emplaceBack(-1,-1,1,0,1);const o=new e.StructArrayLayout3ui6;o.emplaceBack(0,1,2),o.emplaceBack(2,3,0),this.vertexBuffer=t.createVertexBuffer(i,zo.members),this.indexBuffer=t.createIndexBuffer(o),this.segments=e.SegmentVector.simpleSegment(0,0,4,2);}destroy(){this.vertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy();}}const Oo={symbol:function(t,i,o,r,n){if("translucent"!==t.renderPass)return;const s=e.StencilMode.disabled,a=t.colorModeForRenderPass();o.layout.get("text-variable-anchor")&&function(t,i,o,r,n,s,a){const l=i.transform,c="map"===n,h="map"===s;for(const i of t){const t=r.getTile(i),n=t.getBucket(o);if(!n||!n.text||!n.text.segments.get().length)continue;const s=e.evaluateSizeForZoom(n.textSizeData,l.zoom),u=xt(i,n.getProjection(),l),_=l.calculatePixelsToTileUnitsMatrix(t),d=et(u,t.tileID.canonical,h,c,l,n.getProjection(),_),p="none"!==o.layout.get("icon-text-fit")&&n.hasIconData();if(s){const o=Math.pow(2,l.zoom-t.tileID.overscaledZ);uo(n,c,h,a,e.symbolSize,l,d,i,o,s,p);}}}(r,t,o,i,o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),n),0!==o.paint.get("icon-opacity").constantOr(1)&&po(t,i,o,r,!1,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),o.layout.get("icon-rotation-alignment"),o.layout.get("icon-pitch-alignment"),o.layout.get("icon-keep-upright"),s,a),0!==o.paint.get("text-opacity").constantOr(1)&&po(t,i,o,r,!0,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),o.layout.get("text-keep-upright"),s,a),i.map.showCollisionBoxes&&(lo(t,i,o,r,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),!0),lo(t,i,o,r,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),!1));},circle:function(t,i,o,r){if("translucent"!==t.renderPass)return;const n=o.paint.get("circle-opacity"),s=o.paint.get("circle-stroke-width"),a=o.paint.get("circle-stroke-opacity"),l=void 0!==o.layout.get("circle-sort-key").constantOr(1);if(0===n.constantOr(1)&&(0===s.constantOr(1)||0===a.constantOr(1)))return;const c=t.context,h=c.gl,u=t.transform,_=t.depthModeForSublayer(0,e.DepthMode.ReadOnly),d=e.StencilMode.disabled,p=t.colorModeForRenderPass(),m="globe"===u.projection.name,f=[e.mercatorXfromLng(u.center.lng),e.mercatorYfromLat(u.center.lat)],g=[];for(let n=0;n<r.length;n++){const s=r[n],a=i.getTile(s),c=a.getBucket(o);if(!c||c.projection.name!==u.projection.name)continue;const h=c.programConfigurations.get(o.id),_=Gi(o);m&&_.push("PROJECTION_GLOBE_VIEW");const d=t.useProgram("circle",h,_),p=c.layoutVertexBuffer,v=c.globeExtVertexBuffer,x=c.indexBuffer,y=u.projection.createInversionMatrix(u,s.canonical),b={programConfiguration:h,program:d,layoutVertexBuffer:p,globeExtVertexBuffer:v,indexBuffer:x,uniformValues:ji(t,s,a,y,f,o),tile:a};if(l){const t=c.segments.get();for(const i of t)g.push({segments:new e.SegmentVector([i]),sortKey:i.sortKey,state:b});}else g.push({segments:c.segments,sortKey:0,state:b});}l&&g.sort(((e,t)=>e.sortKey-t.sortKey));const v={useDepthForOcclusion:!m};for(const i of g){const{programConfiguration:r,program:n,layoutVertexBuffer:s,globeExtVertexBuffer:a,indexBuffer:l,uniformValues:m,tile:f}=i.state,g=i.segments;t.terrain&&t.terrain.setupElevationDraw(f,n,v),t.prepareDrawProgram(c,n,f.tileID.toUnwrapped()),n.draw(c,h.TRIANGLES,_,d,p,e.CullFaceMode.disabled,m,o.id,s,l,g,o.paint,u.zoom,r,[a]);}},heatmap:function(t,i,o,r){if(0!==o.paint.get("heatmap-opacity"))if("offscreen"===t.renderPass){const n=t.context,s=n.gl,a=e.StencilMode.disabled,l=new e.ColorMode([s.ONE,s.ONE],e.Color.transparent,[!0,!0,!0,!0]);!function(e,t,i,o){const r=e.gl,n=t.width*o,s=t.height*o;e.activeTexture.set(r.TEXTURE1),e.viewport.set([0,0,n,s]);let a=i.heatmapFbo;if(!a||a&&(a.width!==n||a.height!==s)){a&&a.destroy();const t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),a=i.heatmapFbo=e.createFramebuffer(n,s,!1),function(e,t,i,o,r,n){const s=e.gl;s.texImage2D(s.TEXTURE_2D,0,e.isWebGL2&&e.extRenderToTextureHalfFloat?s.RGBA16F:s.RGBA,r,n,0,s.RGBA,e.extRenderToTextureHalfFloat?e.isWebGL2?s.HALF_FLOAT:e.extTextureHalfFloat.HALF_FLOAT_OES:s.UNSIGNED_BYTE,null),o.colorAttachment.set(i);}(e,0,t,a,n,s);}else r.bindTexture(r.TEXTURE_2D,a.colorAttachment.get()),e.bindFramebuffer.set(a.framebuffer);}(n,t,o,"globe"===t.transform.projection.name?.5:.25),n.clear({color:e.Color.transparent});const c=t.transform,h="globe"===c.projection.name,u=h?["PROJECTION_GLOBE_VIEW"]:null,_=h?e.CullFaceMode.frontCCW:e.CullFaceMode.disabled,d=[e.mercatorXfromLng(c.center.lng),e.mercatorYfromLat(c.center.lat)];for(let p=0;p<r.length;p++){const m=r[p];if(i.hasRenderableParent(m))continue;const f=i.getTile(m),g=f.getBucket(o);if(!g||g.projection.name!==c.projection.name)continue;const v=g.programConfigurations.get(o.id),x=t.useProgram("heatmap",v,u),{zoom:y}=t.transform;t.terrain&&t.terrain.setupElevationDraw(f,x),t.prepareDrawProgram(n,x,m.toUnwrapped());const b=c.projection.createInversionMatrix(c,m.canonical);x.draw(n,s.TRIANGLES,e.DepthMode.disabled,a,l,_,Xi(t,m,f,b,d,y,o.paint.get("heatmap-intensity")),o.id,g.layoutVertexBuffer,g.indexBuffer,g.segments,o.paint,t.transform.zoom,v,h?[g.globeExtVertexBuffer]:null);}n.viewport.set([0,0,t.width,t.height]);}else "translucent"===t.renderPass&&(t.context.setColorMode(t.colorModeForRenderPass()),function(t,i){const o=t.context,r=o.gl,n=i.heatmapFbo;if(!n)return;o.activeTexture.set(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,n.colorAttachment.get()),o.activeTexture.set(r.TEXTURE1);let s=i.colorRampTexture;s||(s=i.colorRampTexture=new e.Texture(o,i.colorRamp,r.RGBA)),s.bind(r.LINEAR,r.CLAMP_TO_EDGE),t.useProgram("heatmapTexture").draw(o,r.TRIANGLES,e.DepthMode.disabled,e.StencilMode.disabled,t.colorModeForRenderPass(),e.CullFaceMode.disabled,((e,t,i,o)=>({u_image:0,u_color_ramp:1,u_opacity:t.paint.get("heatmap-opacity")}))(0,i),i.id,t.viewportBuffer,t.quadTriangleIndexBuffer,t.viewportSegments,i.paint,t.transform.zoom);}(t,o));},line:function(t,i,o,r){if("translucent"!==t.renderPass)return;const n=o.paint.get("line-opacity"),s=o.paint.get("line-width");if(0===n.constantOr(1)||0===s.constantOr(1))return;const a=t.depthModeForSublayer(0,e.DepthMode.ReadOnly),l=t.colorModeForRenderPass(),c=t.terrain&&t.terrain.renderingToTexture?1:e.exported.devicePixelRatio,h=o.paint.get("line-dasharray"),u=h.constantOr(1),_=o.layout.get("line-cap"),d=o.paint.get("line-pattern"),p=d.constantOr(1),m=o.paint.get("line-gradient"),f=p?"linePattern":"line",g=t.context,v=g.gl,x=(e=>{const t=[];Ki(e)&&t.push("RENDER_LINE_DASH"),e.paint.get("line-gradient")&&t.push("RENDER_LINE_GRADIENT");const i=e.paint.get("line-trim-offset");0===i[0]&&0===i[1]||t.push("RENDER_LINE_TRIM_OFFSET");const o=e.paint.get("line-pattern").constantOr(1),r=1!==e.paint.get("line-opacity").constantOr(1);return !o&&r&&t.push("RENDER_LINE_ALPHA_DISCARD"),t})(o);let y=x.includes("RENDER_LINE_ALPHA_DISCARD");t.terrain&&t.terrain.clipOrMaskOverlapStencilType()&&(y=!1);for(const n of r){const r=i.getTile(n);if(p&&!r.patternsLoaded())continue;const s=r.getBucket(o);if(!s)continue;t.prepareDrawTile();const b=s.programConfigurations.get(o.id),w=t.useProgram(f,b,x),T=d.constantOr(null);if(T&&r.imageAtlas){const e=r.imageAtlas.patternPositions[T.toString()];e&&b.setConstantPatternPositions(e);}const E=h.constantOr(null),C=_.constantOr(null);if(!p&&E&&C&&r.lineAtlas){const e=r.lineAtlas.getDash(E,C);e&&b.setConstantPatternPositions(e);}let[M,I]=o.paint.get("line-trim-offset");if("round"===C||"square"===C){const e=1;M!==I&&(0===M&&(M-=e),1===I&&(I+=e));}const P=t.terrain?n.projMatrix:null,S=p?$i(t,r,o,P,c):qi(t,r,o,P,s.lineClipsArray.length,c,[M,I]);if(m){const r=s.gradients[o.id];let a=r.texture;if(o.gradientVersion!==r.version){let l=256;if(o.stepInterpolant){const o=i.getSource().maxzoom,r=n.canonical.z===o?Math.ceil(1<<t.transform.maxZoom-n.canonical.z):1;l=e.clamp(e.nextPowerOfTwo(s.maxLineLength/e.EXTENT*1024*r),256,g.maxTextureSize);}r.gradient=e.renderColorRamp({expression:o.gradientExpression(),evaluationKey:"lineProgress",resolution:l,image:r.gradient||void 0,clips:s.lineClipsArray}),r.texture?r.texture.update(r.gradient):r.texture=new e.Texture(g,r.gradient,v.RGBA),r.version=o.gradientVersion,a=r.texture;}g.activeTexture.set(v.TEXTURE1),a.bind(o.stepInterpolant?v.NEAREST:v.LINEAR,v.CLAMP_TO_EDGE);}u&&(g.activeTexture.set(v.TEXTURE0),r.lineAtlasTexture.bind(v.LINEAR,v.REPEAT),b.updatePaintBuffers()),p&&(g.activeTexture.set(v.TEXTURE0),r.imageAtlasTexture.bind(v.LINEAR,v.CLAMP_TO_EDGE),b.updatePaintBuffers()),t.prepareDrawProgram(g,w,n.toUnwrapped());const D=i=>{w.draw(g,v.TRIANGLES,a,i,l,e.CullFaceMode.disabled,S,o.id,s.layoutVertexBuffer,s.indexBuffer,s.segments,o.paint,t.transform.zoom,b,[s.layoutVertexBuffer2]);};if(y){const i=t.stencilModeForClipping(n).ref;0===i&&t.terrain&&g.clear({stencil:0});const o={func:v.EQUAL,mask:255};S.u_alpha_discard_threshold=.8,D(new e.StencilMode(o,i,255,v.KEEP,v.KEEP,v.INVERT)),S.u_alpha_discard_threshold=0,D(new e.StencilMode(o,i,255,v.KEEP,v.KEEP,v.KEEP));}else D(t.stencilModeForClipping(n));}y&&(t.resetStencilClippingMasks(),t.terrain&&g.clear({stencil:0}));},fill:function(t,i,o,r){const n=o.paint.get("fill-color"),s=o.paint.get("fill-opacity");if(0===s.constantOr(1))return;const a=t.colorModeForRenderPass(),l=o.paint.get("fill-pattern"),c=t.opaquePassEnabledForLayer()&&!l.constantOr(1)&&1===n.constantOr(e.Color.transparent).a&&1===s.constantOr(0)?"opaque":"translucent";if(t.renderPass===c){const n=t.depthModeForSublayer(1,"opaque"===t.renderPass?e.DepthMode.ReadWrite:e.DepthMode.ReadOnly);fo(t,i,o,r,n,a,!1);}if("translucent"===t.renderPass&&o.paint.get("fill-antialias")){const n=t.depthModeForSublayer(o.getPaintProperty("fill-outline-color")?2:0,e.DepthMode.ReadOnly);fo(t,i,o,r,n,a,!0);}},"fill-extrusion":function(t,i,o,r){const n=o.paint.get("fill-extrusion-opacity");if(0!==n&&"translucent"===t.renderPass){const s=new e.DepthMode(t.context.gl.LEQUAL,e.DepthMode.ReadWrite,t.depthRangeFor3D);if(1!==n||o.paint.get("fill-extrusion-pattern").constantOr(1))go(t,i,o,r,s,e.StencilMode.disabled,e.ColorMode.disabled),go(t,i,o,r,s,t.stencilModeFor3D(),t.colorModeForRenderPass()),t.resetStencilClippingMasks();else {const n=t.colorModeForRenderPass();go(t,i,o,r,s,e.StencilMode.disabled,n);}}},hillshade:function(t,i,o,r){if("offscreen"!==t.renderPass&&"translucent"!==t.renderPass)return;const n=t.context,s=t.depthModeForSublayer(0,e.DepthMode.ReadOnly),a=t.colorModeForRenderPass(),l=t.terrain&&t.terrain.renderingToTexture,[c,h]="translucent"!==t.renderPass||l?[{},r]:t.stencilConfigForOverlap(r);for(const r of h){const n=i.getTile(r);if(n.needsHillshadePrepare&&"offscreen"===t.renderPass)fi(t,n,o,s,e.StencilMode.disabled,a);else if("translucent"===t.renderPass){const e=l&&t.terrain?t.terrain.stencilModeForRTTOverlap(r):c[r.overscaledZ];pi(t,r,n,o,s,e,a);}}n.viewport.set([0,0,t.width,t.height]),t.resetStencilClippingMasks();},raster:function(t,i,o,r,n,s){if("translucent"!==t.renderPass)return;if(0===o.paint.get("raster-opacity"))return;if(!r.length)return;const a=t.context,l=a.gl,c=i.getSource(),h=t.useProgram("raster"),u=t.colorModeForRenderPass(),_=t.terrain&&t.terrain.renderingToTexture,[d,p]=c instanceof Pe||_?[{},r]:t.stencilConfigForOverlap(r),m=p[p.length-1].overscaledZ,f=!t.options.moving;for(const r of p){const n=_?e.DepthMode.disabled:t.depthModeForSublayer(r.overscaledZ-m,1===o.paint.get("raster-opacity")?e.DepthMode.ReadWrite:e.DepthMode.ReadOnly,l.LESS),p=r.toUnwrapped(),g=i.getTile(r);if(_&&(!g||!g.hasData()))continue;const v=_?r.projMatrix:t.transform.calculateProjMatrix(p,f),x=t.terrain&&_?t.terrain.stencilModeForRTTOverlap(r):d[r.overscaledZ],y=s?0:o.paint.get("raster-fade-duration");g.registerFadeDuration(y);const b=i.findLoadedParent(r,0),w=Mi(g,b,i,t.transform,y);let T,E;t.terrain&&t.terrain.prepareDrawTile();const C="nearest"===o.paint.get("raster-resampling")?l.NEAREST:l.LINEAR;a.activeTexture.set(l.TEXTURE0),g.texture.bind(C,l.CLAMP_TO_EDGE),a.activeTexture.set(l.TEXTURE1),b?(b.texture.bind(C,l.CLAMP_TO_EDGE),T=Math.pow(2,b.tileID.overscaledZ-g.tileID.overscaledZ),E=[g.tileID.canonical.x*T%1,g.tileID.canonical.y*T%1]):g.texture.bind(C,l.CLAMP_TO_EDGE),g.texture.useMipmap&&a.extTextureFilterAnisotropic&&t.transform.pitch>20&&l.texParameterf(l.TEXTURE_2D,a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,a.extTextureFilterAnisotropicMax);const M=Ji(v,E||[0,0],T||1,w,o,c instanceof Pe?c.perspectiveTransform:[0,0]);if(t.prepareDrawProgram(a,h,p),c instanceof Pe)c.boundsBuffer&&c.boundsSegments&&h.draw(a,l.TRIANGLES,n,e.StencilMode.disabled,u,e.CullFaceMode.disabled,M,o.id,c.boundsBuffer,t.quadTriangleIndexBuffer,c.boundsSegments);else {const{tileBoundsBuffer:i,tileBoundsIndexBuffer:r,tileBoundsSegments:s}=t.getTileBoundsBuffers(g);h.draw(a,l.TRIANGLES,n,x,u,e.CullFaceMode.disabled,M,o.id,i,r,s);}}t.resetStencilClippingMasks();},background:function(t,i,o,r){const n=o.paint.get("background-color"),s=o.paint.get("background-opacity");if(0===s)return;const a=t.context,l=a.gl,c=t.transform,h=c.tileSize,u=o.paint.get("background-pattern");if(t.isPatternMissing(u))return;const _=!u&&1===n.a&&1===s&&t.opaquePassEnabledForLayer()?"opaque":"translucent";if(t.renderPass!==_)return;const d=e.StencilMode.disabled,p=t.depthModeForSublayer(0,"opaque"===_?e.DepthMode.ReadWrite:e.DepthMode.ReadOnly),m=t.colorModeForRenderPass(),f=t.useProgram(u?"backgroundPattern":"background");let g,v=r;v||(g=t.getBackgroundTiles(),v=Object.values(g).map((e=>e.tileID))),u&&(a.activeTexture.set(l.TEXTURE0),t.imageManager.bind(t.context));for(const _ of v){const v=_.toUnwrapped(),x=r?_.projMatrix:t.transform.calculateProjMatrix(v);t.prepareDrawTile();const y=i?i.getTile(_):g?g[_.key]:new e.Tile(_,h,c.zoom,t),b=u?no(x,s,t,u,{tileID:_,tileSize:h}):ro(x,s,n);t.prepareDrawProgram(a,f,v);const{tileBoundsBuffer:w,tileBoundsIndexBuffer:T,tileBoundsSegments:E}=t.getTileBoundsBuffers(y);f.draw(a,l.TRIANGLES,p,d,m,e.CullFaceMode.disabled,b,o.id,w,T,E);}},sky:function(t,i,o){const r=t.transform,n="mercator"===r.projection.name||"globe"===r.projection.name?1:e.smoothstep(7,8,r.zoom),s=o.paint.get("sky-opacity")*n;if(0===s)return;const a=t.context,l=o.paint.get("sky-type"),c=new e.DepthMode(a.gl.LEQUAL,e.DepthMode.ReadOnly,[0,1]),h=t.frameCounter/1e3%1;"atmosphere"===l?"offscreen"===t.renderPass?o.needsSkyboxCapture(t)&&(function(t,i,o,r){const n=t.context,s=n.gl;let a=i.skyboxFbo;if(!a){a=i.skyboxFbo=n.createFramebuffer(32,32,!1),i.skyboxGeometry=new Lo(n),i.skyboxTexture=n.gl.createTexture(),s.bindTexture(s.TEXTURE_CUBE_MAP,i.skyboxTexture),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MIN_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MAG_FILTER,s.LINEAR);for(let e=0;e<6;++e)s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,s.RGBA,32,32,0,s.RGBA,s.UNSIGNED_BYTE,null);}n.bindFramebuffer.set(a.framebuffer),n.viewport.set([0,0,32,32]);const l=i.getCenter(t,!0),c=t.useProgram("skyboxCapture"),h=new Float64Array(16);e.identity(h),e.rotateY(h,h,.5*-Math.PI),Ao(n,i,c,h,l,0),e.identity(h),e.rotateY(h,h,.5*Math.PI),Ao(n,i,c,h,l,1),e.identity(h),e.rotateX(h,h,.5*-Math.PI),Ao(n,i,c,h,l,2),e.identity(h),e.rotateX(h,h,.5*Math.PI),Ao(n,i,c,h,l,3),e.identity(h),Ao(n,i,c,h,l,4),e.identity(h),e.rotateY(h,h,Math.PI),Ao(n,i,c,h,l,5),n.viewport.set([0,0,t.width,t.height]);}(t,o),o.markSkyboxValid(t)):"sky"===t.renderPass&&function(t,i,o,r,n){const s=t.context,a=s.gl,l=t.transform,c=t.useProgram("skybox");s.activeTexture.set(a.TEXTURE0),a.bindTexture(a.TEXTURE_CUBE_MAP,i.skyboxTexture);const h=((e,t,i,o,r)=>({u_matrix:e,u_sun_direction:t,u_cubemap:0,u_opacity:o,u_temporal_offset:r}))(l.skyboxMatrix,i.getCenter(t,!1),0,r,n);t.prepareDrawProgram(s,c),c.draw(s,a.TRIANGLES,o,e.StencilMode.disabled,t.colorModeForRenderPass(),e.CullFaceMode.backCW,h,"skybox",i.skyboxGeometry.vertexBuffer,i.skyboxGeometry.indexBuffer,i.skyboxGeometry.segment);}(t,o,c,s,h):"gradient"===l&&"sky"===t.renderPass&&function(t,i,o,r,n){const s=t.context,a=s.gl,l=t.transform,c=t.useProgram("skyboxGradient");i.skyboxGeometry||(i.skyboxGeometry=new Lo(s)),s.activeTexture.set(a.TEXTURE0);let h=i.colorRampTexture;h||(h=i.colorRampTexture=new e.Texture(s,i.colorRamp,a.RGBA)),h.bind(a.LINEAR,a.CLAMP_TO_EDGE);const u=((t,i,o,r,n)=>({u_matrix:t,u_color_ramp:0,u_center_direction:i,u_radius:e.degToRad(o),u_opacity:r,u_temporal_offset:n}))(l.skyboxMatrix,i.getCenter(t,!1),i.paint.get("sky-gradient-radius"),r,n);t.prepareDrawProgram(s,c),c.draw(s,a.TRIANGLES,o,e.StencilMode.disabled,t.colorModeForRenderPass(),e.CullFaceMode.backCW,u,"skyboxGradient",i.skyboxGeometry.vertexBuffer,i.skyboxGeometry.indexBuffer,i.skyboxGeometry.segment);}(t,o,c,s,h);},debug:function(e,t,i){for(let o=0;o<i.length;o++)Eo(e,t,i[o]);},custom:function(t,i,o,r){const n=t.context,s=o.implementation;if(!t.transform.projection.unsupportedLayers||!t.transform.projection.unsupportedLayers.includes("custom")||t.terrain&&(t.terrain.renderingToTexture||"offscreen"===t.renderPass)&&o.isLayerDraped()){if("offscreen"===t.renderPass){const i=s.prerender;if(i){if(t.setCustomLayerDefaults(),n.setColorMode(t.colorModeForRenderPass()),"globe"===t.transform.projection.name){const o=t.transform.pointMerc;i.call(s,n.gl,t.transform.customLayerMatrix(),t.transform.getProjection(),t.transform.globeToMercatorMatrix(),e.globeToMercatorTransition(t.transform.zoom),[o.x,o.y],t.transform.pixelsPerMeterRatio);}else i.call(s,n.gl,t.transform.customLayerMatrix());n.setDirty(),t.setBaseState();}}else if("translucent"===t.renderPass){if(t.terrain&&t.terrain.renderingToTexture){const i=s.renderToTile;if(i){const o=r[0].canonical,a=new e.MercatorCoordinate(o.x+r[0].wrap*(1<<o.z),o.y,o.z);n.setDepthMode(e.DepthMode.disabled),n.setStencilMode(e.StencilMode.disabled),n.setColorMode(t.colorModeForRenderPass()),t.setCustomLayerDefaults(),i.call(s,n.gl,a),n.setDirty(),t.setBaseState();}return}t.setCustomLayerDefaults(),n.setColorMode(t.colorModeForRenderPass()),n.setStencilMode(e.StencilMode.disabled);const i="3d"===s.renderingMode?new e.DepthMode(t.context.gl.LEQUAL,e.DepthMode.ReadWrite,t.depthRangeFor3D):t.depthModeForSublayer(0,e.DepthMode.ReadOnly);if(n.setDepthMode(i),"globe"===t.transform.projection.name){const i=t.transform.pointMerc;s.render(n.gl,t.transform.customLayerMatrix(),t.transform.getProjection(),t.transform.globeToMercatorMatrix(),e.globeToMercatorTransition(t.transform.zoom),[i.x,i.y],t.transform.pixelsPerMeterRatio);}else s.render(n.gl,t.transform.customLayerMatrix());n.setDirty(),t.setBaseState(),n.bindFramebuffer.set(null);}}else e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");}};class Bo{constructor(t,i,o=!1){this.context=new Ee(t,o),this.transform=i,this._tileTextures={},this.frameCopies=[],this.loadTimeStamps=[],this.setup(),this.numSublayers=e.SourceCache.maxUnderzooming+e.SourceCache.maxOverzooming+1,this.depthEpsilon=1/Math.pow(2,16),this.deferredRenderGpuTimeQueries=[],this.gpuTimers={},this.frameCounter=0,this._backgroundTiles={};}updateTerrain(e,t){const i=!!e&&!!e.terrain&&this.transform.projection.supportsTerrain;if(!(i||this._terrain&&this._terrain.enabled))return;this._terrain||(this._terrain=new Di(this,e));const o=this._terrain;this.transform.elevation=i?o:null,o.update(e,this.transform,t);}_updateFog(e){const t=e.fog;if(!t||"globe"===this.transform.projection.name||t.getOpacity(this.transform.pitch)<1||t.properties.get("horizon-blend")<.03)return void(this.transform.fogCullDistSq=null);const[i,o]=t.getFovAdjustedRange(this.transform._fov);if(i>o)return void(this.transform.fogCullDistSq=null);const r=i+.78*(o-i);this.transform.fogCullDistSq=r*r;}get terrain(){return this.transform._terrainEnabled()&&this._terrain&&this._terrain.enabled?this._terrain:null}resize(t,i){if(this.width=t*e.exported.devicePixelRatio,this.height=i*e.exported.devicePixelRatio,this.context.viewport.set([0,0,this.width,this.height]),this.style)for(const e of this.style.order)this.style._layers[e].resize();}setup(){const t=this.context,i=new e.StructArrayLayout2i4;i.emplaceBack(0,0),i.emplaceBack(e.EXTENT,0),i.emplaceBack(0,e.EXTENT),i.emplaceBack(e.EXTENT,e.EXTENT),this.tileExtentBuffer=t.createVertexBuffer(i,e.posAttributes.members),this.tileExtentSegments=e.SegmentVector.simpleSegment(0,0,4,2);const o=new e.StructArrayLayout2i4;o.emplaceBack(0,0),o.emplaceBack(e.EXTENT,0),o.emplaceBack(0,e.EXTENT),o.emplaceBack(e.EXTENT,e.EXTENT),this.debugBuffer=t.createVertexBuffer(o,e.posAttributes.members),this.debugSegments=e.SegmentVector.simpleSegment(0,0,4,5);const r=new e.StructArrayLayout2i4;r.emplaceBack(-1,-1),r.emplaceBack(1,-1),r.emplaceBack(-1,1),r.emplaceBack(1,1),this.viewportBuffer=t.createVertexBuffer(r,e.posAttributes.members),this.viewportSegments=e.SegmentVector.simpleSegment(0,0,4,2);const n=new e.StructArrayLayout4i8;n.emplaceBack(0,0,0,0),n.emplaceBack(e.EXTENT,0,e.EXTENT,0),n.emplaceBack(0,e.EXTENT,0,e.EXTENT),n.emplaceBack(e.EXTENT,e.EXTENT,e.EXTENT,e.EXTENT),this.mercatorBoundsBuffer=t.createVertexBuffer(n,e.boundsAttributes.members),this.mercatorBoundsSegments=e.SegmentVector.simpleSegment(0,0,4,2);const s=new e.StructArrayLayout3ui6;s.emplaceBack(0,1,2),s.emplaceBack(2,1,3),this.quadTriangleIndexBuffer=t.createIndexBuffer(s);const a=new e.StructArrayLayout1ui2;for(const e of [0,1,3,2,0])a.emplaceBack(e);this.debugIndexBuffer=t.createIndexBuffer(a),this.emptyTexture=new e.Texture(t,new e.RGBAImage({width:1,height:1},Uint8Array.of(0,0,0,0)),t.gl.RGBA),this.identityMat=e.create();const l=this.context.gl;this.stencilClearMode=new e.StencilMode({func:l.ALWAYS,mask:0},0,255,l.ZERO,l.ZERO,l.ZERO),this.loadTimeStamps.push(e.window.performance.now()),this.atmosphereBuffer=new Ro(this.context);}getMercatorTileBoundsBuffers(){return {tileBoundsBuffer:this.mercatorBoundsBuffer,tileBoundsIndexBuffer:this.quadTriangleIndexBuffer,tileBoundsSegments:this.mercatorBoundsSegments}}getTileBoundsBuffers(e){return e._makeTileBoundsBuffers(this.context,this.transform.projection),e._tileBoundsBuffer?{tileBoundsBuffer:e._tileBoundsBuffer,tileBoundsIndexBuffer:e._tileBoundsIndexBuffer,tileBoundsSegments:e._tileBoundsSegments}:this.getMercatorTileBoundsBuffers()}clearStencil(){const t=this.context,i=t.gl;this.nextStencilID=1,this.currentStencilSource=void 0,this._tileClippingMaskIDs={},this.useProgram("clippingMask").draw(t,i.TRIANGLES,e.DepthMode.disabled,this.stencilClearMode,e.ColorMode.disabled,e.CullFaceMode.disabled,Ci(this.identityMat),"$clipping",this.viewportBuffer,this.quadTriangleIndexBuffer,this.viewportSegments);}resetStencilClippingMasks(){this.terrain||(this.currentStencilSource=void 0,this._tileClippingMaskIDs={});}_renderTileClippingMasks(t,i,o){if(!i||this.currentStencilSource===i.id||!t.isTileClipped()||!o||0===o.length)return;if(this._tileClippingMaskIDs&&!this.terrain){let e=!1;for(const t of o)if(void 0===this._tileClippingMaskIDs[t.key]){e=!0;break}if(!e)return}this.currentStencilSource=i.id;const r=this.context,n=r.gl;this.nextStencilID+o.length>256&&this.clearStencil(),r.setColorMode(e.ColorMode.disabled),r.setDepthMode(e.DepthMode.disabled);const s=this.useProgram("clippingMask");this._tileClippingMaskIDs={};for(const t of o){const o=i.getTile(t),a=this._tileClippingMaskIDs[t.key]=this.nextStencilID++,{tileBoundsBuffer:l,tileBoundsIndexBuffer:c,tileBoundsSegments:h}=this.getTileBoundsBuffers(o);s.draw(r,n.TRIANGLES,e.DepthMode.disabled,new e.StencilMode({func:n.ALWAYS,mask:0},a,255,n.KEEP,n.KEEP,n.REPLACE),e.ColorMode.disabled,e.CullFaceMode.disabled,Ci(t.projMatrix),"$clipping",l,c,h);}}stencilModeFor3D(){this.currentStencilSource=void 0,this.nextStencilID+1>256&&this.clearStencil();const t=this.nextStencilID++,i=this.context.gl;return new e.StencilMode({func:i.NOTEQUAL,mask:255},t,255,i.KEEP,i.KEEP,i.REPLACE)}stencilModeForClipping(t){if(this.terrain)return this.terrain.stencilModeForRTTOverlap(t);const i=this.context.gl;return new e.StencilMode({func:i.EQUAL,mask:255},this._tileClippingMaskIDs[t.key],0,i.KEEP,i.KEEP,i.REPLACE)}stencilConfigForOverlap(t){const i=this.context.gl,o=t.sort(((e,t)=>t.overscaledZ-e.overscaledZ)),r=o[o.length-1].overscaledZ,n=o[0].overscaledZ-r+1;if(n>1){this.currentStencilSource=void 0,this.nextStencilID+n>256&&this.clearStencil();const t={};for(let o=0;o<n;o++)t[o+r]=new e.StencilMode({func:i.GEQUAL,mask:255},o+this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);return this.nextStencilID+=n,[t,o]}return [{[r]:e.StencilMode.disabled},o]}colorModeForRenderPass(){const t=this.context.gl;if(this._showOverdrawInspector){const i=1/8;return new e.ColorMode([t.CONSTANT_COLOR,t.ONE],new e.Color(i,i,i,0),[!0,!0,!0,!0])}return "opaque"===this.renderPass?e.ColorMode.unblended:e.ColorMode.alphaBlended}depthModeForSublayer(t,i,o){if(!this.opaquePassEnabledForLayer())return e.DepthMode.disabled;const r=1-((1+this.currentLayer)*this.numSublayers+t)*this.depthEpsilon;return new e.DepthMode(o||this.context.gl.LEQUAL,i,[r,r])}opaquePassEnabledForLayer(){return this.currentLayer<this.opaquePassCutoff}render(t,i){this.style=t,this.options=i,this.imageManager=t.imageManager,this.glyphManager=t.glyphManager,this.symbolFadeChange=t.placement.symbolFadeChange(e.exported.now()),this.imageManager.beginFrame();const o=this.style.order,r=this.style._sourceCaches;for(const e in r){const t=r[e];t.used&&t.prepare(this.context);}const n={},s={},a={};for(const e in r){const t=r[e];n[e]=t.getVisibleCoordinates(),s[e]=n[e].slice().reverse(),a[e]=t.getVisibleCoordinates(!0).reverse();}this.opaquePassCutoff=1/0;for(let e=0;e<o.length;e++)if(this.style._layers[o[e]].is3D()){this.opaquePassCutoff=e;break}if(this.terrain&&(this.terrain.updateTileBinding(a),this.opaquePassCutoff=0),"globe"!==this.transform.projection.name||this.globeSharedBuffers||(this.globeSharedBuffers=new e.GlobeSharedBuffers(this.context)),!e.isMapAuthenticated(this.context.gl))return;this.renderPass="offscreen";for(const e of o){const i=this.style._layers[e],o=t._getLayerSourceCache(i);if(!i.hasOffscreenPass()||i.isHidden(this.transform.zoom))continue;const r=o?s[o.id]:void 0;("custom"===i.type||i.isSky()||r&&r.length)&&this.renderLayer(this,o,i,r);}this.depthRangeFor3D=[0,1-(t.order.length+2)*this.numSublayers*this.depthEpsilon];const l=this.terrain;if(l&&(this.style.hasSymbolLayers()||this.style.hasCircleLayers())&&l.drawDepth(),this.context.bindFramebuffer.set(null),this.context.viewport.set([0,0,this.width,this.height]),this.context.clear({color:i.showOverdrawInspector?e.Color.black:e.Color.transparent,depth:1}),this.clearStencil(),this._showOverdrawInspector=i.showOverdrawInspector,this.renderPass="opaque",!this.terrain)for(this.currentLayer=o.length-1;this.currentLayer>=0;this.currentLayer--){const e=this.style._layers[o[this.currentLayer]],i=t._getLayerSourceCache(e);if(e.isSky())continue;const r=i?s[i.id]:void 0;this._renderTileClippingMasks(e,i,r),this.renderLayer(this,i,e,r);}if(this.style.fog&&this.transform.projection.supportsFog&&function(t,i){const o=t.context,r=o.gl,n=t.transform,s=new e.DepthMode(r.LEQUAL,e.DepthMode.ReadOnly,[0,1]),a=t.useProgram("globeAtmosphere",null,"globe"===n.projection.name?["PROJECTION_GLOBE_VIEW","FOG"]:["FOG"]),l=e.globeToMercatorTransition(n.zoom),c=i.properties.get("color").toArray01(),h=i.properties.get("high-color").toArray01(),u=i.properties.get("space-color").toArray01PremultipliedAlpha(),_=e.identity$1([]);e.rotateY$1(_,_,-e.degToRad(n._center.lng)),e.rotateX$1(_,_,e.degToRad(n._center.lat)),e.rotateZ$1(_,_,n.angle),e.rotateX$1(_,_,-n._pitch);const d=e.fromQuat(new Float32Array(16),_),p=e.mapValue(i.properties.get("star-intensity"),0,1,0,.25),m=5e-4,f=e.mapValue(i.properties.get("horizon-blend"),0,1,m,.25),g=e.globeUseCustomAntiAliasing(t,o,n)&&f===m?n.worldSize/(2*Math.PI*1.025)-1:n.globeRadius,v=t.frameCounter/1e3%1,x=e.length(n.globeCenterInViewSpace),y=Math.sqrt(Math.pow(x,2)-Math.pow(g,2)),b=Math.acos(y/x),w=((t,i,o,r,n,s,a,l,c,h,u,_,d,p)=>({u_frustum_tl:t,u_frustum_tr:i,u_frustum_br:o,u_frustum_bl:r,u_horizon:n,u_transition:s,u_fadeout_range:a,u_color:l,u_high_color:c,u_space_color:h,u_star_intensity:u,u_star_size:5*e.exported.devicePixelRatio,u_star_density:0,u_temporal_offset:_,u_horizon_angle:d,u_rotation_matrix:p}))(n.frustumCorners.TL,n.frustumCorners.TR,n.frustumCorners.BR,n.frustumCorners.BL,n.frustumCorners.horizon,l,f,c,h,u,p,v,b,d);t.prepareDrawProgram(o,a);const T=t.atmosphereBuffer;T&&a.draw(o,r.TRIANGLES,s,e.StencilMode.disabled,e.ColorMode.alphaBlended,e.CullFaceMode.backCW,w,"skybox",T.vertexBuffer,T.indexBuffer,T.segments);}(this,this.style.fog),this.renderPass="sky",(e.globeToMercatorTransition(this.transform.zoom)>0||"globe"!==this.transform.projection.name)&&this.transform.isHorizonVisible())for(this.currentLayer=0;this.currentLayer<o.length;this.currentLayer++){const e=this.style._layers[o[this.currentLayer]],i=t._getLayerSourceCache(e);e.isSky()&&this.renderLayer(this,i,e,i?s[i.id]:void 0);}for(this.renderPass="translucent",this.currentLayer=0;this.currentLayer<o.length;){const e=this.style._layers[o[this.currentLayer]],i=t._getLayerSourceCache(e);if(e.isSky()){++this.currentLayer;continue}if(this.terrain&&this.style.isLayerDraped(e)){if(e.isHidden(this.transform.zoom)){++this.currentLayer;continue}this.currentLayer=this.terrain.renderBatch(this.currentLayer);continue}const r=i?("symbol"===e.type?a:s)[i.id]:void 0;this._renderTileClippingMasks(e,i,i?n[i.id]:void 0),this.renderLayer(this,i,e,r),++this.currentLayer;}if(this.terrain&&this.terrain.postRender(),this.options.showTileBoundaries||this.options.showQueryGeometry||this.options.showTileAABBs){let i=null;e.values(this.style._layers).forEach((e=>{const o=t._getLayerSourceCache(e);o&&!e.isHidden(this.transform.zoom)&&(!i||i.getSource().maxzoom<o.getSource().maxzoom)&&(i=o);})),i&&this.options.showTileBoundaries&&Oo.debug(this,i,i.getVisibleCoordinates());}this.options.showPadding&&function(e){const t=e.transform.padding;Co(e,e.transform.height-(t.top||0),3,xo),Co(e,t.bottom||0,3,yo),Mo(e,t.left||0,3,bo),Mo(e,e.transform.width-(t.right||0),3,wo);const i=e.transform.centerPoint;!function(e,t,i,o){Io(e,t-1,i-10,2,20,o),Io(e,t-10,i-1,20,2,o);}(e,i.x,e.transform.height-i.y,To);}(this),this.context.setDefault(),this.frameCounter=(this.frameCounter+1)%Number.MAX_SAFE_INTEGER,this.tileLoaded&&this.options.speedIndexTiming&&(this.loadTimeStamps.push(e.window.performance.now()),this.saveCanvasCopy());}renderLayer(e,t,i,o){i.isHidden(this.transform.zoom)||("background"===i.type||"sky"===i.type||"custom"===i.type||o&&o.length)&&(this.id=i.id,this.gpuTimingStart(i),(!e.transform.projection.unsupportedLayers||!e.transform.projection.unsupportedLayers.includes(i.type)||e.terrain&&"custom"===i.type)&&Oo[i.type](e,t,i,o,this.style.placement.variableOffsets,this.options.isInitialLoad),this.gpuTimingEnd());}gpuTimingStart(e){if(!this.options.gpuTiming)return;const t=this.context.extTimerQuery;let i=this.gpuTimers[e.id];i||(i=this.gpuTimers[e.id]={calls:0,cpuTime:0,query:t.createQueryEXT()}),i.calls++,t.beginQueryEXT(t.TIME_ELAPSED_EXT,i.query);}gpuTimingDeferredRenderStart(){if(this.options.gpuTimingDeferredRender){const e=this.context.extTimerQuery,t=e.createQueryEXT();this.deferredRenderGpuTimeQueries.push(t),e.beginQueryEXT(e.TIME_ELAPSED_EXT,t);}}gpuTimingDeferredRenderEnd(){if(!this.options.gpuTimingDeferredRender)return;const e=this.context.extTimerQuery;e.endQueryEXT(e.TIME_ELAPSED_EXT);}gpuTimingEnd(){if(!this.options.gpuTiming)return;const e=this.context.extTimerQuery;e.endQueryEXT(e.TIME_ELAPSED_EXT);}collectGpuTimers(){const e=this.gpuTimers;return this.gpuTimers={},e}collectDeferredRenderGpuQueries(){const e=this.deferredRenderGpuTimeQueries;return this.deferredRenderGpuTimeQueries=[],e}queryGpuTimers(e){const t={};for(const i in e){const o=e[i],r=this.context.extTimerQuery,n=r.getQueryObjectEXT(o.query,r.QUERY_RESULT_EXT)/1e6;r.deleteQueryEXT(o.query),t[i]=n;}return t}queryGpuTimeDeferredRender(e){if(!this.options.gpuTimingDeferredRender)return 0;const t=this.context.extTimerQuery;let i=0;for(const o of e)i+=t.getQueryObjectEXT(o,t.QUERY_RESULT_EXT)/1e6,t.deleteQueryEXT(o);return i}translatePosMatrix(t,i,o,r,n){if(!o[0]&&!o[1])return t;const s=n?"map"===r?this.transform.angle:0:"viewport"===r?-this.transform.angle:0;if(s){const e=Math.sin(s),t=Math.cos(s);o=[o[0]*t-o[1]*e,o[0]*e+o[1]*t];}const a=[n?o[0]:D(i,o[0],this.transform.zoom),n?o[1]:D(i,o[1],this.transform.zoom),0],l=new Float32Array(16);return e.translate(l,t,a),l}saveTileTexture(e){const t=this._tileTextures[e.size[0]];t?t.push(e):this._tileTextures[e.size[0]]=[e];}getTileTexture(e){const t=this._tileTextures[e];return t&&t.length>0?t.pop():null}isPatternMissing(e){return null===e||void 0!==e&&!this.imageManager.getPattern(e.toString())}terrainRenderModeElevated(){return this.style&&!!this.style.getTerrain()&&!!this.terrain&&!this.terrain.renderingToTexture}currentGlobalDefines(){const e=this.terrain&&this.terrain.renderingToTexture,t=this.terrain&&0===this.terrain.exaggeration(),i=this.style&&this.style.fog,o=[];return this.terrainRenderModeElevated()&&o.push("TERRAIN"),"globe"===this.transform.projection.name&&o.push("GLOBE"),t&&o.push("ZERO_EXAGGERATION"),i&&!e&&0!==i.getOpacity(this.transform.pitch)&&o.push("FOG"),e&&o.push("RENDER_TO_TEXTURE"),this._showOverdrawInspector&&o.push("OVERDRAW_INSPECTOR"),o}useProgram(e,t,i){this.cache=this.cache||{};const o=i||[],r=this.currentGlobalDefines().concat(o),n=Li.cacheKey(ci[e],e,r,t);return this.cache[n]||(this.cache[n]=new Li(this.context,e,ci[e],t,so[e],r)),this.cache[n]}setCustomLayerDefaults(){this.context.unbindVAO(),this.context.cullFace.setDefault(),this.context.frontFace.setDefault(),this.context.cullFaceSide.setDefault(),this.context.activeTexture.setDefault(),this.context.pixelStoreUnpack.setDefault(),this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.context.pixelStoreUnpackFlipY.setDefault();}setBaseState(){const e=this.context.gl;this.context.cullFace.set(!1),this.context.viewport.set([0,0,this.width,this.height]),this.context.blendEquation.set(e.FUNC_ADD);}initDebugOverlayCanvas(){null==this.debugOverlayCanvas&&(this.debugOverlayCanvas=e.window.document.createElement("canvas"),this.debugOverlayCanvas.width=512,this.debugOverlayCanvas.height=512,this.debugOverlayTexture=new e.Texture(this.context,this.debugOverlayCanvas,this.context.gl.RGBA));}destroy(){this._terrain&&this._terrain.destroy(),this.globeSharedBuffers&&this.globeSharedBuffers.destroy(),this.emptyTexture.destroy(),this.debugOverlayTexture&&this.debugOverlayTexture.destroy(),this.atmosphereBuffer&&this.atmosphereBuffer.destroy();}prepareDrawTile(){this.terrain&&this.terrain.prepareDrawTile();}prepareDrawProgram(t,i,o){if(this.terrain&&this.terrain.renderingToTexture)return;const r=this.style.fog;if(r){const n=r.getOpacity(this.transform.pitch),s=((t,i,o,r,n,s,a,l,c,h,u)=>{const _=t.transform,d=i.properties.get("color").toArray01();d[3]=r;const p=t.frameCounter/1e3%1;return {u_fog_matrix:o?_.calculateFogTileMatrix(o):t.identityMat,u_fog_range:i.getFovAdjustedRange(_._fov),u_fog_color:d,u_fog_horizon_blend:i.properties.get("horizon-blend"),u_fog_temporal_offset:p,u_frustum_tl:n,u_frustum_tr:s,u_frustum_br:a,u_frustum_bl:l,u_globe_pos:c,u_globe_radius:h,u_viewport:u,u_globe_transition:e.globeToMercatorTransition(_.zoom),u_is_globe:+("globe"===_.projection.name)}})(this,r,o,n,this.transform.frustumCorners.TL,this.transform.frustumCorners.TR,this.transform.frustumCorners.BR,this.transform.frustumCorners.BL,this.transform.globeCenterInViewSpace,this.transform.globeRadius,[this.transform.width*e.exported.devicePixelRatio,this.transform.height*e.exported.devicePixelRatio]);i.setFogUniformValues(t,s);}}setTileLoadedFlag(e){this.tileLoaded=e;}saveCanvasCopy(){const e=this.canvasCopy();e&&(this.frameCopies.push(e),this.tileLoaded=!1);}canvasCopy(){const e=this.context.gl,t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.copyTexImage2D(e.TEXTURE_2D,0,e.RGBA,0,0,e.drawingBufferWidth,e.drawingBufferHeight,0),t}getCanvasCopiesAndTimestamps(){return {canvasCopies:this.frameCopies,timeStamps:this.loadTimeStamps}}averageElevationNeedsEasing(){if(!this.transform._elevation)return !1;const e=this.style&&this.style.fog;return !!e&&0!==e.getOpacity(this.transform.pitch)}getBackgroundTiles(){const t=this._backgroundTiles,i=this._backgroundTiles={},o=this.transform.coveringTiles({tileSize:512});for(const r of o)i[r.key]=t[r.key]||new e.Tile(r,512,this.transform.tileZoom,this);return i}clearBackgroundTiles(){this._backgroundTiles={};}}class ko{constructor(e=0,t=0,i=0,o=0){if(isNaN(e)||e<0||isNaN(t)||t<0||isNaN(i)||i<0||isNaN(o)||o<0)throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");this.top=e,this.bottom=t,this.left=i,this.right=o;}interpolate(t,i,o){return null!=i.top&&null!=t.top&&(this.top=e.number(t.top,i.top,o)),null!=i.bottom&&null!=t.bottom&&(this.bottom=e.number(t.bottom,i.bottom,o)),null!=i.left&&null!=t.left&&(this.left=e.number(t.left,i.left,o)),null!=i.right&&null!=t.right&&(this.right=e.number(t.right,i.right,o)),this}getCenter(t,i){const o=e.clamp((this.left+t-this.right)/2,0,t),r=e.clamp((this.top+i-this.bottom)/2,0,i);return new e.Point(o,r)}equals(e){return this.top===e.top&&this.bottom===e.bottom&&this.left===e.left&&this.right===e.right}clone(){return new ko(this.top,this.bottom,this.left,this.right)}toJSON(){return {top:this.top,bottom:this.bottom,left:this.left,right:this.right}}}function Fo(t,i){const o=e.getColumn(t,3);e.fromQuat(t,i),e.setColumn(t,3,o);}function Uo(t,i){const o=e.identity$1([]);return e.rotateZ$1(o,o,-i),e.rotateX$1(o,o,-t),o}function No(t,i){const o=[t[0],t[1],0],r=[i[0],i[1],0];if(e.length(o)>=1e-15){const t=e.normalize([],o);e.scale$2(r,t,e.dot(r,t)),i[0]=r[0],i[1]=r[1];}const n=e.cross([],i,t);if(e.len(n)<1e-15)return null;const s=Math.atan2(-n[1],n[0]);return Uo(Math.atan2(Math.sqrt(t[0]*t[0]+t[1]*t[1]),-t[2]),s)}class jo{constructor(e,t){this.position=e,this.orientation=t;}get position(){return this._position}set position(t){if(t){const i=t instanceof e.MercatorCoordinate?t:new e.MercatorCoordinate(t[0],t[1],t[2]);this._renderWorldCopies&&(i.x=e.wrap(i.x,0,1)),this._position=i;}else this._position=null;}lookAtPoint(t,i){if(this.orientation=null,!this.position)return;const o=this.position,r=this._elevation?this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)):0,n=e.MercatorCoordinate.fromLngLat(t,r),s=[n.x-o.x,n.y-o.y,n.z-o.z];i||(i=[0,0,1]),i[2]=Math.abs(i[2]),this.orientation=No(s,i);}setPitchBearing(t,i){this.orientation=Uo(e.degToRad(t),e.degToRad(-i));}}class Go{constructor(t,i){this._transform=e.identity([]),this.orientation=i,this.position=t;}get mercatorPosition(){const t=this.position;return new e.MercatorCoordinate(t[0],t[1],t[2])}get position(){const t=e.getColumn(this._transform,3);return [t[0],t[1],t[2]]}set position(t){var i;t&&e.setColumn(this._transform,3,[(i=t)[0],i[1],i[2],1]);}get orientation(){return this._orientation}set orientation(t){this._orientation=t||e.identity$1([]),t&&Fo(this._transform,this._orientation);}getPitchBearing(){const e=this.forward(),t=this.right();return {bearing:Math.atan2(-t[1],t[0]),pitch:Math.atan2(Math.sqrt(e[0]*e[0]+e[1]*e[1]),-e[2])}}setPitchBearing(e,t){this._orientation=Uo(e,t),Fo(this._transform,this._orientation);}forward(){const t=e.getColumn(this._transform,2);return [-t[0],-t[1],-t[2]]}up(){const t=e.getColumn(this._transform,1);return [-t[0],-t[1],-t[2]]}right(){const t=e.getColumn(this._transform,0);return [t[0],t[1],t[2]]}getCameraToWorld(t,i){const o=new Float64Array(16);return e.invert(o,this.getWorldToCamera(t,i)),o}getWorldToCameraPosition(t,i,o){const r=this.position;e.scale$2(r,r,-t);const n=new Float64Array(16);return e.fromScaling(n,[o,o,o]),e.translate(n,n,r),n[10]*=i,n}getWorldToCamera(t,i){const o=new Float64Array(16),r=new Float64Array(4),n=this.position;return e.conjugate(r,this._orientation),e.scale$2(n,n,-t),e.fromQuat(o,r),e.translate(o,o,n),o[1]*=-1,o[5]*=-1,o[9]*=-1,o[13]*=-1,o[8]*=i,o[9]*=i,o[10]*=i,o[11]*=i,o}getCameraToClipPerspective(t,i,o,r){const n=new Float64Array(16);return e.perspective(n,t,i,o,r),n}getDistanceToElevation(t,i=!1){const o=0===t?0:e.mercatorZfromAltitude(t,i?e.latFromMercatorY(this.position[1]):this.position[1]),r=this.forward();return (o-this.position[2])/r[2]}clone(){return new Go([...this.position],[...this.orientation])}}function Zo(t,i){const o=Wo(t.projection,t.zoom,t.width,t.height),r=function(t,i,o,r,n){const s=new e.LngLat(o.lng-180*Xo,o.lat),a=new e.LngLat(o.lng+180*Xo,o.lat),l=t.project(s.lng,s.lat),c=t.project(a.lng,a.lat),h=-Math.atan2(c.y-l.y,c.x-l.x),u=e.MercatorCoordinate.fromLngLat(o);u.y=e.clamp(u.y,-1+Xo,1-Xo);const _=u.toLngLat(),d=t.project(_.lng,_.lat),p=e.MercatorCoordinate.fromLngLat(_);p.x+=Xo;const m=p.toLngLat(),f=t.project(m.lng,m.lat),g=$o(f.x-d.x,f.y-d.y,h),v=e.MercatorCoordinate.fromLngLat(_);v.y+=Xo;const x=v.toLngLat(),y=t.project(x.lng,x.lat),b=$o(y.x-d.x,y.y-d.y,h),w=Math.abs(g.x)/Math.abs(b.y),T=e.identity([]);e.rotateZ(T,T,-h*(1-(n?0:r)));const E=e.identity([]);return e.scale(E,E,[1,1-(1-w)*r,1]),E[4]=-b.x/b.y*r,e.rotateZ(E,E,h),e.multiply(E,T,E),E}(t.projection,0,t.center,o,i),n=Vo(t);return e.scale(r,r,[n,n,1]),r}function Vo(t){const i=t.projection,o=Wo(t.projection,t.zoom,t.width,t.height),r=qo(i,t.center),n=qo(i,e.LngLat.convert(i.center));return Math.pow(2,r*o+(1-o)*n)}function Wo(t,i,o,r,n=1/0){const s=t.range;if(!s)return 0;const a=Math.min(n,Math.max(o,r)),l=Math.log(a/1024)/Math.LN2;return e.smoothstep(s[0]+l,s[1]+l,i)}const Xo=1/4e4;function qo(t,i){const o=e.clamp(i.lat,-e.MAX_MERCATOR_LATITUDE,e.MAX_MERCATOR_LATITUDE),r=new e.LngLat(i.lng-180*Xo,o),n=new e.LngLat(i.lng+180*Xo,o),s=t.project(r.lng,o),a=t.project(n.lng,o),l=e.MercatorCoordinate.fromLngLat(r),c=e.MercatorCoordinate.fromLngLat(n),h=a.x-s.x,u=a.y-s.y,_=c.x-l.x,d=c.y-l.y,p=Math.sqrt((_*_+d*d)/(h*h+u*u));return Math.log(p)/Math.LN2}function $o(e,t,i){const o=Math.cos(i),r=Math.sin(i);return {x:e*o-t*r,y:e*r+t*o}}class Ho{constructor(t,i,o,r,n,s,a){this.tileSize=512,this._renderWorldCopies=void 0===n||n,this._minZoom=t||0,this._maxZoom=i||22,this._minPitch=null==o?0:o,this._maxPitch=null==r?60:r,this.setProjection(s),this.setMaxBounds(a),this.width=0,this.height=0,this._center=new e.LngLat(0,0),this.zoom=0,this.angle=0,this._fov=.6435011087932844,this._pitch=0,this._nearZ=0,this._farZ=0,this._unmodified=!0,this._edgeInsets=new ko,this._projMatrixCache={},this._alignedProjMatrixCache={},this._fogTileMatrixCache={},this._distanceTileDataCache={},this._camera=new Go,this._centerAltitude=0,this._averageElevation=0,this.cameraElevationReference="ground",this._pixelsPerMercatorPixel=1,this.globeRadius=0,this.globeCenterInViewSpace=[0,0,0],this._horizonShift=.1;}clone(){const e=new Ho(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies,this.getProjection());return e._elevation=this._elevation,e._centerAltitude=this._centerAltitude,e._centerAltitudeValidForExaggeration=this._centerAltitudeValidForExaggeration,e.tileSize=this.tileSize,e.mercatorFromTransition=this.mercatorFromTransition,e.width=this.width,e.height=this.height,e.cameraElevationReference=this.cameraElevationReference,e._center=this._center,e._setZoom(this.zoom),e._seaLevelZoom=this._seaLevelZoom,e.angle=this.angle,e._fov=this._fov,e._pitch=this._pitch,e._nearZ=this._nearZ,e._farZ=this._farZ,e._averageElevation=this._averageElevation,e._unmodified=this._unmodified,e._edgeInsets=this._edgeInsets.clone(),e._camera=this._camera.clone(),e._calcMatrices(),e.freezeTileCoverage=this.freezeTileCoverage,e.frustumCorners=this.frustumCorners,e}get elevation(){return this._elevation}set elevation(e){this._elevation!==e&&(this._elevation=e,this._updateCameraOnTerrain(),this._calcMatrices());}updateElevation(e,t=!1){const i=this._elevation&&this._elevation.exaggeration()!==this._centerAltitudeValidForExaggeration;(null==this._seaLevelZoom||i)&&this._updateCameraOnTerrain(),(e||i)&&this._constrainCamera(t),this._calcMatrices();}getProjection(){return e.pick(this.projection,["name","center","parallels"])}setProjection(i){this.projectionOptions=i||{name:"mercator"};const o=this.projection?this.getProjection():void 0;this.projection=e.getProjection(this.projectionOptions);const r=!t(o,this.getProjection());return r&&this._calcMatrices(),this.mercatorFromTransition=!1,r}setMercatorFromTransition(){const t=this.projection.name;this.mercatorFromTransition=!0,this.projectionOptions={name:"mercator"},this.projection=e.getProjection({name:"mercator"});const i=t!==this.projection.name;return i&&this._calcMatrices(),i}get minZoom(){return this._minZoom}set minZoom(e){this._minZoom!==e&&(this._minZoom=e,this.zoom=Math.max(this.zoom,e));}get maxZoom(){return this._maxZoom}set maxZoom(e){this._maxZoom!==e&&(this._maxZoom=e,this.zoom=Math.min(this.zoom,e));}get minPitch(){return this._minPitch}set minPitch(e){this._minPitch!==e&&(this._minPitch=e,this.pitch=Math.max(this.pitch,e));}get maxPitch(){return this._maxPitch}set maxPitch(e){this._maxPitch!==e&&(this._maxPitch=e,this.pitch=Math.min(this.pitch,e));}get renderWorldCopies(){return this._renderWorldCopies&&!0===this.projection.supportsWorldCopies}set renderWorldCopies(e){void 0===e?e=!0:null===e&&(e=!1),this._renderWorldCopies=e;}get worldSize(){return this.tileSize*this.scale}get cameraWorldSizeForFog(){const e=Math.max(this._camera.getDistanceToElevation(this._averageElevation),Number.EPSILON);return this._worldSizeFromZoom(this._zoomFromMercatorZ(e))}get cameraWorldSize(){const e=Math.max(this._camera.getDistanceToElevation(this._averageElevation,!0),Number.EPSILON);return this._worldSizeFromZoom(this._zoomFromMercatorZ(e))}get pixelsPerMeter(){return this.projection.pixelsPerMeter(this.center.lat,this.worldSize)}get cameraPixelsPerMeter(){return e.mercatorZfromAltitude(this.center.lat,this.cameraWorldSizeForFog)}get centerOffset(){return this.centerPoint._sub(this.size._div(2))}get size(){return new e.Point(this.width,this.height)}get bearing(){return e.wrap(this.rotation,-180,180)}set bearing(e){this.rotation=e;}get rotation(){return -this.angle/Math.PI*180}set rotation(t){const i=-t*Math.PI/180;var o;this.angle!==i&&(this._unmodified=!1,this.angle=i,this._calcMatrices(),this.rotationMatrix=(o=new e.ARRAY_TYPE(4),e.ARRAY_TYPE!=Float32Array&&(o[1]=0,o[2]=0),o[0]=1,o[3]=1,o),function(e,t,i){var o=t[0],r=t[1],n=t[2],s=t[3],a=Math.sin(i),l=Math.cos(i);e[0]=o*l+n*a,e[1]=r*l+s*a,e[2]=o*-a+n*l,e[3]=r*-a+s*l;}(this.rotationMatrix,this.rotationMatrix,this.angle));}get pitch(){return this._pitch/Math.PI*180}set pitch(t){const i=e.clamp(t,this.minPitch,this.maxPitch)/180*Math.PI;this._pitch!==i&&(this._unmodified=!1,this._pitch=i,this._calcMatrices());}get aspect(){return this.width/this.height}get fov(){return this._fov/Math.PI*180}get fovX(){return this._fov}get fovY(){const e=1/Math.tan(.5*this.fovX);return 2*Math.atan(1/this.aspect/e)}set fov(t){t=Math.max(.01,Math.min(60,t)),this._fov!==t&&(this._unmodified=!1,this._fov=e.degToRad(t),this._calcMatrices());}get averageElevation(){return this._averageElevation}set averageElevation(e){this._averageElevation=e,this._calcFogMatrices(),this._distanceTileDataCache={};}get zoom(){return this._zoom}set zoom(e){const t=Math.min(Math.max(e,this.minZoom),this.maxZoom);this._zoom!==t&&(this._unmodified=!1,this._setZoom(t),this._updateSeaLevelZoom(),this._constrain(),this._calcMatrices());}_setZoom(e){this._zoom=e,this.scale=this.zoomScale(e),this.tileZoom=Math.floor(e),this.zoomFraction=e-this.tileZoom;}_updateCameraOnTerrain(){if(!this._elevation||!this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))return this._centerAltitude=0,this._seaLevelZoom=null,void(this._centerAltitudeValidForExaggeration=void 0);const e=this._elevation;this._centerAltitude=e.getAtPointOrZero(this.locationCoordinate(this.center)),this._centerAltitudeValidForExaggeration=e.exaggeration(),this._updateSeaLevelZoom();}_updateSeaLevelZoom(){void 0!==this._centerAltitudeValidForExaggeration&&(this._seaLevelZoom=this._zoomFromMercatorZ((this.pixelsPerMeter*this._centerAltitude+this.cameraToCenterDistance)/this.worldSize));}sampleAverageElevation(){if(!this._elevation)return 0;const t=this._elevation,i=[[.5,.2],[.3,.5],[.5,.5],[.7,.5],[.5,.8]],o=this.horizonLineFromTop();let r=0,n=0;for(let s=0;s<i.length;s++){const a=new e.Point(i[s][0]*this.width,o+i[s][1]*(this.height-o)),l=t.pointCoordinate(a);if(!l)continue;const c=1/Math.hypot(l[0]-this._camera.position[0],l[1]-this._camera.position[1]);r+=l[3]*c,n+=c;}return 0===n?NaN:r/n}get center(){return this._center}set center(e){e.lat===this._center.lat&&e.lng===this._center.lng||(this._unmodified=!1,this._center=e,this._terrainEnabled()&&("ground"===this.cameraElevationReference?this._updateCameraOnTerrain():this._updateZoomFromElevation()),this._constrain(),this._calcMatrices());}_updateZoomFromElevation(){if(null==this._seaLevelZoom||!this._elevation)return;const e=this._seaLevelZoom,t=this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),i=this.pixelsPerMeter/this.worldSize*t,o=this._mercatorZfromZoom(e),r=this._mercatorZfromZoom(this._maxZoom),n=Math.max(o-i,r);this._setZoom(this._zoomFromMercatorZ(n));}get padding(){return this._edgeInsets.toJSON()}set padding(e){this._edgeInsets.equals(e)||(this._unmodified=!1,this._edgeInsets.interpolate(this._edgeInsets,e,1),this._calcMatrices());}computeZoomRelativeTo(t){const i=this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint,t.toAltitude()));let o;o=t.z<this._camera.position[2]?[i.x,i.y,i.z]:[t.x,t.y,t.z];const r=e.length(e.sub([],this._camera.position,o));return e.clamp(this._zoomFromMercatorZ(r),this._minZoom,this._maxZoom)}setFreeCameraOptions(t){if(!this.height)return;if(!t.position&&!t.orientation)return;this._updateCameraState();let i=!1;if(t.orientation&&!e.exactEquals(t.orientation,this._camera.orientation)&&(i=this._setCameraOrientation(t.orientation)),t.position){const o=[t.position.x,t.position.y,t.position.z];e.exactEquals$1(o,this._camera.position)||(this._setCameraPosition(o),i=!0);}i&&(this._updateStateFromCamera(),this.recenterOnTerrain());}getFreeCameraOptions(){this._updateCameraState();const t=this._camera.position,i=new jo;return i.position=new e.MercatorCoordinate(t[0],t[1],t[2]),i.orientation=this._camera.orientation,i._elevation=this.elevation,i._renderWorldCopies=this.renderWorldCopies,i}_setCameraOrientation(t){if(!e.length$1(t))return !1;e.normalize$1(t,t);const i=e.transformQuat([],[0,0,-1],t),o=e.transformQuat([],[0,-1,0],t);if(o[2]<0)return !1;const r=No(i,o);return !!r&&(this._camera.orientation=r,!0)}_setCameraPosition(t){const i=this.zoomScale(this.minZoom)*this.tileSize,o=this.zoomScale(this.maxZoom)*this.tileSize,r=this.cameraToCenterDistance;t[2]=e.clamp(t[2],r/o,r/i),this._camera.position=t;}get centerPoint(){return this._edgeInsets.getCenter(this.width,this.height)}get fovAboveCenter(){return this._fov*(.5+this.centerOffset.y/this.height)}isPaddingEqual(e){return this._edgeInsets.equals(e)}interpolatePadding(e,t,i){this._unmodified=!1,this._edgeInsets.interpolate(e,t,i),this._constrain(),this._calcMatrices();}coveringZoomLevel(e){const t=(e.roundZoom?Math.round:Math.floor)(this.zoom+this.scaleZoom(this.tileSize/e.tileSize));return Math.max(0,t)}getVisibleUnwrappedCoordinates(t){const i=[new e.UnwrappedTileID(0,t)];if(this.renderWorldCopies){const o=this.pointCoordinate(new e.Point(0,0)),r=this.pointCoordinate(new e.Point(this.width,0)),n=this.pointCoordinate(new e.Point(this.width,this.height)),s=this.pointCoordinate(new e.Point(0,this.height)),a=Math.floor(Math.min(o.x,r.x,n.x,s.x)),l=Math.floor(Math.max(o.x,r.x,n.x,s.x)),c=1;for(let o=a-c;o<=l+c;o++)0!==o&&i.push(new e.UnwrappedTileID(o,t));}return i}coveringTiles(t){let i=this.coveringZoomLevel(t);const o=i,r=this.elevation&&!t.isTerrainDEM,n="mercator"===this.projection.name;if(void 0!==t.minzoom&&i<t.minzoom)return [];void 0!==t.maxzoom&&i>t.maxzoom&&(i=t.maxzoom);const s=this.locationCoordinate(this.center),a=this.center.lat,l=1<<i,c=[l*s.x,l*s.y,0],h="globe"===this.projection.name,u=!h,_=e.Frustum.fromInvProjectionMatrix(this.invProjMatrix,this.worldSize,i,u),d=h?this._camera.mercatorPosition:this.pointCoordinate(this.getCameraPoint()),p=l*e.mercatorZfromAltitude(1,this.center.lat),m=this._camera.position[2]/e.mercatorZfromAltitude(1,this.center.lat),f=[l*d.x,l*d.y,m*(u?1:p)],g=this.cameraToCenterDistance/t.tileSize*(t.roundZoom?1:.502),v=this.pitch<=60&&this._edgeInsets.top<=this._edgeInsets.bottom&&!this._elevation&&!this.projection.isReprojectedInTileSpace?i:0,x=t.isTerrainDEM&&this._elevation?1e4*this._elevation.exaggeration():this._centerAltitude,y=t.isTerrainDEM?-x:this._elevation?this._elevation.getMinElevationBelowMSL():0,b=this.projection.isReprojectedInTileSpace?Vo(this):1,w=t=>{const i=1/4e4,o=new e.MercatorCoordinate(t.x+i,t.y,t.z),r=new e.MercatorCoordinate(t.x,t.y+i,t.z),n=t.toLngLat(),s=o.toLngLat(),a=r.toLngLat(),l=this.locationCoordinate(n),c=this.locationCoordinate(s),h=this.locationCoordinate(a),u=Math.hypot(c.x-l.x,c.y-l.y),_=Math.hypot(h.x-l.x,h.y-l.y);return Math.sqrt(u*_)*b/i},T=t=>{const i=x,o=y;return {aabb:e.tileAABB(this,l,0,0,0,t,o,i,this.projection),zoom:0,x:0,y:0,minZ:o,maxZ:i,wrap:t,fullyVisible:!1}},E=[];let C=[];const M=i,I=t.reparseOverscaled?o:i,P=e=>e*e,S=P((m-this._centerAltitude)*p),D=e=>{if(!this._elevation||!e.tileID||!n)return;const t=this._elevation.getMinMaxForTile(e.tileID),i=e.aabb;t?(i.min[2]=t.min,i.max[2]=t.max,i.center[2]=(i.min[2]+i.max[2])/2):(e.shouldSplit=L(e),e.shouldSplit||(i.min[2]=i.max[2]=i.center[2]=this._centerAltitude));},L=t=>{if(t.zoom<v)return !0;if(t.zoom===M)return !1;if(null!=t.shouldSplit)return t.shouldSplit;const i=t.aabb.distanceX(f),n=t.aabb.distanceY(f);let s=S,l=1;if(h){s=P(t.aabb.distanceZ(f));const i=Math.pow(2,t.zoom),o=e.latFromMercatorY((t.y+1)/i),r=e.latFromMercatorY(t.y/i),n=Math.min(Math.max(a,o),r),c=e.circumferenceAtLatitude(n)/e.circumferenceAtLatitude(a);if(l=n===a?1/Math.max(1,this._mercatorScaleRatio-.3):Math.min(1,c/this._mercatorScaleRatio),this.zoom<=e.GLOBE_ZOOM_THRESHOLD_MIN&&t.zoom===M-1&&c>=.9)return !0}else if(r&&(s=P(t.aabb.distanceZ(f)*p)),this.projection.isReprojectedInTileSpace&&o<=5){const i=Math.pow(2,t.zoom),o=w(new e.MercatorCoordinate((t.x+.5)/i,(t.y+.5)/i));l=o>.85?1:o;}const c=i*i+n*n+s,u=P((1<<M-t.zoom)*g*l*((e,t)=>{if(t*P(.707)<e)return 1;const i=Math.sqrt(t/e);return i/(1.4144271570014144+(Math.pow(1.1,i-1.4144271570014144+1)-1)/(1.1-1)-1)})(Math.max(s,S),c));return c<u};if(this.renderWorldCopies)for(let e=1;e<=3;e++)E.push(T(-e)),E.push(T(e));for(E.push(T(0));E.length>0;){const o=E.pop(),s=o.x,a=o.y;let u=o.fullyVisible;if(!u){const e=o.aabb.intersects(_);if(0===e)continue;u=2===e;}if(o.zoom!==M&&L(o))for(let t=0;t<4;t++){const i=(s<<1)+t%2,c=(a<<1)+(t>>1),_={aabb:n?o.aabb.quadrant(t):e.tileAABB(this,l,o.zoom+1,i,c,o.wrap,o.minZ,o.maxZ,this.projection),zoom:o.zoom+1,x:i,y:c,wrap:o.wrap,fullyVisible:u,tileID:void 0,shouldSplit:void 0,minZ:o.minZ,maxZ:o.maxZ};r&&!h&&(_.tileID=new e.OverscaledTileID(o.zoom+1===M?I:o.zoom+1,o.wrap,o.zoom+1,i,c),D(_)),E.push(_);}else {const r=o.zoom===M?I:o.zoom;if(t.minzoom&&t.minzoom>r)continue;const n=c[0]-(.5+s+(o.wrap<<o.zoom))*(1<<i-o.zoom),l=c[1]-.5-a,h=o.tileID?o.tileID:new e.OverscaledTileID(r,o.wrap,o.zoom,s,a);C.push({tileID:h,distanceSq:n*n+l*l});}}if(this.fogCullDistSq){const i=this.fogCullDistSq,o=this.horizonLineFromTop();C=C.filter((r=>{const n=[0,0,0,1],s=[e.EXTENT,e.EXTENT,0,1],a=this.calculateFogTileMatrix(r.tileID.toUnwrapped());e.transformMat4$1(n,n,a),e.transformMat4$1(s,s,a);const l=e.getAABBPointSquareDist(n,s);if(0===l)return !0;let c=!1;const h=this._elevation;if(h&&l>i&&0!==o){const i=this.calculateProjMatrix(r.tileID.toUnwrapped());let n;t.isTerrainDEM||(n=h.getMinMaxForTile(r.tileID)),n||(n={min:y,max:x});const s=e.furthestTileCorner(this.rotation),a=[s[0]*e.EXTENT,s[1]*e.EXTENT,n.max];e.transformMat4(a,a,i),c=(1-a[1])*this.height*.5<o;}return l<i||c}));}return C.sort(((e,t)=>e.distanceSq-t.distanceSq)).map((e=>e.tileID))}resize(e,t){this.width=e,this.height=t,this.pixelsToGLUnits=[2/e,-2/t],this._constrain(),this._calcMatrices();}get unmodified(){return this._unmodified}zoomScale(e){return Math.pow(2,e)}scaleZoom(e){return Math.log(e)/Math.LN2}project(t){const i=e.clamp(t.lat,-e.MAX_MERCATOR_LATITUDE,e.MAX_MERCATOR_LATITUDE),o=this.projection.project(t.lng,i);return new e.Point(o.x*this.worldSize,o.y*this.worldSize)}unproject(e){return this.projection.unproject(e.x/this.worldSize,e.y/this.worldSize)}get point(){return this.project(this.center)}get pointMerc(){return this.point._div(this.worldSize)}get pixelsPerMeterRatio(){return this.pixelsPerMeter/e.mercatorZfromAltitude(1,this.center.lat)/this.worldSize}setLocationAtPoint(t,i){let o,r;const n=this.centerPoint;if("globe"===this.projection.name){const e=this.worldSize;o=(i.x-n.x)/e,r=(i.y-n.y)/e;}else {const e=this.pointCoordinate(i),t=this.pointCoordinate(n);o=e.x-t.x,r=e.y-t.y;}const s=this.locationCoordinate(t);this.setLocation(new e.MercatorCoordinate(s.x-o,s.y-r));}setLocation(e){this.center=this.coordinateLocation(e),this.projection.wrap&&(this.center=this.center.wrap());}locationPoint(e){return this.projection.locationPoint(this,e)}locationPoint3D(e){return this.projection.locationPoint(this,e,!0)}pointLocation(e){return this.coordinateLocation(this.pointCoordinate(e))}pointLocation3D(e){return this.coordinateLocation(this.pointCoordinate3D(e))}locationCoordinate(t,i){const o=i?e.mercatorZfromAltitude(i,t.lat):void 0,r=this.projection.project(t.lng,t.lat);return new e.MercatorCoordinate(r.x,r.y,o)}coordinateLocation(e){return this.projection.unproject(e.x,e.y)}pointRayIntersection(t,i){const o=null!=i?i:this._centerAltitude,r=[t.x,t.y,0,1],n=[t.x,t.y,1,1];e.transformMat4$1(r,r,this.pixelMatrixInverse),e.transformMat4$1(n,n,this.pixelMatrixInverse);const s=n[3];e.scale$1(r,r,1/r[3]),e.scale$1(n,n,1/s);const a=r[2],l=n[2];return {p0:r,p1:n,t:a===l?0:(o-a)/(l-a)}}screenPointToMercatorRay(t){const i=[t.x,t.y,0,1],o=[t.x,t.y,1,1];return e.transformMat4$1(i,i,this.pixelMatrixInverse),e.transformMat4$1(o,o,this.pixelMatrixInverse),e.scale$1(i,i,1/i[3]),e.scale$1(o,o,1/o[3]),i[2]=e.mercatorZfromAltitude(i[2],this._center.lat)*this.worldSize,o[2]=e.mercatorZfromAltitude(o[2],this._center.lat)*this.worldSize,e.scale$1(i,i,1/this.worldSize),e.scale$1(o,o,1/this.worldSize),new e.Ray([i[0],i[1],i[2]],e.normalize([],e.sub([],o,i)))}rayIntersectionCoordinate(t){const{p0:i,p1:o,t:r}=t,n=e.mercatorZfromAltitude(i[2],this._center.lat),s=e.mercatorZfromAltitude(o[2],this._center.lat);return new e.MercatorCoordinate(e.number(i[0],o[0],r)/this.worldSize,e.number(i[1],o[1],r)/this.worldSize,e.number(n,s,r))}pointCoordinate(e,t=this._centerAltitude){return this.projection.pointCoordinate(this,e.x,e.y,t)}pointCoordinate3D(t){if(!this.elevation)return this.pointCoordinate(t);let i=this.projection.pointCoordinate3D(this,t.x,t.y);if(i)return new e.MercatorCoordinate(i[0],i[1],i[2]);let o=0,r=this.horizonLineFromTop();if(t.y>r)return this.pointCoordinate(t);const n=.02*r,s=t.clone();for(let t=0;t<10&&r-o>n;t++){s.y=e.number(o,r,.66);const t=this.projection.pointCoordinate3D(this,s.x,s.y);t?(r=s.y,i=t):o=s.y;}return i?new e.MercatorCoordinate(i[0],i[1],i[2]):this.pointCoordinate(t)}isPointAboveHorizon(e){return this.projection.isPointAboveHorizon(this,e)}isPointOnSurface(t){if(t.y<0||t.y>this.height||t.x<0||t.x>this.width)return !1;if(this.elevation||this.zoom>=e.GLOBE_ZOOM_THRESHOLD_MAX)return !this.isPointAboveHorizon(t);const i=this.pointCoordinate(t);return i.y>=0&&i.y<=1}_coordinatePoint(t,i){const o=i&&this.elevation?this.elevation.getAtPointOrZero(t,this._centerAltitude):this._centerAltitude,r=[t.x*this.worldSize,t.y*this.worldSize,o+t.toAltitude(),1];return e.transformMat4$1(r,r,this.pixelMatrix),r[3]>0?new e.Point(r[0]/r[3],r[1]/r[3]):new e.Point(Number.MAX_VALUE,Number.MAX_VALUE)}_getBoundsNonRectangular(){const{top:t,left:i}=this._edgeInsets,o=this.height-this._edgeInsets.bottom,r=this.width-this._edgeInsets.right,n=this.pointLocation3D(new e.Point(i,t)),s=this.pointLocation3D(new e.Point(r,t)),a=this.pointLocation3D(new e.Point(r,o)),l=this.pointLocation3D(new e.Point(i,o));let c=Math.min(n.lng,s.lng,a.lng,l.lng),h=Math.max(n.lng,s.lng,a.lng,l.lng),u=Math.min(n.lat,s.lat,a.lat,l.lat),_=Math.max(n.lat,s.lat,a.lat,l.lat);const d=Math.pow(2,-this.zoom)/16*270,p="globe"===this.projection.name?1:4,m=(t,i,o,r,n)=>{const s=(t+o)/2,a=(i+r)/2,l=new e.Point(s,a),{lng:f,lat:g}=this.pointLocation3D(l),v=Math.max(0,c-f,u-g,f-h,g-_);c=Math.min(c,f),h=Math.max(h,f),u=Math.min(u,g),_=Math.max(_,g),(n<p||v>d)&&(m(t,i,s,a,n+1),m(s,a,o,r,n+1));};if(m(i,t,r,t,1),m(r,t,r,o,1),m(r,o,i,o,1),m(i,o,i,t,1),"globe"===this.projection.name){const[t,i]=e.polesInViewport(this);t?(_=90,h=180,c=-180):i&&(u=-90,h=180,c=-180);}return new e.LngLatBounds(new e.LngLat(c,u),new e.LngLat(h,_))}_getBoundsRectangular(t,i){const{top:o,left:r}=this._edgeInsets,n=this.height-this._edgeInsets.bottom,s=this.width-this._edgeInsets.right,a=new e.Point(r,o),l=new e.Point(s,o),c=new e.Point(s,n),h=new e.Point(r,n);let u=this.pointCoordinate(a,t),_=this.pointCoordinate(l,t);const d=this.pointCoordinate(c,i),p=this.pointCoordinate(h,i),m=(e,t)=>(t.y-e.y)/(t.x-e.x);return u.y>1&&_.y>=0?u=new e.MercatorCoordinate((1-p.y)/m(p,u)+p.x,1):u.y<0&&_.y<=1&&(u=new e.MercatorCoordinate(-p.y/m(p,u)+p.x,0)),_.y>1&&u.y>=0?_=new e.MercatorCoordinate((1-d.y)/m(d,_)+d.x,1):_.y<0&&u.y<=1&&(_=new e.MercatorCoordinate(-d.y/m(d,_)+d.x,0)),(new e.LngLatBounds).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(_)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(d))}_getBoundsRectangularTerrain(){const e=this.elevation;if(!e.visibleDemTiles.length||e.isUsingMockSource())return this._getBoundsRectangular(0,0);const t=e.visibleDemTiles.reduce(((e,t)=>{if(t.dem){const i=t.dem.tree;e.min=Math.min(e.min,i.minimums[0]),e.max=Math.max(e.max,i.maximums[0]);}return e}),{min:Number.MAX_VALUE,max:0});return this._getBoundsRectangular(t.min*e.exaggeration(),t.max*e.exaggeration())}getBounds(){return "mercator"===this.projection.name||"equirectangular"===this.projection.name?this._terrainEnabled()?this._getBoundsRectangularTerrain():this._getBoundsRectangular(0,0):this._getBoundsNonRectangular()}horizonLineFromTop(e=!0){const t=this.height/2/Math.tan(this._fov/2)/Math.tan(Math.max(this._pitch,.1))+this.centerOffset.y,i=this.height/2-t*(1-this._horizonShift);return e?Math.max(0,i):i}getMaxBounds(){return this.maxBounds}setMaxBounds(t){this.maxBounds=t,this.minLat=-e.MAX_MERCATOR_LATITUDE,this.maxLat=e.MAX_MERCATOR_LATITUDE,this.minLng=-180,this.maxLng=180,t&&(this.minLat=t.getSouth(),this.maxLat=t.getNorth(),this.minLng=t.getWest(),this.maxLng=t.getEast(),this.maxLng<this.minLng&&(this.maxLng+=360)),this.worldMinX=e.mercatorXfromLng(this.minLng)*this.tileSize,this.worldMaxX=e.mercatorXfromLng(this.maxLng)*this.tileSize,this.worldMinY=e.mercatorYfromLat(this.maxLat)*this.tileSize,this.worldMaxY=e.mercatorYfromLat(this.minLat)*this.tileSize,this._constrain();}calculatePosMatrix(e,t){return this.projection.createTileMatrix(this,t,e)}calculateDistanceTileData(t){const i=t.key,o=this._distanceTileDataCache;if(o[i])return o[i];const r=t.canonical,n=1/this.height,s=this.cameraWorldSize,a=s/this.zoomScale(r.z),l=(r.x+Math.pow(2,r.z)*t.wrap)*a,c=r.y*a,h=this.point;h.x*=s/this.worldSize,h.y*=s/this.worldSize;const u=this.angle,_=Math.sin(-u),d=-Math.cos(-u);return o[i]={bearing:[_,d],center:[(h.x-l)*n,(h.y-c)*n],scale:a/e.EXTENT*n},o[i]}calculateFogTileMatrix(t){const i=t.key,o=this._fogTileMatrixCache;if(o[i])return o[i];const r=this.projection.createTileMatrix(this,this.cameraWorldSizeForFog,t);return e.multiply(r,this.worldToFogMatrix,r),o[i]=new Float32Array(r),o[i]}calculateProjMatrix(t,i=!1){const o=t.key,r=i?this._alignedProjMatrixCache:this._projMatrixCache;if(r[o])return r[o];const n=this.calculatePosMatrix(t,this.worldSize);return e.multiply(n,this.projection.isReprojectedInTileSpace?this.mercatorMatrix:i?this.alignedProjMatrix:this.projMatrix,n),r[o]=new Float32Array(n),r[o]}calculatePixelsToTileUnitsMatrix(t){const i=t.tileID.key,o=this._pixelsToTileUnitsCache;if(o[i])return o[i];const r=function(t,i){const{scale:o}=t.tileTransform,r=o*e.EXTENT/(t.tileSize*Math.pow(2,i.zoom-t.tileID.overscaledZ+t.tileID.canonical.z));return n=new Float32Array(4),l=(s=i.inverseAdjustmentMatrix)[1],c=s[2],h=s[3],_=(a=[r,r])[1],n[0]=s[0]*(u=a[0]),n[1]=l*u,n[2]=c*_,n[3]=h*_,n;var n,s,a,l,c,h,u,_;}(t,this);return o[i]=r,o[i]}customLayerMatrix(){return this.mercatorMatrix.slice()}globeToMercatorMatrix(){if("globe"===this.projection.name){const t=1/this.worldSize,i=e.fromScaling([],[t,t,t]);return e.multiply(i,i,this.globeMatrix),i}}recenterOnTerrain(){if(!this._elevation||"globe"===this.projection.name)return;const t=this._elevation;this._updateCameraState();const i=e.mercatorZfromAltitude(1,this._center.lat)*this.worldSize,o=this._computeCameraPosition(i),r=this._camera.forward(),n=e.mercatorZfromAltitude(1,this._center.lat);o[2]/=n,r[2]/=n,e.normalize(r,r);const s=t.raycast(o,r,t.exaggeration());if(s){const t=e.scaleAndAdd([],o,r,s),i=new e.MercatorCoordinate(t[0],t[1],e.mercatorZfromAltitude(t[2],e.latFromMercatorY(t[1]))),a=(i.z+e.length([i.x-o[0],i.y-o[1],i.z-o[2]*n]))*this._pixelsPerMercatorPixel;this._seaLevelZoom=this._zoomFromMercatorZ(a),this._centerAltitude=i.toAltitude(),this._center=this.coordinateLocation(i),this._updateZoomFromElevation(),this._constrain(),this._calcMatrices();}}_constrainCamera(t=!1){if(!this._elevation)return;const i=this._elevation,o=e.mercatorZfromAltitude(1,this._center.lat)*this.worldSize,r=this._computeCameraPosition(o),n=i.getAtPointOrZero(new e.MercatorCoordinate(...r)),s=this.pixelsPerMeter/this.worldSize*n,a=this._minimumHeightOverTerrain(),l=r[2]-s;if(l<=a)if(l<0||t){const t=this.locationCoordinate(this._center,this._centerAltitude),i=[r[0],r[1],t.z-r[2]],o=e.length(i);i[2]-=(a-l)/this._pixelsPerMercatorPixel;const n=e.length(i);if(0===n)return;e.scale$2(i,i,o/n*this._pixelsPerMercatorPixel),this._camera.position=[r[0],r[1],t.z*this._pixelsPerMercatorPixel-i[2]],this._updateStateFromCamera();}else this._isCameraConstrained=!0;}_constrain(){if(!this.center||!this.width||!this.height||this._constraining)return;this._constraining=!0;const t="globe"===this.projection.name||this.mercatorFromTransition;if(this.projection.isReprojectedInTileSpace||t){const i=this.center;return i.lat=e.clamp(i.lat,this.minLat,this.maxLat),(this.maxBounds||!this.renderWorldCopies&&!t)&&(i.lng=e.clamp(i.lng,this.minLng,this.maxLng)),this.center=i,void(this._constraining=!1)}const i=this._unmodified,{x:o,y:r}=this.point;let n=0,s=o,a=r;const l=this.width/2,c=this.height/2,h=this.worldMinY*this.scale,u=this.worldMaxY*this.scale;if(r-c<h&&(a=h+c),r+c>u&&(a=u-c),u-h<this.height&&(n=Math.max(n,this.height/(u-h)),a=(u+h)/2),this.maxBounds||!this._renderWorldCopies||!this.projection.wrap){const e=this.worldMinX*this.scale,t=this.worldMaxX*this.scale,i=this.worldSize/2-(e+t)/2;s=(o+i+this.worldSize)%this.worldSize-i,s-l<e&&(s=e+l),s+l>t&&(s=t-l),t-e<this.width&&(n=Math.max(n,this.width/(t-e)),s=(t+e)/2);}s===o&&a===r||(this.center=this.unproject(new e.Point(s,a))),n&&(this.zoom+=this.scaleZoom(n)),this._constrainCamera(),this._unmodified=i,this._constraining=!1;}_minZoomForBounds(){let e=Math.max(0,this.scaleZoom(this.height/(this.worldMaxY-this.worldMinY)));return this.maxBounds&&(e=Math.max(e,this.scaleZoom(this.width/(this.worldMaxX-this.worldMinX)))),e}_maxCameraBoundsDistance(){return this._mercatorZfromZoom(this._minZoomForBounds())}_calcMatrices(){if(!this.height)return;const t=this.centerOffset,i=this.pixelsPerMeter;"globe"===this.projection.name&&(this._mercatorScaleRatio=e.mercatorZfromAltitude(1,this.center.lat)/e.mercatorZfromAltitude(1,e.GLOBE_SCALE_MATCH_LATITUDE));const o=Wo(this.projection,this.zoom,this.width,this.height,1024);this._pixelsPerMercatorPixel=this.projection.pixelSpaceConversion(this.center.lat,this.worldSize,o),this.cameraToCenterDistance=.5/Math.tan(.5*this._fov)*this.height*this._pixelsPerMercatorPixel,this._updateCameraState(),this._farZ=this.projection.farthestPixelDistance(this),this._nearZ=this.height/50;const r="meters"===this.projection.zAxisUnit?i:1,n=this._camera.getWorldToCamera(this.worldSize,r),s=this._camera.getCameraToClipPerspective(this._fov,this.width/this.height,this._nearZ,this._farZ);s[8]=2*-t.x/this.width,s[9]=2*t.y/this.height;let a=e.mul([],s,n);if(this.projection.isReprojectedInTileSpace){const t=this.locationCoordinate(this.center),i=e.identity([]);e.translate(i,i,[t.x*this.worldSize,t.y*this.worldSize,0]),e.multiply(i,i,Zo(this)),e.translate(i,i,[-t.x*this.worldSize,-t.y*this.worldSize,0]),e.multiply(a,a,i),this.inverseAdjustmentMatrix=function(e){const t=Zo(e,!0);return v([],[t[0],t[1],t[4],t[5]])}(this);}else this.inverseAdjustmentMatrix=[1,0,0,1];this.mercatorMatrix=e.scale([],a,[this.worldSize,this.worldSize,this.worldSize/r,1]),this.projMatrix=a,this.invProjMatrix=e.invert(new Float64Array(16),this.projMatrix);const l=e.invert([],s);this.frustumCorners=e.FrustumCorners.fromInvProjectionMatrix(l,this.horizonLineFromTop(),this.height);const c=new Float32Array(16);e.identity(c),e.scale(c,c,[1,-1,1]),e.rotateX(c,c,this._pitch),e.rotateZ(c,c,this.angle);const h=e.perspective(new Float32Array(16),this._fov,this.width/this.height,this._nearZ,this._farZ),u=(Math.PI/2-this._pitch)*(this.height/this._fov)*this._horizonShift;h[8]=2*-t.x/this.width,h[9]=2*(t.y+u)/this.height,this.skyboxMatrix=e.multiply(c,h,c);const _=this.point,d=_.x,p=_.y,m=this.width%2/2,f=this.height%2/2,g=Math.cos(this.angle),x=Math.sin(this.angle),y=d-Math.round(d)+g*m+x*f,b=p-Math.round(p)+g*f+x*m,w=new Float64Array(a);if(e.translate(w,w,[y>.5?y-1:y,b>.5?b-1:b,0]),this.alignedProjMatrix=w,a=e.create(),e.scale(a,a,[this.width/2,-this.height/2,1]),e.translate(a,a,[1,-1,0]),this.labelPlaneMatrix=a,a=e.create(),e.scale(a,a,[1,-1,1]),e.translate(a,a,[-1,-1,0]),e.scale(a,a,[2/this.width,2/this.height,1]),this.glCoordMatrix=a,this.pixelMatrix=e.multiply(new Float64Array(16),this.labelPlaneMatrix,this.projMatrix),this._calcFogMatrices(),this._distanceTileDataCache={},a=e.invert(new Float64Array(16),this.pixelMatrix),!a)throw new Error("failed to invert matrix");if(this.pixelMatrixInverse=a,"globe"===this.projection.name||this.mercatorFromTransition){this.globeMatrix=e.calculateGlobeMatrix(this);const t=[this.globeMatrix[12],this.globeMatrix[13],this.globeMatrix[14]];this.globeCenterInViewSpace=e.transformMat4(t,t,n),this.globeRadius=this.worldSize/2/Math.PI-1;}else this.globeMatrix=a;this._projMatrixCache={},this._alignedProjMatrixCache={},this._pixelsToTileUnitsCache={};}_calcFogMatrices(){this._fogTileMatrixCache={};const t=this.cameraWorldSizeForFog,i=this.cameraPixelsPerMeter,o=this._camera.position,r=1/this.height/this._pixelsPerMercatorPixel,n=[t,t,i];e.scale$2(n,n,r),e.scale$2(o,o,-1),e.multiply$2(o,o,n);const s=e.create();e.translate(s,s,o),e.scale(s,s,n),this.mercatorFogMatrix=s,this.worldToFogMatrix=this._camera.getWorldToCameraPosition(t,i,r);}_computeCameraPosition(e){const t=(e=e||this.pixelsPerMeter)/this.pixelsPerMeter,i=this._camera.forward(),o=this.point,r=this._mercatorZfromZoom(this._seaLevelZoom?this._seaLevelZoom:this._zoom)*t-e/this.worldSize*this._centerAltitude;return [o.x/this.worldSize-i[0]*r,o.y/this.worldSize-i[1]*r,e/this.worldSize*this._centerAltitude-i[2]*r]}_updateCameraState(){this.height&&(this._camera.setPitchBearing(this._pitch,this.angle),this._camera.position=this._computeCameraPosition());}_translateCameraConstrained(t){const i=this._maxCameraBoundsDistance()*Math.cos(this._pitch),o=this._camera.position[2],r=t[2];let n=1;this.projection.wrap&&(this.center=this.center.wrap()),r>0&&(n=Math.min((i-o)/r,1)),this._camera.position=e.scaleAndAdd([],this._camera.position,t,n),this._updateStateFromCamera();}_updateStateFromCamera(){const t=this._camera.position,i=this._camera.forward(),{pitch:o,bearing:r}=this._camera.getPitchBearing(),n=e.mercatorZfromAltitude(this._centerAltitude,this.center.lat)*this._pixelsPerMercatorPixel,s=this._mercatorZfromZoom(this._maxZoom)*Math.cos(e.degToRad(this._maxPitch)),a=Math.max((t[2]-n)/Math.cos(o),s),l=this._zoomFromMercatorZ(a);e.scaleAndAdd(t,t,i,a),this._pitch=e.clamp(o,e.degToRad(this.minPitch),e.degToRad(this.maxPitch)),this.angle=e.wrap(r,-Math.PI,Math.PI),this._setZoom(e.clamp(l,this._minZoom,this._maxZoom)),this._updateSeaLevelZoom(),this._center=this.coordinateLocation(new e.MercatorCoordinate(t[0],t[1],t[2])),this._unmodified=!1,this._constrain(),this._calcMatrices();}_worldSizeFromZoom(e){return Math.pow(2,e)*this.tileSize}_mercatorZfromZoom(e){return this.cameraToCenterDistance/this._worldSizeFromZoom(e)}_minimumHeightOverTerrain(){const e=Math.min((null!=this._seaLevelZoom?this._seaLevelZoom:this._zoom)+4,this._maxZoom);return this._mercatorZfromZoom(e)}_zoomFromMercatorZ(e){return this.scaleZoom(this.cameraToCenterDistance/(e*this.tileSize))}zoomFromMercatorZAdjusted(t){let i=0,o=e.GLOBE_ZOOM_THRESHOLD_MAX,r=0,n=1/0;for(;o-i>1e-6&&o>i;){const e=i+.5*(o-i),s=this.tileSize*Math.pow(2,e),a=this.getCameraToCenterDistance(this.projection,e,s),l=this.scaleZoom(a/(t*this.tileSize)),c=Math.abs(e-l);c<n&&(n=c,r=e),e<l?i=e:o=e;}return r}_terrainEnabled(){return !(!this._elevation||!this.projection.supportsTerrain&&(e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."),1))}anyCornerOffEdge(t,i){const o=Math.min(t.x,i.x),r=Math.max(t.x,i.x),n=Math.min(t.y,i.y),s=Math.max(t.y,i.y);if(n<this.horizonLineFromTop(!1))return !0;if("mercator"!==this.projection.name)return !1;const a=[new e.Point(o,n),new e.Point(r,s),new e.Point(o,s),new e.Point(r,n)],l=this.renderWorldCopies?-3:0,c=this.renderWorldCopies?4:1;for(const e of a){const t=this.pointRayIntersection(e);if(t.t<0)return !0;const i=this.rayIntersectionCoordinate(t);if(i.x<l||i.y<0||i.x>c||i.y>1)return !0}return !1}isHorizonVisible(){return this.pitch+e.radToDeg(this.fovAboveCenter)>88||this.anyCornerOffEdge(new e.Point(0,0),new e.Point(this.width,this.height))}zoomDeltaToMovement(t,i){const o=e.length(e.sub([],this._camera.position,t)),r=this._zoomFromMercatorZ(o)+i;return o-this._mercatorZfromZoom(r)}getCameraPoint(){if("globe"===this.projection.name){const t=function([t,i,o],r){const n=[t,i,o,1];e.transformMat4$1(n,n,r);const s=n[3]=Math.max(n[3],1e-6);return n[0]/=s,n[1]/=s,n[2]/=s,n}([this.globeMatrix[12],this.globeMatrix[13],this.globeMatrix[14]],this.pixelMatrix);return new e.Point(t[0],t[1])}{const t=Math.tan(this._pitch)*(this.cameraToCenterDistance||1);return this.centerPoint.add(new e.Point(0,t))}}getCameraToCenterDistance(e,t=this.zoom,i=this.worldSize){const o=Wo(e,t,this.width,this.height,1024),r=e.pixelSpaceConversion(this.center.lat,i,o);return .5/Math.tan(.5*this._fov)*this.height*r}getWorldToCameraMatrix(){const t=this._camera.getWorldToCamera(this.worldSize,"meters"===this.projection.zAxisUnit?this.pixelsPerMeter:1);return "globe"===this.projection.name&&e.multiply(t,t,this.globeMatrix),t}}function Yo(e,t){let i=!1,o=null;const r=()=>{o=null,i&&(e(),o=setTimeout(r,t),i=!1);};return ()=>(i=!0,o||r(),o)}class Ko{constructor(t){this._hashName=t&&encodeURIComponent(t),e.bindAll(["_getCurrentHash","_onHashChange","_updateHash"],this),this._updateHash=Yo(this._updateHashUnthrottled.bind(this),300);}addTo(t){return this._map=t,e.window.addEventListener("hashchange",this._onHashChange,!1),t.on("moveend",this._updateHash),this}remove(){return this._map?(this._map.off("moveend",this._updateHash),e.window.removeEventListener("hashchange",this._onHashChange,!1),clearTimeout(this._updateHash()),this._map=void 0,this):this}getHashString(){const t=this._map;if(!t)return "";const i=Jo(t);if(this._hashName){const t=this._hashName;let o=!1;const r=e.window.location.hash.slice(1).split("&").map((e=>{const r=e.split("=")[0];return r===t?(o=!0,`${r}=${i}`):e})).filter((e=>e));return o||r.push(`${t}=${i}`),`#${r.join("&")}`}return `#${i}`}_getCurrentHash(){const t=e.window.location.hash.replace("#","");if(this._hashName){let e;return t.split("&").map((e=>e.split("="))).forEach((t=>{t[0]===this._hashName&&(e=t);})),(e&&e[1]||"").split("/")}return t.split("/")}_onHashChange(){const e=this._map;if(!e)return !1;const t=this._getCurrentHash();if(t.length>=3&&!t.some((e=>isNaN(e)))){const i=e.dragRotate.isEnabled()&&e.touchZoomRotate.isEnabled()?+(t[3]||0):e.getBearing();return e.jumpTo({center:[+t[2],+t[1]],zoom:+t[0],bearing:i,pitch:+(t[4]||0)}),!0}return !1}_updateHashUnthrottled(){const t=e.window.location.href.replace(/(#.+)?$/,this.getHashString());e.window.history.replaceState(e.window.history.state,null,t);}}function Jo(e,t){const i=e.getCenter(),o=Math.round(100*e.getZoom())/100,r=Math.ceil((o*Math.LN2+Math.log(512/360/.5))/Math.LN10),n=Math.pow(10,r),s=Math.round(i.lng*n)/n,a=Math.round(i.lat*n)/n,l=e.getBearing(),c=e.getPitch();let h=t?`/${s}/${a}/${o}`:`${o}/${a}/${s}`;return (l||c)&&(h+="/"+Math.round(10*l)/10),c&&(h+=`/${Math.round(c)}`),h}const Qo={linearity:.3,easing:e.bezier(0,0,.3,1)},er=e.extend({deceleration:2500,maxSpeed:1400},Qo),tr=e.extend({deceleration:20,maxSpeed:1400},Qo),ir=e.extend({deceleration:1e3,maxSpeed:360},Qo),or=e.extend({deceleration:1e3,maxSpeed:90},Qo);class rr{constructor(e){this._map=e,this.clear();}clear(){this._inertiaBuffer=[];}record(t){this._drainInertiaBuffer(),this._inertiaBuffer.push({time:e.exported.now(),settings:t});}_drainInertiaBuffer(){const t=this._inertiaBuffer,i=e.exported.now();for(;t.length>0&&i-t[0].time>160;)t.shift();}_onMoveEnd(t){if(this._map._prefersReducedMotion())return;if(this._drainInertiaBuffer(),this._inertiaBuffer.length<2)return;const i={zoom:0,bearing:0,pitch:0,pan:new e.Point(0,0),pinchAround:void 0,around:void 0};for(const{settings:e}of this._inertiaBuffer)i.zoom+=e.zoomDelta||0,i.bearing+=e.bearingDelta||0,i.pitch+=e.pitchDelta||0,e.panDelta&&i.pan._add(e.panDelta),e.around&&(i.around=e.around),e.pinchAround&&(i.pinchAround=e.pinchAround);const o=this._inertiaBuffer[this._inertiaBuffer.length-1].time-this._inertiaBuffer[0].time,r={};if(i.pan.mag()){const n=sr(i.pan.mag(),o,e.extend({},er,t||{}));r.offset=i.pan.mult(n.amount/i.pan.mag()),r.center=this._map.transform.center,nr(r,n);}if(i.zoom){const e=sr(i.zoom,o,tr);r.zoom=this._map.transform.zoom+e.amount,nr(r,e);}if(i.bearing){const t=sr(i.bearing,o,ir);r.bearing=this._map.transform.bearing+e.clamp(t.amount,-179,179),nr(r,t);}if(i.pitch){const e=sr(i.pitch,o,or);r.pitch=this._map.transform.pitch+e.amount,nr(r,e);}if(r.zoom||r.bearing){const e=void 0===i.pinchAround?i.around:i.pinchAround;r.around=e?this._map.unproject(e):this._map.getCenter();}return this.clear(),r.noMoveStart=!0,r}}function nr(e,t){(!e.duration||e.duration<t.duration)&&(e.duration=t.duration,e.easing=t.easing);}function sr(t,i,o){const{maxSpeed:r,linearity:n,deceleration:s}=o,a=e.clamp(t*n/(i/1e3),-r,r),l=Math.abs(a)/(s*n);return {easing:o.easing,duration:1e3*l,amount:a*(l/2)}}class ar extends e.Event{preventDefault(){this._defaultPrevented=!0;}get defaultPrevented(){return this._defaultPrevented}constructor(t,i,o,r={}){const n=p(i.getCanvasContainer(),o),s=i.unproject(n);super(t,e.extend({point:n,lngLat:s,originalEvent:o},r)),this._defaultPrevented=!1,this.target=i;}}class lr extends e.Event{preventDefault(){this._defaultPrevented=!0;}get defaultPrevented(){return this._defaultPrevented}constructor(t,i,o){const r="touchend"===t?o.changedTouches:o.touches,n=m(i.getCanvasContainer(),r),s=n.map((e=>i.unproject(e))),a=n.reduce(((e,t,i,o)=>e.add(t.div(o.length))),new e.Point(0,0));super(t,{points:n,point:a,lngLats:s,lngLat:i.unproject(a),originalEvent:o}),this._defaultPrevented=!1;}}class cr extends e.Event{preventDefault(){this._defaultPrevented=!0;}get defaultPrevented(){return this._defaultPrevented}constructor(e,t,i){super(e,{originalEvent:i}),this._defaultPrevented=!1;}}class hr{constructor(e,t){this._map=e,this._clickTolerance=t.clickTolerance;}reset(){this._mousedownPos=void 0;}wheel(e){return this._firePreventable(new cr(e.type,this._map,e))}mousedown(e,t){return this._mousedownPos=t,this._firePreventable(new ar(e.type,this._map,e))}mouseup(e){this._map.fire(new ar(e.type,this._map,e));}preclick(t){const i=e.extend({},t);i.type="preclick",this._map.fire(new ar(i.type,this._map,i));}click(e,t){this._mousedownPos&&this._mousedownPos.dist(t)>=this._clickTolerance||(this.preclick(e),this._map.fire(new ar(e.type,this._map,e)));}dblclick(e){return this._firePreventable(new ar(e.type,this._map,e))}mouseover(e){this._map.fire(new ar(e.type,this._map,e));}mouseout(e){this._map.fire(new ar(e.type,this._map,e));}touchstart(e){return this._firePreventable(new lr(e.type,this._map,e))}touchmove(e){this._map.fire(new lr(e.type,this._map,e));}touchend(e){this._map.fire(new lr(e.type,this._map,e));}touchcancel(e){this._map.fire(new lr(e.type,this._map,e));}_firePreventable(e){if(this._map.fire(e),e.defaultPrevented)return {}}isEnabled(){return !0}isActive(){return !1}enable(){}disable(){}}class ur{constructor(e){this._map=e;}reset(){this._delayContextMenu=!1,this._contextMenuEvent=void 0;}mousemove(e){this._map.fire(new ar(e.type,this._map,e));}mousedown(){this._delayContextMenu=!0;}mouseup(){this._delayContextMenu=!1,this._contextMenuEvent&&(this._map.fire(new ar("contextmenu",this._map,this._contextMenuEvent)),delete this._contextMenuEvent);}contextmenu(e){this._delayContextMenu?this._contextMenuEvent=e:this._map.fire(new ar(e.type,this._map,e)),this._map.listens("contextmenu")&&e.preventDefault();}isEnabled(){return !0}isActive(){return !1}enable(){}disable(){}}class _r{constructor(e,t){this._map=e,this._el=e.getCanvasContainer(),this._container=e.getContainer(),this._clickTolerance=t.clickTolerance||1;}isEnabled(){return !!this._enabled}isActive(){return !!this._active}enable(){this.isEnabled()||(this._enabled=!0);}disable(){this.isEnabled()&&(this._enabled=!1);}mousedown(e,t){this.isEnabled()&&e.shiftKey&&0===e.button&&(h(),this._startPos=this._lastPos=t,this._active=!0);}mousemoveWindow(e,t){if(!this._active)return;const i=t,o=this._startPos,r=this._lastPos;if(!o||!r||r.equals(i)||!this._box&&i.dist(o)<this._clickTolerance)return;this._lastPos=i,this._box||(this._box=n("div","mapboxgl-boxzoom",this._container),this._container.classList.add("mapboxgl-crosshair"),this._fireEvent("boxzoomstart",e));const s=Math.min(o.x,i.x),a=Math.max(o.x,i.x),l=Math.min(o.y,i.y),c=Math.max(o.y,i.y);this._map._requestDomTask((()=>{this._box&&(this._box.style.transform=`translate(${s}px,${l}px)`,this._box.style.width=a-s+"px",this._box.style.height=c-l+"px");}));}mouseupWindow(t,i){if(!this._active)return;const o=this._startPos,r=i;if(o&&0===t.button){if(this.reset(),d(),o.x!==r.x||o.y!==r.y)return this._map.fire(new e.Event("boxzoomend",{originalEvent:t})),{cameraAnimation:e=>e.fitScreenCoordinates(o,r,this._map.getBearing(),{linear:!1})};this._fireEvent("boxzoomcancel",t);}}keydown(e){this._active&&27===e.keyCode&&(this.reset(),this._fireEvent("boxzoomcancel",e));}blur(){this.reset();}reset(){this._active=!1,this._container.classList.remove("mapboxgl-crosshair"),this._box&&(this._box.remove(),this._box=null),u(),delete this._startPos,delete this._lastPos;}_fireEvent(t,i){return this._map.fire(new e.Event(t,{originalEvent:i}))}}function dr(e,t){const i={};for(let o=0;o<e.length;o++)i[e[o].identifier]=t[o];return i}class pr{constructor(e){this.reset(),this.numTouches=e.numTouches;}reset(){this.centroid=void 0,this.startTime=0,this.touches={},this.aborted=!1;}touchstart(t,i,o){(this.centroid||o.length>this.numTouches)&&(this.aborted=!0),this.aborted||(0===this.startTime&&(this.startTime=t.timeStamp),o.length===this.numTouches&&(this.centroid=function(t){const i=new e.Point(0,0);for(const e of t)i._add(e);return i.div(t.length)}(i),this.touches=dr(o,i)));}touchmove(e,t,i){if(this.aborted||!this.centroid)return;const o=dr(i,t);for(const e in this.touches){const t=o[e];(!t||t.dist(this.touches[e])>30)&&(this.aborted=!0);}}touchend(e,t,i){if((!this.centroid||e.timeStamp-this.startTime>500)&&(this.aborted=!0),0===i.length){const e=!this.aborted&&this.centroid;if(this.reset(),e)return e}}}class mr{constructor(e){this.singleTap=new pr(e),this.numTaps=e.numTaps,this.reset();}reset(){this.lastTime=1/0,this.lastTap=void 0,this.count=0,this.singleTap.reset();}touchstart(e,t,i){this.singleTap.touchstart(e,t,i);}touchmove(e,t,i){this.singleTap.touchmove(e,t,i);}touchend(e,t,i){const o=this.singleTap.touchend(e,t,i);if(o){const t=e.timeStamp-this.lastTime<500,i=!this.lastTap||this.lastTap.dist(o)<30;if(t&&i||this.reset(),this.count++,this.lastTime=e.timeStamp,this.lastTap=o,this.count===this.numTaps)return this.reset(),o}}}class fr{constructor(){this._zoomIn=new mr({numTouches:1,numTaps:2}),this._zoomOut=new mr({numTouches:2,numTaps:1}),this.reset();}reset(){this._active=!1,this._zoomIn.reset(),this._zoomOut.reset();}touchstart(e,t,i){this._zoomIn.touchstart(e,t,i),this._zoomOut.touchstart(e,t,i);}touchmove(e,t,i){this._zoomIn.touchmove(e,t,i),this._zoomOut.touchmove(e,t,i);}touchend(e,t,i){const o=this._zoomIn.touchend(e,t,i),r=this._zoomOut.touchend(e,t,i);return o?(this._active=!0,e.preventDefault(),setTimeout((()=>this.reset()),0),{cameraAnimation:t=>t.easeTo({duration:300,zoom:t.getZoom()+1,around:t.unproject(o)},{originalEvent:e})}):r?(this._active=!0,e.preventDefault(),setTimeout((()=>this.reset()),0),{cameraAnimation:t=>t.easeTo({duration:300,zoom:t.getZoom()-1,around:t.unproject(r)},{originalEvent:e})}):void 0}touchcancel(){this.reset();}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}const gr={0:1,2:2};class vr{constructor(e){this.reset(),this._clickTolerance=e.clickTolerance||1;}blur(){this.reset();}reset(){this._active=!1,this._moved=!1,this._lastPoint=void 0,this._eventButton=void 0;}_correctButton(e,t){return !1}_move(e,t){return {}}mousedown(e,t){if(this._lastPoint)return;const i=f(e);this._correctButton(e,i)&&(this._lastPoint=t,this._eventButton=i);}mousemoveWindow(e,t){const i=this._lastPoint;if(i)if(e.preventDefault(),null!=this._eventButton&&function(e,t){const i=gr[t];return void 0===e.buttons||(e.buttons&i)!==i}(e,this._eventButton))this.reset();else if(this._moved||!(t.dist(i)<this._clickTolerance))return this._moved=!0,this._lastPoint=t,this._move(i,t)}mouseupWindow(e){this._lastPoint&&f(e)===this._eventButton&&(this._moved&&d(),this.reset());}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}class xr extends vr{mousedown(e,t){super.mousedown(e,t),this._lastPoint&&(this._active=!0);}_correctButton(e,t){return 0===t&&!e.ctrlKey}_move(e,t){return {around:t,panDelta:t.sub(e)}}}class yr extends vr{_correctButton(e,t){return 0===t&&e.ctrlKey||2===t}_move(e,t){const i=.8*(t.x-e.x);if(i)return this._active=!0,{bearingDelta:i}}contextmenu(e){e.preventDefault();}}class br extends vr{_correctButton(e,t){return 0===t&&e.ctrlKey||2===t}_move(e,t){const i=-.5*(t.y-e.y);if(i)return this._active=!0,{pitchDelta:i}}contextmenu(e){e.preventDefault();}}class wr{constructor(t,i){this._map=t,this._el=t.getCanvasContainer(),this._minTouches=1,this._clickTolerance=i.clickTolerance||1,this.reset(),e.bindAll(["_addTouchPanBlocker","_showTouchPanBlockerAlert"],this);}reset(){this._active=!1,this._touches={},this._sum=new e.Point(0,0);}touchstart(e,t,i){return this._calculateTransform(e,t,i)}touchmove(t,i,o){if(this._active&&!(o.length<this._minTouches)){if(this._map._cooperativeGestures&&!this._map.isMoving()){if(1===o.length&&!e.isFullscreen())return void this._showTouchPanBlockerAlert();"hidden"!==this._alertContainer.style.visibility&&(this._alertContainer.style.visibility="hidden",clearTimeout(this._alertTimer));}return t.cancelable&&t.preventDefault(),this._calculateTransform(t,i,o)}}touchend(e,t,i){this._calculateTransform(e,t,i),this._active&&i.length<this._minTouches&&this.reset();}touchcancel(){this.reset();}_calculateTransform(t,i,o){o.length>0&&(this._active=!0);const r=dr(o,i),n=new e.Point(0,0),s=new e.Point(0,0);let a=0;for(const e in r){const t=r[e],i=this._touches[e];i&&(n._add(t),s._add(t.sub(i)),a++,r[e]=t);}if(this._touches=r,a<this._minTouches||!s.mag())return;const l=s.div(a);return this._sum._add(l),this._sum.mag()<this._clickTolerance?void 0:{around:n.div(a),panDelta:l}}enable(){this._enabled=!0,this._map._cooperativeGestures&&(this._addTouchPanBlocker(),this._el.classList.add("mapboxgl-touch-pan-blocker-override","mapboxgl-scrollable-page"));}disable(){this._enabled=!1,this._map._cooperativeGestures&&(clearTimeout(this._alertTimer),this._alertContainer.remove(),this._el.classList.remove("mapboxgl-touch-pan-blocker-override","mapboxgl-scrollable-page")),this.reset();}isEnabled(){return !!this._enabled}isActive(){return !!this._active}_addTouchPanBlocker(){this._map&&!this._alertContainer&&(this._alertContainer=n("div","mapboxgl-touch-pan-blocker",this._map._container),this._alertContainer.textContent=this._map._getUIString("TouchPanBlocker.Message"),this._alertContainer.style.fontSize=`${Math.max(10,Math.min(24,Math.floor(.05*this._el.clientWidth)))}px`);}_showTouchPanBlockerAlert(){this._alertContainer.style.visibility="visible",this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"),this._alertContainer.setAttribute("role","alert"),clearTimeout(this._alertTimer),this._alertTimer=setTimeout((()=>{this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"),this._alertContainer.setAttribute("role","null");}),500);}}class Tr{constructor(){this.reset();}reset(){this._active=!1,this._firstTwoTouches=void 0;}_start(e){}_move(e,t,i){return {}}touchstart(e,t,i){this._firstTwoTouches||i.length<2||(this._firstTwoTouches=[i[0].identifier,i[1].identifier],this._start([t[0],t[1]]));}touchmove(e,t,i){const o=this._firstTwoTouches;if(!o)return;e.preventDefault();const[r,n]=o,s=Er(i,t,r),a=Er(i,t,n);if(!s||!a)return;const l=this._aroundCenter?null:s.add(a).div(2);return this._move([s,a],l,e)}touchend(e,t,i){if(!this._firstTwoTouches)return;const[o,r]=this._firstTwoTouches,n=Er(i,t,o),s=Er(i,t,r);n&&s||(this._active&&d(),this.reset());}touchcancel(){this.reset();}enable(e){this._enabled=!0,this._aroundCenter=!!e&&"center"===e.around;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}function Er(e,t,i){for(let o=0;o<e.length;o++)if(e[o].identifier===i)return t[o]}function Cr(e,t){return Math.log(e/t)/Math.LN2}class Mr extends Tr{reset(){super.reset(),this._distance=0,this._startDistance=0;}_start(e){this._startDistance=this._distance=e[0].dist(e[1]);}_move(e,t){const i=this._distance;if(this._distance=e[0].dist(e[1]),this._active||!(Math.abs(Cr(this._distance,this._startDistance))<.1))return this._active=!0,{zoomDelta:Cr(this._distance,i),pinchAround:t}}}function Ir(e,t){return 180*e.angleWith(t)/Math.PI}class Pr extends Tr{reset(){super.reset(),this._minDiameter=0,this._startVector=void 0,this._vector=void 0;}_start(e){this._startVector=this._vector=e[0].sub(e[1]),this._minDiameter=e[0].dist(e[1]);}_move(e,t){const i=this._vector;if(this._vector=e[0].sub(e[1]),i&&(this._active||!this._isBelowThreshold(this._vector)))return this._active=!0,{bearingDelta:Ir(this._vector,i),pinchAround:t}}_isBelowThreshold(e){this._minDiameter=Math.min(this._minDiameter,e.mag());const t=25/(Math.PI*this._minDiameter)*360,i=this._startVector;if(!i)return !1;const o=Ir(e,i);return Math.abs(o)<t}}function Sr(e){return Math.abs(e.y)>Math.abs(e.x)}class Dr extends Tr{constructor(e){super(),this._map=e;}reset(){super.reset(),this._valid=void 0,this._firstMove=void 0,this._lastPoints=void 0;}_start(e){this._lastPoints=e,Sr(e[0].sub(e[1]))&&(this._valid=!1);}_move(t,i,o){const r=this._lastPoints;if(!r)return;const n=t[0].sub(r[0]),s=t[1].sub(r[1]);return this._map._cooperativeGestures&&!e.isFullscreen()&&o.touches.length<3||(this._valid=this.gestureBeginsVertically(n,s,o.timeStamp),!this._valid)?void 0:(this._lastPoints=t,this._active=!0,{pitchDelta:(n.y+s.y)/2*-.5})}gestureBeginsVertically(e,t,i){if(void 0!==this._valid)return this._valid;const o=e.mag()>=2,r=t.mag()>=2;if(!o&&!r)return;if(!o||!r)return null==this._firstMove&&(this._firstMove=i),i-this._firstMove<100&&void 0;const n=e.y>0==t.y>0;return Sr(e)&&Sr(t)&&n}}const Lr={panStep:100,bearingStep:15,pitchStep:10};class Ar{constructor(){const e=Lr;this._panStep=e.panStep,this._bearingStep=e.bearingStep,this._pitchStep=e.pitchStep,this._rotationDisabled=!1;}blur(){this.reset();}reset(){this._active=!1;}keydown(e){if(e.altKey||e.ctrlKey||e.metaKey)return;let t=0,i=0,o=0,r=0,n=0;switch(e.keyCode){case 61:case 107:case 171:case 187:t=1;break;case 189:case 109:case 173:t=-1;break;case 37:e.shiftKey?i=-1:(e.preventDefault(),r=-1);break;case 39:e.shiftKey?i=1:(e.preventDefault(),r=1);break;case 38:e.shiftKey?o=1:(e.preventDefault(),n=-1);break;case 40:e.shiftKey?o=-1:(e.preventDefault(),n=1);break;default:return}return this._rotationDisabled&&(i=0,o=0),{cameraAnimation:s=>{const a=s.getZoom();s.easeTo({duration:300,easeId:"keyboardHandler",easing:zr,zoom:t?Math.round(a)+t*(e.shiftKey?2:1):a,bearing:s.getBearing()+i*this._bearingStep,pitch:s.getPitch()+o*this._pitchStep,offset:[-r*this._panStep,-n*this._panStep],center:s.getCenter()},{originalEvent:e});}}}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}disableRotation(){this._rotationDisabled=!0;}enableRotation(){this._rotationDisabled=!1;}}function zr(e){return e*(2-e)}const Rr=4.000244140625;class Or{constructor(t,i){this._map=t,this._el=t.getCanvasContainer(),this._handler=i,this._delta=0,this._defaultZoomRate=.01,this._wheelZoomRate=.0022222222222222222,e.bindAll(["_onTimeout","_addScrollZoomBlocker","_showBlockerAlert"],this);}setZoomRate(e){this._defaultZoomRate=e;}setWheelZoomRate(e){this._wheelZoomRate=e;}isEnabled(){return !!this._enabled}isActive(){return this._active||void 0!==this._finishTimeout}isZooming(){return !!this._zooming}enable(e){this.isEnabled()||(this._enabled=!0,this._aroundCenter=!!e&&"center"===e.around,this._map._cooperativeGestures&&this._addScrollZoomBlocker());}disable(){this.isEnabled()&&(this._enabled=!1,this._map._cooperativeGestures&&(clearTimeout(this._alertTimer),this._alertContainer.remove()));}wheel(t){if(!this.isEnabled())return;if(this._map._cooperativeGestures){if(!(t.ctrlKey||t.metaKey||this.isZooming()||e.isFullscreen()))return void this._showBlockerAlert();"hidden"!==this._alertContainer.style.visibility&&(this._alertContainer.style.visibility="hidden",clearTimeout(this._alertTimer));}let i=t.deltaMode===e.window.WheelEvent.DOM_DELTA_LINE?40*t.deltaY:t.deltaY;const o=e.exported.now(),r=o-(this._lastWheelEventTime||0);this._lastWheelEventTime=o,0!==i&&i%Rr==0?this._type="wheel":0!==i&&Math.abs(i)<4?this._type="trackpad":r>400?(this._type=null,this._lastValue=i,this._timeout=setTimeout(this._onTimeout,40,t)):this._type||(this._type=Math.abs(r*i)<200?"trackpad":"wheel",this._timeout&&(clearTimeout(this._timeout),this._timeout=null,i+=this._lastValue)),t.shiftKey&&i&&(i/=4),this._type&&(this._lastWheelEvent=t,this._delta-=i,this._active||this._start(t)),t.preventDefault();}_onTimeout(e){this._type="wheel",this._delta-=this._lastValue,this._active||this._start(e);}_start(e){if(!this._delta)return;this._frameId&&(this._frameId=null),this._active=!0,this.isZooming()||(this._zooming=!0),this._finishTimeout&&(clearTimeout(this._finishTimeout),delete this._finishTimeout);const t=p(this._el,e);this._aroundPoint=this._aroundCenter?this._map.transform.centerPoint:t,this._aroundCoord=this._map.transform.pointCoordinate3D(this._aroundPoint),this._targetZoom=void 0,this._frameId||(this._frameId=!0,this._handler._triggerRenderFrame());}renderFrame(){if(!this._frameId)return;if(this._frameId=null,!this.isActive())return;const t=this._map.transform;"wheel"===this._type&&t.projection.wrap&&(t._center.lng>=180||t._center.lng<=-180)&&(this._prevEase=null,this._easing=null,this._lastWheelEvent=null,this._lastWheelEventTime=0);const i=()=>t._terrainEnabled()&&this._aroundCoord?t.computeZoomRelativeTo(this._aroundCoord):t.zoom;if(0!==this._delta){const e="wheel"===this._type&&Math.abs(this._delta)>Rr?this._wheelZoomRate:this._defaultZoomRate;let o=2/(1+Math.exp(-Math.abs(this._delta*e)));this._delta<0&&0!==o&&(o=1/o);const r=i(),n=Math.pow(2,r),s="number"==typeof this._targetZoom?t.zoomScale(this._targetZoom):n;this._targetZoom=Math.min(t.maxZoom,Math.max(t.minZoom,t.scaleZoom(s*o))),"wheel"===this._type&&(this._startZoom=r,this._easing=this._smoothOutEasing(200)),this._delta=0;}const o="number"==typeof this._targetZoom?this._targetZoom:i(),r=this._startZoom,n=this._easing;let s,a=!1;if("wheel"===this._type&&r&&n){const t=Math.min((e.exported.now()-this._lastWheelEventTime)/200,1),i=n(t);s=e.number(r,o,i),t<1?this._frameId||(this._frameId=!0):a=!0;}else s=o,a=!0;return this._active=!0,a&&(this._active=!1,this._finishTimeout=setTimeout((()=>{this._zooming=!1,this._handler._triggerRenderFrame(),delete this._targetZoom,delete this._finishTimeout;}),200)),{noInertia:!0,needsRenderFrame:!a,zoomDelta:s-i(),around:this._aroundPoint,aroundCoord:this._aroundCoord,originalEvent:this._lastWheelEvent}}_smoothOutEasing(t){let i=e.ease;if(this._prevEase){const t=this._prevEase,o=(e.exported.now()-t.start)/t.duration,r=t.easing(o+.01)-t.easing(o),n=.27/Math.sqrt(r*r+1e-4)*.01,s=Math.sqrt(.0729-n*n);i=e.bezier(n,s,.25,1);}return this._prevEase={start:e.exported.now(),duration:t,easing:i},i}blur(){this.reset();}reset(){this._active=!1;}_addScrollZoomBlocker(){this._map&&!this._alertContainer&&(this._alertContainer=n("div","mapboxgl-scroll-zoom-blocker",this._map._container),this._alertContainer.textContent=/(Mac|iPad)/i.test(e.window.navigator.userAgent)?this._map._getUIString("ScrollZoomBlocker.CmdMessage"):this._map._getUIString("ScrollZoomBlocker.CtrlMessage"),this._alertContainer.style.fontSize=`${Math.max(10,Math.min(24,Math.floor(.05*this._el.clientWidth)))}px`);}_showBlockerAlert(){this._alertContainer.style.visibility="visible",this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"),this._alertContainer.setAttribute("role","alert"),clearTimeout(this._alertTimer),this._alertTimer=setTimeout((()=>{this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"),this._alertContainer.setAttribute("role","null");}),200);}}class Br{constructor(e,t){this._clickZoom=e,this._tapZoom=t;}enable(){this._clickZoom.enable(),this._tapZoom.enable();}disable(){this._clickZoom.disable(),this._tapZoom.disable();}isEnabled(){return this._clickZoom.isEnabled()&&this._tapZoom.isEnabled()}isActive(){return this._clickZoom.isActive()||this._tapZoom.isActive()}}class kr{constructor(){this.reset();}reset(){this._active=!1;}blur(){this.reset();}dblclick(e,t){return e.preventDefault(),{cameraAnimation:i=>{i.easeTo({duration:300,zoom:i.getZoom()+(e.shiftKey?-1:1),around:i.unproject(t)},{originalEvent:e});}}}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}class Fr{constructor(){this._tap=new mr({numTouches:1,numTaps:1}),this.reset();}reset(){this._active=!1,this._swipePoint=void 0,this._swipeTouch=0,this._tapTime=0,this._tap.reset();}touchstart(e,t,i){this._swipePoint||(this._tapTime&&e.timeStamp-this._tapTime>500&&this.reset(),this._tapTime?i.length>0&&(this._swipePoint=t[0],this._swipeTouch=i[0].identifier):this._tap.touchstart(e,t,i));}touchmove(e,t,i){if(this._tapTime){if(this._swipePoint){if(i[0].identifier!==this._swipeTouch)return;const o=t[0],r=o.y-this._swipePoint.y;return this._swipePoint=o,e.preventDefault(),this._active=!0,{zoomDelta:r/128}}}else this._tap.touchmove(e,t,i);}touchend(e,t,i){this._tapTime?this._swipePoint&&0===i.length&&this.reset():this._tap.touchend(e,t,i)&&(this._tapTime=e.timeStamp);}touchcancel(){this.reset();}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}class Ur{constructor(e,t,i){this._el=e,this._mousePan=t,this._touchPan=i;}enable(e){this._inertiaOptions=e||{},this._mousePan.enable(),this._touchPan.enable(),this._el.classList.add("mapboxgl-touch-drag-pan");}disable(){this._mousePan.disable(),this._touchPan.disable(),this._el.classList.remove("mapboxgl-touch-drag-pan");}isEnabled(){return this._mousePan.isEnabled()&&this._touchPan.isEnabled()}isActive(){return this._mousePan.isActive()||this._touchPan.isActive()}}class Nr{constructor(e,t,i){this._pitchWithRotate=e.pitchWithRotate,this._mouseRotate=t,this._mousePitch=i;}enable(){this._mouseRotate.enable(),this._pitchWithRotate&&this._mousePitch.enable();}disable(){this._mouseRotate.disable(),this._mousePitch.disable();}isEnabled(){return this._mouseRotate.isEnabled()&&(!this._pitchWithRotate||this._mousePitch.isEnabled())}isActive(){return this._mouseRotate.isActive()||this._mousePitch.isActive()}}class jr{constructor(e,t,i,o){this._el=e,this._touchZoom=t,this._touchRotate=i,this._tapDragZoom=o,this._rotationDisabled=!1,this._enabled=!0;}enable(e){this._touchZoom.enable(e),this._rotationDisabled||this._touchRotate.enable(e),this._tapDragZoom.enable(),this._el.classList.add("mapboxgl-touch-zoom-rotate");}disable(){this._touchZoom.disable(),this._touchRotate.disable(),this._tapDragZoom.disable(),this._el.classList.remove("mapboxgl-touch-zoom-rotate");}isEnabled(){return this._touchZoom.isEnabled()&&(this._rotationDisabled||this._touchRotate.isEnabled())&&this._tapDragZoom.isEnabled()}isActive(){return this._touchZoom.isActive()||this._touchRotate.isActive()||this._tapDragZoom.isActive()}disableRotation(){this._rotationDisabled=!0,this._touchRotate.disable();}enableRotation(){this._rotationDisabled=!1,this._touchZoom.isEnabled()&&this._touchRotate.enable();}}const Gr=e=>e.zoom||e.drag||e.pitch||e.rotate;class Zr extends e.Event{}class Vr{constructor(){this.constants=[1,1,.01],this.radius=0;}setup(t,i){const o=e.sub([],i,t);this.radius=e.length(o[2]<0?e.div([],o,this.constants):[o[0],o[1],0]);}projectRay(t){e.div(t,t,this.constants),e.normalize(t,t),e.mul$1(t,t,this.constants);const i=e.scale$2([],t,this.radius);if(i[2]>0){const t=e.scale$2([],[0,0,1],e.dot(i,[0,0,1])),o=e.scale$2([],e.normalize([],[i[0],i[1],0]),this.radius),r=e.add([],i,e.scale$2([],e.sub([],e.add([],o,t),i),2));i[0]=r[0],i[1]=r[1];}return i}}function Wr(e){return e.panDelta&&e.panDelta.mag()||e.zoomDelta||e.bearingDelta||e.pitchDelta}class Xr{constructor(t,i){this._map=t,this._el=this._map.getCanvasContainer(),this._handlers=[],this._handlersById={},this._changes=[],this._inertia=new rr(t),this._bearingSnap=i.bearingSnap,this._previousActiveHandlers={},this._trackingEllipsoid=new Vr,this._dragOrigin=null,this._eventsInProgress={},this._addDefaultHandlers(i),e.bindAll(["handleEvent","handleWindowEvent"],this);const o=this._el;this._listeners=[[o,"touchstart",{passive:!0}],[o,"touchmove",{passive:!1}],[o,"touchend",void 0],[o,"touchcancel",void 0],[o,"mousedown",void 0],[o,"mousemove",void 0],[o,"mouseup",void 0],[e.window.document,"mousemove",{capture:!0}],[e.window.document,"mouseup",void 0],[o,"mouseover",void 0],[o,"mouseout",void 0],[o,"dblclick",void 0],[o,"click",void 0],[o,"keydown",{capture:!1}],[o,"keyup",void 0],[o,"wheel",{passive:!1}],[o,"contextmenu",void 0],[e.window,"blur",void 0]];for(const[t,i,o]of this._listeners)t.addEventListener(i,t===e.window.document?this.handleWindowEvent:this.handleEvent,o);}destroy(){for(const[t,i,o]of this._listeners)t.removeEventListener(i,t===e.window.document?this.handleWindowEvent:this.handleEvent,o);}_addDefaultHandlers(e){const t=this._map,i=t.getCanvasContainer();this._add("mapEvent",new hr(t,e));const o=t.boxZoom=new _r(t,e);this._add("boxZoom",o);const r=new fr,n=new kr;t.doubleClickZoom=new Br(n,r),this._add("tapZoom",r),this._add("clickZoom",n);const s=new Fr;this._add("tapDragZoom",s);const a=t.touchPitch=new Dr(t);this._add("touchPitch",a);const l=new yr(e),c=new br(e);t.dragRotate=new Nr(e,l,c),this._add("mouseRotate",l,["mousePitch"]),this._add("mousePitch",c,["mouseRotate"]);const h=new xr(e),u=new wr(t,e);t.dragPan=new Ur(i,h,u),this._add("mousePan",h),this._add("touchPan",u,["touchZoom","touchRotate"]);const _=new Pr,d=new Mr;t.touchZoomRotate=new jr(i,d,_,s),this._add("touchRotate",_,["touchPan","touchZoom"]),this._add("touchZoom",d,["touchPan","touchRotate"]),this._add("blockableMapEvent",new ur(t));const p=t.scrollZoom=new Or(t,this);this._add("scrollZoom",p,["mousePan"]);const m=t.keyboard=new Ar;this._add("keyboard",m);for(const i of ["boxZoom","doubleClickZoom","tapDragZoom","touchPitch","dragRotate","dragPan","touchZoomRotate","scrollZoom","keyboard"])e.interactive&&e[i]&&t[i].enable(e[i]);}_add(e,t,i){this._handlers.push({handlerName:e,handler:t,allowed:i}),this._handlersById[e]=t;}stop(e){if(!this._updatingCamera){for(const{handler:e}of this._handlers)e.reset();this._inertia.clear(),this._fireEvents({},{},e),this._changes=[];}}isActive(){for(const{handler:e}of this._handlers)if(e.isActive())return !0;return !1}isZooming(){return !!this._eventsInProgress.zoom||this._map.scrollZoom.isZooming()}isRotating(){return !!this._eventsInProgress.rotate}isMoving(){return !!Gr(this._eventsInProgress)||this.isZooming()}_isDragging(){return !!this._eventsInProgress.drag}_blockedByActive(e,t,i){for(const o in e)if(o!==i&&(!t||t.indexOf(o)<0))return !0;return !1}handleWindowEvent(e){this.handleEvent(e,`${e.type}Window`);}_getMapTouches(e){const t=[];for(const i of e)this._el.contains(i.target)&&t.push(i);return t}handleEvent(e,t){this._updatingCamera=!0;const i="renderFrame"===e.type,o=i?void 0:e,r={needsRenderFrame:!1},n={},s={},a=e.touches?this._getMapTouches(e.touches):void 0,l=a?m(this._el,a):i?void 0:p(this._el,e);for(const{handlerName:i,handler:c,allowed:h}of this._handlers){if(!c.isEnabled())continue;let u;this._blockedByActive(s,h,i)?c.reset():c[t||e.type]&&(u=c[t||e.type](e,l,a),this.mergeHandlerResult(r,n,u,i,o),u&&u.needsRenderFrame&&this._triggerRenderFrame()),(u||c.isActive())&&(s[i]=c);}const c={};for(const e in this._previousActiveHandlers)s[e]||(c[e]=o);this._previousActiveHandlers=s,(Object.keys(c).length||Wr(r))&&(this._changes.push([r,n,c]),this._triggerRenderFrame()),(Object.keys(s).length||Wr(r))&&this._map._stop(!0),this._updatingCamera=!1;const{cameraAnimation:h}=r;h&&(this._inertia.clear(),this._fireEvents({},{},!0),this._changes=[],h(this._map));}mergeHandlerResult(t,i,o,r,n){if(!o)return;e.extend(t,o);const s={handlerName:r,originalEvent:o.originalEvent||n};void 0!==o.zoomDelta&&(i.zoom=s),void 0!==o.panDelta&&(i.drag=s),void 0!==o.pitchDelta&&(i.pitch=s),void 0!==o.bearingDelta&&(i.rotate=s);}_applyChanges(){const t={},i={},o={};for(const[r,n,s]of this._changes)r.panDelta&&(t.panDelta=(t.panDelta||new e.Point(0,0))._add(r.panDelta)),r.zoomDelta&&(t.zoomDelta=(t.zoomDelta||0)+r.zoomDelta),r.bearingDelta&&(t.bearingDelta=(t.bearingDelta||0)+r.bearingDelta),r.pitchDelta&&(t.pitchDelta=(t.pitchDelta||0)+r.pitchDelta),void 0!==r.around&&(t.around=r.around),void 0!==r.aroundCoord&&(t.aroundCoord=r.aroundCoord),void 0!==r.pinchAround&&(t.pinchAround=r.pinchAround),r.noInertia&&(t.noInertia=r.noInertia),e.extend(i,n),e.extend(o,s);this._updateMapTransform(t,i,o),this._changes=[];}_updateMapTransform(t,i,o){const r=this._map,n=r.transform,s=e=>[e.x,e.y,e.z];if((e=>{const t=this._eventsInProgress.drag;return t&&!this._handlersById[t.handlerName].isActive()})()&&!Wr(t)){const e=n.zoom;n.cameraElevationReference="sea",n.recenterOnTerrain(),n.cameraElevationReference="ground",e!==n.zoom&&this._map._update(!0);}if(n._isCameraConstrained&&r._stop(!0),!Wr(t))return void this._fireEvents(i,o,!0);let{panDelta:a,zoomDelta:l,bearingDelta:c,pitchDelta:h,around:u,aroundCoord:_,pinchAround:d}=t;n._isCameraConstrained&&(l>0&&(l=0),n._isCameraConstrained=!1),void 0!==d&&(u=d),(l||(e=>i[e]&&!this._eventsInProgress[e])("drag"))&&u&&(this._dragOrigin=s(n.pointCoordinate3D(u)),this._trackingEllipsoid.setup(n._camera.position,this._dragOrigin)),n.cameraElevationReference="sea",r._stop(!0),u=u||r.transform.centerPoint,c&&(n.bearing+=c),h&&(n.pitch+=h),n._updateCameraState();const p=[0,0,0];if(a)if("mercator"===n.projection.name){const e=this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u).dir),t=this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u.sub(a)).dir);p[0]=t[0]-e[0],p[1]=t[1]-e[1];}else {const t=n.pointCoordinate(u);if("globe"===n.projection.name){a=a.rotate(-n.angle);const i=n._pixelsPerMercatorPixel/n.worldSize;p[0]=-a.x*e.mercatorScale(e.latFromMercatorY(t.y))*i,p[1]=-a.y*e.mercatorScale(n.center.lat)*i;}else {const e=n.pointCoordinate(u.sub(a));t&&e&&(p[0]=e.x-t.x,p[1]=e.y-t.y);}}const m=n.zoom,f=[0,0,0];if(l){const t=s(_||n.pointCoordinate3D(u)),i={dir:e.normalize([],e.sub([],t,n._camera.position))};if(i.dir[2]<0){const o=n.zoomDeltaToMovement(t,l);e.scale$2(f,i.dir,o);}}const g=e.add(p,p,f);n._translateCameraConstrained(g),l&&Math.abs(n.zoom-m)>1e-4&&n.recenterOnTerrain(),n.cameraElevationReference="ground",this._map._update(),t.noInertia||this._inertia.record(t),this._fireEvents(i,o,!0);}_fireEvents(t,i,o){const r=Gr(this._eventsInProgress),n=Gr(t),s={};for(const e in t){const{originalEvent:i}=t[e];this._eventsInProgress[e]||(s[`${e}start`]=i),this._eventsInProgress[e]=t[e];}!r&&n&&this._fireEvent("movestart",n.originalEvent);for(const e in s)this._fireEvent(e,s[e]);n&&this._fireEvent("move",n.originalEvent);for(const e in t){const{originalEvent:i}=t[e];this._fireEvent(e,i);}const a={};let l;for(const e in this._eventsInProgress){const{handlerName:t,originalEvent:o}=this._eventsInProgress[e];this._handlersById[t].isActive()||(delete this._eventsInProgress[e],l=i[t]||o,a[`${e}end`]=l);}for(const e in a)this._fireEvent(e,a[e]);const c=Gr(this._eventsInProgress);if(o&&(r||n)&&!c){this._updatingCamera=!0;const t=this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),i=e=>0!==e&&-this._bearingSnap<e&&e<this._bearingSnap;t?(i(t.bearing||this._map.getBearing())&&(t.bearing=0),this._map.easeTo(t,{originalEvent:l})):(this._map.fire(new e.Event("moveend",{originalEvent:l})),i(this._map.getBearing())&&this._map.resetNorth()),this._updatingCamera=!1;}}_fireEvent(t,i){this._map.fire(new e.Event(t,i?{originalEvent:i}:{}));}_requestFrame(){return this._map.triggerRepaint(),this._map._renderTaskQueue.add((e=>{this._frameId=void 0,this.handleEvent(new Zr("renderFrame",{timeStamp:e})),this._applyChanges();}))}_triggerRenderFrame(){void 0===this._frameId&&(this._frameId=this._requestFrame());}}const qr="map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";class $r extends e.Evented{constructor(t,i){super(),this._moving=!1,this._zooming=!1,this.transform=t,this._bearingSnap=i.bearingSnap,this._respectPrefersReducedMotion=!1!==i.respectPrefersReducedMotion,e.bindAll(["_renderFrameCallback"],this);}getCenter(){return new e.LngLat(this.transform.center.lng,this.transform.center.lat)}setCenter(e,t){return this.jumpTo({center:e},t)}panBy(t,i,o){return t=e.Point.convert(t).mult(-1),this.panTo(this.transform.center,e.extend({offset:t},i),o)}panTo(t,i,o){return this.easeTo(e.extend({center:t},i),o)}getZoom(){return this.transform.zoom}setZoom(e,t){return this.jumpTo({zoom:e},t),this}zoomTo(t,i,o){return this.easeTo(e.extend({zoom:t},i),o)}zoomIn(e,t){return this.zoomTo(this.getZoom()+1,e,t),this}zoomOut(e,t){return this.zoomTo(this.getZoom()-1,e,t),this}getBearing(){return this.transform.bearing}setBearing(e,t){return this.jumpTo({bearing:e},t),this}getPadding(){return this.transform.padding}setPadding(e,t){return this.jumpTo({padding:e},t),this}rotateTo(t,i,o){return this.easeTo(e.extend({bearing:t},i),o)}resetNorth(t,i){return this.rotateTo(0,e.extend({duration:1e3},t),i),this}resetNorthPitch(t,i){return this.easeTo(e.extend({bearing:0,pitch:0,duration:1e3},t),i),this}snapToNorth(e,t){return Math.abs(this.getBearing())<this._bearingSnap?this.resetNorth(e,t):this}getPitch(){return this.transform.pitch}setPitch(e,t){return this.jumpTo({pitch:e},t),this}cameraForBounds(t,i){t=e.LngLatBounds.convert(t);const o=i&&i.bearing||0,r=i&&i.pitch||0,n=t.getNorthWest(),s=t.getSouthEast();return this._cameraForBounds(this.transform,n,s,o,r,i)}_extendCameraOptions(t){const i={top:0,bottom:0,right:0,left:0};if("number"==typeof(t=e.extend({padding:i,offset:[0,0],maxZoom:this.transform.maxZoom},t)).padding){const e=t.padding;t.padding={top:e,bottom:e,right:e,left:e};}return t.padding=e.extend(i,t.padding),t}_minimumAABBFrustumDistance(e,t){const i=t.max[0]-t.min[0],o=t.max[1]-t.min[1];return i/o>e.aspect?i/(2*Math.tan(.5*e.fovX)*e.aspect):o/(2*Math.tan(.5*e.fovY)*e.aspect)}_cameraForBoundsOnGlobe(t,i,o,r,n,s){const a=t.clone(),l=this._extendCameraOptions(s);a.bearing=r,a.pitch=n;const c=e.LngLat.convert(i),h=e.LngLat.convert(o),u=.5*(c.lat+h.lat),_=.5*(c.lng+h.lng),d=e.latLngToECEF(u,_),p=e.normalize([],d),m=e.normalize([],e.cross([],p,[0,1,0])),f=e.cross([],m,p),g=[m[0],m[1],m[2],0,f[0],f[1],f[2],0,p[0],p[1],p[2],0,0,0,0,1],v=[d,e.latLngToECEF(c.lat,c.lng),e.latLngToECEF(h.lat,c.lng),e.latLngToECEF(h.lat,h.lng),e.latLngToECEF(c.lat,h.lng),e.latLngToECEF(u,c.lng),e.latLngToECEF(u,h.lng),e.latLngToECEF(c.lat,_),e.latLngToECEF(h.lat,_)];let x=e.Aabb.fromPoints(v.map((t=>[e.dot(m,t),e.dot(f,t),e.dot(p,t)])));const y=e.transformMat4([],x.center,g);0===e.squaredLength(y)&&e.set(y,0,0,1),e.normalize(y,y),e.scale$2(y,y,e.GLOBE_RADIUS),a.center=e.ecefToLatLng(y);const b=a.getWorldToCameraMatrix(),w=e.invert(new Float64Array(16),b);x=e.Aabb.applyTransform(x,e.multiply([],b,g)),e.transformMat4(y,y,b);const T=.5*(x.max[2]-x.min[2]),E=this._minimumAABBFrustumDistance(a,x),C=e.scale$2([],[0,0,1],T),M=e.add(C,y,C),I=E+(0===a.pitch?0:e.distance(y,M)),P=a.globeCenterInViewSpace,S=e.sub([],y,[P[0],P[1],P[2]]);e.normalize(S,S),e.scale$2(S,S,I);const D=e.add([],y,S);e.transformMat4(D,D,w);const L=e.earthRadius/e.GLOBE_RADIUS,A=e.length(D),z=e.mercatorZfromAltitude(Math.max(A*L-e.earthRadius,Number.EPSILON),0),R=Math.min(a.zoomFromMercatorZAdjusted(z),l.maxZoom);return R>.5*(e.GLOBE_ZOOM_THRESHOLD_MIN+e.GLOBE_ZOOM_THRESHOLD_MAX)?(a.setProjection({name:"mercator"}),a.zoom=R,this._cameraForBounds(a,i,o,r,n,s)):{center:a.center,zoom:R,bearing:r,pitch:n}}queryTerrainElevation(t,i){const o=this.transform.elevation;return o?(i=e.extend({},{exaggerated:!0},i),o.getAtPoint(e.MercatorCoordinate.fromLngLat(t),null,i.exaggerated)):null}_cameraForBounds(t,i,o,r,n,s){if("globe"===t.projection.name)return this._cameraForBoundsOnGlobe(t,i,o,r,n,s);const a=t.clone(),l=this._extendCameraOptions(s),c=a.padding;a.bearing=r,a.pitch=n;const h=e.LngLat.convert(i),u=e.LngLat.convert(o),_=new e.LngLat(h.lng,u.lat),d=new e.LngLat(u.lng,h.lat),p=a.project(h),m=a.project(u),f=this.queryTerrainElevation(h),g=this.queryTerrainElevation(u),v=this.queryTerrainElevation(_),x=this.queryTerrainElevation(d),y=[[p.x,p.y,Math.min(f||0,g||0,v||0,x||0)],[m.x,m.y,Math.max(f||0,g||0,v||0,x||0)]];let b=e.Aabb.fromPoints(y);const w=a.getWorldToCameraMatrix(),T=e.invert(new Float64Array(16),w);b=e.Aabb.applyTransform(b,w);const E=e.sub([],b.max,b.min),C=c.left||0,M=c.right||0,I=c.bottom||0,P=c.top||0,{left:S,right:D,top:L,bottom:A}=l.padding,z=.5*(C+M),R=.5*(P+I),O=Math.min(a.scaleZoom(a.scale*Math.min((a.width-(C+M+S+D))/E[0],(a.height-(I+P+A+L))/E[1])),l.maxZoom),B=a.scale/a.zoomScale(O);b=new e.Aabb([b.min[0]-(S+z)*B,b.min[1]-(A+R)*B,b.min[2]],[b.max[0]+(D+z)*B,b.max[1]+(L+R)*B,b.max[2]]);const k=.5*E[2],F=this._minimumAABBFrustumDistance(a,b),U=[0,0,1,0];e.transformMat4$1(U,U,w),e.normalize$2(U,U);const N=e.scale$2([],U,F+k),j=e.add([],b.center,N),G=("number"==typeof l.offset.x&&"number"==typeof l.offset.y?new e.Point(l.offset.x,l.offset.y):e.Point.convert(l.offset)).rotate(-e.degToRad(r));b.center[0]-=G.x*B,b.center[1]+=G.y*B,e.transformMat4(b.center,b.center,T),e.transformMat4(j,j,T);const Z=[b.center[0],b.center[1],j[2]*a.pixelsPerMeter];e.scale$2(Z,Z,1/a.worldSize);const V=e.lngFromMercatorX(Z[0]),W=e.latFromMercatorY(Z[1]),X=Math.min(a._zoomFromMercatorZ(Z[2]),l.maxZoom),q=new e.LngLat(V,W);return a.mercatorFromTransition&&X<.5*(e.GLOBE_ZOOM_THRESHOLD_MIN+e.GLOBE_ZOOM_THRESHOLD_MAX)?(a.setProjection({name:"globe"}),a.zoom=X,this._cameraForBounds(a,i,o,r,n,s)):{center:q,zoom:X,bearing:r,pitch:n}}fitBounds(e,t,i){const o=this.cameraForBounds(e,t);return this._fitInternal(o,t,i)}fitScreenCoordinates(t,i,o,r,n){const s=e.Point.convert(t),a=e.Point.convert(i),l=new e.Point(Math.min(s.x,a.x),Math.min(s.y,a.y)),c=new e.Point(Math.max(s.x,a.x),Math.max(s.y,a.y));if("mercator"===this.transform.projection.name&&this.transform.anyCornerOffEdge(s,a))return this;const h=this.transform.pointLocation3D(l),u=this.transform.pointLocation3D(c),_=this.transform.pointLocation3D(new e.Point(l.x,c.y)),d=this.transform.pointLocation3D(new e.Point(c.x,l.y)),p=[Math.min(h.lng,u.lng,_.lng,d.lng),Math.min(h.lat,u.lat,_.lat,d.lat)],m=[Math.max(h.lng,u.lng,_.lng,d.lng),Math.max(h.lat,u.lat,_.lat,d.lat)],f=r&&r.pitch?r.pitch:this.getPitch(),g=this._cameraForBounds(this.transform,p,m,o,f,r);return this._fitInternal(g,r,n)}_fitInternal(t,i,o){return t?(delete(i=e.extend(t,i)).padding,i.linear?this.easeTo(i,o):this.flyTo(i,o)):this}jumpTo(t,i){this.stop();const o=t.preloadOnly?this.transform.clone():this.transform;let r=!1,n=!1,s=!1;return "zoom"in t&&o.zoom!==+t.zoom&&(r=!0,o.zoom=+t.zoom),void 0!==t.center&&(o.center=e.LngLat.convert(t.center)),"bearing"in t&&o.bearing!==+t.bearing&&(n=!0,o.bearing=+t.bearing),"pitch"in t&&o.pitch!==+t.pitch&&(s=!0,o.pitch=+t.pitch),null==t.padding||o.isPaddingEqual(t.padding)||(o.padding=t.padding),t.preloadOnly?(this._preloadTiles(o),this):(this.fire(new e.Event("movestart",i)).fire(new e.Event("move",i)),r&&this.fire(new e.Event("zoomstart",i)).fire(new e.Event("zoom",i)).fire(new e.Event("zoomend",i)),n&&this.fire(new e.Event("rotatestart",i)).fire(new e.Event("rotate",i)).fire(new e.Event("rotateend",i)),s&&this.fire(new e.Event("pitchstart",i)).fire(new e.Event("pitch",i)).fire(new e.Event("pitchend",i)),this.fire(new e.Event("moveend",i)))}getFreeCameraOptions(){return this.transform.projection.supportsFreeCamera||e.warnOnce(qr),this.transform.getFreeCameraOptions()}setFreeCameraOptions(t,i){const o=this.transform;if(!o.projection.supportsFreeCamera)return e.warnOnce(qr),this;this.stop();const r=o.zoom,n=o.pitch,s=o.bearing;o.setFreeCameraOptions(t);const a=r!==o.zoom,l=n!==o.pitch,c=s!==o.bearing;return this.fire(new e.Event("movestart",i)).fire(new e.Event("move",i)),a&&this.fire(new e.Event("zoomstart",i)).fire(new e.Event("zoom",i)).fire(new e.Event("zoomend",i)),c&&this.fire(new e.Event("rotatestart",i)).fire(new e.Event("rotate",i)).fire(new e.Event("rotateend",i)),l&&this.fire(new e.Event("pitchstart",i)).fire(new e.Event("pitch",i)).fire(new e.Event("pitchend",i)),this.fire(new e.Event("moveend",i)),this}easeTo(t,i){this._stop(!1,t.easeId),(!1===(t=e.extend({offset:[0,0],duration:500,easing:e.ease},t)).animate||this._prefersReducedMotion(t))&&(t.duration=0);const o=this.transform,r=this.getZoom(),n=this.getBearing(),s=this.getPitch(),a=this.getPadding(),l="zoom"in t?+t.zoom:r,c="bearing"in t?this._normalizeBearing(t.bearing,n):n,h="pitch"in t?+t.pitch:s,u="padding"in t?t.padding:o.padding,_=e.Point.convert(t.offset);let d,p,m;if("globe"===o.projection.name){const i=e.MercatorCoordinate.fromLngLat(o.center),r=_.rotate(-o.angle);i.x+=r.x/o.worldSize,i.y+=r.y/o.worldSize;const n=i.toLngLat(),s=e.LngLat.convert(t.center||n);this._normalizeCenter(s),d=o.centerPoint.add(r),p=new e.Point(i.x,i.y).mult(o.worldSize),m=new e.Point(e.mercatorXfromLng(s.lng),e.mercatorYfromLat(s.lat)).mult(o.worldSize).sub(p);}else {d=o.centerPoint.add(_);const i=o.pointLocation(d),r=e.LngLat.convert(t.center||i);this._normalizeCenter(r),p=o.project(i),m=o.project(r).sub(p);}const f=o.zoomScale(l-r);let g,v;t.around&&(g=e.LngLat.convert(t.around),v=o.locationPoint(g));const x=this._zooming||l!==r,y=this._rotating||n!==c,b=this._pitching||h!==s,w=!o.isPaddingEqual(u),T=o=>T=>{if(x&&(o.zoom=e.number(r,l,T)),y&&(o.bearing=e.number(n,c,T)),b&&(o.pitch=e.number(s,h,T)),w&&(o.interpolatePadding(a,u,T),d=o.centerPoint.add(_)),g)o.setLocationAtPoint(g,v);else {const e=o.zoomScale(o.zoom-r),t=l>r?Math.min(2,f):Math.max(.5,f),i=Math.pow(t,1-T),n=o.unproject(p.add(m.mult(T*i)).mult(e));o.setLocationAtPoint(o.renderWorldCopies?n.wrap():n,d);}return t.preloadOnly||this._fireMoveEvents(i),o};if(t.preloadOnly){const e=this._emulate(T,t.duration,o);return this._preloadTiles(e),this}const E={moving:this._moving,zooming:this._zooming,rotating:this._rotating,pitching:this._pitching};return this._zooming=x,this._rotating=y,this._pitching=b,this._padding=w,this._easeId=t.easeId,this._prepareEase(i,t.noMoveStart,E),this._ease(T(o),(e=>{o.recenterOnTerrain(),this._afterEase(i,e);}),t),this}_prepareEase(t,i,o={}){this._moving=!0,this.transform.cameraElevationReference="sea",i||o.moving||this.fire(new e.Event("movestart",t)),this._zooming&&!o.zooming&&this.fire(new e.Event("zoomstart",t)),this._rotating&&!o.rotating&&this.fire(new e.Event("rotatestart",t)),this._pitching&&!o.pitching&&this.fire(new e.Event("pitchstart",t));}_fireMoveEvents(t){this.fire(new e.Event("move",t)),this._zooming&&this.fire(new e.Event("zoom",t)),this._rotating&&this.fire(new e.Event("rotate",t)),this._pitching&&this.fire(new e.Event("pitch",t));}_afterEase(t,i){if(this._easeId&&i&&this._easeId===i)return;this._easeId=void 0,this.transform.cameraElevationReference="ground";const o=this._zooming,r=this._rotating,n=this._pitching;this._moving=!1,this._zooming=!1,this._rotating=!1,this._pitching=!1,this._padding=!1,o&&this.fire(new e.Event("zoomend",t)),r&&this.fire(new e.Event("rotateend",t)),n&&this.fire(new e.Event("pitchend",t)),this.fire(new e.Event("moveend",t));}flyTo(t,i){if(this._prefersReducedMotion(t)){const o=e.pick(t,["center","zoom","bearing","pitch","around"]);return this.jumpTo(o,i)}this.stop(),t=e.extend({offset:[0,0],speed:1.2,curve:1.42,easing:e.ease},t);const o=this.transform,r=this.getZoom(),n=this.getBearing(),s=this.getPitch(),a=this.getPadding(),l="zoom"in t?e.clamp(+t.zoom,o.minZoom,o.maxZoom):r,c="bearing"in t?this._normalizeBearing(t.bearing,n):n,h="pitch"in t?+t.pitch:s,u="padding"in t?t.padding:o.padding,_=o.zoomScale(l-r),d=e.Point.convert(t.offset);let p=o.centerPoint.add(d);const m=o.pointLocation(p),f=e.LngLat.convert(t.center||m);this._normalizeCenter(f);const g=o.project(m),v=o.project(f).sub(g);let x=t.curve;const y=Math.max(o.width,o.height),b=y/_,w=v.mag();if("minZoom"in t){const i=e.clamp(Math.min(t.minZoom,r,l),o.minZoom,o.maxZoom),n=y/o.zoomScale(i-r);x=Math.sqrt(n/w*2);}const T=x*x;function E(e){const t=(b*b-y*y+(e?-1:1)*T*T*w*w)/(2*(e?b:y)*T*w);return Math.log(Math.sqrt(t*t+1)-t)}function C(e){return (Math.exp(e)-Math.exp(-e))/2}function M(e){return (Math.exp(e)+Math.exp(-e))/2}const I=E(0);let P=function(e){return M(I)/M(I+x*e)},S=function(e){return y*((M(I)*(C(t=I+x*e)/M(t))-C(I))/T)/w;var t;},D=(E(1)-I)/x;if(Math.abs(w)<1e-6||!isFinite(D)){if(Math.abs(y-b)<1e-6)return this.easeTo(t,i);const e=b<y?-1:1;D=Math.abs(Math.log(b/y))/x,S=function(){return 0},P=function(t){return Math.exp(e*x*t)};}t.duration="duration"in t?+t.duration:1e3*D/("screenSpeed"in t?+t.screenSpeed/x:+t.speed),t.maxDuration&&t.duration>t.maxDuration&&(t.duration=0);const L=n!==c,A=h!==s,z=!o.isPaddingEqual(u),R=o=>_=>{const m=_*D,x=1/P(m);o.zoom=1===_?l:r+o.scaleZoom(x),L&&(o.bearing=e.number(n,c,_)),A&&(o.pitch=e.number(s,h,_)),z&&(o.interpolatePadding(a,u,_),p=o.centerPoint.add(d));const y=1===_?f:o.unproject(g.add(v.mult(S(m))).mult(x));return o.setLocationAtPoint(o.renderWorldCopies?y.wrap():y,p),o._updateCameraOnTerrain(),t.preloadOnly||this._fireMoveEvents(i),o};if(t.preloadOnly){const e=this._emulate(R,t.duration,o);return this._preloadTiles(e),this}return this._zooming=!0,this._rotating=L,this._pitching=A,this._padding=z,this._prepareEase(i,!1),this._ease(R(o),(()=>this._afterEase(i)),t),this}isEasing(){return !!this._easeFrameId}stop(){return this._stop()}_stop(e,t){if(this._easeFrameId&&(this._cancelRenderFrame(this._easeFrameId),this._easeFrameId=void 0,this._onEaseFrame=void 0),this._onEaseEnd){const e=this._onEaseEnd;this._onEaseEnd=void 0,e.call(this,t);}if(!e){const e=this.handlers;e&&e.stop(!1);}return this}_ease(t,i,o){!1===o.animate||0===o.duration?(t(1),i()):(this._easeStart=e.exported.now(),this._easeOptions=o,this._onEaseFrame=t,this._onEaseEnd=i,this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback));}_renderFrameCallback(){const t=Math.min((e.exported.now()-this._easeStart)/this._easeOptions.duration,1),i=this._onEaseFrame;i&&i(this._easeOptions.easing(t)),t<1?this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback):this.stop();}_normalizeBearing(t,i){t=e.wrap(t,-180,180);const o=Math.abs(t-i);return Math.abs(t-360-i)<o&&(t-=360),Math.abs(t+360-i)<o&&(t+=360),t}_normalizeCenter(e){const t=this.transform;if(!t.renderWorldCopies||t.maxBounds)return;const i=e.lng-t.center.lng;e.lng+=i>180?-360:i<-180?360:0;}_prefersReducedMotion(t){return this._respectPrefersReducedMotion&&e.exported.prefersReducedMotion&&!(t&&t.essential)}_emulate(e,t,i){const o=Math.ceil(15*t/1e3),r=[],n=e(i.clone());for(let e=0;e<=o;e++){const t=n(e/o);r.push(t.clone());}return r}}class Hr{constructor(t={}){this.options=t,e.bindAll(["_toggleAttribution","_updateEditLink","_updateData","_updateCompact"],this);}getDefaultPosition(){return "bottom-right"}onAdd(e){const t=this.options&&this.options.compact;return this._map=e,this._container=n("div","mapboxgl-ctrl mapboxgl-ctrl-attrib"),this._compactButton=n("button","mapboxgl-ctrl-attrib-button",this._container),n("span","mapboxgl-ctrl-icon",this._compactButton).setAttribute("aria-hidden","true"),this._compactButton.type="button",this._compactButton.addEventListener("click",this._toggleAttribution),this._setElementTitle(this._compactButton,"ToggleAttribution"),this._innerContainer=n("div","mapboxgl-ctrl-attrib-inner",this._container),this._innerContainer.setAttribute("role","list"),t&&this._container.classList.add("mapboxgl-compact"),this._updateAttributions(),this._updateEditLink(),this._map.on("styledata",this._updateData),this._map.on("sourcedata",this._updateData),this._map.on("moveend",this._updateEditLink),void 0===t&&(this._map.on("resize",this._updateCompact),this._updateCompact()),this._container}onRemove(){this._container.remove(),this._map.off("styledata",this._updateData),this._map.off("sourcedata",this._updateData),this._map.off("moveend",this._updateEditLink),this._map.off("resize",this._updateCompact),this._map=void 0,this._attribHTML=void 0;}_setElementTitle(e,t){const i=this._map._getUIString(`AttributionControl.${t}`);e.setAttribute("aria-label",i),e.removeAttribute("title"),e.firstElementChild&&e.firstElementChild.setAttribute("title",i);}_toggleAttribution(){this._container.classList.contains("mapboxgl-compact-show")?(this._container.classList.remove("mapboxgl-compact-show"),this._compactButton.setAttribute("aria-expanded","false")):(this._container.classList.add("mapboxgl-compact-show"),this._compactButton.setAttribute("aria-expanded","true"));}_updateEditLink(){let t=this._editLink;t||(t=this._editLink=this._container.querySelector(".mapbox-improve-map"));const i=[{key:"owner",value:this.styleOwner},{key:"id",value:this.styleId},{key:"access_token",value:this._map._requestManager._customAccessToken||e.config.ACCESS_TOKEN}];if(t){const o=i.reduce(((e,t,o)=>(t.value&&(e+=`${t.key}=${t.value}${o<i.length-1?"&":""}`),e)),"?");t.href=`${e.config.FEEDBACK_URL}/${o}#${Jo(this._map,!0)}`,t.rel="noopener nofollow",this._setElementTitle(t,"MapFeedback");}}_updateData(e){!e||"metadata"!==e.sourceDataType&&"visibility"!==e.sourceDataType&&"style"!==e.dataType||(this._updateAttributions(),this._updateEditLink());}_updateAttributions(){if(!this._map.style)return;let e=[];if(this._map.style.stylesheet){const e=this._map.style.stylesheet;this.styleOwner=e.owner,this.styleId=e.id;}const t=this._map.style._sourceCaches;for(const i in t){const o=t[i];if(o.used){const t=o.getSource();t.attribution&&e.indexOf(t.attribution)<0&&e.push(t.attribution);}}e.sort(((e,t)=>e.length-t.length)),e=e.filter(((t,i)=>{for(let o=i+1;o<e.length;o++)if(e[o].indexOf(t)>=0)return !1;return !0})),this.options.customAttribution&&(Array.isArray(this.options.customAttribution)?e=[...this.options.customAttribution,...e]:e.unshift(this.options.customAttribution));const i=e.join(" | ");i!==this._attribHTML&&(this._attribHTML=i,e.length?(this._innerContainer.innerHTML=i,this._container.classList.remove("mapboxgl-attrib-empty")):this._container.classList.add("mapboxgl-attrib-empty"),this._editLink=null);}_updateCompact(){this._map.getCanvasContainer().offsetWidth<=640?this._container.classList.add("mapboxgl-compact"):this._container.classList.remove("mapboxgl-compact","mapboxgl-compact-show");}}class Yr{constructor(){e.bindAll(["_updateLogo","_updateCompact"],this);}onAdd(e){this._map=e,this._container=n("div","mapboxgl-ctrl");const t=n("a","mapboxgl-ctrl-logo");return t.target="_blank",t.rel="noopener nofollow",t.href="https://www.mapbox.com/",t.setAttribute("aria-label",this._map._getUIString("LogoControl.Title")),t.setAttribute("rel","noopener nofollow"),this._container.appendChild(t),this._container.style.display="none",this._map.on("sourcedata",this._updateLogo),this._updateLogo(),this._map.on("resize",this._updateCompact),this._updateCompact(),this._container}onRemove(){this._container.remove(),this._map.off("sourcedata",this._updateLogo),this._map.off("resize",this._updateCompact);}getDefaultPosition(){return "bottom-left"}_updateLogo(e){e&&"metadata"!==e.sourceDataType||(this._container.style.display=this._logoRequired()?"block":"none");}_logoRequired(){if(!this._map.style)return !0;const e=this._map.style._sourceCaches;if(0===Object.entries(e).length)return !0;for(const t in e){const i=e[t].getSource();if(i.hasOwnProperty("mapbox_logo")&&!i.mapbox_logo)return !1}return !0}_updateCompact(){const e=this._container.children;if(e.length){const t=e[0];this._map.getCanvasContainer().offsetWidth<250?t.classList.add("mapboxgl-compact"):t.classList.remove("mapboxgl-compact");}}}class Kr{constructor(){this._queue=[],this._id=0,this._cleared=!1,this._currentlyRunning=!1;}add(e){const t=++this._id;return this._queue.push({callback:e,id:t,cancelled:!1}),t}remove(e){const t=this._currentlyRunning,i=t?this._queue.concat(t):this._queue;for(const t of i)if(t.id===e)return void(t.cancelled=!0)}run(e=0){const t=this._currentlyRunning=this._queue;this._queue=[];for(const i of t)if(!i.cancelled&&(i.callback(e),this._cleared))break;this._cleared=!1,this._currentlyRunning=!1;}clear(){this._currentlyRunning&&(this._cleared=!0),this._queue=[];}}function Jr(t,i,o){if(t=new e.LngLat(t.lng,t.lat),i){const r=new e.LngLat(t.lng-360,t.lat),n=new e.LngLat(t.lng+360,t.lat),s=360*Math.ceil(Math.abs(t.lng-o.center.lng)/360),a=o.locationPoint(t).distSqr(i),l=i.x<0||i.y<0||i.x>o.width||i.y>o.height;o.locationPoint(r).distSqr(i)<a&&(l||Math.abs(r.lng-o.center.lng)<s)?t=r:o.locationPoint(n).distSqr(i)<a&&(l||Math.abs(n.lng-o.center.lng)<s)&&(t=n);}for(;Math.abs(t.lng-o.center.lng)>180;){const e=o.locationPoint(t);if(e.x>=0&&e.y>=0&&e.x<=o.width&&e.y<=o.height)break;t.lng>o.center.lng?t.lng-=360:t.lng+=360;}return t}const Qr={center:"translate(-50%,-50%)",top:"translate(-50%,0)","top-left":"translate(0,0)","top-right":"translate(-100%,0)",bottom:"translate(-50%,-100%)","bottom-left":"translate(0,-100%)","bottom-right":"translate(-100%,-100%)",left:"translate(0,-50%)",right:"translate(-100%,-50%)"};class en extends e.Evented{constructor(t,i){if(super(),(t instanceof e.window.HTMLElement||i)&&(t=e.extend({element:t},i)),e.bindAll(["_update","_onMove","_onUp","_addDragHandler","_onMapClick","_onKeyPress","_clearFadeTimer"],this),this._anchor=t&&t.anchor||"center",this._color=t&&t.color||"#3FB1CE",this._scale=t&&t.scale||1,this._draggable=t&&t.draggable||!1,this._clickTolerance=t&&t.clickTolerance||0,this._isDragging=!1,this._state="inactive",this._rotation=t&&t.rotation||0,this._rotationAlignment=t&&t.rotationAlignment||"auto",this._pitchAlignment=t&&t.pitchAlignment&&t.pitchAlignment||"auto",this._updateMoving=()=>this._update(!0),this._occludedOpacity=t&&t.occludedOpacity||.2,t&&t.element)this._element=t.element,this._offset=e.Point.convert(t&&t.offset||[0,0]);else {this._defaultMarker=!0,this._element=n("div");const i=41,o=27,r=s("svg",{display:"block",height:i*this._scale+"px",width:o*this._scale+"px",viewBox:`0 0 ${o} ${i}`},this._element),a=s("radialGradient",{id:"shadowGradient"},s("defs",{},r));s("stop",{offset:"10%","stop-opacity":.4},a),s("stop",{offset:"100%","stop-opacity":.05},a),s("ellipse",{cx:13.5,cy:34.8,rx:10.5,ry:5.25,fill:"url(#shadowGradient)"},r),s("path",{fill:this._color,d:"M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"},r),s("path",{opacity:.25,d:"M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"},r),s("circle",{fill:"white",cx:13.5,cy:13.5,r:5.5},r),this._offset=e.Point.convert(t&&t.offset||[0,-14]);}this._element.hasAttribute("aria-label")||this._element.setAttribute("aria-label","Map marker"),this._element.classList.add("mapboxgl-marker"),this._element.addEventListener("dragstart",(e=>{e.preventDefault();})),this._element.addEventListener("mousedown",(e=>{e.preventDefault();}));const o=this._element.classList;for(const e in Qr)o.remove(`mapboxgl-marker-anchor-${e}`);o.add(`mapboxgl-marker-anchor-${this._anchor}`),this._popup=null;}addTo(e){return e===this._map||(this.remove(),this._map=e,e.getCanvasContainer().appendChild(this._element),e.on("move",this._updateMoving),e.on("moveend",this._update),e.on("remove",this._clearFadeTimer),e._addMarker(this),this.setDraggable(this._draggable),this._update(),e.on("click",this._onMapClick)),this}remove(){const e=this._map;return e&&(e.off("click",this._onMapClick),e.off("move",this._updateMoving),e.off("moveend",this._update),e.off("mousedown",this._addDragHandler),e.off("touchstart",this._addDragHandler),e.off("mouseup",this._onUp),e.off("touchend",this._onUp),e.off("mousemove",this._onMove),e.off("touchmove",this._onMove),e.off("remove",this._clearFadeTimer),e._removeMarker(this),this._map=void 0),this._clearFadeTimer(),this._element.remove(),this._popup&&this._popup.remove(),this}getLngLat(){return this._lngLat}setLngLat(t){return this._lngLat=e.LngLat.convert(t),this._pos=null,this._popup&&this._popup.setLngLat(this._lngLat),this._update(!0),this}getElement(){return this._element}setPopup(e){if(this._popup&&(this._popup.remove(),this._popup=null,this._element.removeAttribute("role"),this._element.removeEventListener("keypress",this._onKeyPress),this._originalTabIndex||this._element.removeAttribute("tabindex")),e){if(!("offset"in e.options)){const t=38.1,i=13.5,o=Math.sqrt(Math.pow(i,2)/2);e.options.offset=this._defaultMarker?{top:[0,0],"top-left":[0,0],"top-right":[0,0],bottom:[0,-t],"bottom-left":[o,-1*(t-i+o)],"bottom-right":[-o,-1*(t-i+o)],left:[i,-1*(t-i)],right:[-i,-1*(t-i)]}:this._offset;}this._popup=e,e._marker=this,this._lngLat&&this._popup.setLngLat(this._lngLat),this._element.setAttribute("role","button"),this._originalTabIndex=this._element.getAttribute("tabindex"),this._originalTabIndex||this._element.setAttribute("tabindex","0"),this._element.addEventListener("keypress",this._onKeyPress),this._element.setAttribute("aria-expanded","false");}return this}_onKeyPress(e){const t=e.code,i=e.charCode||e.keyCode;"Space"!==t&&"Enter"!==t&&32!==i&&13!==i||this.togglePopup();}_onMapClick(e){const t=e.originalEvent.target,i=this._element;this._popup&&(t===i||i.contains(t))&&this.togglePopup();}getPopup(){return this._popup}togglePopup(){const e=this._popup;return e?(e.isOpen()?(e.remove(),this._element.setAttribute("aria-expanded","false")):this._map&&(e.addTo(this._map),this._element.setAttribute("aria-expanded","true")),this):this}_behindTerrain(){const e=this._map,t=this._pos;if(!e||!t)return !1;const i=e.unproject(t),o=e.getFreeCameraOptions();if(!o.position)return !1;const r=o.position.toLngLat();return r.distanceTo(i)<.9*r.distanceTo(this._lngLat)}_evaluateOpacity(){const t=this._map;if(!t)return;const i=this._pos;if(!i||i.x<0||i.x>t.transform.width||i.y<0||i.y>t.transform.height)return void this._clearFadeTimer();const o=t.unproject(i);let r;t._showingGlobe()&&e.isLngLatBehindGlobe(t.transform,this._lngLat)?r=0:(r=1-t._queryFogOpacity(o),t.transform._terrainEnabled()&&t.getTerrain()&&this._behindTerrain()&&(r*=this._occludedOpacity)),this._element.style.opacity=`${r}`,this._element.style.pointerEvents=r>0?"auto":"none",this._popup&&this._popup._setOpacity(r),this._fadeTimer=null;}_clearFadeTimer(){this._fadeTimer&&(clearTimeout(this._fadeTimer),this._fadeTimer=null);}_updateDOM(){const e=this._pos;if(!e||!this._map)return;const t=this._offset.mult(this._scale);this._element.style.transform=`\n            translate(${e.x}px,${e.y}px)\n            ${Qr[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t.x}px,${t.y}px)\n        `;}_calculateXYTransform(){const t=this._pos,i=this._map,o=this.getPitchAlignment();if(!i||!t||"map"!==o)return "";if(!i._showingGlobe()){const e=i.getPitch();return e?`rotateX(${e}deg)`:""}const r=e.radToDeg(e.globeTiltAtLngLat(i.transform,this._lngLat)),n=t.sub(e.globeCenterToScreenPoint(i.transform)),s=Math.abs(n.x)+Math.abs(n.y);if(0===s)return "";const a=r/s;return `rotateX(${-n.y*a}deg) rotateY(${n.x*a}deg)`}_calculateZTransform(){const t=this._pos,i=this._map;if(!i||!t)return "";let o=0;const r=this.getRotationAlignment();if("map"===r)if(i._showingGlobe()){const t=i.project(new e.LngLat(this._lngLat.lng,this._lngLat.lat+.001)),r=i.project(new e.LngLat(this._lngLat.lng,this._lngLat.lat-.001)).sub(t);o=e.radToDeg(Math.atan2(r.y,r.x))-90;}else o=-i.getBearing();else if("horizon"===r){const r=e.smoothstep(4,6,i.getZoom()),n=e.globeCenterToScreenPoint(i.transform);n.y+=r*i.transform.height;const s=t.sub(n),a=e.radToDeg(Math.atan2(s.y,s.x));o=(a>90?a-270:a+90)*(1-r);}return o+=this._rotation,o?`rotateZ(${o}deg)`:""}_update(t){e.window.cancelAnimationFrame(this._updateFrameId);const i=this._map;i&&(i.transform.renderWorldCopies&&(this._lngLat=Jr(this._lngLat,this._pos,i.transform)),this._pos=i.project(this._lngLat),!0===t?this._updateFrameId=e.window.requestAnimationFrame((()=>{this._element&&this._pos&&this._anchor&&(this._pos=this._pos.round(),this._updateDOM());})):this._pos=this._pos.round(),i._requestDomTask((()=>{this._map&&(this._element&&this._pos&&this._anchor&&this._updateDOM(),(i._showingGlobe()||i.getTerrain()||i.getFog())&&!this._fadeTimer&&(this._fadeTimer=setTimeout(this._evaluateOpacity.bind(this),60)));})));}getOffset(){return this._offset}setOffset(t){return this._offset=e.Point.convert(t),this._update(),this}_onMove(t){const i=this._map;if(!i)return;const o=this._pointerdownPos,r=this._positionDelta;if(o&&r){if(!this._isDragging){const e=this._clickTolerance||i._clickTolerance;if(t.point.dist(o)<e)return;this._isDragging=!0;}this._pos=t.point.sub(r),this._lngLat=i.unproject(this._pos),this.setLngLat(this._lngLat),this._element.style.pointerEvents="none","pending"===this._state&&(this._state="active",this.fire(new e.Event("dragstart"))),this.fire(new e.Event("drag"));}}_onUp(){this._element.style.pointerEvents="auto",this._positionDelta=null,this._pointerdownPos=null,this._isDragging=!1;const t=this._map;t&&(t.off("mousemove",this._onMove),t.off("touchmove",this._onMove)),"active"===this._state&&this.fire(new e.Event("dragend")),this._state="inactive";}_addDragHandler(e){const t=this._map,i=this._pos;t&&i&&this._element.contains(e.originalEvent.target)&&(e.preventDefault(),this._positionDelta=e.point.sub(i),this._pointerdownPos=e.point,this._state="pending",t.on("mousemove",this._onMove),t.on("touchmove",this._onMove),t.once("mouseup",this._onUp),t.once("touchend",this._onUp));}setDraggable(e){this._draggable=!!e;const t=this._map;return t&&(e?(t.on("mousedown",this._addDragHandler),t.on("touchstart",this._addDragHandler)):(t.off("mousedown",this._addDragHandler),t.off("touchstart",this._addDragHandler))),this}isDraggable(){return this._draggable}setRotation(e){return this._rotation=e||0,this._update(),this}getRotation(){return this._rotation}setRotationAlignment(e){return this._rotationAlignment=e||"auto",this._update(),this}getRotationAlignment(){return "auto"===this._rotationAlignment||"horizon"===this._rotationAlignment&&this._map&&!this._map._showingGlobe()?"viewport":this._rotationAlignment}setPitchAlignment(e){return this._pitchAlignment=e||"auto",this._update(),this}getPitchAlignment(){return "auto"===this._pitchAlignment?this.getRotationAlignment():this._pitchAlignment}setOccludedOpacity(e){return this._occludedOpacity=e||.2,this._update(),this}getOccludedOpacity(){return this._occludedOpacity}}const tn={closeButton:!0,closeOnClick:!0,focusAfterOpen:!0,className:"",maxWidth:"240px"},on=["a[href]","[tabindex]:not([tabindex='-1'])","[contenteditable]:not([contenteditable='false'])","button:not([disabled])","input:not([disabled])","select:not([disabled])","textarea:not([disabled])"].join(", ");function rn(t=new e.Point(0,0),i="bottom"){if("number"==typeof t){const o=Math.round(Math.sqrt(.5*Math.pow(t,2)));switch(i){case"top":return new e.Point(0,t);case"top-left":return new e.Point(o,o);case"top-right":return new e.Point(-o,o);case"bottom":return new e.Point(0,-t);case"bottom-left":return new e.Point(o,-o);case"bottom-right":return new e.Point(-o,-o);case"left":return new e.Point(t,0);case"right":return new e.Point(-t,0)}return new e.Point(0,0)}return t instanceof e.Point||Array.isArray(t)?e.Point.convert(t):e.Point.convert(t[i]||[0,0])}class nn{constructor(e){this.jumpTo(e);}getValue(t){if(t<=this._startTime)return this._start;if(t>=this._endTime)return this._end;const i=e.easeCubicInOut((t-this._startTime)/(this._endTime-this._startTime));return this._start*(1-i)+this._end*i}isEasing(e){return e>=this._startTime&&e<=this._endTime}jumpTo(e){this._startTime=-1/0,this._endTime=-1/0,this._start=e,this._end=e;}easeTo(e,t,i){this._start=this.getValue(t),this._end=e,this._startTime=t,this._endTime=t+i;}}const sn={"AttributionControl.ToggleAttribution":"Toggle attribution","AttributionControl.MapFeedback":"Map feedback","FullscreenControl.Enter":"Enter fullscreen","FullscreenControl.Exit":"Exit fullscreen","GeolocateControl.FindMyLocation":"Find my location","GeolocateControl.LocationNotAvailable":"Location not available","LogoControl.Title":"Mapbox logo","Map.Title":"Map","NavigationControl.ResetBearing":"Reset bearing to north","NavigationControl.ZoomIn":"Zoom in","NavigationControl.ZoomOut":"Zoom out","ScrollZoomBlocker.CtrlMessage":"Use ctrl + scroll to zoom the map","ScrollZoomBlocker.CmdMessage":"Use ⌘ + scroll to zoom the map","TouchPanBlocker.Message":"Use two fingers to move the map"},an={center:[0,0],zoom:0,bearing:0,pitch:0,minZoom:-2,maxZoom:22,minPitch:0,maxPitch:85,interactive:!0,scrollZoom:!0,boxZoom:!0,dragRotate:!0,dragPan:!0,keyboard:!0,doubleClickZoom:!0,touchZoomRotate:!0,touchPitch:!0,cooperativeGestures:!1,performanceMetricsCollection:!0,bearingSnap:7,clickTolerance:3,pitchWithRotate:!0,hash:!1,attributionControl:!0,failIfMajorPerformanceCaveat:!1,preserveDrawingBuffer:!1,trackResize:!0,optimizeForTerrain:!0,renderWorldCopies:!0,refreshExpiredTiles:!0,minTileCacheSize:null,maxTileCacheSize:null,localIdeographFontFamily:"sans-serif",localFontFamily:null,transformRequest:null,accessToken:null,fadeDuration:300,respectPrefersReducedMotion:!0,crossSourceCollisions:!0},ln={showCompass:!0,showZoom:!0,visualizePitch:!1};class cn{constructor(t,i,o=!1){this._clickTolerance=10,this.element=i,this.mouseRotate=new yr({clickTolerance:t.dragRotate._mouseRotate._clickTolerance}),this.map=t,o&&(this.mousePitch=new br({clickTolerance:t.dragRotate._mousePitch._clickTolerance})),e.bindAll(["mousedown","mousemove","mouseup","touchstart","touchmove","touchend","reset"],this),i.addEventListener("mousedown",this.mousedown),i.addEventListener("touchstart",this.touchstart,{passive:!1}),i.addEventListener("touchmove",this.touchmove),i.addEventListener("touchend",this.touchend),i.addEventListener("touchcancel",this.reset);}down(e,t){this.mouseRotate.mousedown(e,t),this.mousePitch&&this.mousePitch.mousedown(e,t),h();}move(e,t){const i=this.map,o=this.mouseRotate.mousemoveWindow(e,t),r=o&&o.bearingDelta;if(r&&i.setBearing(i.getBearing()+r),this.mousePitch){const o=this.mousePitch.mousemoveWindow(e,t),r=o&&o.pitchDelta;r&&i.setPitch(i.getPitch()+r);}}off(){const e=this.element;e.removeEventListener("mousedown",this.mousedown),e.removeEventListener("touchstart",this.touchstart,{passive:!1}),e.removeEventListener("touchmove",this.touchmove),e.removeEventListener("touchend",this.touchend),e.removeEventListener("touchcancel",this.reset),this.offTemp();}offTemp(){u(),e.window.removeEventListener("mousemove",this.mousemove),e.window.removeEventListener("mouseup",this.mouseup);}mousedown(t){this.down(e.extend({},t,{ctrlKey:!0,preventDefault:()=>t.preventDefault()}),p(this.element,t)),e.window.addEventListener("mousemove",this.mousemove),e.window.addEventListener("mouseup",this.mouseup);}mousemove(e){this.move(e,p(this.element,e));}mouseup(e){this.mouseRotate.mouseupWindow(e),this.mousePitch&&this.mousePitch.mouseupWindow(e),this.offTemp();}touchstart(e){1!==e.targetTouches.length?this.reset():(this._startPos=this._lastPos=m(this.element,e.targetTouches)[0],this.down({type:"mousedown",button:0,ctrlKey:!0,preventDefault:()=>e.preventDefault()},this._startPos));}touchmove(e){1!==e.targetTouches.length?this.reset():(this._lastPos=m(this.element,e.targetTouches)[0],this.move({preventDefault:()=>e.preventDefault()},this._lastPos));}touchend(e){0===e.targetTouches.length&&this._startPos&&this._lastPos&&this._startPos.dist(this._lastPos)<this._clickTolerance&&this.element.click(),this.reset();}reset(){this.mouseRotate.reset(),this.mousePitch&&this.mousePitch.reset(),delete this._startPos,delete this._lastPos,this.offTemp();}}const hn={positionOptions:{enableHighAccuracy:!1,maximumAge:0,timeout:6e3},fitBoundsOptions:{maxZoom:15},trackUserLocation:!1,showAccuracyCircle:!0,showUserLocation:!0,showUserHeading:!1},un={maxWidth:100,unit:"metric"},_n={kilometer:"km",meter:"m",mile:"mi",foot:"ft","nautical-mile":"nm"},dn={version:e.version,supported:i,setRTLTextPlugin:e.setRTLTextPlugin,getRTLTextPluginStatus:e.getRTLTextPluginStatus,Map:class extends $r{constructor(t){if(e.LivePerformanceUtils.mark(e.PerformanceMarkers.create),null!=(t=e.extend({},an,t)).minZoom&&null!=t.maxZoom&&t.minZoom>t.maxZoom)throw new Error("maxZoom must be greater than or equal to minZoom");if(null!=t.minPitch&&null!=t.maxPitch&&t.minPitch>t.maxPitch)throw new Error("maxPitch must be greater than or equal to minPitch");if(null!=t.minPitch&&t.minPitch<0)throw new Error("minPitch must be greater than or equal to 0");if(null!=t.maxPitch&&t.maxPitch>85)throw new Error("maxPitch must be less than or equal to 85");if(t.antialias&&e.isSafariWithAntialiasingBug(e.window)&&(t.antialias=!1,e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")),super(new Ho(t.minZoom,t.maxZoom,t.minPitch,t.maxPitch,t.renderWorldCopies),t),this._interactive=t.interactive,this._minTileCacheSize=t.minTileCacheSize,this._maxTileCacheSize=t.maxTileCacheSize,this._failIfMajorPerformanceCaveat=t.failIfMajorPerformanceCaveat,this._preserveDrawingBuffer=t.preserveDrawingBuffer,this._antialias=t.antialias,this._useWebGL2=t.useWebGL2,this._trackResize=t.trackResize,this._bearingSnap=t.bearingSnap,this._refreshExpiredTiles=t.refreshExpiredTiles,this._fadeDuration=t.fadeDuration,this._isInitialLoad=!0,this._crossSourceCollisions=t.crossSourceCollisions,this._collectResourceTiming=t.collectResourceTiming,this._optimizeForTerrain=t.optimizeForTerrain,this._language=this._parseLanguage(t.language),this._worldview=t.worldview,this._renderTaskQueue=new Kr,this._domRenderTaskQueue=new Kr,this._controls=[],this._markers=[],this._popups=[],this._mapId=e.uniqueId(),this._locale=e.extend({},sn,t.locale),this._clickTolerance=t.clickTolerance,this._cooperativeGestures=t.cooperativeGestures,this._performanceMetricsCollection=t.performanceMetricsCollection,this._containerWidth=0,this._containerHeight=0,this._averageElevationLastSampledAt=-1/0,this._averageElevationExaggeration=0,this._averageElevation=new nn(0),this._interactionRange=[1/0,-1/0],this._visibilityHidden=0,this._useExplicitProjection=!1,this._requestManager=new e.RequestManager(t.transformRequest,t.accessToken,t.testMode),this._silenceAuthErrors=!!t.testMode,"string"==typeof t.container){if(this._container=e.window.document.getElementById(t.container),!this._container)throw new Error(`Container '${t.container}' not found.`)}else {if(!(t.container instanceof e.window.HTMLElement))throw new Error("Invalid type: 'container' must be a String or HTMLElement.");this._container=t.container;}if(this._container.childNodes.length>0&&e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."),t.maxBounds&&this.setMaxBounds(t.maxBounds),e.bindAll(["_onWindowOnline","_onWindowResize","_onVisibilityChange","_onMapScroll","_contextLost","_contextRestored"],this),this._setupContainer(),this._setupPainter(),void 0===this.painter)throw new Error("Failed to initialize WebGL.");this.on("move",(()=>this._update(!1))),this.on("moveend",(()=>this._update(!1))),this.on("zoom",(()=>this._update(!0))),void 0!==e.window&&(e.window.addEventListener("online",this._onWindowOnline,!1),e.window.addEventListener("resize",this._onWindowResize,!1),e.window.addEventListener("orientationchange",this._onWindowResize,!1),e.window.addEventListener("webkitfullscreenchange",this._onWindowResize,!1),e.window.addEventListener("visibilitychange",this._onVisibilityChange,!1)),this.handlers=new Xr(this,t),this._localFontFamily=t.localFontFamily,this._localIdeographFontFamily=t.localIdeographFontFamily,t.style&&this.setStyle(t.style,{localFontFamily:this._localFontFamily,localIdeographFontFamily:this._localIdeographFontFamily}),t.projection&&this.setProjection(t.projection),this._hash=t.hash&&new Ko("string"==typeof t.hash&&t.hash||void 0).addTo(this),this._hash&&this._hash._onHashChange()||(this.jumpTo({center:t.center,zoom:t.zoom,bearing:t.bearing,pitch:t.pitch}),t.bounds&&(this.resize(),this.fitBounds(t.bounds,e.extend({},t.fitBoundsOptions,{duration:0})))),this.resize(),t.attributionControl&&this.addControl(new Hr({customAttribution:t.customAttribution})),this._logoControl=new Yr,this.addControl(this._logoControl,t.logoPosition),this.on("style.load",(()=>{this.transform.unmodified&&this.jumpTo(this.style.stylesheet);})),this.on("data",(t=>{this._update("style"===t.dataType),this.fire(new e.Event(`${t.dataType}data`,t));})),this.on("dataloading",(t=>{this.fire(new e.Event(`${t.dataType}dataloading`,t));}));}_getMapId(){return this._mapId}addControl(t,i){if(void 0===i&&(i=t.getDefaultPosition?t.getDefaultPosition():"top-right"),!t||!t.onAdd)return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));const o=t.onAdd(this);this._controls.push(t);const r=this._controlPositions[i];return -1!==i.indexOf("bottom")?r.insertBefore(o,r.firstChild):r.appendChild(o),this}removeControl(t){if(!t||!t.onRemove)return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));const i=this._controls.indexOf(t);return i>-1&&this._controls.splice(i,1),t.onRemove(this),this}hasControl(e){return this._controls.indexOf(e)>-1}getContainer(){return this._container}getCanvasContainer(){return this._canvasContainer}getCanvas(){return this._canvas}resize(t){if(this._updateContainerDimensions(),this._containerWidth===this.transform.width&&this._containerHeight===this.transform.height)return this;this._resizeCanvas(this._containerWidth,this._containerHeight),this.transform.resize(this._containerWidth,this._containerHeight),this.painter.resize(Math.ceil(this._containerWidth),Math.ceil(this._containerHeight));const i=!this._moving;return i&&this.fire(new e.Event("movestart",t)).fire(new e.Event("move",t)),this.fire(new e.Event("resize",t)),i&&this.fire(new e.Event("moveend",t)),this}getBounds(){return this.transform.getBounds()}getMaxBounds(){return this.transform.getMaxBounds()||null}setMaxBounds(t){return this.transform.setMaxBounds(e.LngLatBounds.convert(t)),this._update()}setMinZoom(t){if((t=null==t?-2:t)>=-2&&t<=this.transform.maxZoom)return this.transform.minZoom=t,this._update(),this.getZoom()<t?this.setZoom(t):this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")),this;throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")}getMinZoom(){return this.transform.minZoom}setMaxZoom(t){if((t=null==t?22:t)>=this.transform.minZoom)return this.transform.maxZoom=t,this._update(),this.getZoom()>t?this.setZoom(t):this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")),this;throw new Error("maxZoom must be greater than the current minZoom")}getMaxZoom(){return this.transform.maxZoom}setMinPitch(t){if((t=null==t?0:t)<0)throw new Error("minPitch must be greater than or equal to 0");if(t>=0&&t<=this.transform.maxPitch)return this.transform.minPitch=t,this._update(),this.getPitch()<t?this.setPitch(t):this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")),this;throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")}getMinPitch(){return this.transform.minPitch}setMaxPitch(t){if((t=null==t?85:t)>85)throw new Error("maxPitch must be less than or equal to 85");if(t>=this.transform.minPitch)return this.transform.maxPitch=t,this._update(),this.getPitch()>t?this.setPitch(t):this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")),this;throw new Error("maxPitch must be greater than or equal to minPitch")}getMaxPitch(){return this.transform.maxPitch}getRenderWorldCopies(){return this.transform.renderWorldCopies}setRenderWorldCopies(e){return this.transform.renderWorldCopies=e,this.transform.renderWorldCopies||this._forceMarkerAndPopupUpdate(!0),this._update()}getLanguage(){return this._language}_parseLanguage(t){return "auto"===t?e.window.navigator.language:Array.isArray(t)?0===t.length?void 0:t.map((t=>"auto"===t?e.window.navigator.language:t)):t}setLanguage(e){const t=this._parseLanguage(e);if(!this.style||t===this._language)return this;this._language=t,this.style._reloadSources();for(const e of this._controls)e._setLanguage&&e._setLanguage(this._language);return this}getWorldview(){return this._worldview}setWorldview(e){return this.style&&e!==this._worldview?(this._worldview=e,this.style._reloadSources(),this):this}getProjection(){return this.transform.mercatorFromTransition?{name:"globe",center:[0,0]}:this.transform.getProjection()}_showingGlobe(){return "globe"===this.transform.projection.name}setProjection(e){return this._lazyInitEmptyStyle(),e?"string"==typeof e&&(e={name:e}):e=null,this._useExplicitProjection=!!e,this._prioritizeAndUpdateProjection(e,this.style.stylesheet?this.style.stylesheet.projection:null)}_updateProjectionTransition(){if("globe"!==this.getProjection().name)return;const t=this.transform,i=t.projection.name;let o;"globe"===i&&t.zoom>=e.GLOBE_ZOOM_THRESHOLD_MAX?(t.setMercatorFromTransition(),o=!0):"mercator"===i&&t.zoom<e.GLOBE_ZOOM_THRESHOLD_MAX&&(t.setProjection({name:"globe"}),o=!0),o&&(this.style.applyProjectionUpdate(),this.style._forceSymbolLayerUpdate());}_prioritizeAndUpdateProjection(e,t){return this._updateProjection(e||t||{name:"mercator"})}_updateProjection(t){let i;if(i="globe"===t.name&&this.transform.zoom>=e.GLOBE_ZOOM_THRESHOLD_MAX?this.transform.setMercatorFromTransition():this.transform.setProjection(t),this.style.applyProjectionUpdate(),i){this.painter.clearBackgroundTiles();for(const e in this.style._sourceCaches)this.style._sourceCaches[e].clearTiles();this._update(!0),this._forceMarkerAndPopupUpdate(!0);}return this}project(t){return this.transform.locationPoint3D(e.LngLat.convert(t))}unproject(t){return this.transform.pointLocation3D(e.Point.convert(t))}isMoving(){return this._moving||this.handlers&&this.handlers.isMoving()||!1}isZooming(){return this._zooming||this.handlers&&this.handlers.isZooming()||!1}isRotating(){return this._rotating||this.handlers&&this.handlers.isRotating()||!1}_isDragging(){return this.handlers&&this.handlers._isDragging()||!1}_createDelegatedListener(e,t,i){if("mouseenter"===e||"mouseover"===e){let o=!1;const r=r=>{const n=t.filter((e=>this.getLayer(e))),s=n.length?this.queryRenderedFeatures(r.point,{layers:n}):[];s.length?o||(o=!0,i.call(this,new ar(e,this,r.originalEvent,{features:s}))):o=!1;},n=()=>{o=!1;};return {layers:new Set(t),listener:i,delegates:{mousemove:r,mouseout:n}}}if("mouseleave"===e||"mouseout"===e){let o=!1;const r=r=>{const n=t.filter((e=>this.getLayer(e)));(n.length?this.queryRenderedFeatures(r.point,{layers:n}):[]).length?o=!0:o&&(o=!1,i.call(this,new ar(e,this,r.originalEvent)));},n=t=>{o&&(o=!1,i.call(this,new ar(e,this,t.originalEvent)));};return {layers:new Set(t),listener:i,delegates:{mousemove:r,mouseout:n}}}{const o=e=>{const o=t.filter((e=>this.getLayer(e))),r=o.length?this.queryRenderedFeatures(e.point,{layers:o}):[];r.length&&(e.features=r,i.call(this,e),delete e.features);};return {layers:new Set(t),listener:i,delegates:{[e]:o}}}}on(e,t,i){if(void 0===i)return super.on(e,t);Array.isArray(t)||(t=[t]);const o=this._createDelegatedListener(e,t,i);this._delegatedListeners=this._delegatedListeners||{},this._delegatedListeners[e]=this._delegatedListeners[e]||[],this._delegatedListeners[e].push(o);for(const e in o.delegates)this.on(e,o.delegates[e]);return this}once(e,t,i){if(void 0===i)return super.once(e,t);Array.isArray(t)||(t=[t]);const o=this._createDelegatedListener(e,t,i);for(const e in o.delegates)this.once(e,o.delegates[e]);return this}off(e,t,i){if(void 0===i)return super.off(e,t);t=new Set(Array.isArray(t)?t:[t]);const o=(e,t)=>{if(e.size!==t.size)return !1;for(const i of e)if(!t.has(i))return !1;return !0},r=this._delegatedListeners?this._delegatedListeners[e]:void 0;return r&&(e=>{for(let r=0;r<e.length;r++){const n=e[r];if(n.listener===i&&o(n.layers,t)){for(const e in n.delegates)this.off(e,n.delegates[e]);return e.splice(r,1),this}}})(r),this}queryRenderedFeatures(t,i){return this.style?(void 0!==i||void 0===t||t instanceof e.Point||Array.isArray(t)||(i=t,t=void 0),this.style.queryRenderedFeatures(t=t||[[0,0],[this.transform.width,this.transform.height]],i=i||{},this.transform)):[]}querySourceFeatures(e,t){return this.style.querySourceFeatures(e,t)}isPointOnSurface(t){const{name:i}=this.transform.projection;return "globe"!==i&&"mercator"!==i&&e.warnOnce(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`),this.transform.isPointOnSurface(e.Point.convert(t))}setStyle(t,i){return !1!==(i=e.extend({},{localIdeographFontFamily:this._localIdeographFontFamily,localFontFamily:this._localFontFamily},i)).diff&&i.localIdeographFontFamily===this._localIdeographFontFamily&&i.localFontFamily===this._localFontFamily&&this.style&&t?(this._diffStyle(t,i),this):(this._localIdeographFontFamily=i.localIdeographFontFamily,this._localFontFamily=i.localFontFamily,this._updateStyle(t,i))}_getUIString(e){const t=this._locale[e];if(null==t)throw new Error(`Missing UI string '${e}'`);return t}_updateStyle(e,t){return this.style&&(this.style.setEventedParent(null),this.style._remove(),this.style=void 0),e&&(this.style=new Kt(this,t||{}),this.style.setEventedParent(this,{style:this.style}),"string"==typeof e?this.style.loadURL(e):this.style.loadJSON(e)),this._updateTerrain(),this}_lazyInitEmptyStyle(){this.style||(this.style=new Kt(this,{}),this.style.setEventedParent(this,{style:this.style}),this.style.loadEmpty());}_diffStyle(t,i){if("string"==typeof t){const o=this._requestManager.normalizeStyleURL(t),r=this._requestManager.transformRequest(o,e.ResourceType.Style);e.getJSON(r,((t,o)=>{t?this.fire(new e.ErrorEvent(t)):o&&this._updateDiff(o,i);}));}else "object"==typeof t&&this._updateDiff(t,i);}_updateDiff(t,i){try{this.style.setState(t)&&this._update(!0);}catch(o){e.warnOnce(`Unable to perform style diff: ${o.message||o.error||o}.  Rebuilding the style from scratch.`),this._updateStyle(t,i);}}getStyle(){if(this.style)return this.style.serialize()}isStyleLoaded(){return this.style?this.style.loaded():(e.warnOnce("There is no style added to the map."),!1)}addSource(e,t){return this._lazyInitEmptyStyle(),this.style.addSource(e,t),this._update(!0)}isSourceLoaded(e){return !!this.style&&this.style._isSourceCacheLoaded(e)}areTilesLoaded(){const e=this.style&&this.style._sourceCaches;for(const t in e){const i=e[t]._tiles;for(const e in i){const t=i[e];if("loaded"!==t.state&&"errored"!==t.state)return !1}}return !0}addSourceType(e,t,i){this._lazyInitEmptyStyle(),this.style.addSourceType(e,t,i);}removeSource(e){return this.style.removeSource(e),this._updateTerrain(),this._update(!0)}getSource(e){return this.style.getSource(e)}addImage(t,i,{pixelRatio:o=1,sdf:r=!1,stretchX:n,stretchY:s,content:a}={}){if(this._lazyInitEmptyStyle(),i instanceof e.window.HTMLImageElement||e.window.ImageBitmap&&i instanceof e.window.ImageBitmap){const{width:l,height:c,data:h}=e.exported.getImageData(i);this.style.addImage(t,{data:new e.RGBAImage({width:l,height:c},h),pixelRatio:o,stretchX:n,stretchY:s,content:a,sdf:r,version:0});}else if(void 0===i.width||void 0===i.height)this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));else {const{width:l,height:c}=i,h=i;this.style.addImage(t,{data:new e.RGBAImage({width:l,height:c},new Uint8Array(h.data)),pixelRatio:o,stretchX:n,stretchY:s,content:a,sdf:r,version:0,userImage:h}),h.onAdd&&h.onAdd(this,t);}}updateImage(t,i){const o=this.style.getImage(t);if(!o)return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));const r=i instanceof e.window.HTMLImageElement||e.window.ImageBitmap&&i instanceof e.window.ImageBitmap?e.exported.getImageData(i):i,{width:n,height:s}=r;void 0!==n&&void 0!==s?n===o.data.width&&s===o.data.height?(o.data.replace(r.data,!(i instanceof e.window.HTMLImageElement||e.window.ImageBitmap&&i instanceof e.window.ImageBitmap)),this.style.updateImage(t,o)):this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n}, ${s})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`))):this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));}hasImage(t){return t?!!this.style.getImage(t):(this.fire(new e.ErrorEvent(new Error("Missing required image id"))),!1)}removeImage(e){this.style.removeImage(e);}loadImage(t,i){e.getImage(this._requestManager.transformRequest(t,e.ResourceType.Image),((t,o)=>{i(t,o instanceof e.window.HTMLImageElement?e.exported.getImageData(o):o);}));}listImages(){return this.style.listImages()}addLayer(e,t){return this._lazyInitEmptyStyle(),this.style.addLayer(e,t),this._update(!0)}moveLayer(e,t){return this.style.moveLayer(e,t),this._update(!0)}removeLayer(e){return this.style.removeLayer(e),this._update(!0)}getLayer(e){return this.style.getLayer(e)}setLayerZoomRange(e,t,i){return this.style.setLayerZoomRange(e,t,i),this._update(!0)}setFilter(e,t,i={}){return this.style.setFilter(e,t,i),this._update(!0)}getFilter(e){return this.style.getFilter(e)}setPaintProperty(e,t,i,o={}){return this.style.setPaintProperty(e,t,i,o),this._update(!0)}getPaintProperty(e,t){return this.style.getPaintProperty(e,t)}setLayoutProperty(e,t,i,o={}){return this.style.setLayoutProperty(e,t,i,o),this._update(!0)}getLayoutProperty(e,t){return this.style.getLayoutProperty(e,t)}setLight(e,t={}){return this._lazyInitEmptyStyle(),this.style.setLight(e,t),this._update(!0)}getLight(){return this.style.getLight()}setTerrain(e){return this._lazyInitEmptyStyle(),!e&&this.transform.projection.requiresDraping?this.style.setTerrainForDraping():this.style.setTerrain(e),this._averageElevationLastSampledAt=-1/0,this._update(!0)}getTerrain(){return this.style?this.style.getTerrain():null}setFog(e){return this._lazyInitEmptyStyle(),this.style.setFog(e),this._update(!0)}getFog(){return this.style?this.style.getFog():null}_queryFogOpacity(t){return this.style&&this.style.fog?this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t),this.transform):0}setFeatureState(e,t){return this.style.setFeatureState(e,t),this._update()}removeFeatureState(e,t){return this.style.removeFeatureState(e,t),this._update()}getFeatureState(e){return this.style.getFeatureState(e)}_updateContainerDimensions(){if(!this._container)return;const t=this._container.getBoundingClientRect().width||400,i=this._container.getBoundingClientRect().height||300;let o,r,n,s=this._container;for(;s&&(!r||!n);){const t=e.window.getComputedStyle(s).transform;t&&"none"!==t&&(o=t.match(/matrix.*\((.+)\)/)[1].split(", "),o[0]&&"0"!==o[0]&&"1"!==o[0]&&(r=o[0]),o[3]&&"0"!==o[3]&&"1"!==o[3]&&(n=o[3])),s=s.parentElement;}this._containerWidth=r?Math.abs(t/r):t,this._containerHeight=n?Math.abs(i/n):i;}_detectMissingCSS(){"rgb(250, 128, 114)"!==e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color")&&e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");}_setupContainer(){const e=this._container;e.classList.add("mapboxgl-map"),(this._missingCSSCanary=n("div","mapboxgl-canary",e)).style.visibility="hidden",this._detectMissingCSS();const t=this._canvasContainer=n("div","mapboxgl-canvas-container",e);this._interactive&&t.classList.add("mapboxgl-interactive"),this._canvas=n("canvas","mapboxgl-canvas",t),this._canvas.addEventListener("webglcontextlost",this._contextLost,!1),this._canvas.addEventListener("webglcontextrestored",this._contextRestored,!1),this._canvas.setAttribute("tabindex","0"),this._canvas.setAttribute("aria-label",this._getUIString("Map.Title")),this._canvas.setAttribute("role","region"),this._updateContainerDimensions(),this._resizeCanvas(this._containerWidth,this._containerHeight);const i=this._controlContainer=n("div","mapboxgl-control-container",e),o=this._controlPositions={};["top-left","top-right","bottom-left","bottom-right"].forEach((e=>{o[e]=n("div",`mapboxgl-ctrl-${e}`,i);})),this._container.addEventListener("scroll",this._onMapScroll,!1);}_resizeCanvas(t,i){const o=e.exported.devicePixelRatio||1;this._canvas.width=o*Math.ceil(t),this._canvas.height=o*Math.ceil(i),this._canvas.style.width=`${t}px`,this._canvas.style.height=`${i}px`;}_addMarker(e){this._markers.push(e);}_removeMarker(e){const t=this._markers.indexOf(e);-1!==t&&this._markers.splice(t,1);}_addPopup(e){this._popups.push(e);}_removePopup(e){const t=this._popups.indexOf(e);-1!==t&&this._popups.splice(t,1);}_setupPainter(){const t=e.extend({},i.webGLContextAttributes,{failIfMajorPerformanceCaveat:this._failIfMajorPerformanceCaveat,preserveDrawingBuffer:this._preserveDrawingBuffer,antialias:this._antialias||!1}),o=this._useWebGL2&&this._canvas.getContext("webgl2",t),r=o||this._canvas.getContext("webgl",t)||this._canvas.getContext("experimental-webgl",t);r?(this._useWebGL2&&!o&&e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."),e.storeAuthState(r,!0),this.painter=new Bo(r,this.transform,!!o),this.on("data",(e=>{"source"===e.dataType&&this.painter.setTileLoadedFlag(!0);})),e.exported$1.testSupport(r)):this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));}_contextLost(t){t.preventDefault(),this._frame&&(this._frame.cancel(),this._frame=null),this.fire(new e.Event("webglcontextlost",{originalEvent:t}));}_contextRestored(t){this._setupPainter(),this.resize(),this._update(),this.fire(new e.Event("webglcontextrestored",{originalEvent:t}));}_onMapScroll(e){if(e.target===this._container)return this._container.scrollTop=0,this._container.scrollLeft=0,!1}loaded(){return !this._styleDirty&&!this._sourcesDirty&&!!this.style&&this.style.loaded()}_update(e){return this.style?(this._styleDirty=this._styleDirty||e,this._sourcesDirty=!0,this.triggerRepaint(),this):this}_requestRenderFrame(e){return this._update(),this._renderTaskQueue.add(e)}_cancelRenderFrame(e){this._renderTaskQueue.remove(e);}_requestDomTask(e){!this.loaded()||this.loaded()&&!this.isMoving()?e():this._domRenderTaskQueue.add(e);}_render(t){let i;const o=this.painter.context.extTimerQuery,r=e.exported.now();if(this.listens("gpu-timing-frame")&&(i=o.createQueryEXT(),o.beginQueryEXT(o.TIME_ELAPSED_EXT,i)),this.painter.context.setDirty(),this.painter.setBaseState(),(this.isMoving()||this.isRotating()||this.isZooming())&&(this._interactionRange[0]=Math.min(this._interactionRange[0],e.window.performance.now()),this._interactionRange[1]=Math.max(this._interactionRange[1],e.window.performance.now())),this._renderTaskQueue.run(t),this._domRenderTaskQueue.run(t),this._removed)return;this._updateProjectionTransition();const n=this._isInitialLoad?0:this._fadeDuration;if(this.style&&this._styleDirty){this._styleDirty=!1;const t=this.transform.zoom,i=this.transform.pitch,o=e.exported.now(),r=new e.EvaluationParameters(t,{now:o,fadeDuration:n,pitch:i,transition:this.style.getTransition()});this.style.update(r);}this.style&&this.style.fog&&this.style.fog.hasTransition()&&(this.style._markersNeedUpdate=!0,this._sourcesDirty=!0);let s=!1;if(this.style&&this._sourcesDirty?(this._sourcesDirty=!1,this.painter._updateFog(this.style),this._updateTerrain(),s=this._updateAverageElevation(r),this.style._updateSources(this.transform),this._forceMarkerAndPopupUpdate()):s=this._updateAverageElevation(r),this._placementDirty=this.style&&this.style._updatePlacement(this.painter.transform,this.showCollisionBoxes,n,this._crossSourceCollisions),this.style&&this.painter.render(this.style,{showTileBoundaries:this.showTileBoundaries,showTerrainWireframe:this.showTerrainWireframe,showOverdrawInspector:this._showOverdrawInspector,showQueryGeometry:!!this._showQueryGeometry,showTileAABBs:this.showTileAABBs,rotating:this.isRotating(),zooming:this.isZooming(),moving:this.isMoving(),fadeDuration:n,isInitialLoad:this._isInitialLoad,showPadding:this.showPadding,gpuTiming:!!this.listens("gpu-timing-layer"),gpuTimingDeferredRender:!!this.listens("gpu-timing-deferred-render"),speedIndexTiming:this.speedIndexTiming}),this.fire(new e.Event("render")),this.loaded()&&!this._loaded&&(this._loaded=!0,this.fire(new e.Event("load"))),this.style&&this.style.hasTransitions()&&(this._styleDirty=!0),this.style&&!this._placementDirty&&this.style._releaseSymbolFadeTiles(),i){const t=e.exported.now()-r;o.endQueryEXT(o.TIME_ELAPSED_EXT,i),setTimeout((()=>{const n=o.getQueryObjectEXT(i,o.QUERY_RESULT_EXT)/1e6;o.deleteQueryEXT(i),this.fire(new e.Event("gpu-timing-frame",{cpuTime:t,gpuTime:n})),e.window.performance.mark("frame-gpu",{startTime:r,detail:{gpuTime:n}});}),50);}if(this.listens("gpu-timing-layer")){const t=this.painter.collectGpuTimers();setTimeout((()=>{const i=this.painter.queryGpuTimers(t);this.fire(new e.Event("gpu-timing-layer",{layerTimes:i}));}),50);}if(this.listens("gpu-timing-deferred-render")){const t=this.painter.collectDeferredRenderGpuQueries();setTimeout((()=>{const i=this.painter.queryGpuTimeDeferredRender(t);this.fire(new e.Event("gpu-timing-deferred-render",{gpuTime:i}));}),50);}const a=this._sourcesDirty||this._styleDirty||this._placementDirty||s;if(a||this._repaint)this.triggerRepaint();else {const t=!this.isMoving()&&this.loaded();if(t&&(s=this._updateAverageElevation(r,!0)),s)this.triggerRepaint();else if(this._triggerFrame(!1),t&&(this.fire(new e.Event("idle")),this._isInitialLoad=!1,this.speedIndexTiming)){const t=this._calculateSpeedIndex();this.fire(new e.Event("speedindexcompleted",{speedIndex:t})),this.speedIndexTiming=!1;}}!this._loaded||this._fullyLoaded||a||(this._fullyLoaded=!0,e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad),this._performanceMetricsCollection&&e.postPerformanceEvent(this._requestManager._customAccessToken,{width:this.painter.width,height:this.painter.height,interactionRange:this._interactionRange,visibilityHidden:this._visibilityHidden,terrainEnabled:!!this.painter.style.getTerrain(),fogEnabled:!!this.painter.style.getFog(),projection:this.getProjection().name,zoom:this.transform.zoom,renderer:this.painter.context.renderer,vendor:this.painter.context.vendor}),this._authenticate());}_forceMarkerAndPopupUpdate(e){for(const t of this._markers)e&&!this.getRenderWorldCopies()&&(t._lngLat=t._lngLat.wrap()),t._update();for(const t of this._popups)!e||this.getRenderWorldCopies()||t._trackPointer||(t._lngLat=t._lngLat.wrap()),t._update();}_updateAverageElevation(e,t=!1){const i=e=>(this.transform.averageElevation=e,this._update(!1),!0);if(!this.painter.averageElevationNeedsEasing())return 0!==this.transform.averageElevation&&i(0);if((t||e-this._averageElevationLastSampledAt>500)&&!this._averageElevation.isEasing(e)){const t=this.transform.averageElevation;let o=this.transform.sampleAverageElevation(),r=!1;this.transform.elevation&&(r=this.transform.elevation.exaggeration()!==this._averageElevationExaggeration,this._averageElevationExaggeration=this.transform.elevation.exaggeration()),isNaN(o)?o=0:this._averageElevationLastSampledAt=e;const n=Math.abs(t-o);if(n>1){if(this._isInitialLoad||r)return this._averageElevation.jumpTo(o),i(o);this._averageElevation.easeTo(o,e,300);}else if(n>1e-4)return this._averageElevation.jumpTo(o),i(o)}return !!this._averageElevation.isEasing(e)&&i(this._averageElevation.getValue(e))}_authenticate(){e.getMapSessionAPI(this._getMapId(),this._requestManager._skuToken,this._requestManager._customAccessToken,(t=>{if(t&&(t.message===e.AUTH_ERR_MSG||401===t.status)){const t=this.painter.context.gl;e.storeAuthState(t,!1),this._logoControl instanceof Yr&&this._logoControl._updateLogo(),t&&t.clear(t.DEPTH_BUFFER_BIT|t.COLOR_BUFFER_BIT|t.STENCIL_BUFFER_BIT),this._silenceAuthErrors||this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));}})),e.postMapLoadEvent(this._getMapId(),this._requestManager._skuToken,this._requestManager._customAccessToken,(()=>{}));}_updateTerrain(){const e=this._isDragging();this.painter.updateTerrain(this.style,e);}_calculateSpeedIndex(){const e=this.painter.canvasCopy(),t=this.painter.getCanvasCopiesAndTimestamps();t.timeStamps.push(performance.now());const i=this.painter.context.gl,o=i.createFramebuffer();function r(e){i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0);const t=new Uint8Array(i.drawingBufferWidth*i.drawingBufferHeight*4);return i.readPixels(0,0,i.drawingBufferWidth,i.drawingBufferHeight,i.RGBA,i.UNSIGNED_BYTE,t),t}return i.bindFramebuffer(i.FRAMEBUFFER,o),this._canvasPixelComparison(r(e),t.canvasCopies.map(r),t.timeStamps)}_canvasPixelComparison(e,t,i){let o=i[1]-i[0];const r=e.length/4;for(let n=0;n<t.length;n++){const s=t[n];let a=0;for(let t=0;t<s.length;t+=4)s[t]===e[t]&&s[t+1]===e[t+1]&&s[t+2]===e[t+2]&&s[t+3]===e[t+3]&&(a+=1);o+=(i[n+2]-i[n+1])*(1-a/r);}return o}remove(){this._hash&&this._hash.remove();for(const e of this._controls)e.onRemove(this);this._controls=[],this._frame&&(this._frame.cancel(),this._frame=null),this._renderTaskQueue.clear(),this._domRenderTaskQueue.clear(),this.style&&this.style.destroy(),this.painter.destroy(),this.handlers&&this.handlers.destroy(),this.handlers=void 0,this.setStyle(null),void 0!==e.window&&(e.window.removeEventListener("resize",this._onWindowResize,!1),e.window.removeEventListener("orientationchange",this._onWindowResize,!1),e.window.removeEventListener("webkitfullscreenchange",this._onWindowResize,!1),e.window.removeEventListener("online",this._onWindowOnline,!1),e.window.removeEventListener("visibilitychange",this._onVisibilityChange,!1));const t=this.painter.context.gl.getExtension("WEBGL_lose_context");t&&t.loseContext(),this._canvas.removeEventListener("webglcontextlost",this._contextLost,!1),this._canvas.removeEventListener("webglcontextrestored",this._contextRestored,!1),this._canvasContainer.remove(),this._controlContainer.remove(),this._missingCSSCanary.remove(),this._canvas=void 0,this._canvasContainer=void 0,this._controlContainer=void 0,this._missingCSSCanary=void 0,this._container.classList.remove("mapboxgl-map"),this._container.removeEventListener("scroll",this._onMapScroll,!1),e.removeAuthState(this.painter.context.gl),this._removed=!0,this.fire(new e.Event("remove"));}triggerRepaint(){this._triggerFrame(!0);}_triggerFrame(t){this._renderNextFrame=this._renderNextFrame||t,this.style&&!this._frame&&(this._frame=e.exported.frame((e=>{const t=!!this._renderNextFrame;this._frame=null,this._renderNextFrame=null,t&&this._render(e);})));}_preloadTiles(t){const i=this.style?Object.values(this.style._sourceCaches):[];return e.asyncAll(i,((e,i)=>e._preloadTiles(t,i)),(()=>{this.triggerRepaint();})),this}_onWindowOnline(){this._update();}_onWindowResize(e){this._trackResize&&this.resize({originalEvent:e})._update();}_onVisibilityChange(){"hidden"===e.window.document.visibilityState&&this._visibilityHidden++;}get showTileBoundaries(){return !!this._showTileBoundaries}set showTileBoundaries(e){this._showTileBoundaries!==e&&(this._showTileBoundaries=e,this._update());}get showTerrainWireframe(){return !!this._showTerrainWireframe}set showTerrainWireframe(e){this._showTerrainWireframe!==e&&(this._showTerrainWireframe=e,this._update());}get speedIndexTiming(){return !!this._speedIndexTiming}set speedIndexTiming(e){this._speedIndexTiming!==e&&(this._speedIndexTiming=e,this._update());}get showPadding(){return !!this._showPadding}set showPadding(e){this._showPadding!==e&&(this._showPadding=e,this._update());}get showCollisionBoxes(){return !!this._showCollisionBoxes}set showCollisionBoxes(e){this._showCollisionBoxes!==e&&(this._showCollisionBoxes=e,e?this.style._generateCollisionBoxes():this._update());}get showOverdrawInspector(){return !!this._showOverdrawInspector}set showOverdrawInspector(e){this._showOverdrawInspector!==e&&(this._showOverdrawInspector=e,this._update());}get repaint(){return !!this._repaint}set repaint(e){this._repaint!==e&&(this._repaint=e,this.triggerRepaint());}get vertices(){return !!this._vertices}set vertices(e){this._vertices=e,this._update();}get showTileAABBs(){return !!this._showTileAABBs}set showTileAABBs(e){this._showTileAABBs!==e&&(this._showTileAABBs=e,e&&this._update());}_setCacheLimits(t,i){e.setCacheLimits(t,i);}get version(){return e.version}},NavigationControl:class{constructor(t){this.options=e.extend({},ln,t),this._container=n("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._container.addEventListener("contextmenu",(e=>e.preventDefault())),this.options.showZoom&&(e.bindAll(["_setButtonTitle","_updateZoomButtons"],this),this._zoomInButton=this._createButton("mapboxgl-ctrl-zoom-in",(e=>{this._map&&this._map.zoomIn({},{originalEvent:e});})),n("span","mapboxgl-ctrl-icon",this._zoomInButton).setAttribute("aria-hidden","true"),this._zoomOutButton=this._createButton("mapboxgl-ctrl-zoom-out",(e=>{this._map&&this._map.zoomOut({},{originalEvent:e});})),n("span","mapboxgl-ctrl-icon",this._zoomOutButton).setAttribute("aria-hidden","true")),this.options.showCompass&&(e.bindAll(["_rotateCompassArrow"],this),this._compass=this._createButton("mapboxgl-ctrl-compass",(e=>{const t=this._map;t&&(this.options.visualizePitch?t.resetNorthPitch({},{originalEvent:e}):t.resetNorth({},{originalEvent:e}));})),this._compassIcon=n("span","mapboxgl-ctrl-icon",this._compass),this._compassIcon.setAttribute("aria-hidden","true"));}_updateZoomButtons(){const e=this._map;if(!e)return;const t=e.getZoom(),i=t===e.getMaxZoom(),o=t===e.getMinZoom();this._zoomInButton.disabled=i,this._zoomOutButton.disabled=o,this._zoomInButton.setAttribute("aria-disabled",i.toString()),this._zoomOutButton.setAttribute("aria-disabled",o.toString());}_rotateCompassArrow(){const e=this._map;if(!e)return;const t=this.options.visualizePitch?`scale(${1/Math.pow(Math.cos(e.transform.pitch*(Math.PI/180)),.5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle*(180/Math.PI)}deg)`:`rotate(${e.transform.angle*(180/Math.PI)}deg)`;e._requestDomTask((()=>{this._compassIcon&&(this._compassIcon.style.transform=t);}));}onAdd(e){return this._map=e,this.options.showZoom&&(this._setButtonTitle(this._zoomInButton,"ZoomIn"),this._setButtonTitle(this._zoomOutButton,"ZoomOut"),e.on("zoom",this._updateZoomButtons),this._updateZoomButtons()),this.options.showCompass&&(this._setButtonTitle(this._compass,"ResetBearing"),this.options.visualizePitch&&e.on("pitch",this._rotateCompassArrow),e.on("rotate",this._rotateCompassArrow),this._rotateCompassArrow(),this._handler=new cn(e,this._compass,this.options.visualizePitch)),this._container}onRemove(){const e=this._map;e&&(this._container.remove(),this.options.showZoom&&e.off("zoom",this._updateZoomButtons),this.options.showCompass&&(this.options.visualizePitch&&e.off("pitch",this._rotateCompassArrow),e.off("rotate",this._rotateCompassArrow),this._handler&&this._handler.off(),this._handler=void 0),this._map=void 0);}_createButton(e,t){const i=n("button",e,this._container);return i.type="button",i.addEventListener("click",t),i}_setButtonTitle(e,t){if(!this._map)return;const i=this._map._getUIString(`NavigationControl.${t}`);e.setAttribute("aria-label",i),e.firstElementChild&&e.firstElementChild.setAttribute("title",i);}},GeolocateControl:class extends e.Evented{constructor(t){super(),this.options=e.extend({geolocation:e.window.navigator.geolocation},hn,t),e.bindAll(["_onSuccess","_onError","_onZoom","_finish","_setupUI","_updateCamera","_updateMarker","_updateMarkerRotation","_onDeviceOrientation"],this),this._updateMarkerRotationThrottled=Yo(this._updateMarkerRotation,20),this._numberOfWatches=0;}onAdd(e){return this._map=e,this._container=n("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._checkGeolocationSupport(this._setupUI),this._container}onRemove(){void 0!==this._geolocationWatchID&&(this.options.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0),this.options.showUserLocation&&this._userLocationDotMarker&&this._userLocationDotMarker.remove(),this.options.showAccuracyCircle&&this._accuracyCircleMarker&&this._accuracyCircleMarker.remove(),this._container.remove(),this._map.off("zoom",this._onZoom),this._map=void 0,this._numberOfWatches=0,this._noTimeout=!1;}_checkGeolocationSupport(t){const i=(e=!!this.options.geolocation)=>{this._supportsGeolocation=e,t(e);};void 0!==this._supportsGeolocation?t(this._supportsGeolocation):void 0!==e.window.navigator.permissions?e.window.navigator.permissions.query({name:"geolocation"}).then((e=>i("denied"!==e.state))).catch((()=>i())):i();}_isOutOfMapMaxBounds(e){const t=this._map.getMaxBounds(),i=e.coords;return !!t&&(i.longitude<t.getWest()||i.longitude>t.getEast()||i.latitude<t.getSouth()||i.latitude>t.getNorth())}_setErrorState(){switch(this._watchState){case"WAITING_ACTIVE":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"ACTIVE_LOCK":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");break;case"BACKGROUND":this._watchState="BACKGROUND_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");}}_onSuccess(t){if(this._map){if(this._isOutOfMapMaxBounds(t))return this._setErrorState(),this.fire(new e.Event("outofmaxbounds",t)),this._updateMarker(),void this._finish();if(this.options.trackUserLocation)switch(this._lastKnownPosition=t,this._watchState){case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"BACKGROUND":case"BACKGROUND_ERROR":this._watchState="BACKGROUND",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");}this.options.showUserLocation&&"OFF"!==this._watchState&&this._updateMarker(t),this.options.trackUserLocation&&"ACTIVE_LOCK"!==this._watchState||this._updateCamera(t),this.options.showUserLocation&&this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"),this.fire(new e.Event("geolocate",t)),this._finish();}}_updateCamera(t){const i=new e.LngLat(t.coords.longitude,t.coords.latitude),o=t.coords.accuracy,r=this._map.getBearing(),n=e.extend({bearing:r},this.options.fitBoundsOptions);this._map.fitBounds(i.toBounds(o),n,{geolocateSource:!0});}_updateMarker(t){if(t){const i=new e.LngLat(t.coords.longitude,t.coords.latitude);this._accuracyCircleMarker.setLngLat(i).addTo(this._map),this._userLocationDotMarker.setLngLat(i).addTo(this._map),this._accuracy=t.coords.accuracy,this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();}else this._userLocationDotMarker.remove(),this._accuracyCircleMarker.remove();}_updateCircleRadius(){const t=this._map.transform,i=e.mercatorZfromAltitude(1,t._center.lat)*t.worldSize,o=Math.ceil(2*this._accuracy*i);this._circleElement.style.width=`${o}px`,this._circleElement.style.height=`${o}px`;}_onZoom(){this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();}_updateMarkerRotation(){this._userLocationDotMarker&&"number"==typeof this._heading?(this._userLocationDotMarker.setRotation(this._heading),this._dotElement.classList.add("mapboxgl-user-location-show-heading")):(this._dotElement.classList.remove("mapboxgl-user-location-show-heading"),this._userLocationDotMarker.setRotation(0));}_onError(t){if(this._map){if(this.options.trackUserLocation)if(1===t.code){this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.disabled=!0;const e=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.setAttribute("aria-label",e),this._geolocateButton.firstElementChild&&this._geolocateButton.firstElementChild.setAttribute("title",e),void 0!==this._geolocationWatchID&&this._clearWatch();}else {if(3===t.code&&this._noTimeout)return;this._setErrorState();}"OFF"!==this._watchState&&this.options.showUserLocation&&this._dotElement.classList.add("mapboxgl-user-location-dot-stale"),this.fire(new e.Event("error",t)),this._finish();}}_finish(){this._timeoutId&&clearTimeout(this._timeoutId),this._timeoutId=void 0;}_setupUI(t){if(void 0!==this._map){if(this._container.addEventListener("contextmenu",(e=>e.preventDefault())),this._geolocateButton=n("button","mapboxgl-ctrl-geolocate",this._container),n("span","mapboxgl-ctrl-icon",this._geolocateButton).setAttribute("aria-hidden","true"),this._geolocateButton.type="button",!1===t){e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");const t=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.disabled=!0,this._geolocateButton.setAttribute("aria-label",t),this._geolocateButton.firstElementChild&&this._geolocateButton.firstElementChild.setAttribute("title",t);}else {const e=this._map._getUIString("GeolocateControl.FindMyLocation");this._geolocateButton.setAttribute("aria-label",e),this._geolocateButton.firstElementChild&&this._geolocateButton.firstElementChild.setAttribute("title",e);}this.options.trackUserLocation&&(this._geolocateButton.setAttribute("aria-pressed","false"),this._watchState="OFF"),this.options.showUserLocation&&(this._dotElement=n("div","mapboxgl-user-location"),this._dotElement.appendChild(n("div","mapboxgl-user-location-dot")),this._dotElement.appendChild(n("div","mapboxgl-user-location-heading")),this._userLocationDotMarker=new en({element:this._dotElement,rotationAlignment:"map",pitchAlignment:"map"}),this._circleElement=n("div","mapboxgl-user-location-accuracy-circle"),this._accuracyCircleMarker=new en({element:this._circleElement,pitchAlignment:"map"}),this.options.trackUserLocation&&(this._watchState="OFF"),this._map.on("zoom",this._onZoom)),this._geolocateButton.addEventListener("click",this.trigger.bind(this)),this._setup=!0,this.options.trackUserLocation&&this._map.on("movestart",(t=>{t.geolocateSource||"ACTIVE_LOCK"!==this._watchState||t.originalEvent&&"resize"===t.originalEvent.type||(this._watchState="BACKGROUND",this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this.fire(new e.Event("trackuserlocationend")));}));}}_onDeviceOrientation(e){this._userLocationDotMarker&&(e.webkitCompassHeading?this._heading=e.webkitCompassHeading:!0===e.absolute&&(this._heading=-1*e.alpha),this._updateMarkerRotationThrottled());}trigger(){if(!this._setup)return e.warnOnce("Geolocate control triggered before added to a map"),!1;if(this.options.trackUserLocation){switch(this._watchState){case"OFF":this._watchState="WAITING_ACTIVE",this.fire(new e.Event("trackuserlocationstart"));break;case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":case"BACKGROUND_ERROR":this._numberOfWatches--,this._noTimeout=!1,this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this.fire(new e.Event("trackuserlocationend"));break;case"BACKGROUND":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._lastKnownPosition&&this._updateCamera(this._lastKnownPosition),this.fire(new e.Event("trackuserlocationstart"));}switch(this._watchState){case"WAITING_ACTIVE":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_LOCK":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"BACKGROUND":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");break;case"BACKGROUND_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");}if("OFF"===this._watchState&&void 0!==this._geolocationWatchID)this._clearWatch();else if(void 0===this._geolocationWatchID){let e;this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","true"),this._numberOfWatches++,this._numberOfWatches>1?(e={maximumAge:6e5,timeout:0},this._noTimeout=!0):(e=this.options.positionOptions,this._noTimeout=!1),this._geolocationWatchID=this.options.geolocation.watchPosition(this._onSuccess,this._onError,e),this.options.showUserHeading&&this._addDeviceOrientationListener();}}else this.options.geolocation.getCurrentPosition(this._onSuccess,this._onError,this.options.positionOptions),this._timeoutId=setTimeout(this._finish,1e4);return !0}_addDeviceOrientationListener(){const t=()=>{e.window.addEventListener("ondeviceorientationabsolute"in e.window?"deviceorientationabsolute":"deviceorientation",this._onDeviceOrientation);};void 0!==e.window.DeviceMotionEvent&&"function"==typeof e.window.DeviceMotionEvent.requestPermission?DeviceOrientationEvent.requestPermission().then((e=>{"granted"===e&&t();})).catch(console.error):t();}_clearWatch(){this.options.geolocation.clearWatch(this._geolocationWatchID),e.window.removeEventListener("deviceorientation",this._onDeviceOrientation),e.window.removeEventListener("deviceorientationabsolute",this._onDeviceOrientation),this._geolocationWatchID=void 0,this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","false"),this.options.showUserLocation&&this._updateMarker(null);}},AttributionControl:Hr,ScaleControl:class{constructor(t){this.options=e.extend({},un,t),this._isNumberFormatSupported=function(){try{return new Intl.NumberFormat("en",{style:"unit",unitDisplay:"short",unit:"meter"}),!0}catch(e){return !1}}(),e.bindAll(["_update","_setScale","setUnit"],this);}getDefaultPosition(){return "bottom-left"}_update(){const e=this.options.maxWidth||100,t=this._map,i=t._containerHeight/2,o=t._containerWidth/2-e/2,r=t.unproject([o,i]),n=t.unproject([o+e,i]),s=r.distanceTo(n);if("imperial"===this.options.unit){const t=3.2808*s;t>5280?this._setScale(e,t/5280,"mile"):this._setScale(e,t,"foot");}else "nautical"===this.options.unit?this._setScale(e,s/1852,"nautical-mile"):s>=1e3?this._setScale(e,s/1e3,"kilometer"):this._setScale(e,s,"meter");}_setScale(e,t,i){this._map._requestDomTask((()=>{const o=function(e){const t=Math.pow(10,`${Math.floor(e)}`.length-1);let i=e/t;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:i>=1?1:function(e){const t=Math.pow(10,Math.ceil(-Math.log(e)/Math.LN10));return Math.round(e*t)/t}(i),t*i}(t),r=o/t;this._container.innerHTML=this._isNumberFormatSupported&&"nautical-mile"!==i?new Intl.NumberFormat(this._language,{style:"unit",unitDisplay:"short",unit:i}).format(o):`${o}&nbsp;${_n[i]}`,this._container.style.width=e*r+"px";}));}onAdd(e){return this._map=e,this._language=e.getLanguage(),this._container=n("div","mapboxgl-ctrl mapboxgl-ctrl-scale",e.getContainer()),this._container.dir="auto",this._map.on("move",this._update),this._update(),this._container}onRemove(){this._container.remove(),this._map.off("move",this._update),this._map=void 0;}_setLanguage(e){this._language=e,this._update();}setUnit(e){this.options.unit=e,this._update();}},FullscreenControl:class{constructor(t){this._fullscreen=!1,t&&t.container&&(t.container instanceof e.window.HTMLElement?this._container=t.container:e.warnOnce("Full screen control 'container' must be a DOM element.")),e.bindAll(["_onClickFullscreen","_changeIcon"],this),"onfullscreenchange"in e.window.document?this._fullscreenchange="fullscreenchange":"onwebkitfullscreenchange"in e.window.document&&(this._fullscreenchange="webkitfullscreenchange");}onAdd(t){return this._map=t,this._container||(this._container=this._map.getContainer()),this._controlContainer=n("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._checkFullscreenSupport()?this._setupUI():(this._controlContainer.style.display="none",e.warnOnce("This device does not support fullscreen mode.")),this._controlContainer}onRemove(){this._controlContainer.remove(),this._map=null,e.window.document.removeEventListener(this._fullscreenchange,this._changeIcon);}_checkFullscreenSupport(){return !(!e.window.document.fullscreenEnabled&&!e.window.document.webkitFullscreenEnabled)}_setupUI(){const t=this._fullscreenButton=n("button","mapboxgl-ctrl-fullscreen",this._controlContainer);n("span","mapboxgl-ctrl-icon",t).setAttribute("aria-hidden","true"),t.type="button",this._updateTitle(),this._fullscreenButton.addEventListener("click",this._onClickFullscreen),e.window.document.addEventListener(this._fullscreenchange,this._changeIcon);}_updateTitle(){const e=this._getTitle();this._fullscreenButton.setAttribute("aria-label",e),this._fullscreenButton.firstElementChild&&this._fullscreenButton.firstElementChild.setAttribute("title",e);}_getTitle(){return this._map._getUIString(this._isFullscreen()?"FullscreenControl.Exit":"FullscreenControl.Enter")}_isFullscreen(){return this._fullscreen}_changeIcon(){(e.window.document.fullscreenElement||e.window.document.webkitFullscreenElement)===this._container!==this._fullscreen&&(this._fullscreen=!this._fullscreen,this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),this._updateTitle());}_onClickFullscreen(){this._isFullscreen()?e.window.document.exitFullscreen?e.window.document.exitFullscreen():e.window.document.webkitCancelFullScreen&&e.window.document.webkitCancelFullScreen():this._container.requestFullscreen?this._container.requestFullscreen():this._container.webkitRequestFullscreen&&this._container.webkitRequestFullscreen();}},Popup:class extends e.Evented{constructor(t){super(),this.options=e.extend(Object.create(tn),t),e.bindAll(["_update","_onClose","remove","_onMouseEvent"],this),this._classList=new Set(t&&t.className?t.className.trim().split(/\s+/):[]);}addTo(t){return this._map&&this.remove(),this._map=t,this.options.closeOnClick&&t.on("preclick",this._onClose),this.options.closeOnMove&&t.on("move",this._onClose),t.on("remove",this.remove),this._update(),t._addPopup(this),this._focusFirstElement(),this._trackPointer?(t.on("mousemove",this._onMouseEvent),t.on("mouseup",this._onMouseEvent),t._canvasContainer.classList.add("mapboxgl-track-pointer")):t.on("move",this._update),this.fire(new e.Event("open")),this}isOpen(){return !!this._map}remove(){this._content&&this._content.remove(),this._container&&(this._container.remove(),this._container=void 0);const t=this._map;return t&&(t.off("move",this._update),t.off("move",this._onClose),t.off("preclick",this._onClose),t.off("click",this._onClose),t.off("remove",this.remove),t.off("mousemove",this._onMouseEvent),t.off("mouseup",this._onMouseEvent),t.off("drag",this._onMouseEvent),t._canvasContainer&&t._canvasContainer.classList.remove("mapboxgl-track-pointer"),t._removePopup(this),this._map=void 0),this.fire(new e.Event("close")),this}getLngLat(){return this._lngLat}setLngLat(t){this._lngLat=e.LngLat.convert(t),this._pos=null,this._trackPointer=!1,this._update();const i=this._map;return i&&(i.on("move",this._update),i.off("mousemove",this._onMouseEvent),i._canvasContainer.classList.remove("mapboxgl-track-pointer")),this}trackPointer(){this._trackPointer=!0,this._pos=null,this._update();const e=this._map;return e&&(e.off("move",this._update),e.on("mousemove",this._onMouseEvent),e.on("drag",this._onMouseEvent),e._canvasContainer.classList.add("mapboxgl-track-pointer")),this}getElement(){return this._container}setText(t){return this.setDOMContent(e.window.document.createTextNode(t))}setHTML(t){const i=e.window.document.createDocumentFragment(),o=e.window.document.createElement("body");let r;for(o.innerHTML=t;r=o.firstChild,r;)i.appendChild(r);return this.setDOMContent(i)}getMaxWidth(){return this._container&&this._container.style.maxWidth}setMaxWidth(e){return this.options.maxWidth=e,this._update(),this}setDOMContent(e){let t=this._content;if(t)for(;t.hasChildNodes();)t.firstChild&&t.removeChild(t.firstChild);else t=this._content=n("div","mapboxgl-popup-content",this._container||void 0);if(t.appendChild(e),this.options.closeButton){const e=this._closeButton=n("button","mapboxgl-popup-close-button",t);e.type="button",e.setAttribute("aria-label","Close popup"),e.setAttribute("aria-hidden","true"),e.innerHTML="&#215;",e.addEventListener("click",this._onClose);}return this._update(),this._focusFirstElement(),this}addClassName(e){return this._classList.add(e),this._updateClassList(),this}removeClassName(e){return this._classList.delete(e),this._updateClassList(),this}setOffset(e){return this.options.offset=e,this._update(),this}toggleClassName(e){let t;return this._classList.delete(e)?t=!1:(this._classList.add(e),t=!0),this._updateClassList(),t}_onMouseEvent(e){this._update(e.point);}_getAnchor(e){if(this.options.anchor)return this.options.anchor;const t=this._map,i=this._container,o=this._pos;if(!t||!i||!o)return "bottom";const r=i.offsetWidth,n=i.offsetHeight,s=o.x<r/2,a=o.x>t.transform.width-r/2;if(o.y+e<n)return s?"top-left":a?"top-right":"top";if(o.y>t.transform.height-n){if(s)return "bottom-left";if(a)return "bottom-right"}return s?"left":a?"right":"bottom"}_updateClassList(){const e=this._container;if(!e)return;const t=[...this._classList];t.push("mapboxgl-popup"),this._anchor&&t.push(`mapboxgl-popup-anchor-${this._anchor}`),this._trackPointer&&t.push("mapboxgl-popup-track-pointer"),e.className=t.join(" ");}_update(t){const i=this._map,o=this._content;if(!i||!this._lngLat&&!this._trackPointer||!o)return;let r=this._container;if(r||(r=this._container=n("div","mapboxgl-popup",i.getContainer()),this._tip=n("div","mapboxgl-popup-tip",r),r.appendChild(o)),this.options.maxWidth&&r.style.maxWidth!==this.options.maxWidth&&(r.style.maxWidth=this.options.maxWidth),i.transform.renderWorldCopies&&!this._trackPointer&&(this._lngLat=Jr(this._lngLat,this._pos,i.transform)),!this._trackPointer||t){const e=this._pos=this._trackPointer&&t?t:i.project(this._lngLat),o=rn(this.options.offset),r=this._anchor=this._getAnchor(o.y),n=rn(this.options.offset,r),s=e.add(n).round();i._requestDomTask((()=>{this._container&&r&&(this._container.style.transform=`${Qr[r]} translate(${s.x}px,${s.y}px)`);}));}if(!this._marker&&i._showingGlobe()){const t=e.isLngLatBehindGlobe(i.transform,this._lngLat)?0:1;this._setOpacity(t);}this._updateClassList();}_focusFirstElement(){if(!this.options.focusAfterOpen||!this._container)return;const e=this._container.querySelector(on);e&&e.focus();}_onClose(){this.remove();}_setOpacity(e){this._container&&(this._container.style.opacity=`${e}`),this._content&&(this._content.style.pointerEvents=e?"auto":"none");}},Marker:en,Style:Kt,LngLat:e.LngLat,LngLatBounds:e.LngLatBounds,Point:e.Point,MercatorCoordinate:e.MercatorCoordinate,FreeCameraOptions:jo,Evented:e.Evented,config:e.config,prewarm:function(){Ue().acquire(Be);},clearPrewarmedResources:function(){const e=Fe;e&&(e.isPreloaded()&&1===e.numActive()?(e.release(Be),Fe=null):console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));},get accessToken(){return e.config.ACCESS_TOKEN},set accessToken(t){e.config.ACCESS_TOKEN=t;},get baseApiUrl(){return e.config.API_URL},set baseApiUrl(t){e.config.API_URL=t;},get workerCount(){return ke.workerCount},set workerCount(e){ke.workerCount=e;},get maxParallelImageRequests(){return e.config.MAX_PARALLEL_IMAGE_REQUESTS},set maxParallelImageRequests(t){e.config.MAX_PARALLEL_IMAGE_REQUESTS=t;},clearStorage(t){e.clearTileCache(t);},workerUrl:"",workerClass:null,setNow:e.exported.setNow,restoreNow:e.exported.restoreNow};return dn}));

  //
  // Our custom intro provides a specialized "define()" function, called by the
  // AMD modules below, that sets up the worker blob URL and then executes the
  // main module, storing its exported value as 'mapboxgl'


  var mapboxgl$1 = mapboxgl;

  return mapboxgl$1;

  }));

  });

  var mapboxgl = /*@__PURE__*/getDefaultExportFromCjs(mapboxGl);

  class MapLayer {
    /**
     * Map Instance initialization
     * @param context tool object
     * @param parent map factory instance
     */
    constructor(context, parent) {
      console.warn("constructor should be implemented in map instance", context, parent);
    }

    /**
     * Drawing map in their dom element
     */
    initMap() {
      console.warn("initMap method should be implemented in map instance");
    }

    /**
     * fit map to screen using ne-sw coordinates
     */
    rescaleMap() {
      console.warn("rescaleMap method should be implemented in map instance");
    }

    /**
     * Move map layer in pixels
     * @param {Integer} x
     * @param {Integer} y
     */
    moveOver(x, y) {
      console.warn("moveOver method should be implemented in map instance", x, y);
    }

    /**
     * return current canvas [[left, top], [right, bottom]]
     * @return {Array} []
     */
    getCanvas() {
      console.warn("getCanvas method should be implemented in map instance");
      return [[0, 0], [0, 0]];
    }

    /**
     * return map center {lat: lat, lng lng}
     * @return {Object} {}
     */
    getCenter() {
      console.warn("getCenter method should be implemented in map instance");
      return { lat: 0, lng: 0 };
    }

    /**
     * @param {Array} center
     * @param {bool} increment increase zoom if true
     */
    zoomMap(center, increment) {
      console.warn("zoomMap method should be implemented in map instance", center, increment);
    }

    /**
     * Translate lat, lon into x, y
     * @param lon
     * @param lat
     * @return {Array} [x, y]
     */
    geo2Point(lon, lat) {
      console.warn("geo2Point method should be implemented in map instance", lon, lat);
      return [0, 0];
    }

    /**
     * Translate x, y  into lat, lon
     * @param x
     * @param y
     * @return {Array} [lon, lat]
     */
    point2Geo(x, y) {
      console.warn("point2Geo method should be implemented in map instance", x,y);
      return [0, 0];
    }
  }

  class TopojsonLayer extends MapLayer {
    constructor(context, parent) {
      super(context, parent);
      this.shapes = null;
      this.mapLands = [];
      this.parent = parent;
      this.resolvedCentroidCache = {};
      this.context = context;
      this.parent = parent;
      this.paths = {};
      this.areasAreShown = false;
      d3GeoProjection();
    }

    initMap() {
      const _this = this;
      this.mapGraph = this.parent.mapSvg.html("").append("g")
        .attr("class", "vzb-bmc-map-graph");
      
      const assetName = sharedComponents.LegacyUtils.getProp(this.context, ["ui", "map", "topology", "path"])
        || ("assets/world-50m.json");

      const projection = "geo" + sharedComponents.LegacyUtils.capitalize(this.context.ui.map.projection);

      this.zeroProjection = d3$1[projection]();
      this.zeroProjection
        .scale(1)
        .translate([0, 0]);

      this.projection = d3$1[projection]();
      this.projection
        .scale(1)
        .translate([0, 0]);

      this.mapPath = d3$1.geoPath()
        .projection(this.projection);


      this.context.ui.map.scale = 1;
      return this.context.ui.map.skipShapesLoading ? Promise.resolve() : this._loadShapes(assetName).then(
        shapes => {
          _this.parent.inPreload = false;
          _this.shapes = shapes;
          _this.mapFeature = topojson.feature(_this.shapes, _this.shapes.objects[this.context.ui.map.topology.objects.boundaries]);
          _this.mapBounds = _this.mapPath.bounds(_this.mapFeature);
          _this.boundaries = topojson.mesh(_this.shapes, _this.shapes.objects[_this.context.ui.map.topology.objects.boundaries], (a, b) => a !== b);
          if (_this.mapFeature.features) {
            sharedComponents.LegacyUtils.forEach(_this.mapFeature.features, (feature) => {
              feature.key = feature.properties[_this.context.ui.map.topology.geoIdProperty] ?
                feature.properties[_this.context.ui.map.topology.geoIdProperty].toString() : feature.id;
              _this.paths[feature.key] = feature;
            });
          }
        }
      );
    }

    showAreas() {
      const _this = this;
      this.areasAreShown = true;
      if (_this.mapFeature.features) {
        _this.mapLands = _this.mapGraph.selectAll(".land")
          .data(_this.mapFeature.features)
          .enter().insert("path")
          .attr("d", _this.mapPath)
          .attr("class", "land")
          .style("opacity", _this.context.ui.opacitySelectDim)
          .on("mouseover", (event, d) => {
            _this.parent._interact()._mouseover(event, d.key);
          })
          .on("mouseout", (event, d) => {
            _this.parent._interact()._mouseout(event, d.key);
          })
          .on("click", (event, d) => {
            _this.parent._interact()._click(event, d.key);
          })
          .onTap((event, d) => {
            _this.parent._interact()._click(event, d.key);
            event.stopPropagation();
          })
          .each(function(d) {
            const view = d3$1.select(this);
            view
              .attr("id", d.key)
              .style("opacity", d => _this.parent.getOpacity(d.key))
              .style("fill", d => _this.parent.getMapColor(d.key));
          });
      } else {
        _this.mapGraph.insert("path")
          .datum(_this.mapFeature)
          .attr("class", "land");

      }
      _this.mapGraph.insert("path")
        .datum(_this.boundaries)
        .attr("class", "boundary");
    }

    hideAreas() {
      this.areasAreShown = false;
      this.mapGraph.selectAll("*").remove();
    }

    updateOpacity() {
      const _this = this;
      this.mapLands
        .style("opacity", d => _this.parent.getOpacity(d.key));
    }

    updateMapColors() {
      const _this = this;
      this.mapLands
        .style("fill", d => _this.parent.getMapColor(d.key));
    }

    _loadShapes(assetName) {
      this.parent.inPreload = true;
      return this.context.model.data.source.reader.getAsset(assetName);
    }

    rescaleMap(canvas, preserveAspectRatio) {
      //var topoCanvas =
      let emitEvent = false;
      const margin = {left: 0, top: 0}; //the map is done in full bleed, so we don't care about margins

      const currentNW = this.zeroProjection([
        this.context.ui.map.bounds.west,
        this.context.ui.map.bounds.north
      ]);
      const currentSE = this.zeroProjection([
        this.context.ui.map.bounds.east,
        this.context.ui.map.bounds.south
      ]);
      let scaleDelta = 1, mapTopOffset = 0, mapLeftOffset = 0;

      if (!canvas || preserveAspectRatio) {
        if (!canvas) {
          emitEvent = true;
          canvas = [
            [0, 0],
            [this.context.chartWidth, this.context.chartHeight]
          ];
          mapTopOffset =  margin.top;
          mapLeftOffset =  margin.left;
        }
        const scaleX = Math.abs((canvas[1][0] - canvas[0][0]) / (currentSE[0] - currentNW[0]));
        const scaleY = Math.abs((canvas[1][1] - canvas[0][1]) / (currentSE[1] - currentNW[1]));
        if (scaleX != scaleY) {
          if (scaleX > scaleY) {
            scaleDelta = scaleY;
            mapLeftOffset += (Math.abs(canvas[1][0] - canvas[0][0]) - Math.abs(scaleDelta * (currentNW[1] - currentSE[1]))) / 2;
          } else {
            scaleDelta = scaleX;
            mapTopOffset += (Math.abs(canvas[1][1] - canvas[0][1]) - Math.abs(scaleDelta * (currentNW[0] - currentSE[0]))) / 2;
          }
        }
      } else {
        scaleDelta = Math.abs((canvas[1][0] - canvas[0][0]) / (currentSE[0] - currentNW[0]));
      }
      // translate projection to the middle of map
      this.projection
        .translate([canvas[0][0] - (currentNW[0] * scaleDelta) + mapLeftOffset - margin.left, canvas[0][1] - (currentNW[1] * scaleDelta) + mapTopOffset - margin.top])
        .scale(scaleDelta)
        .precision(0.1);

      this.mapGraph
        .selectAll("path").attr("d", this.mapPath);

      // resize and put in center
      this.parent.mapSvg
        .style("transform", "translate(" + margin.left + "px," + margin.top + "px)")
        .attr("width", this.context.chartWidth)
        .attr("height", this.context.chartHeight);

      // set skew function used for bubbles in chart
      this.geo2Point(
        this.context.ui.map.bounds.west,
        this.context.ui.map.bounds.north
      );
      this.geo2Point(
        this.context.ui.map.bounds.east,
        this.context.ui.map.bounds.south
      );

      // if canvas not received this map is main and shound trigger redraw points on tool
      if (emitEvent) {
        this.parent.boundsChanged(false);
      }
    }

    centroid(key) {
      if ((key || key == 0) && this.paths[key]) {
        if (this.resolvedCentroidCache[key]) return this.geo2Point(this.resolvedCentroidCache[key][0], this.resolvedCentroidCache[key][1]);
        const centroid = this.mapPath.centroid(this.paths[key]);
        this.resolvedCentroidCache[key] = this.point2Geo(centroid[0], centroid[1]);
        return centroid;
      }
      return null;
    }

    geo2Point(lon, lat) {
      return this.projection([lon || 0, lat || 0]);
    }

    point2Geo(x, y) {
      return this.projection.invert([x || 0, y || 0]);
    }

    getCanvas() {
      return [
        this.geo2Point(this.context.ui.map.bounds.west, this.context.ui.map.bounds.north),
        this.geo2Point(this.context.ui.map.bounds.east, this.context.ui.map.bounds.south)
      ];
    }

    moveOver(x, y) {
      const translate = this.projection.translate();
      this.projection
        .translate([translate[0] + x, translate[1] + y]);

      this.mapGraph
        .selectAll("path").attr("d", this.mapPath);
    }

    zoomMap(center, increment) {
      return new Promise(resolve => {
        const point = this.geo2Point(center[0], center[1]);
        const margin = {left: 0, top: 0}; //the map is done in full bleed, so we don't care about margins
        const leftOffset = margin.left;//this.context.width / 2 - point[0];
        const topOffset = margin.top;//this.context.height / 2 - point[1];
        const wMod = Math.min(2, Math.max(0, (point[0]) / this.context.chartWidth * 2));
        const hMod = Math.min(2, Math.max(0, (point[1]) / this.context.chartHeight * 2));
        const wScale = this.context.chartWidth * 0.1 * increment;
        const hScale = this.context.chartHeight * 0.1 * increment;
        this.rescaleMap([
          [-wScale * wMod + leftOffset, -hScale * hMod + topOffset],
          [
            this.context.chartWidth + wScale * (2 - wMod) + leftOffset,
            this.context.chartHeight + hScale * (2 - hMod) + topOffset
          ]
        ], true);
        resolve();
      });
    }
  }

  class GoogleMapLayer extends MapLayer {

    constructor(context, parent) {
      super(context, parent);
      this.context = context;
      this.parent = parent;
      this.bounds = null;
      this.transformation = null;
    }

    initMap() {
      const _this = this;
      this.mapCanvas = this.parent.mapRoot;
      this.mapCanvas
        .style("width", "100%")
        .style("height", "100%");

      Google.KEY = "AIzaSyAP0vMZwYojifwGYHTnEtYV40v6-MdLGFM";
      return new Promise((resolve) => {
        Google.load(google => {
          _this.google = google;
          _this.map = new google.maps.Map(_this.mapCanvas.node(), {
            draggable: false,
            zoomControl: false,
            scrollwheel: false,
            disableDoubleClickZoom: true,
            disableDefaultUI: true,
            backgroundColor: "#FFFFFF"
          });
          _this.updateLayer();
          _this.overlay = new google.maps.OverlayView();
          _this.overlay.draw = function() {
          };
          _this.overlay.setMap(_this.map);
          // set initial bounds on load, sometimes "rescaleMap" method is not working correctly
          google.maps.event.addListener(_this.map, "bounds_changed", () => {
            if (!(this.transformation instanceof Promise)) {
              this.transformation = new Promise((resolve) => {
                google.maps.event.addListenerOnce(_this.map, "idle", () => {
                  resolve();
                  this.transformation = null;
                });
              });
            }
          });

          google.maps.event.addListenerOnce(_this.map, "idle", () => {
            const rectBounds = new google.maps.LatLngBounds(
              new google.maps.LatLng(_this.context.ui.map.bounds.north, _this.context.ui.map.bounds.west),
              new google.maps.LatLng(_this.context.ui.map.bounds.south, _this.context.ui.map.bounds.east)
            );
            _this.map.fitBounds(rectBounds);
            google.maps.event.trigger(_this.map, "resize");
          });

          /*
           const rectangle = new google.maps.Rectangle({
           bounds: {
           north: _this.context.ui.map.bounds.north,
           east: _this.context.ui.map.bounds.east,
           south: _this.context.ui.map.bounds.south,
           west: _this.context.ui.map.bounds.west
           },
           editable: true,
           draggable: true
           });
           rectangle.setMap(_this.map);
  */
          resolve();
        });
      });
    }

    _waitMap() {
      if (this.transformation instanceof Promise) {
        return this.transformation;
      } else {
        return new Promise((resolve) => resolve());
      }
    }
    
    updateLayer() {
      if (this.map) {
        const style = this.context.ui.map.mapStyle.split(" ");
        this.map.setMapTypeId(style[0]);
        if (style[1]) {
          switch (style[1]) {
          case "grayscale":
            this.map.setOptions({
              styles: [{
                stylers: [{
                  saturation: -100
                }]
              }]
            });
            break;
          default:
            this.map.setOptions({
              styles: []
            });
          }
        } else {
          this.map.setOptions({
            styles: []
          });
        }
      }
    }

    rescaleMap() {
      this._waitMap().then(() => {
        const rectBounds = new this.google.maps.LatLngBounds(
          new this.google.maps.LatLng(this.context.ui.map.bounds.north, this.context.ui.map.bounds.west),
          new this.google.maps.LatLng(this.context.ui.map.bounds.south, this.context.ui.map.bounds.east)
        );
        this.map.fitBounds(rectBounds);
        this.google.maps.event.trigger(this.map, "resize");
        this.google.maps.event.addListener(this.map, "idle", () => {
          const bounds = this.map.getBounds();
          if (bounds && (!this.bounds || this.bounds != bounds)) {
            this.bounds = bounds;
            this.parent.boundsChanged();
          }
        });
      });
    }

    zoomMap(center, increment) {
      const _this = this;
      return new Promise((resolve) => {
        const zoomPoint = this.geo2Point(center[0], center[1]);
        _this.map.setZoom(_this.map.getZoom() + 1 * increment);
        const zoomPoint1 = this.geo2Point(center[0], center[1]);
        _this.map.panBy(zoomPoint1[0] - zoomPoint[0], zoomPoint1[1] - zoomPoint[1]);
        _this.google.maps.event.addListenerOnce(_this.map, "idle", () => {
          resolve();
        });
      });
    }


    geo2Point(x, y) {
      const projection = this.overlay.getProjection();
      if (!projection) {
        return null;
      }
      const coords = projection.fromLatLngToContainerPixel(new this.google.maps.LatLng(y, x));
      return [coords.x, coords.y];
    }

    point2Geo(x, y) {
      const projection = this.map.getProjection();
      const ne = this.map.getBounds().getNorthEast();
      const sw = this.map.getBounds().getSouthWest();
      const topRight = projection.fromLatLngToPoint(ne);
      const bottomLeft = projection.fromLatLngToPoint(sw);
      const scale = Math.pow(2, this.map.getZoom());
      const point = projection.fromPointToLatLng(new this.google.maps.Point(x / scale + bottomLeft.x, y / scale + topRight.y));
      return [point.lng(), point.lat()];
    }

    moveOver(x, y) {
      const _this = this;
      return new Promise((resolve) => {
        _this.map.panBy(-x, -y);
        _this.google.maps.event.addListenerOnce(_this.map, "idle", () => {
          resolve();
        });
      });
    }

    getZoom() {
      return this.map.getZoom();
    }

    getCanvas() {
      return [
        this.geo2Point(this.context.ui.map.bounds.west, this.context.ui.map.bounds.north),
        this.geo2Point(this.context.ui.map.bounds.east, this.context.ui.map.bounds.south)
      ];
    }

    getCenter() {
      const center = this.map.getCenter();
      return { lat: center.lat(), lng: center.lng() };
    }
  }

  class MapboxLayer extends MapLayer {

    constructor(context, parent) {
      super(context, parent);
      mapboxgl.accessToken = context.ui.map.accessToken || "pk.eyJ1Ijoic2VyZ2V5ZiIsImEiOiJjaXlqeWo5YnYwMDBzMzJwZnlwZXJ2bnA2In0.e711ku9KzcFW_x5wmOZTag";
      this.context = context;
      this.parent = parent;
    }

    initMap() {
      const _this = this;
      this.mapCanvas = this.parent.mapRoot;
      return new Promise((resolve) => {
        _this.map = new mapboxgl.Map({
          container: _this.mapCanvas.node(),
          interactive: false,
          style: this.context.ui.map.mapStyle,
          hash: false
        });
        _this.bounds = [[
          _this.context.ui.map.bounds.west,
          _this.context.ui.map.bounds.south
        ], [
          _this.context.ui.map.bounds.east,
          _this.context.ui.map.bounds.north
        ]];
        _this.map.fitBounds(_this.bounds);
        resolve();
      });
    }

    rescaleMap(duration) {
      const _this = this;
      _this.bounds = [[
        _this.context.ui.map.bounds.west,
        _this.context.ui.map.bounds.south
      ], [
        _this.context.ui.map.bounds.east,
        _this.context.ui.map.bounds.north
      ]];
      sharedComponents.LegacyUtils.defer(() => {
        if (!duration) duration = 0;
        _this.map.fitBounds(_this.bounds, { duration: duration });
        _this.map.resize();
        if (duration) {
          sharedComponents.LegacyUtils.delay(duration).then(() => {
            _this.parent.boundsChanged();
          });        
        } else {
          _this.parent.boundsChanged();
        }
      });
    }

    getCenter() {
      const center = this.map.getCenter();
      return { lat: center.lat, lng: center.lng };
    }

    moveOver(dx, dy) {
      this.map.panBy([-dx, -dy], { duration: 0 });
    }

    zoomMap(center, increment) {
      const _this = this;
      return new Promise((resolve) => {
        this.map.easeTo({
          duration: 300,
          around: center,
          zoom: _this.map.getZoom() + 1 * increment
        });
        sharedComponents.LegacyUtils.delay(300).then(
          () => {
            resolve();
          }
        );
      });
    }

    updateLayer() {
      if (this.map) {
        this.map.setStyle(this.context.ui.map.mapStyle);
      }
    }

    getCanvas() {
      return [
        this.geo2Point(this.context.ui.map.bounds.west, this.context.ui.map.bounds.north),
        this.geo2Point(this.context.ui.map.bounds.east, this.context.ui.map.bounds.south)
      ];
    }

    geo2Point(lon, lat) {
      const coords = this.map.project([lon, lat]);
      return [coords.x, coords.y];
    }

    point2Geo(x, y) {
      const geo = this.map.unproject([x, y]);
      return [geo.lng, geo.lat];
    }


  }

  class Map$1 {
    constructor(context, domSelector) {
      this.context = context;
      this.domSelector = domSelector;
      this.zooming = false;
      this.topojsonMap = null;
      this.keys = {};
      this.mapEngine = this.context.ui.map.mapEngine;
      this.mapInstance = null;
      if (this.context.element instanceof d3$1.selection) {
        this.mapRoot = this.context.element.select(domSelector);
        this.mapSvg = this.context.element.select(".vzb-bmc-map-background");
      } else {
        this.mapRoot = d3$1.select(this.context.element).select(domSelector);
        this.mapSvg = d3$1.select(this.context.element).select(".vzb-bmc-map-background");
      }
      this.mapRoot.html("");
      this.mapSvg.html("");
      return this;
    }

    getMap() {
      if (!this.mapInstance) {
        if (this.context.ui.map.showMap) {
          switch (this.context.ui.map.mapEngine) {
          case "google":
            this.mapInstance = new GoogleMapLayer(this.context, this);
            break;
          case "mapbox":
            this.mapInstance = new MapboxLayer(this.context, this);
            break;
          }
        }
        if (!this.topojsonMap) {
          this.topojsonMap = new TopojsonLayer(this.context, this);
        }
        return this;
      }
    }

    initMap() {
      if (!this.mapInstance) {
        return this.topojsonMap.initMap(this.domSelector).then(() => {
          this.topojsonMap.showAreas();
        });
      }
      const topojsonPromise = this.topojsonMap.initMap(this.domSelector);
      if (this.context.ui.map.showAreas) {
        topojsonPromise.then(() => {
          this.topojsonMap.showAreas();
        });
      }
      return Promise.all([
        this.mapInstance.initMap(this.domSelector),
        topojsonPromise
      ]);
    }

    ready() {
      const _this = this;
      this._bounds = null;
      let x1, y1, x2, y2;
      // this.keys = Object.keys(_this.context.values.hook_centroid)
      //   .reduce((obj, key) => {
      //     obj[_this.context.values.hook_centroid[key]] = key;
      //     return obj;
      //   }, {});
      this.keys = _this.context.__dataProcessed
        .reduce((obj, data) => {
          obj[data.centroid] = data[Symbol.for("key")];
          return obj;
        }, {});
      sharedComponents.LegacyUtils.forEach(this.keys, (val, key) => {
        const centroid = this.topojsonMap.centroid(key);
        if (!centroid) return;
        if ((!x1 && x1 != 0) || x1 > centroid[0]) {
          x1 = centroid[0];
        }
        if ((!x2 && x2 != 0) || x2 < centroid[0]) {
          x2 = centroid[0];
        }
        if ((!y1 && y1 != 0) || y1 > centroid[1]) {
          y1 = centroid[1];
        }
        if ((!y2 && y2 != 0) || y2 < centroid[1]) {
          y2 = centroid[1];
        }
      });
      if (x1 < x2 && y1 < y2) {
        const nw = this.topojsonMap.point2Geo(x1, y1);
        const se = this.topojsonMap.point2Geo(x2, y2);
        this._bounds = {
          west: nw[0],
          north: nw[1],
          east: se[0],
          south: se[1]
        };
      }
      this.context.mapBoundsChanged();
    }

    rescaleMap() {
      if (this.mapInstance) {
        this.mapRoot
          .style("position", "absolute")
          .style("left", 0)
          .style("right", 0)
          .style("top", 0)
          .style("bottom", 0)
          .style("width", this.context.width + "px")
          .style("height", this.context.height + (this.context.ui.map.overflowBottom || 0) + "px");
        this.mapInstance.rescaleMap();
      } else {
        this.topojsonMap.rescaleMap();
      }
    }

    layerChanged() {
      if (this.mapEngine == this.context.ui.map.mapEngine &&
        this.context.ui.map.showMap &&
        this.mapInstance) {
        if (this.topojsonMap.areasAreShown != this.context.ui.map.showAreas) {
          if (!this.context.ui.map.showAreas) {
            this.topojsonMap.hideAreas();
          } else {
            this.topojsonMap.showAreas();
          }
        }
        this.mapInstance.updateLayer();
      } else {
        this.mapEngine = this.context.ui.map.mapEngine;
        this.mapInstance = null;
        this.mapRoot.html("");
        this.getMap();
        this.initMap(this.domSelector).then(
          () => {
            if (this.mapInstance) {
              this.mapInstance.rescaleMap();
            } else {
              this.topojsonMap.rescaleMap();
            }
          });
      }
    }

    getMapColor(key) {
      const datapoint = this.context.model.dataMap.get(key);
      return datapoint ? this.context.mcScale(datapoint.color_map) : this.context.COLOR_WHITEISH;
    }

    getOpacity(key) {
      if (this.keys[key]) {
        return this.context.getMapOpacity(this.keys[key]);
      }
      return this.context.COLOR_WHITEISH;
    }

    updateColors() {
      if (this.context.ui.map.showAreas) {
        this.topojsonMap.updateMapColors();
      }
    }

    _getCenter() {
      if (this.mapInstance) {
        return this.mapInstance.getCenter();
      }
      return this.topojsonMap.getCenter();
    }
    
    resetZoom(duration) {
      if (this._bounds) {
        this._hideTopojson();
        this.context.ui.map.bounds = {
          west: this._bounds.west,
          north: this._bounds.north,
          east: this._bounds.east,
          south: this._bounds.south
        };
        if (this.mapInstance) {
          this.mapInstance.rescaleMap(duration);
        } else {
          this.topojsonMap.rescaleMap(duration);
        }
        if (!duration) duration = 0;
        return new Promise((resolve) => {
          sharedComponents.LegacyUtils.delay(duration).then(() => {
            this._showTopojson(300);
            resolve();
          });
        });
      } 
    }
    
    panStarted() {
      this.zooming = true;
      if (this.context.ui.map.showMap) {
        this._hideTopojson();
      }
      this.canvasBefore = this.getCanvas();
    }

    panFinished() {
      const nw = this.point2Geo(this.canvasBefore[0][0], this.canvasBefore[0][1]);
      const se = this.point2Geo(this.canvasBefore[1][0], this.canvasBefore[1][1]);
      this.context.ui.map.bounds = {
        west: nw[0],
        north: nw[1],
        east: se[0],
        south: se[1]
      };
      this.zooming = false;
      this.boundsChanged();
      this._showTopojson(300);
    }

    zoomRectangle(x1, y1, x2, y2) {
      const nw = this.point2Geo(Math.min(x1, x2), Math.min(y1, y2));
      const se = this.point2Geo(Math.max(x1, x2), Math.max(y1, y2));
      this.context.ui.map.bounds = {
        west: nw[0],
        north: nw[1],
        east: se[0],
        south: se[1]
      };
      this.zooming = false;
      if (this.mapInstance) {
        this.mapInstance.rescaleMap();
      } else {
        this.topojsonMap.rescaleMap();
      }
      this._showTopojson(300);
    }

    moveOver(dx, dy) {
      if (this.mapInstance) {
        return this.mapInstance.moveOver(dx, dy);
      }
      this.topojsonMap.moveOver(dx, dy);
    }

    _interact() {
      return this.context._mapInteract();
    }

    updateOpacity() {
      if (this.context.ui.map.showAreas) {
        this.topojsonMap.updateOpacity();
      }
    }

    _hideTopojson(duration) {
      if (this.context.ui.map.showAreas) {
        if (duration) {
          this.topojsonMap.mapGraph
            .transition()
            .duration(duration)
            .style("opacity", 0);
        } else {
          this.topojsonMap.mapGraph
            .style("opacity", 0);
        }
      }
    }

    _showTopojson(duration) {
      if (this.context.ui.map.showAreas) {
        this.topojsonMap.mapGraph
          .interrupt()
          .transition()
          .duration(duration)
          .style("opacity", duration);
      }
    }

    /**
     * @param {Array} center
     * @param {Integer} increment increase zoom if 1 decrease if -1
     */
    zoomMap(center, increment) {
      const _this = this;
      const geoCenter = this.point2Geo(center[0], center[1]);
      this.canvasBefore = this.getCanvas();
      this.zooming = true;
      if (this.context.ui.map.showMap) {
        this._hideTopojson(100);
      }
      let response;
      if (this.mapInstance) {
        response = this.mapInstance.zoomMap(geoCenter, increment);
      } else if (this.context.ui.map.showAreas) {
        response = this.topojsonMap.zoomMap(geoCenter, increment);
      }
      return response.then(
        () => {
          const nw = this.point2Geo(this.canvasBefore[0][0], this.canvasBefore[0][1]);
          const se = this.point2Geo(this.canvasBefore[1][0], this.canvasBefore[1][1]);
          _this.context.ui.map.bounds = {
            west: nw[0],
            north: nw[1],
            east: se[0],
            south: se[1]
          };
          this.zooming = false;
          this.boundsChanged();
          /*
           if (_this.mapInstance) {
           _this.mapInstance.rescaleMap();
           } else {
           */
          //          _this.topojsonMap.rescaleMap();
          //        }
          this._showTopojson(300);
        }
      );
    }

    boundsChanged(rescaleTopojson = true) {
      if (!this.zooming) {
        if (rescaleTopojson) {
          let canvas;
          if (this.mapInstance) {
            canvas = this.mapInstance.getCanvas();
          }
          this.topojsonMap.rescaleMap(canvas);
        }
        this.context.mapBoundsChanged();
      }
    }

    centroid(key) {
      if (this.topojsonMap) {
        return this.topojsonMap.centroid(key);
      }
      return null;
    }

    getCanvas() {
      if (this.mapInstance) {
        return this.mapInstance.getCanvas();
      } else if (this.context.ui.map.showAreas) {
        return this.topojsonMap.getCanvas();
      }
      return [[0, 0], [0, 0]];
    }

    point2Geo(x, y) {
      if (this.mapInstance) {
        return this.mapInstance.point2Geo(x, y);
      } else if (this.context.ui.map.showAreas) {
        return this.topojsonMap.point2Geo(x, y);
      }
      return [0, 0];
    }

    geo2Point(lon, lat) {
      if (this.mapInstance) {
        return this.mapInstance.geo2Point(lon, lat);
      } else if (this.context.ui.map.showAreas) {
        return this.topojsonMap.geo2Point(lon, lat);
      }
      return [0, 0];
    }

  }

  const {ICON_QUESTION} = sharedComponents.Icons;
  //const COLOR_BLACKISH = "rgb(51, 51, 51)";
  const COLOR_WHITEISH = "rgb(253, 253, 253)";

  const MAX_RADIUS_EM = 0.05;

  const PROFILE_CONSTANTS = (width, height) => ({
    SMALL: {
      margin: { top: 10, right: 10, left: 10, bottom: 0 },
      infoElHeight: 16,
      minRadiusPx: 0.5,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
    },
    MEDIUM: {
      margin: { top: 20, right: 20, left: 20, bottom: 30 },
      infoElHeight: 20,
      minRadiusPx: 1,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
    },
    LARGE: {
      margin: { top: 30, right: 30, left: 30, bottom: 35 },
      infoElHeight: 22,
      minRadiusPx: 1,
      maxRadiusPx: Math.max(0.5, MAX_RADIUS_EM * sharedComponents.LegacyUtils.hypotenuse(width, height)),
    }
  });

  const PROFILE_CONSTANTS_FOR_PROJECTOR = () => ({
    MEDIUM: {
      infoElHeight: 26
    },
    LARGE: {
      infoElHeight: 32
    }
  });

  //BUBBLE MAP CHART COMPONENT
  class _VizabiExtApiMap extends sharedComponents.Chart {

    constructor(config) {

      config.template = `
      <div id="vzb-map-background"></div>
      <svg class="vzb-extapimap-svg vzb-export">
          <g class="vzb-bmc-map-background"></g>
          <g class="vzb-bmc-graph">
              <g class="vzb-bmc-titles">
                <g class="vzb-bmc-date"></g>
                <g class="vzb-bmc-axis-s-title"><text></text></g>
                <g class="vzb-bmc-axis-c-title"><text></text></g>
                <g class="vzb-bmc-axis-a-title"><text></text></g>

                <g class="vzb-bmc-axis-s-info vzb-noexport"></g>
                <g class="vzb-bmc-axis-c-info vzb-noexport"></g>
                <g class="vzb-bmc-axis-a-info vzb-noexport"></g>
              </g>


              <g class="vzb-bmc-lines"></g>
              <g class="vzb-bmc-bubbles"></g>

              <g class="vzb-bmc-labels"></g>
              <rect class="vzb-bc-zoom-rect"></rect>
          </g>
      </svg>
    `;

      config.subcomponents = [{
        type: sharedComponents.Labels,
        placeholder: ".vzb-bmc-labels",      
        options: {
          CSS_PREFIX: "vzb-bmc",
          LABELS_CONTAINER_CLASS: "vzb-bmc-labels",
          LINES_CONTAINER_CLASS: "vzb-bmc-lines",
          SUPPRESS_HIGHLIGHT_DURING_PLAY: false
        },
        name: "labels"
      },{
        type: sharedComponents.DateTimeBackground,
        placeholder: ".vzb-bmc-date"
      }];

      super(config);
    }

    setup() {
      this.DOM = {
        chartSvg: this.element.select("svg"),
        zoomRect: this.element.select(".vzb-bc-zoom-rect")
      };
      this.DOM.chartSvg.select(".vzb-bmc-graph").call(graph => 
        Object.assign(this.DOM, {
          graph,
          titles: graph.select(".vzb-bmc-titles"),
          bubbleContainerCrop: graph.select(".vzb-bmc-bubbles-crop"),
          bubbleContainer: graph.select(".vzb-bmc-bubbles"),
          labelListContainer: graph.select(".vzb-bmc-bubble-labels"),
          sTitle: graph.select(".vzb-bmc-axis-s-title"),
          cTitle: graph.select(".vzb-bmc-axis-c-title"),
          aTitle: graph.select(".vzb-bmc-axis-a-title"),
          sInfo: graph.select(".vzb-bmc-axis-s-info"),
          cInfo: graph.select(".vzb-bmc-axis-c-info"),
          aInfo: graph.select(".vzb-bmc-axis-a-info"),
          year: graph.select(".vzb-bmc-date")
        })
      );

      this.bubblesDrawing = null;

      this.isMobile = sharedComponents.LegacyUtils.isMobileOrTablet();

      this._date = this.findChild({type: "DateTimeBackground"});
      this._date.setConditions({ xAlign: "left", yAlign: "bottom" });

      this._labels = this.findChild({type: "Labels"});

      const zoomOnWheel = function(event) {
        if (_this.ui.zoomOnScrolling) {
          const mouse = d3$1.pointer(event);
          _this._hideEntities();
          _this.map.zoomMap(mouse, event.wheelDelta > 0 ? 1 : -1).then(
            () => {
              _this._showEntities(100);
            }
          );
          event.stopPropagation();
          event.preventDefault();
          event.returnValue = false;
          return false;
        }
      };

      this.element.call(this._createMapDragger());
      this.element.on("mousewheel", zoomOnWheel)
        .on("wheel", zoomOnWheel);

      const _this = this;
      d3$1.select("body")
        .on("keydown", event => {
          if (_this.ui.cursorMode !== "arrow" && _this.ui.cursorMode !== "hand") return;
          if (event.metaKey || event.ctrlKey) {
            _this.DOM.chartSvg.classed("vzb-zoomin", true);
            //_this.ui.set("cursorMode", "plus", false, false);
          }
        })
        .on("keyup", event => {
          if (_this.ui.cursorMode !== "arrow" && _this.ui.cursorMode !== "hand") return;
          if (!event.metaKey && !event.ctrlKey) {
            _this.DOM.chartSvg.classed("vzb-zoomin", false);
            //_this.ui.set("cursorMode", "arrow", false, false);
          }
        })
        //this is for the case when user would press ctrl and move away from the browser tab or window
        //keyup event would happen somewhere else and won't be captured, so zoomin class would get stuck
        .on("mouseenter", event => {
          if (_this.ui.cursorMode !== "arrow" && _this.ui.cursorMode !== "hand") return;
          if (!event.metaKey && !event.ctrlKey) {
            _this.ui.cursorMode = "arrow";
          }
        });

      this.root.element.on("custom-resetZoom.extapimap", () => {
        _this._hideEntities();
        _this.map.resetZoom(500).then(() => {
          _this._showEntities();
        });
      });
    
    }

    get MDL(){
      return {
        frame: this.model.encoding.frame,
        selected: this.model.encoding.selected,
        highlighted: this.model.encoding.highlighted,
        superHighlighted: this.model.encoding.superhighlighted,
        size: this.model.encoding.size,
        color: this.model.encoding.color,
        mapColor: this.model.encoding.color_map,
        label: this.model.encoding.label,
        centroid: this.model.encoding.centroid
      };
    }

    draw(){
      this.localise = this.services.locale.auto(this.MDL.frame.interval);

      this.treemenu = this.root.findChild({type: "TreeMenu"});

      // new scales and axes
      this.sScale = this.MDL.size.scale.d3Scale;
      this.cScale = color => color? this.MDL.color.scale.d3Scale(color) : COLOR_WHITEISH;
      this.mcScale = color => color? this.MDL.mapColor.scale.d3Scale(color) : COLOR_WHITEISH;

      this.TIMEDIM = this.MDL.frame.data.concept;
      this.KEYS = this.model.data.space.filter(dim => dim !== this.TIMEDIM);

      if (this._updateLayoutProfile()) return; //return if exists with error

      mobx.runInAction(() => {
        this.preload().then(() => {
          if (this.map.inPreload) return;
          this.addReaction(this._updateSize);
          //this.addReaction(this._updateMarkerSizeLimits);
          this.addReaction(this._getDuration);
          this.addReaction(this._drawData);
          this.addReaction(this._mapReady);
          this.addReaction(this._updateMap);
          this.addReaction(this._updateMapColors);
          this.addReaction(this._updateOpacity);
          this.addReaction(this._blinkSuperHighlighted);
          this.addReaction(this._updateUIStrings);
          this.addReaction(this._highlightDataPoints);
          this.addReaction(this._selectDataPoints);
          //this.addReaction(this._redrawData);

          this.addReaction(this._setupCursorMode);
        });
      });
    }

    _mapReady() {
      this.status;
      mobx.runInAction(() => {
        this.map.ready();
      });
    }
    
    _updateLayoutProfile(){
      this.services.layout.size;

      this.height = (this.element.node().clientHeight) || 0;
      this.width = (this.element.node().clientWidth) || 0;
      
      this.profileConstants = this.services.layout.getProfileConstants(
        PROFILE_CONSTANTS(this.width, this.height), 
        PROFILE_CONSTANTS_FOR_PROJECTOR(this.width, this.height)
      );

      const margin = this.profileConstants.margin;
      this.chartHeight = this.height - margin.top - margin.bottom;
      this.chartWidth = this.width - margin.left - margin.right;
      if (!this.height || !this.width) return sharedComponents.LegacyUtils.warn("Chart _updateProfile() abort: container is too little or has display:none");

    }

    _drawData() {
      this._processFrameData();
      this._createAndDeleteBubbles();
      this._updateMarkerSizeLimits();
      mobx.runInAction(() => {
        this._redrawData();
      });
    }

    _redrawData(duration) {
      this.services.layout.size;
      
      //this._processFrameData();
      //this._createAndDeleteBubbles();

      const _this = this;
      if (!duration) duration = this.__duration;
      if (!this.bubbles) return sharedComponents.LegacyUtils.warn("redrawDataPoints(): no entityBubbles defined. likely a premature call, fix it!");

      this.bubbles.each(function(d) {
        const view = d3$1.select(this);

        d.r = sharedComponents.LegacyUtils.areaToRadius(_this.sScale(d.size)||0);
        d.center = _this._getPosition(d);

        d.hidden = (!d.size && d.size !== 0) || !d.center;

        if(d.center) {
          view
            .attr("cx", d.center[0])
            .attr("cy", d.center[1]);
        }
   
        view
          .classed("vzb-hidden", d.hidden);
          
        if (view.classed("vzb-hidden") !== d.hidden || !duration) {
          view
            .attr("r", d.r)
            .attr("fill", _this.cScale(d.color));
        } else {
          view.transition().duration(duration).ease(d3$1.easeLinear)
            .attr("r", d.r)
            .attr("fill", _this.cScale(d.color));
        }

        _this._updateLabel(d, duration);
      });
    }

    _updateLabel(d, duration) {
      if (!duration) duration = this.__duration;

      // only for selected entities
      if (this.MDL.selected.data.filter.has(d)) {

        const showhide = d.hidden !== d.hidden_1;
        const valueLST = null;
        const cache = {
          labelX0: d.center[0] / this.width,
          labelY0: d.center[1] / this.height,
          scaledS0: d.r,
          scaledC0: this.cScale(d.color),
          initTextBBox: null,
          initFontSize: null  
        };

        this._labels.updateLabel(d, cache, d.center[0] / this.width, d.center[1] / this.height, d.size, d.color, this.__labelWithoutFrame(d), valueLST, duration, showhide);
      }
    }

    _getPosition(d) {
      if (d.lat && d.lon) {
        return this.map.geo2Point(d.lon, d.lat);
      }
      if (d.centroid) {
        return this.map.centroid(d.centroid);
      }
      sharedComponents.LegacyUtils.warn("_getPosition(): was unable to resolve bubble positions either via lat/long or centroid");
      return [0,0];
    }

    getValue(d){
      return d;
    }

    _processFrameData() {
      return this.__dataProcessed = this.model.dataArray
        .concat()
        .map(this.getValue)
        //TODO sorting can be done via order encoding
        .sort((a, b) => b.size - a.size);
    }
    _createAndDeleteBubbles() {

      this.bubbles = this.DOM.bubbleContainer.selectAll(".vzb-bmc-bubble")
        .data(!this.ui.map.showBubbles ? [] : this.__dataProcessed, d => d[Symbol.for("key")]);

      //exit selection
      this.bubbles.exit().remove();

      //enter selection -- init circles
      this.bubbles = this.bubbles.enter().append("circle")
        .attr("class", "vzb-bmc-bubble")
        .attr("id", (d) => `vzb-br-bar-${d[Symbol.for("key")]}-${this.id}`)
        .merge(this.bubbles);

      if(!sharedComponents.LegacyUtils.isTouchDevice()){
        this.bubbles
          .on("mousedown", this._interact().mousedown)
          .on("mousemove", this._interact().mouseover)
          .on("mouseout", this._interact().mouseout)
          .on("click", this._interact().click);
      } else {
        this.bubbles
          .on("tap", this._interact().tap);
      }
    }

    _interact() {
      const _this = this;

      return {
        mousedown(event) {
          if (_this.ui.cursorMode === "arrow") event.stopPropagation();
        },
        mouseover(event, d) {
          if (_this.ui.panWithArrow && !event.shiftKey || _this.zooming || _this.map.zooming || _this.ui.cursorMode !== "arrow" || _this.MDL.frame.dragging) return;

          _this.hovered = d;
          _this.MDL.highlighted.data.filter.clear(d);
          _this.MDL.highlighted.data.filter.set(d);
          _this._labels.showCloseCross(d, true);
          //put the exact value in the size title
          //this.updateTitleNumbers();
          //_this.fitSizeOfTitles();       
        },
        mouseout(event, d) {
          if (_this.zooming || _this.map.zooming ||_this.ui.cursorMode !== "arrow" || _this.MDL.frame.dragging) return;

          _this.hovered = null;
          _this.MDL.highlighted.data.filter.delete(d);
          _this._labels.showCloseCross(d, false);
          //_this.updateTitleNumbers();
          //_this.fitSizeOfTitles();
        },
        click(event, d) {
          if (_this.zooming || _this.map.zooming ||_this.ui.cursorMode !== "arrow") return;

          _this.MDL.selected.data.filter.toggle(d);
        },
        tap(event, d) {
          if (_this.zooming || _this.map.zooming ||_this.ui.cursorMode !== "arrow") return;

          _this.MDL.selected.data.filter.toggle(d);
          event.stopPropagation();
        }
      };
    }

    _getMarkerItemForArea(id) {
      if (!id) return undefined;

      const d = Object.assign({}, this.model.dataMap.get(id));
      d.r = 3;
      d.center = this._getPosition(d);
      d.hidden = !d.center;

      return  d;
    }

    _mapInteract() {
      const _this = this;
      return {
        _mouseover(event, key) {
          if (sharedComponents.LegacyUtils.isTouchDevice()
            || _this.ui.cursorMode !== "arrow"
            || _this.ui.map.showBubbles
            || !_this.map.keys[key]
          ) return;
          _this._interact().mouseover(event, _this._getMarkerItemForArea(_this.map.keys[key]));
        },
        _mouseout(event, key) {
          if (sharedComponents.LegacyUtils.isTouchDevice()
            || _this.ui.cursorMode !== "arrow"
            || _this.ui.map.showBubbles
            || !_this.map.keys[key]
          ) return;
          _this._interact().mouseout(event, _this._getMarkerItemForArea(_this.map.keys[key]));
        },
        _click(event, key) {
          if (sharedComponents.LegacyUtils.isTouchDevice()
            || _this.ui.cursorMode !== "arrow"
            || _this.ui.map.showBubbles
            || !_this.map.keys[key]
          ) return;
          _this._interact().click(event, _this._getMarkerItemForArea(_this.map.keys[key]));
        }
      };
    }


    repositionElements() {
      const margin = this.profileConstants.margin;
      const infoElHeight = this.profileConstants.infoElHeight;
      const isRTL = this.services.locale.isRTL();

      this.DOM.titles
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      this._date.setConditions({
        widthRatio: 2 / 10
      });
      this._date.resize(this.width, this.height - margin.top);

      //TITLES

      //hide the first line about bubble size when no bubbles
      const hideSTitle = !this.ui.map.showBubbles;
      this.DOM.sTitle
        .style("font-size", infoElHeight)
        .attr("transform", "translate(" + (isRTL ? this.chartWidth : 0) + "," + margin.top + ")")
        .classed("vzb-hidden", hideSTitle);

      //hide the second line about color in large profile or when color is constant or no bubbles
      const hideCTitle = this.services.layout.profile === "LARGE" || this.MDL.color.data.isConstant || !this.ui.map.showBubbles;
      this.DOM.cTitle
        .attr("transform", "translate(" + (isRTL ? this.chartWidth : 0) + "," + (margin.top + (hideSTitle ? 0 : infoElHeight)) + ")")
        .classed("vzb-hidden", hideCTitle);

      //hide the second line about color in large profile or when color is constant or no bubbles
      const hideATitle = !this.ui.map.showAreas;
      this.DOM.aTitle
        .attr("transform", "translate(" + (isRTL ? this.chartWidth : 0) + "," + (margin.top + (hideSTitle ? 0 : infoElHeight) + (hideCTitle ? 0 : infoElHeight)) + ")")
        .classed("vzb-hidden", hideATitle);

      // INFO ELEMENTS

      this.DOM.cInfo.classed("vzb-hidden", hideSTitle);  

      if (!hideSTitle && this.DOM.sInfo.select("svg").node()) {
        const titleBBox = this.DOM.sTitle.node().getBBox();
        const t = sharedComponents.LegacyUtils.transform(this.DOM.sTitle.node());
        const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);

        this.DOM.sInfo
          .attr("transform", `translate(${hTranslate},${t.translateY - infoElHeight * 0.8})`)
          .select("svg")
          .attr("width", infoElHeight)
          .attr("height", infoElHeight);
      }

      this.DOM.cInfo.classed("vzb-hidden", hideCTitle);

      if (!hideCTitle && this.DOM.cInfo.select("svg").node()) {
        const titleBBox = this.DOM.cTitle.node().getBBox();
        const t = sharedComponents.LegacyUtils.transform(this.DOM.cTitle.node());
        const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);

        this.DOM.cInfo  
          .attr("transform", `translate(${hTranslate},${t.translateY - infoElHeight * 0.8})`)
          .select("svg")
          .attr("width", infoElHeight)
          .attr("height", infoElHeight);
      }

      this.DOM.aInfo.classed("vzb-hidden", hideATitle);

      if (!hideATitle && this.DOM.aInfo.select("svg").node()) {
        const titleBBox = this.DOM.aTitle.node().getBBox();
        const t = sharedComponents.LegacyUtils.transform(this.DOM.cTitle.node());
        const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);

        this.DOM.aInfo  
          .attr("transform", `translate(${hTranslate},${t.translateY - infoElHeight * 0.8})`)
          .select("svg")
          .attr("width", infoElHeight)
          .attr("height", infoElHeight);
      }
    }

    _updateMapColors() {
      this.map.updateColors();
    }

    _updateMap() {
      this.ui.map.showAreas;
      this.ui.map.showMap;
      this.ui.map.mapStyle;

      this.map.layerChanged();
    }

    _updateMarkerSizeLimits() {
      //this is very funny
      this.services.layout.size;
      this.MDL.size.scale.domain;

      const {
        minRadiusPx: minRadius,
        maxRadiusPx: maxRadius
      } = this.profileConstants;

      const extent = this.MDL.size.scale.extent || [0, 1];

      let minArea = sharedComponents.LegacyUtils.radiusToArea(Math.max(maxRadius * extent[0], minRadius));
      let maxArea = sharedComponents.LegacyUtils.radiusToArea(Math.max(maxRadius * extent[1], minRadius));

      this.sScale.range([minArea, maxArea]);
    }

    _updateUIStrings() {
      const _this = this;

      const isRTL = this.services.locale.isRTL();

      const conceptPropsS = _this.MDL.size.data.conceptProps;
      const conceptPropsC = _this.MDL.color.data.conceptProps;
      const conceptPropsA = _this.MDL.mapColor.data.conceptProps;

      this.strings = {
        title: {
          S: conceptPropsS.name || conceptPropsS.concept,
          C: conceptPropsC.name || conceptPropsC.concept,
          A: conceptPropsA.name || conceptPropsA.concept
        }
      };

      this.DOM.sTitle
        .classed("vzb-disabled", this.treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .select("text").text(this.localise("buttons/size") + ": " + this.strings.title.S)
        .on("click", () => {
          this.treemenu
            .encoding("size")
            .alignX(isRTL ? "right" : "left")
            .alignY("top")
            .updateView()
            .toggle();
        });

      this.DOM.cTitle
        .classed("vzb-disabled", this.treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .select("text").text(this.localise("buttons/color") + ": " + this.strings.title.C)
        .on("click", () => {
          this.treemenu
            .encoding("color")
            .alignX(isRTL ? "right" : "left")
            .alignY("top")
            .updateView()
            .toggle();
        });

      this.DOM.aTitle
        .classed("vzb-disabled", this.treemenu.state.ownReadiness !== sharedComponents.Utils.STATUS.READY)
        .select("text").text(this.localise("buttons/mapcolors") + ": " + this.strings.title.A)
        .on("click", () => {
          this.treemenu
            .encoding("color_map")
            .alignX(isRTL ? "right" : "left")
            .alignY("top")
            .updateView()
            .toggle();
        });

      const toolRect = _this.root.element.node().getBoundingClientRect();
      const chartRect = _this.element.node().getBoundingClientRect();

      this._drawInfoEl(this.DOM.sInfo, this.DOM.sTitle, this.MDL.size, {x: chartRect.left - toolRect.left});
      this._drawInfoEl(this.DOM.cInfo, this.DOM.cTitle, this.MDL.color);
      this._drawInfoEl(this.DOM.aInfo, this.DOM.aTitle, this.MDL.mapColor);
    }

    _drawInfoEl(element, titleElement, model, posOffset = {}){
      const dataNotes = this.root.findChild({type: "DataNotes"});
      const conceptProps = model.data.conceptProps;
      const infoElHeight = this.profileConstants.infoElHeight;

      element
        .on("click", () => {
          dataNotes.pin();
        })
        .on("mouseover", function() {
          const rect = this.getBBox();
          const ctx = sharedComponents.LegacyUtils.makeAbsoluteContext(this, this.farthestViewportElement);
          const coord = ctx(rect.x - 10, rect.y + rect.height + 10);
          dataNotes
            .setEncoding(model)
            .show()
            .setPos(coord.x + posOffset.x || 0, coord.y + posOffset.y || 0);
        })
        .on("mouseout", () => {
          dataNotes.hide();
        })
        .html(ICON_QUESTION)
        .select("svg")
        .attr("width", infoElHeight + "px").attr("height", infoElHeight + "px")
        .classed("vzb-hidden", 
          !conceptProps.description && !conceptProps.sourceLink || titleElement.classed("vzb-hidden")
        );
    }

    _updateSize() {
      this.services.layout.size;

      this.DOM.chartSvg
        .style("width", this.width + "px")
        .style("height", this.height + (this.ui.map.overflowBottom || 0) + "px");

      mobx.runInAction(() => {
        this.map.rescaleMap();
      });

      this.repositionElements();
    }

    // show size number on title when hovered on a bubble
    updateTitleNumbers() {
      const _this = this;

      let mobile; // if is mobile device and only one bubble is selected, update the sTitle for the bubble
      if (_this.isMobile && _this.model.marker.select && _this.model.marker.select.length === 1) {
        mobile = _this.model.marker.select[0];
      }

      if (_this.hovered || mobile) {
        const conceptPropsS = _this.model.marker.size.getConceptprops();
        const conceptPropsC = _this.model.marker.color.getConceptprops();
        _this.model.marker.mapColor.getConceptprops();

        const hovered = _this.hovered || mobile;
        const formatterS = _this.model.marker.size.getTickFormatter();
        const formatterC = _this.model.marker.color.getTickFormatter();

        const unitS = conceptPropsS.unit || "";
        const unitC = conceptPropsC.unit || "";

        const valueS = _this.values.size[sharedComponents.LegacyUtils.getKey(hovered, _this.dataKeys.size)];
        let valueC = _this.values.color[sharedComponents.LegacyUtils.getKey(hovered, _this.dataKeys.color)];
        let valueA = _this.values.color[sharedComponents.LegacyUtils.getKey(hovered, _this.dataKeys.map_color)];

        //resolve value for color from the color legend model
        if (_this.model.marker.color.isDiscrete() && valueC) {
          valueC = this.model.marker.color.getColorlegendMarker().label.getItems()[valueC] || "";
        }

        _this.DOM.sTitle.select("text")
          .text(_this.localise("buttons/size") + ": " + formatterS(valueS) + " " + unitS);

        _this.DOM.cTitle.select("text")
          .text(_this.localise("buttons/color") + ": " +
            (valueC || valueC === 0 ? formatterC(valueC) + " " + unitC : _this.localise("hints/nodata")));

        _this.DOM.aTitle.select("text")
          .text(_this.localise("buttons/mapcolors") + ": " +
            (valueA || valueA === 0 ? formatterC(valueA) + " " + unitA : _this.localise("hints/nodata")));
    

        this.DOM.sInfo.classed("vzb-hidden", true);
        this.DOM.cInfo.classed("vzb-hidden", true);
        this.DOM.aInfo.classed("vzb-hidden", true);
      } else {
        this.DOM.sTitle.select("text")
          .text(this.localise("buttons/size") + ": " + this.strings.title.S);
        this.DOM.cTitle.select("text")
          .text(this.localise("buttons/color") + ": " + this.strings.title.C);
        this.DOM.aTitle.select("text")
          .text(this.localise("buttons/mapcolors") + ": " + this.strings.title.A);


        this.DOM.sInfo.classed("vzb-hidden", this.DOM.sTitle.classed("vzb-hidden"));
        this.DOM.cInfo.classed("vzb-hidden", this.DOM.cTitle.classed("vzb-hidden"));
        this.DOM.aInfo.classed("vzb-hidden", this.DOM.aTitle.classed("vzb-hidden"));
      }
    }

    fitSizeOfTitles() {
      // reset font sizes first to make the measurement consistent
      const sTitleText = this.DOM.sTitle.select("text").style("font-size", null);
      const cTitleText = this.DOM.cTitle.select("text").style("font-size", null);
      const aTitleText = this.DOM.aTitle.select("text").style("font-size", null);

      const maxTextW = d3$1.max([
        this.DOM.sTitle.classed("vzb-hidden") ? null : sTitleText.node().getBBox().width,
        this.DOM.cTitle.classed("vzb-hidden") ? null : cTitleText.node().getBBox().width,
        this.DOM.cTitle.classed("vzb-hidden") ? null : aTitleText.node().getBBox().width,
      ]);

      const maxFontSize = d3$1.max([
        parseInt(sTitleText.style("font-size")),
        parseInt(cTitleText.style("font-size")),
        parseInt(aTitleText.style("font-size")),
      ]);

      const font = maxTextW > this.width ? maxFontSize * this.width / maxTextW + "px" : null;

      sTitleText.style("font-size", font);
      cTitleText.style("font-size", font);
      aTitleText.style("font-size", font);
    }

    _getDuration() {
      //smooth animation is needed when playing, except for the case when time jumps from end to start
      if(!this.MDL.frame) return 0;
      this.frameValue_1 = this.frameValue;
      this.frameValue = this.MDL.frame.value;
      return this.__duration = this.MDL.frame.playing && (this.frameValue - this.frameValue_1 > 0) ? this.MDL.frame.speed : 0;

      //this._updateForecastOverlay();

      //possibly update the exact value in size title
      //this.updateTitleNumbers();
    }

    _updateOpacity() {
      this.MDL.frame.value; //listen

      this.someHighlighted = this.MDL.highlighted.data.filter.any() || this.MDL.superHighlighted.data.filter.any();
      this.someSelected = this.MDL.selected.data.filter.any();

      if (this.ui.map.showAreas)
        this.map.updateOpacity();

      if (this.ui.map.showBubbles)
        this.bubbles.style("opacity", d => this.getOpacity(d));
    }

    _blinkSuperHighlighted() {
      if (!this.MDL.superHighlighted || !this.ui.map.showBubbles) return;

      const superHighlightFilter = this.MDL.superHighlighted.data.filter;

      this.bubbles
        .classed("vzb-super-highlighted", d => superHighlightFilter.has(d));
    }

    _drawForecastOverlay() {
      this.DOM.forecastOverlay.classed("vzb-hidden", 
        !this.MDL.frame.endBeforeForecast || 
        !this.ui.showForecastOverlay || 
        (this.MDL.frame.value <= this.MDL.frame.endBeforeForecast)
      );
    }

    _hideEntities(duration) {
      this.DOM.graph.select("." + this._labels.options.LABELS_CONTAINER_CLASS)
        .transition()
        .duration(duration)
        .style("opacity", 0);
      this.DOM.graph.select("." + this._labels.options.LINES_CONTAINER_CLASS)
        .transition()
        .duration(duration)
        .style("opacity", 0);
      this.DOM.bubbleContainer
        .transition()
        .duration(duration)
        .style("opacity", 0);
    }

    _showEntities(duration) {
      this.DOM.graph.select("." + this._labels.options.LABELS_CONTAINER_CLASS)
        .transition()
        .duration(duration)
        .style("opacity", 1);
      this.DOM.graph.select("." + this._labels.options.LINES_CONTAINER_CLASS)
        .transition()
        .duration(duration)
        .style("opacity", 1);
      this.DOM.bubbleContainer
        .transition()
        .duration(duration)
        .style("opacity", 1);

    }

    mapBoundsChanged() {
      this._redrawData();
      //this.updateMarkerSizeLimits();
      //this.redrawDataPoints(null, true);
      if (!this.ui.map.showBubbles) this.updateLabels(null);
    }

    updateLabels() {
      const selectedFilter = this.MDL.selected.data.filter;
      for (const key of selectedFilter.markers.keys()) {
        this._updateLabel(this.ui.map.showBubbles ? this.model.dataMap.get(key) : this._getMarkerItemForArea(key));
      }
    }

    getMapOpacity(key) {
      if (this.ui.map.showBubbles)
        return this.ui.opacitySelectDim;
        
      return this.getOpacity( {[Symbol.for("key")]: key} );
    }

    getOpacity(d) {
      const {
        opacityHighlightDim,
        opacitySelectDim,
        opacityRegular,
      } = this.ui;
      
      if (this.MDL.highlighted.data.filter.has(d) || this.MDL.superHighlighted.data.filter.has(d)) return opacityRegular;
      if (this.MDL.selected.data.filter.has(d)) return opacityRegular;

      if (this.someSelected) return opacitySelectDim;
      if (this.someHighlighted) return opacityHighlightDim;

      return opacityRegular;
    }

    _setTooltip(event, d) {
      if (d) {
        const labelValues = {};
        const tooltipCache = {};
        const cLoc = d.cLoc ? d.cLoc : this._getPosition(d);
        const mouse = d3$1.pointer(event);
        const x = cLoc[0] || mouse[0];
        const y = cLoc[1] || mouse[1];
        const offset = d.r || 0;

        labelValues.valueS = d.size;
        labelValues.labelText = this.__labelWithoutFrame(d);
        tooltipCache.labelX0 = labelValues.valueX = x / this.width;
        tooltipCache.labelY0 = labelValues.valueY = y / this.height;
        tooltipCache.scaledS0 = offset;
        tooltipCache.scaledC0 = null;

        this._labels.setTooltip(d, labelValues.labelText, tooltipCache, labelValues);
      } else {
        this._labels.setTooltip();
      }
    }

    __labelWithoutFrame(d) {
      if (typeof d.label == "object") return Object.values(d.label).join(", ");
      if (d.label != null) return "" + d.label;
      return d[Symbol.for("key")];
    }

    _highlightDataPoints() {
      const highlightedFilter = this.MDL.highlighted.data.filter;
      const selectedFilter = this.MDL.selected.data.filter;
      this.someHighlighted = highlightedFilter.any();

      if (highlightedFilter.markers.size === 1) {
        const highlightedKey = highlightedFilter.markers.keys().next().value;
        const d = this.ui.map.showBubbles ? this.model.dataMap.get(highlightedKey) : this._getMarkerItemForArea(highlightedKey);
        const selectedKey = d[Symbol.for("key")];

        //show tooltip
        const isSelected = selectedFilter.has(selectedKey);
        const text = isSelected ? "": this.__labelWithoutFrame(d);
        
        this._labels.highlight(null, false);
        this._labels.highlight({ [Symbol.for("key")]: selectedKey }, true);

        //set tooltip and show axis projections
        if (text) {
          this._setTooltip({}, d);
        } else {
          this._setTooltip();
        }

      } else {
        this._setTooltip();
        this._labels.highlight(null, false);
      }

    }

    _selectDataPoints() {
      this.updateLabels();
    }

    _setupCursorMode() {
      const svg = this.DOM.chartSvg;
      if (this.ui.cursorMode === "plus") {
        svg.classed("vzb-zoomin", true);
        svg.classed("vzb-zoomout", false);
        svg.classed("vzb-panhand", false);
      } else if (this.ui.cursorMode === "minus") {
        svg.classed("vzb-zoomin", false);
        svg.classed("vzb-zoomout", true);
        svg.classed("vzb-panhand", false);
      } else if (this.ui.cursorMode === "hand") {
        svg.classed("vzb-zoomin", false);
        svg.classed("vzb-zoomout", false);
        svg.classed("vzb-panhand", true);
      } else {
        svg.classed("vzb-zoomin", false);
        svg.classed("vzb-zoomout", false);
        svg.classed("vzb-panhand", false);
      }
    }

    _createMapDragger() {
      const _this = this;
      return d3$1.drag()
        .on("start", function(event) {
          if (
            ((event.sourceEvent.metaKey || event.sourceEvent.ctrlKey) && _this.ui.cursorMode == "arrow") ||
            _this.ui.cursorMode == "plus"

          ) {
            _this.dragAction = "zooming";
            _this.zooming = true;
            const mouse = d3$1.pointer(event, _this.DOM.graph.node());
            _this.origin = {
              x: mouse[0],
              y: mouse[1]
            };
            _this.DOM.zoomRect.classed("vzb-invisible", false);
          } else if (
            _this.ui.cursorMode == "hand" ||
            (_this.ui.panWithArrow && _this.ui.cursorMode === "arrow")
          ) {
            _this.dragAction = "panning";
            _this._hideEntities();
            _this.map.panStarted();
            _this.DOM.chartSvg.classed("vzb-zooming", true);
          }
        })
        .on("drag", function(event) {
          switch (_this.dragAction) {
          case "zooming": {
            const mouse = d3$1.pointer(event, _this.DOM.graph.node());
            _this.DOM.zoomRect
              .attr("x", Math.min(mouse[0], _this.origin.x))
              .attr("y", Math.min(mouse[1], _this.origin.y))
              .attr("width", Math.abs(mouse[0] - _this.origin.x))
              .attr("height", Math.abs(mouse[1] - _this.origin.y));
            break;
          }
          case "panning": {
            _this.map.moveOver(event.dx, event.dy);
            break;
          }
          }
        })
        .on("end", function(event) {
          switch (_this.dragAction) {
          case "zooming":
            _this.DOM.zoomRect
              .attr("width", 0)
              .attr("height", 0)
              .classed("vzb-invisible", true);
            if (_this.zooming) {
              const mouse = d3$1.pointer(event, _this.DOM.graph.node());
              if (Math.abs(_this.origin.x - mouse[0]) < 5 || Math.abs(_this.origin.y - mouse[1]) < 5) {
                _this._hideEntities();
                _this.map.zoomMap(mouse, 1).then(
                  () => {
                    _this._showEntities(300);
                  }
                );
              } else {
                _this.map.zoomRectangle(_this.origin.x, _this.origin.y, mouse[0], mouse[1]);
              }
            }
            break;
          case "panning":
            _this.map.panFinished();
            _this._showEntities(300);
            _this.DOM.chartSvg.classed("vzb-zooming", false);
            break;
          }
          if (_this.ui.cursorMode == "minus") {
            const mouse = d3$1.pointer(event, _this.DOM.graph.node());
            _this._hideEntities();
            _this.map.zoomMap(mouse, -1).then(
              () => {
                _this._showEntities(300);
              }
            );
          }
          _this.dragAction = null;
          _this.zooming = false;
        });
    }

    preload() {
      if (this.map) return Promise.resolve();
      return this._initMap();
    }

    _initMap() {
      this.map = new Map$1(this, "#vzb-map-background").getMap();
      return this.map.initMap();
    }

  }

  _VizabiExtApiMap.DEFAULT_UI = {
    "map": {
      "scale": 1,
      "preserveAspectRatio": true,
      "mapEngine": "mapbox",
      "mapStyle": "mapbox://styles/mapbox/light-v9",
      "showBubbles": true,
      "showAreas": false,
      "showMap": true,
      "offset": {
        top: 0.05,
        right: 0.01,
        bottom: 0.05,
        left: -0.12
      },
      "path": null,
      "bounds": {
        "north": 70,
        "west": 80,
        "south": -50,
        "east": -80
      },
      "projection": "mercator",
      topology: {
        path: "assets/world-50m.json",
        objects: {
          boundaries: "countries"
        },
        geoIdProperty: "id",
      }
    }
  };

  const VizabiExtApiMap = mobx.decorate(_VizabiExtApiMap, {
    "MDL": mobx.computed
  });

  sharedComponents.Chart.add("extapimap", VizabiExtApiMap);

  /*
   * Axes dialog
   */
  const mapEngines = [{
    title: "Google",
    value: "google"
  }, {
    title: "Mapbox",
    value: "mapbox"
  }];

  const mapStyles = {
    "google": [{
      title: "Roadmap",
      value: "roadmap"
    }, {
      title: "Terrain",
      value: "terrain"
    }, {
      title: "Satellite",
      value: "satellite"
    }, {
      title: "Satellite + Road",
      value: "hybrid"
    }],
    mapbox: [{
      title: "Grayscale",
      value: "mapbox://styles/mapbox/light-v9"
    }, {
      title: "Land",
      value: "mapbox://styles/mapbox/streets-v9"
    }, {
      title: "Satellite",
      value: "mapbox://styles/mapbox/satellite-v9"
    }, {
      title: "Satellite Street",
      value: "mapbox://styles/mapbox/satellite-streets-v9"
    }]
  };

  class MapOptions extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="mapoptions" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="mapoptions" data-click="dragDialog"></span>
        <div class="vzb-dialog-title">
          <span data-localise="buttons/mapoptions"></span>
        </div>
        <div class="vzb-dialog-content">
          <div class="vzb-lmap-container vzb-lmap-layers">
            <form class="vzb-dialog-paragraph  vzb-map-layers">
              <label for="showBubblesChk"><input id="showBubblesChk" type="checkbox" name="showBubbles"><span data-localise="hints/extapimap/showBubbles"></span></label>
              <label for="showAreasChk"><input id="showAreasChk" type="checkbox" name="showAreas"><span data-localise="hints/extapimap/showAreas"><span></label>
              <label for="showMapChk"><input id="showMapChk" type="checkbox" name="showMap"><span data-localise="hints/extapimap/showMap"></span></label>
            </form>
          </div>
          <div class="vzb-lmap-container vzb-lmap-engine">
            <p class="vzb-dialog-sublabel">
              <span data-localise="hints/extapimap/mapEngine"></span>
            </p>
            <form class="vzb-dialog-paragraph vzb-map-engine"></form>
          </div>
          <div class="vzb-lmap-container vzb-lmap-style">
            <p class="vzb-dialog-sublabel">
              <span data-localise="hints/extapimap/mapStyle"></span>
            </p>
            <form class="vzb-dialog-paragraph  vzb-map-style"></form>
          </div>
        </div>
        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>
      </div>
    `;
    
      config.subcomponents = [
      ];  

      super(config);  
    }

    setup(options) {
      super.setup(options);
      const _this = this;

      this.DOM.mapLayers = this.element.select(".vzb-map-layers");
      this.DOM.mapEngineForm = this.element.select(".vzb-dialog-paragraph.vzb-map-engine");
      this.DOM.mapStyleForm = this.element.select(".vzb-dialog-paragraph.vzb-map-style");


      const mapEngineForm = this.DOM.mapEngineForm.selectAll("label")
        .data(mapEngines);

      mapEngineForm.exit().remove();

      mapEngineForm.enter().append("label")
        .attr("for", (d, i) => "engine" + i)
        .each(function(d, i) {
          d3$1.select(this)
            .append("input")
            .attr("id", "engine" + i)
            .attr("type", "radio")
            .attr("name", "engine")
            .attr("value", d.value)
            .on("change", () => _this.setModel("mapEngine", d.value));
          d3$1.select(this)
            .append("span")
            .text(d.title);
        });

      this.DOM.mapLayers.select("input[name='showBubbles']")
        .property("checked", () => _this.root.ui.chart.map.showBubbles)
        .on("change", function() {
          _this.setModel("showBubbles", d3$1.select(this).property("checked"));
        });
      this.DOM.mapLayers.select("input[name='showAreas']")
        .property("checked",  _this.root.ui.chart.map.showAreas)
        .on("change", function() {
          _this.setModel("showAreas", d3$1.select(this).property("checked"));
        });
      this.DOM.mapLayers.select("input[name='showMap']")
        .property("checked",  _this.root.ui.chart.map.showMap)
        .on("change", function() {
          _this.setModel("showMap", d3$1.select(this).property("checked"));
        });

    }

    draw(){
      super.draw();
    

      this.addReaction(this.updateView);
    }

    updateView() {
      const _this = this;
      this.DOM.mapStyleForm.selectAll("label").remove();
      const mapStyleForm = this.DOM.mapStyleForm.selectAll("label")
        .data(mapStyles[this.root.ui.chart.map.mapEngine] || []);

      mapStyleForm.exit().remove();

      mapStyleForm.enter().append("label")
        .attr("for", (d, i) => "style" + i)
        .each(function(d, i) {
          d3$1.select(this)
            .append("input")
            .attr("id", "style" + i)
            .attr("type", "radio")
            .attr("name", "layer")
            .attr("value", d.value)
            .on("change", () => _this.setModel("mapStyle", d.value));
          d3$1.select(this)
            .append("span")
            .text(d.title);
        });

      this.DOM.mapEngineForm.selectAll("input")
        .property("checked", d => d.value === this.root.ui.chart.map.mapEngine);

      this.DOM.mapStyleForm.selectAll("input")
        .property("checked", d => d.value === this.root.ui.chart.map.mapStyle);

      this.DOM.mapLayers.select("input[name='showBubbles']")
        .property("checked", this.root.ui.chart.map.showBubbles);
      this.DOM.mapLayers.select("input[name='showAreas']")
        .property("checked", this.root.ui.chart.map.showAreas);
      this.DOM.mapLayers.select("input[name='showMap']")
        .property("checked", this.root.ui.chart.map.showMap);
    }

    setModel(what, value) {
      mobx.runInAction(() => {

        if (what === "mapEngine") {
          this.root.ui.chart.map.mapEngine = value;
          this.root.ui.chart.map.mapStyle = mapStyles[value][0].value;
        }
        if (what === "mapStyle") {
          this.root.ui.chart.map.mapStyle = value;
        }
        if (what === "showBubbles" || what === "showAreas" || what === "showMap") {
          this.root.ui.chart.map[what] = value;
        }
      });
    }

  }

  sharedComponents.Dialog.add("mapoptions", MapOptions);

  /*!
   * VIZABI COLOR DIALOG
   */

  class Mapcolors extends sharedComponents.Dialog {

    constructor(config){
      config.template = `
      <div class='vzb-dialog-modal'>
        <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="mapcolors" data-click="pinDialog"></span>
        <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="mapcolors" data-click="dragDialog"></span>

        <div class="vzb-dialog-title">
          <span data-localise="buttons/mapcolors"></span>
          <span class="vzb-caxis-selector"></span>
        </div>

        <div class="vzb-dialog-content vzb-dialog-scrollable">
          <div class="vzb-clegend-container"></div>
        </div>

        <div class="vzb-dialog-buttons">
          <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">
            <span data-localise="buttons/ok"></span>
          </div>
        </div>

      </div>
    `;

      config.subcomponents = [{
        type: sharedComponents.IndicatorPicker,
        placeholder: ".vzb-caxis-selector",
        options: {
          submodel: "encoding",
          targetProp: "color_map",
          showHoverValues: true
        }
      }, {
        type: sharedComponents.ColorLegend,
        placeholder: ".vzb-clegend-container",
        options: {
          colorModelName: "color_map",
          legendModelName: "legend_map"
        }
      }];
      
      super(config);
    }

  }

  sharedComponents.Dialog.add("mapcolors", Mapcolors);

  class ExtApiMap extends sharedComponents.BaseComponent {

    constructor(config){
      const fullMarker = config.model.markers.bubble;
      config.Vizabi.utils.applyDefaults(fullMarker.config, ExtApiMap.DEFAULT_CORE());  

      const frameType = config.Vizabi.stores.encodings.modelTypes.frame;
      const { marker, splashMarker } = frameType.splashMarker(fullMarker);

      config.name = "extapimap";

      config.subcomponents = [{
        type: VizabiExtApiMap,
        placeholder: ".vzb-extapimap",
        model: marker,
        name: "chart"
      },{
        type: sharedComponents.TimeSlider,
        placeholder: ".vzb-timeslider",
        name: "time-slider",
        model: marker
      },{
        type: sharedComponents.SteppedSlider,
        placeholder: ".vzb-speedslider",
        name: "speed-slider",
        model: marker
      },{
        type: sharedComponents.TreeMenu,
        placeholder: ".vzb-treemenu",
        name: "tree-menu",
        model: marker
      },{
        type: sharedComponents.DataNotes,
        placeholder: ".vzb-datanotes",
        model: marker
      },{
        type: sharedComponents.Dialogs,
        placeholder: ".vzb-dialogs",
        model: marker,
        name: "dialogs"
      },{
        type: sharedComponents.ButtonList,
        placeholder: ".vzb-buttonlist",
        name: "buttons",
        model: marker
      }];

      config.template = `
      <div class="vzb-extapimap"></div>
      <div class="vzb-animationcontrols">
        <div class="vzb-timeslider"></div>
        <div class="vzb-speedslider"></div>
      </div>
      <div class="vzb-sidebar">
        <div class="vzb-dialogs"></div>
        <div class="vzb-buttonlist"></div>
      </div>
      <div class="vzb-treemenu"></div>
      <div class="vzb-datanotes"></div>
    `;
    
      config.locale.Vizabi = config.Vizabi;
      config.layout.Vizabi = config.Vizabi;
      config.services = {
        Vizabi: new sharedComponents.CapitalVizabiService({Vizabi: config.Vizabi}),
        locale: new sharedComponents.LocaleService(config.locale),
        layout: new sharedComponents.LayoutService(config.layout)
      };

      super(config);
      this.splashMarker = splashMarker;
    }
  }

  ExtApiMap.mainComponent = VizabiExtApiMap;

  ExtApiMap.DEFAULT_UI = {
    chart: {
      viewWH: {
        width: 0,
        height: 0
        
      },
      map: {
        "showBubbles": true,
        "showAreas": false,
        "showMap": true,
        "mapEngine": "mapbox",
        "mapStyle": "mapbox://styles/mapbox/light-v9",    
        overflowBottom: 50
      },
      opacitySelectDim: 0.3,
      opacityRegular: 0.5,
      cursorMode: "arrow",
      panWithArrow: true,
      adaptMinMaxZoom: false,
      zoomOnScrolling: true,
    }
  };

  ExtApiMap.DEFAULT_CORE = () => ({
    encoding: {
      "size": {
        scale: {
          modelType: "size",
          allowedTypes: ["linear", "log", "genericLog", "pow"],
        }
      },
      "size_label": {
        data: {
          constant: "_default"
        },
        scale: {
          modelType: "size",
          extent: [0, 0.34]
        }
      }
    }
  });

  ExtApiMap.versionInfo = { version: "4.2.1", build: 1712091923818, package: {"homepage":"https://github.com/vizabi/extapimap#readme","name":"@vizabi/extapimap","description":"Vizabi map from external API"}, sharedComponents: sharedComponents.versionInfo};

  exports.Base = ExtApiMap;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["reader-ddfservice"] = factory();
	else
		root["DDFServiceReader"] = factory();
})(window, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/urlon/lib/urlon.js":
/*!*****************************************!*\
  !*** ./node_modules/urlon/lib/urlon.js ***!
  \*****************************************/
/***/ ((module) => {

/* eslint-disable no-labels */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var URLON = {
  stringify: function stringify(input) {
    function encodeString(str) {
      return encodeURI(str.replace(/([=:&@_;/])/g, '/$1'));
    }

    function stringify(input) {
      // Number or Boolean or Null
      if (typeof input === 'number' || input === true || input === false || input === null) {
        return ':' + input;
      }

      var res = []; // Array

      if (input instanceof Array) {
        for (var i = 0; i < input.length; ++i) {
          res.push(stringify(input[i]));
        }

        return '@' + res.join('&') + ';';
      } // Object


      if (_typeof(input) === 'object') {
        for (var key in input) {
          res.push(encodeString(key) + stringify(input[key]));
        }

        return '_' + res.join('&') + ';';
      } // String or undefined


      return '=' + encodeString((input !== null ? input !== undefined ? input : 'undefined' : 'null').toString());
    }

    return stringify(input).replace(/;+$/g, '');
  },
  parse: function parse(str) {
    var pos = 0;
    str = decodeURI(str);

    function read() {
      var token = '';

      for (; pos !== str.length; ++pos) {
        if (str.charAt(pos) === '/') {
          pos += 1;

          if (pos === str.length) {
            token += ';';
            break;
          }
        } else if (str.charAt(pos).match(/[=:&@_;]/)) {
          break;
        }

        token += str.charAt(pos);
      }

      return token;
    }

    function parse() {
      var type = str.charAt(pos++); // String

      if (type === '=') {
        return read();
      } // Number or Boolean


      if (type === ':') {
        var value = read();

        if (value === 'true') {
          return true;
        }

        if (value === 'false') {
          return false;
        }

        value = parseFloat(value);
        return isNaN(value) ? null : value;
      }

      var res; // Array

      if (type === '@') {
        res = [];

        loop: {
          if (pos >= str.length || str.charAt(pos) === ';') {
            break loop;
          }

          while (1) {
            res.push(parse());

            if (pos >= str.length || str.charAt(pos) === ';') {
              break loop;
            }

            pos += 1;
          }
        }

        pos += 1;
        return res;
      } // Object


      if (type === '_') {
        res = {};

        loop: {
          if (pos >= str.length || str.charAt(pos) === ';') {
            break loop;
          }

          while (1) {
            var name = read();
            res[name] = parse();

            if (pos >= str.length || str.charAt(pos) === ';') {
              break loop;
            }

            pos += 1;
          }
        }

        pos += 1;
        return res;
      } // Error


      throw new Error('Unexpected char ' + type);
    }

    return parse();
  }
};
module.exports = URLON;

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Headers": () => (/* binding */ Headers),
/* harmony export */   "Request": () => (/* binding */ Request),
/* harmony export */   "Response": () => (/* binding */ Response),
/* harmony export */   "DOMException": () => (/* binding */ DOMException),
/* harmony export */   "fetch": () => (/* binding */ fetch)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || typeof global !== 'undefined' && global;
var support = {
  searchParams: 'URLSearchParams' in global,
  iterable: 'Symbol' in global && 'iterator' in Symbol,
  blob: 'FileReader' in global && 'Blob' in global && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in global,
  arrayBuffer: 'ArrayBuffer' in global
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}

if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }

  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }

  return name.toLowerCase();
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }

  return value;
} // Build a destructive iterator for the value list


function iteratorFor(items) {
  var iterator = {
    next: function next() {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }

  return iterator;
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};

Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};

Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};

Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};

Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }

  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };

    reader.onerror = function () {
      reject(reader.error);
    };
  });
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }

  return chars.join('');
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function (body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;

    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);

      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };

    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);

        if (isConsumed) {
          return isConsumed;
        }

        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
        } else {
          return Promise.resolve(this._bodyArrayBuffer);
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }

  this.text = function () {
    var rejected = consumed(this);

    if (rejected) {
      return rejected;
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };

  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }

  this.json = function () {
    return this.text().then(JSON.parse);
  };

  return this;
} // HTTP methods whose capitalization should be normalized


var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }

  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }

    this.url = input.url;
    this.credentials = input.credentials;

    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }

    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;

    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';

  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }

  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }

  this._initBody(body);

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/;

      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
      }
    }
  }
}

Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};

function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}

function parseHeaders(rawHeaders) {
  var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2

  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' '); // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751

  preProcessedHeaders.split('\r').map(function (header) {
    return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
  }).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();

    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}

Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }

  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || '';

  this._initBody(bodyInit);
}
Body.call(Response.prototype);

Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};

Response.error = function () {
  var response = new Response(null, {
    status: 0,
    statusText: ''
  });
  response.type = 'error';
  return response;
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }

  return new Response(null, {
    status: status,
    headers: {
      location: url
    }
  });
};

var DOMException = global.DOMException;

try {
  new DOMException();
} catch (err) {
  DOMException = function DOMException(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };

  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function () {
        resolve(new Response(body, options));
      }, 0);
    };

    xhr.onerror = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };

    xhr.ontimeout = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };

    xhr.onabort = function () {
      setTimeout(function () {
        reject(new DOMException('Aborted', 'AbortError'));
      }, 0);
    };

    function fixUrl(url) {
      try {
        return url === '' && global.location.href ? global.location.href : url;
      } catch (e) {
        return url;
      }
    }

    xhr.open(request.method, fixUrl(request.url), true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob';
      } else if (support.arrayBuffer && request.headers.get('Content-Type') && request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1) {
        xhr.responseType = 'arraybuffer';
      }
    }

    if (init && _typeof(init.headers) === 'object' && !(init.headers instanceof Headers)) {
      Object.getOwnPropertyNames(init.headers).forEach(function (name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
    } else {
      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch.polyfill = true;

if (!global.fetch) {
  global.fetch = fetch;
  global.Headers = Headers;
  global.Request = Request;
  global.Response = Response;
}

/***/ }),

/***/ "./node_modules/d3-time-format/src/defaultLocale.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-time-format/src/defaultLocale.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeFormat": () => (/* binding */ timeFormat),
/* harmony export */   "timeParse": () => (/* binding */ timeParse),
/* harmony export */   "utcFormat": () => (/* binding */ utcFormat),
/* harmony export */   "utcParse": () => (/* binding */ utcParse),
/* harmony export */   "default": () => (/* binding */ defaultLocale)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-time-format/src/locale.js");

var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = (0, _locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}

/***/ }),

/***/ "./node_modules/d3-time-format/src/locale.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-time-format/src/locale.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatLocale)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcYear.js");


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }

  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {
    y: y,
    m: m,
    d: d,
    H: 0,
    M: 0,
    S: 0,
    L: 0
  };
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;
  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  }; // These recursive directive definitions must be deferred.

  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function (date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;
      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function (string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week,
          day;
      if (i != string.length) return null; // If a UNIX timestamp is specified, return it.

      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0)); // If this is utcParse, never use the local timezone.

      if (Z && !("Z" in d)) d.Z = 0; // The am-pm flag is 0 for AM, and 1 for PM.

      if ("p" in d) d.H = d.H % 12 + d.p * 12; // If the month was not specified, inherit from the quarter.

      if (d.m === undefined) d.m = "q" in d ? d.q : 0; // Convert day-of-week and week-of-year to day-of-year.

      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;

        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.ceil(week) : (0, d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_1__["default"].offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.ceil(week) : (0, d3_time__WEBPACK_IMPORTED_MODULE_2__.monday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_3__["default"].offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      } // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.


      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      } // Otherwise, all fields are in local time.


      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);

      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function format(specifier) {
      var f = newFormat(specifier += "", formats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    parse: function parse(specifier) {
      var p = newParse(specifier += "", false);

      p.toString = function () {
        return specifier;
      };

      return p;
    },
    utcFormat: function utcFormat(specifier) {
      var f = newFormat(specifier += "", utcFormats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    utcParse: function utcParse(specifier) {
      var p = newParse(specifier += "", true);

      p.toString = function () {
        return specifier;
      };

      return p;
    }
  };
}
var pads = {
  "-": "",
  "_": " ",
  "0": "0"
},
    numberRe = /^\s*\d+/,
    // note: ignores next directive
percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map(function (name, i) {
    return [name.toLowerCase(), i];
  }));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_3__["default"].count((0, d3_time__WEBPACK_IMPORTED_MODULE_4__["default"])(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count((0, d3_time__WEBPACK_IMPORTED_MODULE_4__["default"])(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? (0, d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.count((0, d3_time__WEBPACK_IMPORTED_MODULE_4__["default"])(d), d) + ((0, d3_time__WEBPACK_IMPORTED_MODULE_4__["default"])(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.count((0, d3_time__WEBPACK_IMPORTED_MODULE_4__["default"])(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? (0, d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_1__["default"].count((0, d3_time__WEBPACK_IMPORTED_MODULE_5__["default"])(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcSunday.count((0, d3_time__WEBPACK_IMPORTED_MODULE_5__["default"])(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? (0, d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.count((0, d3_time__WEBPACK_IMPORTED_MODULE_5__["default"])(d), d) + ((0, d3_time__WEBPACK_IMPORTED_MODULE_5__["default"])(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.count((0, d3_time__WEBPACK_IMPORTED_MODULE_5__["default"])(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? (0, d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

/***/ }),

/***/ "./node_modules/d3-time/src/day.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-time/src/day.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "days": () => (/* binding */ days)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");


var day = (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
  return date.setHours(0, 0, 0, 0);
}, function (date, step) {
  return date.setDate(date.getDate() + step);
}, function (start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay;
}, function (date) {
  return date.getDate() - 1;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (day);
var days = day.range;

/***/ }),

/***/ "./node_modules/d3-time/src/duration.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/duration.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "durationSecond": () => (/* binding */ durationSecond),
/* harmony export */   "durationMinute": () => (/* binding */ durationMinute),
/* harmony export */   "durationHour": () => (/* binding */ durationHour),
/* harmony export */   "durationDay": () => (/* binding */ durationDay),
/* harmony export */   "durationWeek": () => (/* binding */ durationWeek),
/* harmony export */   "durationMonth": () => (/* binding */ durationMonth),
/* harmony export */   "durationYear": () => (/* binding */ durationYear)
/* harmony export */ });
var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

/***/ }),

/***/ "./node_modules/d3-time/src/interval.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/interval.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ newInterval)
/* harmony export */ });
var t0 = new Date(),
    t1 = new Date();
function newInterval(floori, offseti, count, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
  }

  interval.floor = function (date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function (date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function (date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function (date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function (start, stop, step) {
    var range = [],
        previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date

    do {
      range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    } while (previous < start && start < stop);

    return range;
  };

  interval.filter = function (test) {
    return newInterval(function (date) {
      if (date >= date) while (floori(date), !test(date)) {
        date.setTime(date - 1);
      }
    }, function (date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty

        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty

        }
      }
    });
  };

  if (count) {
    interval.count = function (start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function (step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
        return field(d) % step === 0;
      } : function (d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }

  return interval;
}

/***/ }),

/***/ "./node_modules/d3-time/src/utcDay.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/utcDay.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcDays": () => (/* binding */ utcDays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");


var utcDay = (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay;
}, function (date) {
  return date.getUTCDate() - 1;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcDay);
var utcDays = utcDay.range;

/***/ }),

/***/ "./node_modules/d3-time/src/utcWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcWeek.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcSunday": () => (/* binding */ utcSunday),
/* harmony export */   "utcMonday": () => (/* binding */ utcMonday),
/* harmony export */   "utcTuesday": () => (/* binding */ utcTuesday),
/* harmony export */   "utcWednesday": () => (/* binding */ utcWednesday),
/* harmony export */   "utcThursday": () => (/* binding */ utcThursday),
/* harmony export */   "utcFriday": () => (/* binding */ utcFriday),
/* harmony export */   "utcSaturday": () => (/* binding */ utcSaturday),
/* harmony export */   "utcSundays": () => (/* binding */ utcSundays),
/* harmony export */   "utcMondays": () => (/* binding */ utcMondays),
/* harmony export */   "utcTuesdays": () => (/* binding */ utcTuesdays),
/* harmony export */   "utcWednesdays": () => (/* binding */ utcWednesdays),
/* harmony export */   "utcThursdays": () => (/* binding */ utcThursdays),
/* harmony export */   "utcFridays": () => (/* binding */ utcFridays),
/* harmony export */   "utcSaturdays": () => (/* binding */ utcSaturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function utcWeekday(i) {
  return (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function (start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

/***/ }),

/***/ "./node_modules/d3-time/src/utcYear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcYear.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcYears": () => (/* binding */ utcYears)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");

var utcYear = (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
  return date.getUTCFullYear();
}); // An optimized implementation for this simple case.

utcYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcYear);
var utcYears = utcYear.range;

/***/ }),

/***/ "./node_modules/d3-time/src/week.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/week.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sunday": () => (/* binding */ sunday),
/* harmony export */   "monday": () => (/* binding */ monday),
/* harmony export */   "tuesday": () => (/* binding */ tuesday),
/* harmony export */   "wednesday": () => (/* binding */ wednesday),
/* harmony export */   "thursday": () => (/* binding */ thursday),
/* harmony export */   "friday": () => (/* binding */ friday),
/* harmony export */   "saturday": () => (/* binding */ saturday),
/* harmony export */   "sundays": () => (/* binding */ sundays),
/* harmony export */   "mondays": () => (/* binding */ mondays),
/* harmony export */   "tuesdays": () => (/* binding */ tuesdays),
/* harmony export */   "wednesdays": () => (/* binding */ wednesdays),
/* harmony export */   "thursdays": () => (/* binding */ thursdays),
/* harmony export */   "fridays": () => (/* binding */ fridays),
/* harmony export */   "saturdays": () => (/* binding */ saturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function weekday(i) {
  return (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

/***/ }),

/***/ "./node_modules/d3-time/src/year.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/year.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "years": () => (/* binding */ years)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");

var year = (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
  return end.getFullYear() - start.getFullYear();
}, function (date) {
  return date.getFullYear();
}); // An optimized implementation for this simple case.

year.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (year);
var years = year.range;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getReader": () => (/* binding */ getReader)
/* harmony export */ });
/* harmony import */ __webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/fetch.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var urlon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! urlon */ "./node_modules/urlon/lib/urlon.js");
 // Polyfill for fetch


 // Time parsing must follow DDF specs here
// https://docs.google.com/document/d/1Cd2kEH5w3SRJYaDcu-M4dU5SY8No84T3g-QlNSW6pIE/edit#heading=h.oafc7aswaafy

var defaultParsers = {
  'YYYYMMDD': function YYYYMMDD(t) {
    return new Date(Date.UTC(Math.floor(t / 10000), Math.floor(t % 10000 / 100) - 1, t % 100));
  },
  'YYYY-MM': function YYYYMM(t) {
    return new Date(Date.UTC(+t.slice(0, 4), +t.slice(-2) - 1));
  },
  'YYYY': function YYYY(t) {
    return new Date(Date.UTC(t, 0));
  },
  'YYYYqQ': (0, d3_time_format__WEBPACK_IMPORTED_MODULE_2__.utcParse)("%Yq%q"),
  'YYYYwWW': (0, d3_time_format__WEBPACK_IMPORTED_MODULE_2__.utcParse)("%Yw%W")
};
var getReader = function getReader() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    init: function init(dataset) {
      var defaults = {
        service: 'https://big-waffle.gapminder.org'
      };
      this.service = options.service || dataset.service || defaults.service;
      this.dataset = dataset.name || defaults.name;
      this.version = dataset.version || defaults.version;
      this.headers = {};

      if (dataset.password) {
        this.headers.Authorization = 'Basic ' + btoa(this.dataset + ":" + options.password);
      }

      Object.assign(this.parsers, dataset.parsers || {}); // add or overwrite parsers
    },
    checkIfAssetExists: function checkIfAssetExists(filePath) {
      var _this = this;

      var asset = filePath.replace(/^assets\//, ''); // some datasets still include the root path in asset names 

      var url = "".concat(this.service, "/").concat(this.dataset).concat(this.version ? "/".concat(this.version) : '', "/assets/").concat(asset);
      return fetch(url, {
        method: "HEAD",
        credentials: 'same-origin',
        redirect: "follow"
      }).then(function (response) {
        //the client should then look into response.ok, response.status and response.url 
        return Promise.resolve(response);
      })["catch"](function (error) {
        error.name = "reader/error/asset";
        error.details = asset;
        error.message = "connection/error";
        error.endpoint = "".concat(_this.service, "/").concat(_this.dataset).concat(_this.version ? '/' + _this.version : '');
        throw error;
      });
    },
    getAsset: function getAsset(filePath) {
      var _this2 = this;

      var asset = filePath.replace(/^assets\//, ''); // some datasets still include the root path in asset names 

      var url = "".concat(this.service, "/").concat(this.dataset).concat(this.version ? "/".concat(this.version) : '', "/assets/").concat(asset);
      return fetch(url, {
        credentials: 'same-origin',
        redirect: "follow"
      }).then(function (response) {
        if (response.ok) {
          var contentType = response.headers.get("Content-Type");

          if (/application\/json/.test(contentType)) {
            return response.json().then(function (data) {
              return data;
            });
          } else {
            return Promise.resolve(response); // in case of an image or so ?
          }
        } else {
          return response.text().then(function (txt) {
            var err = new Error(txt || "DDF Service responded with ".concat(response.status));
            err.code = "HTTP_".concat(response.status);
            return err;
          });
        }
      })["catch"](function (error) {
        error.name = "reader/error/asset";
        error.details = asset;
        error.message = "connection/error";
        error.endpoint = "".concat(_this2.service, "/").concat(_this2.dataset).concat(_this2.version ? '/' + _this2.version : '');
        throw error;
      });
    },
    parsers: {
      time: function time(timeValue) {
        // json() parsing in fetch makes all time values integers except weeks and quarters
        if (Number.isInteger(timeValue)) {
          if (timeValue >= 0 && timeValue < 10000) return defaultParsers['YYYY'](timeValue);
          if (timeValue >= 1000000 && timeValue < 100000000) return defaultParsers['YYYYMMDD'](timeValue);
        } else if (typeof timeValue == 'string') {
          if (timeValue[4] === "-" && timeValue.length == 7) return defaultParsers['YYYY-MM'](timeValue);
          if (timeValue[4] === "q" || timeValue[4] === "Q") return defaultParsers['YYYYqQ'](timeValue);
          if (timeValue[4] === "w" || timeValue[4] === "W") return defaultParsers['YYYYwWW'](timeValue);
        } else {
          return undefined;
        }
      },
      year: function year(timeValue) {
        return defaultParsers['YYYY'](timeValue);
      },
      month: function month(timeValue) {
        return defaultParsers['YYYY-MM'](timeValue);
      },
      day: function day(timeValue) {
        return defaultParsers['YYYYMMDD'](timeValue);
      },
      week: function week(timeValue) {
        return defaultParsers['YYYYwWW'](timeValue);
      },
      quarter: function quarter(timeValue) {
        return defaultParsers['YYYYqQ'](timeValue);
      }
    },
    read: function read(query) {
      var _this3 = this;

      var url = "".concat(this.service, "/").concat(this.dataset).concat(this.version ? "/".concat(this.version) : '', "?").concat(this._queryAsParams(query));
      return fetch(url, {
        credentials: 'same-origin',
        headers: this.headers,
        redirect: "follow"
      }).then(function (response) {
        if (response.ok) {
          /*
          * Return an array of objects
          */
          return response.json().then(function (data) {
            if (data.version) {
              _this3.version = data.version;
            }

            ['info', 'warn', 'error'].forEach(function (level) {
              (data[level] || []).forEach(function (logRecord) {
                var msg = logRecord && logRecord.msg ? logRecord.msg : logRecord;
                console[level](msg);
              });
            });
            var header = data.header;
            var parsers = header.map(function (h) {
              return _this3.parsers[h];
            });
            return (data.rows || []).map(function (row) {
              return row.reduce(function (obj, value, headerIdx) {
                var field = header[headerIdx];
                obj[field] = parsers[headerIdx] ? parsers[headerIdx](value) : value;
                return obj;
              }, {});
            });
          });
        } else {
          return response.text().then(function (txt) {
            var err = new Error(response.text() || "DDF Service responded with ".concat(response.status));
            err.code = "HTTP_".concat(response.status);
            return err;
          });
        }
      })["catch"](function (error) {
        error.name = "reader/error/generic";
        error.details = query;
        error.message = "connection/error";
        error.endpoint = "".concat(_this3.service, "/").concat(_this3.dataset).concat(_this3.version ? '/' + _this3.version : '');
        throw error;
      });
    },
    _queryAsParams: function _queryAsParams(query) {
      // Only include properties specidied in the DDF Query Language specification
      var allowedProperties = ['language', 'select', 'from', 'where', 'join', 'order_by'];
      var cleanQuery = {};
      allowedProperties.filter(function (prop) {
        return query[prop];
      }).forEach(function (prop) {
        cleanQuery[prop] = query[prop];
      });
      return urlon__WEBPACK_IMPORTED_MODULE_1__.stringify(cleanQuery); // could also do encodeURIComponent(JSON.stringify(query))
    }
  };
};
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});

!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.DDFCsvReader=e():t.DDFCsvReader=e();}(window,function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n});},r.r=function(t){Object.defineProperty(t,"__esModule",{value:!0});},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=50)}([function(t,e){var r;r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this");}catch(t){"object"==typeof window&&(r=window);}t.exports=r;},function(t,e){var r=1/0,n=9007199254740991,o=1.7976931348623157e308,i=NaN,u="[object Arguments]",a="[object Function]",c="[object GeneratorFunction]",s="[object String]",f="[object Symbol]",l=/^\s+|\s+$/g,p=/^[-+]0x[0-9a-f]+$/i,h=/^0b[01]+$/i,d=/^0o[0-7]+$/i,y=/^(?:0|[1-9]\d*)$/,v=parseInt;function _(t){return t!=t}function g(t,e){return function(t,e){for(var r=-1,n=t?t.length:0,o=Array(n);++r<n;)o[r]=e(t[r],r,t);return o}(e,function(e){return t[e]})}var b,m,j=Object.prototype,w=j.hasOwnProperty,O=j.toString,E=j.propertyIsEnumerable,A=(b=Object.keys,m=Object,function(t){return b(m(t))}),S=Math.max;function R(t,e){var r=k(t)||function(t){return function(t){return P(t)&&C(t)}(t)&&w.call(t,"callee")&&(!E.call(t,"callee")||O.call(t)==u)}(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],n=r.length,o=!!n;for(var i in t)!e&&!w.call(t,i)||o&&("length"==i||D(i,n))||r.push(i);return r}function T(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||j,e!==n)return A(t);var e,r,n,o=[];for(var i in Object(t))w.call(t,i)&&"constructor"!=i&&o.push(i);return o}function D(t,e){return !!(e=null==e?n:e)&&("number"==typeof t||y.test(t))&&t>-1&&t%1==0&&t<e}var k=Array.isArray;function C(t){return null!=t&&function(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=n}(t.length)&&!function(t){var e=F(t)?O.call(t):"";return e==a||e==c}(t)}function F(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function P(t){return !!t&&"object"==typeof t}t.exports=function(t,e,n,u){var a;t=C(t)?t:(a=t)?g(a,function(t){return C(t)?R(t):T(t)}(a)):[],n=n&&!u?function(t){var e=function(t){if(!t)return 0===t?t:0;if((t=function(t){if("number"==typeof t)return t;if(function(t){return "symbol"==typeof t||P(t)&&O.call(t)==f}(t))return i;if(F(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=F(e)?e+"":e;}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(l,"");var r=h.test(t);return r||d.test(t)?v(t.slice(2),r?2:8):p.test(t)?i:+t}(t))===r||t===-r){var e=t<0?-1:1;return e*o}return t==t?t:0}(t),n=e%1;return e==e?n?e-n:e:0}(n):0;var c=t.length;return n<0&&(n=S(c+n,0)),function(t){return "string"==typeof t||!k(t)&&P(t)&&O.call(t)==s}(t)?n<=c&&t.indexOf(e,n)>-1:!!c&&function(t,e,r){if(e!=e)return function(t,e,r,n){for(var o=t.length,i=r+(n?1:-1);n?i--:++i<o;)if(e(t[i],i,t))return i;return -1}(t,_,r);for(var n=r-1,o=t.length;++n<o;)if(t[n]===e)return n;return -1}(t,e,n)>-1};},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t};},function(t,e,r){(function(t){Object.defineProperty(e,"__esModule",{value:!0});const n=r(4),o=r(1);e.SCHEMAS=new Set(["concepts.schema","entities.schema","datapoints.schema","*.schema"]),e.DATAPOINTS="datapoints",e.ENTITIES="entities",e.CONCEPTS="concepts",e.CONCEPT_TYPE_MEASURE="measure",e.CONCEPT_TYPE_STRING="string",e.CONCEPT_TYPE_ENTITY_DOMAIN="entity_domain",e.CONCEPT_TYPE_ENTITY_SET="entity_set",e.CONCEPT_TYPE_TIME="time",e.RESERVED_CONCEPT="concept",e.RESERVED_CONCEPT_TYPE="concept_type",e.RESERVED_DOMAIN="domain",e.RESERVED_UNIT="unit",e.RESERVED_DRILL_UP="drill_up",e.RESERVED_KEY="key",e.RESERVED_VALUE="value",e.AVAILABLE_QUERY_OPERATORS=new Set(["$eq","$gt","$gte","$lt","$lte","$ne","$in","$nin","$or","$and","$not","$nor","$size","$all","$elemMatch"]),e.AVAILABLE_FROM_CLAUSE_VALUES=new Set([e.CONCEPTS,e.ENTITIES,e.DATAPOINTS,...e.SCHEMAS]),e.AVAILABLE_ORDER_BY_CLAUSE_VALUES=new Set(["asc","desc",1,-1]),e.DEFAULT_REPOSITORY_NAME=t.env.DEFAULT_REPOSITORY_NAME||"systema_globalis",e.DEFAULT_REPOSITORY_BRANCH=t.env.DEFAULT_REPOSITORY_BRANCH||"master",e.DEFAULT_REPOSITORY_HASH="HEAD",e.isSchemaQuery=function(t){const r=n(t,"from");return e.SCHEMAS.has(r)},e.isDatapointsQuery=function(t){return n(t,"from")===e.DATAPOINTS},e.isEntitiesQuery=function(t){return n(t,"from")===e.ENTITIES},e.isConceptsQuery=function(t){return n(t,"from")===e.CONCEPTS},e.isEntityDomainOrSet=function(t,e){return o(e,t)},e.isMeasure=function(t){return o([e.CONCEPT_TYPE_MEASURE],t)},e.isIndicator=function(t){return o([e.CONCEPT_TYPE_MEASURE,e.CONCEPT_TYPE_STRING],t)};}).call(this,r(8));},function(t,e,r){(function(e){var r="Expected a function",n="__lodash_hash_undefined__",o=1/0,i="[object Function]",u="[object GeneratorFunction]",a="[object Symbol]",c=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/,f=/^\./,l=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,p=/\\(\\)?/g,h=/^\[object .+?Constructor\]$/,d="object"==typeof e&&e&&e.Object===Object&&e,y="object"==typeof self&&self&&self.Object===Object&&self,v=d||y||Function("return this")();var _,g=Array.prototype,b=Function.prototype,m=Object.prototype,j=v["__core-js_shared__"],w=(_=/[^.]+$/.exec(j&&j.keys&&j.keys.IE_PROTO||""))?"Symbol(src)_1."+_:"",O=b.toString,E=m.hasOwnProperty,A=m.toString,S=RegExp("^"+O.call(E).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),R=v.Symbol,T=g.splice,D=N(v,"Map"),k=N(Object,"create"),C=R?R.prototype:void 0,F=C?C.toString:void 0;function P(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function x(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function $(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function L(t,e){for(var r,n,o=t.length;o--;)if((r=t[o][0])===(n=e)||r!=r&&n!=n)return o;return -1}function M(t,e){for(var r,n=0,o=(e=function(t,e){if(q(t))return !1;var r=typeof t;if("number"==r||"symbol"==r||"boolean"==r||null==t||V(t))return !0;return s.test(t)||!c.test(t)||null!=e&&t in Object(e)}(e,t)?[e]:q(r=e)?r:B(r)).length;null!=t&&n<o;)t=t[Y(e[n++])];return n&&n==o?t:void 0}function I(t){return !(!z(t)||w&&w in t)&&(function(t){var e=z(t)?A.call(t):"";return e==i||e==u}(t)||function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}(t)?S:h).test(function(t){if(null!=t){try{return O.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}(t))}function U(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function N(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return I(r)?r:void 0}P.prototype.clear=function(){this.__data__=k?k(null):{};},P.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},P.prototype.get=function(t){var e=this.__data__;if(k){var r=e[t];return r===n?void 0:r}return E.call(e,t)?e[t]:void 0},P.prototype.has=function(t){var e=this.__data__;return k?void 0!==e[t]:E.call(e,t)},P.prototype.set=function(t,e){return this.__data__[t]=k&&void 0===e?n:e,this},x.prototype.clear=function(){this.__data__=[];},x.prototype.delete=function(t){var e=this.__data__,r=L(e,t);return !(r<0||(r==e.length-1?e.pop():T.call(e,r,1),0))},x.prototype.get=function(t){var e=this.__data__,r=L(e,t);return r<0?void 0:e[r][1]},x.prototype.has=function(t){return L(this.__data__,t)>-1},x.prototype.set=function(t,e){var r=this.__data__,n=L(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},$.prototype.clear=function(){this.__data__={hash:new P,map:new(D||x),string:new P};},$.prototype.delete=function(t){return U(this,t).delete(t)},$.prototype.get=function(t){return U(this,t).get(t)},$.prototype.has=function(t){return U(this,t).has(t)},$.prototype.set=function(t,e){return U(this,t).set(t,e),this};var B=H(function(t){var e;t=null==(e=t)?"":function(t){if("string"==typeof t)return t;if(V(t))return F?F.call(t):"";var e=t+"";return "0"==e&&1/t==-o?"-0":e}(e);var r=[];return f.test(t)&&r.push(""),t.replace(l,function(t,e,n,o){r.push(n?o.replace(p,"$1"):e||t);}),r});function Y(t){if("string"==typeof t||V(t))return t;var e=t+"";return "0"==e&&1/t==-o?"-0":e}function H(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(r);var n=function(){var r=arguments,o=e?e.apply(this,r):r[0],i=n.cache;if(i.has(o))return i.get(o);var u=t.apply(this,r);return n.cache=i.set(o,u),u};return n.cache=new(H.Cache||$),n}H.Cache=$;var q=Array.isArray;function z(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function V(t){return "symbol"==typeof t||function(t){return !!t&&"object"==typeof t}(t)&&A.call(t)==a}t.exports=function(t,e,r){var n=null==t?void 0:M(t,e);return void 0===n?r:n};}).call(this,r(0));},function(t,e,r){(function(t,r){var n=9007199254740991,o="[object Arguments]",i="[object Function]",u="[object GeneratorFunction]",a="[object Map]",c="[object Set]",s=/^\[object .+?Constructor\]$/,f="object"==typeof t&&t&&t.Object===Object&&t,l="object"==typeof self&&self&&self.Object===Object&&self,p=f||l||Function("return this")(),h="object"==typeof e&&e&&!e.nodeType&&e,d=h&&"object"==typeof r&&r&&!r.nodeType&&r,y=d&&d.exports===h;var v,_,g,b=Function.prototype,m=Object.prototype,j=p["__core-js_shared__"],w=(v=/[^.]+$/.exec(j&&j.keys&&j.keys.IE_PROTO||""))?"Symbol(src)_1."+v:"",O=b.toString,E=m.hasOwnProperty,A=m.toString,S=RegExp("^"+O.call(E).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),R=y?p.Buffer:void 0,T=m.propertyIsEnumerable,D=R?R.isBuffer:void 0,k=(_=Object.keys,g=Object,function(t){return _(g(t))}),C=H(p,"DataView"),F=H(p,"Map"),P=H(p,"Promise"),x=H(p,"Set"),$=H(p,"WeakMap"),L=!T.call({valueOf:1},"valueOf"),M=z(C),I=z(F),U=z(P),N=z(x),B=z($);function Y(t){return !(!K(t)||w&&w in t)&&(J(t)||function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}(t)?S:s).test(z(t))}function H(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return Y(r)?r:void 0}var q=function(t){return A.call(t)};function z(t){if(null!=t){try{return O.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}function V(t){return function(t){return function(t){return !!t&&"object"==typeof t}(t)&&G(t)}(t)&&E.call(t,"callee")&&(!T.call(t,"callee")||A.call(t)==o)}(C&&"[object DataView]"!=q(new C(new ArrayBuffer(1)))||F&&q(new F)!=a||P&&"[object Promise]"!=q(P.resolve())||x&&q(new x)!=c||$&&"[object WeakMap]"!=q(new $))&&(q=function(t){var e=A.call(t),r="[object Object]"==e?t.constructor:void 0,n=r?z(r):void 0;if(n)switch(n){case M:return "[object DataView]";case I:return a;case U:return "[object Promise]";case N:return c;case B:return "[object WeakMap]"}return e});var W=Array.isArray;function G(t){return null!=t&&function(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=n}(t.length)&&!J(t)}var Q=D||function(){return !1};function J(t){var e=K(t)?A.call(t):"";return e==i||e==u}function K(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}r.exports=function(t){if(G(t)&&(W(t)||"string"==typeof t||"function"==typeof t.splice||Q(t)||V(t)))return !t.length;var e=q(t);if(e==a||e==c)return !t.size;if(L||function(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||m)}(t))return !k(t).length;for(var r in t)if(E.call(t,r))return !1;return !0};}).call(this,r(0),r(2)(t));},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.DdfCsvError=e.DDF_ERROR=e.CSV_PARSING_ERROR=e.JSON_PARSING_ERROR=e.FILE_READING_ERROR=void 0,e.FILE_READING_ERROR="File reading error",e.JSON_PARSING_ERROR="JSON parsing error",e.CSV_PARSING_ERROR="CSV parsing error",e.DDF_ERROR="DDF error";e.DdfCsvError=class extends Error{constructor(t,e,r){super(),this.name="DdfCsvError",this.message=`${t} [filepath: ${r}]. ${e}.`,this.details=e,this.file=r;}};},function(t,e){t.exports=function(t){return null==t};},function(t,e){var r,n,o=t.exports={};function i(){throw new Error("setTimeout has not been defined")}function u(){throw new Error("clearTimeout has not been defined")}function a(t){if(r===setTimeout)return setTimeout(t,0);if((r===i||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:i;}catch(t){r=i;}try{n="function"==typeof clearTimeout?clearTimeout:u;}catch(t){n=u;}}();var c,s=[],f=!1,l=-1;function p(){f&&c&&(f=!1,c.length?s=c.concat(s):l=-1,s.length&&h());}function h(){if(!f){var t=a(p);f=!0;for(var e=s.length;e;){for(c=s,s=[];++l<e;)c&&c[l].run();l=-1,e=s.length;}c=null,f=!1,function(t){if(n===clearTimeout)return clearTimeout(t);if((n===u||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{n(t);}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t);}}function d(t,e){this.fun=t,this.array=e;}function y(){}o.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];s.push(new d(t,e)),1!==s.length||f||a(h);},d.prototype.run=function(){this.fun.apply(null,this.array);},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=y,o.addListener=y,o.once=y,o.off=y,o.removeListener=y,o.removeAllListeners=y,o.emit=y,o.prependListener=y,o.prependOnceListener=y,o.listeners=function(t){return []},o.binding=function(t){throw new Error("process.binding is not supported")},o.cwd=function(){return "/"},o.chdir=function(t){throw new Error("process.chdir is not supported")},o.umask=function(){return 0};},function(t,e){t.exports=function(t){for(var e=-1,r=t?t.length:0,n=0,o=[];++e<r;){var i=t[e];i&&(o[n++]=i);}return o};},function(t,e,r){(function(e){var r=1/0,n=1.7976931348623157e308,o=NaN,i="[object Symbol]",u=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,c=/^0b[01]+$/i,s=/^0o[0-7]+$/i,f=parseInt,l="object"==typeof e&&e&&e.Object===Object&&e,p="object"==typeof self&&self&&self.Object===Object&&self,h=l||p||Function("return this")(),d=Object.prototype.toString,y=h.Symbol,v=y?y.prototype:void 0,_=v?v.toString:void 0;function g(t){if("string"==typeof t)return t;if(m(t))return _?_.call(t):"";var e=t+"";return "0"==e&&1/t==-r?"-0":e}function b(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function m(t){return "symbol"==typeof t||function(t){return !!t&&"object"==typeof t}(t)&&d.call(t)==i}function j(t){return t?(t=function(t){if("number"==typeof t)return t;if(m(t))return o;if(b(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=b(e)?e+"":e;}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(u,"");var r=c.test(t);return r||s.test(t)?f(t.slice(2),r?2:8):a.test(t)?o:+t}(t))===r||t===-r?(t<0?-1:1)*n:t==t?t:0:0===t?t:0}t.exports=function(t,e,r){var n,o,i,u;return t=null==(n=t)?"":g(n),o=function(t){var e=j(t),r=e%1;return e==e?r?e-r:e:0}(r),i=0,u=t.length,o==o&&(void 0!==u&&(o=o<=u?o:u),void 0!==i&&(o=o>=i?o:i)),r=o,e=g(e),t.slice(r,r+e.length)==e};}).call(this,r(0));},function(t,e){var r=9007199254740991,n="[object Arguments]",o="[object Function]",i="[object GeneratorFunction]",u=/^(?:0|[1-9]\d*)$/;var a,c,s=Object.prototype,f=s.hasOwnProperty,l=s.toString,p=s.propertyIsEnumerable,h=(a=Object.keys,c=Object,function(t){return a(c(t))});function d(t,e){var r=_(t)||function(t){return function(t){return function(t){return !!t&&"object"==typeof t}(t)&&g(t)}(t)&&f.call(t,"callee")&&(!p.call(t,"callee")||l.call(t)==n)}(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],o=r.length,i=!!o;for(var u in t)!e&&!f.call(t,u)||i&&("length"==u||v(u,o))||r.push(u);return r}function y(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||s,e!==n)return h(t);var e,r,n,o=[];for(var i in Object(t))f.call(t,i)&&"constructor"!=i&&o.push(i);return o}function v(t,e){return !!(e=null==e?r:e)&&("number"==typeof t||u.test(t))&&t>-1&&t%1==0&&t<e}var _=Array.isArray;function g(t){return null!=t&&function(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=r}(t.length)&&!function(t){var e=function(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}(t)?l.call(t):"";return e==o||e==i}(t)}t.exports=function(t){return g(t)?d(t):y(t)};},function(t,e){t.exports=function(t){return t&&t.length?t[0]:void 0};},function(t,e,r){var n;Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.OFF=0]="OFF",t[t.FATAL=1]="FATAL",t[t.ERROR=2]="ERROR",t[t.WARNING=4]="WARNING",t[t.DEBUG=8]="DEBUG",t[t.ALL=15]="ALL";}(n=e.Level||(e.Level={})),e.getLevelByLabel=(t=>{switch(t){case"off":return n.OFF;case"fatal":return n.FATAL;case"error":return n.ERROR;case"warning":return n.WARNING;case"debug":return n.DEBUG;case"all":return n.ALL;default:return n.OFF}}),e.getLabelByLevel=(t=>{switch(t){case n.OFF:return "off";case n.FATAL:return "fatal";case n.ERROR:return "error";case n.WARNING:return "warning";case n.DEBUG:return "debug";case n.ALL:return "all";default:return "off"}});},function(t,e,r){function n(t){for(var r in t)e.hasOwnProperty(r)||(e[r]=t[r]);}Object.defineProperty(e,"__esModule",{value:!0}),n(r(13)),n(r(24));},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),function(t){t.WhereClauseBasedOnConjunction="WhereClauseBasedOnConjunction",t.ConjunctionPartFromWhereClauseCorrespondsToJoin="ConjunctionPartFromWhereClauseCorrespondsToJoin";}(e.QueryFeature||(e.QueryFeature={}));},function(t,e){t.exports=function(t){var e=typeof t;return !!t&&("object"==e||"function"==e)};},function(t,e,r){(function(t){var n=Object.getOwnPropertyDescriptors||function(t){for(var e=Object.keys(t),r={},n=0;n<e.length;n++)r[e[n]]=Object.getOwnPropertyDescriptor(t,e[n]);return r},o=/%[sdj%]/g;e.format=function(t){if(!_(t)){for(var e=[],r=0;r<arguments.length;r++)e.push(a(arguments[r]));return e.join(" ")}r=1;for(var n=arguments,i=n.length,u=String(t).replace(o,function(t){if("%%"===t)return "%";if(r>=i)return t;switch(t){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(t){return "[Circular]"}default:return t}}),c=n[r];r<i;c=n[++r])y(c)||!m(c)?u+=" "+c:u+=" "+a(c);return u},e.deprecate=function(r,n){if(void 0!==t&&!0===t.noDeprecation)return r;if(void 0===t)return function(){return e.deprecate(r,n).apply(this,arguments)};var o=!1;return function(){if(!o){if(t.throwDeprecation)throw new Error(n);t.traceDeprecation?console.trace(n):console.error(n),o=!0;}return r.apply(this,arguments)}};var i,u={};function a(t,r){var n={seen:[],stylize:s};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),d(r)?n.showHidden=r:r&&e._extend(n,r),g(n.showHidden)&&(n.showHidden=!1),g(n.depth)&&(n.depth=2),g(n.colors)&&(n.colors=!1),g(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=c),f(n,t,n.depth)}function c(t,e){var r=a.styles[e];return r?"["+a.colors[r][0]+"m"+t+"["+a.colors[r][1]+"m":t}function s(t,e){return t}function f(t,r,n){if(t.customInspect&&r&&O(r.inspect)&&r.inspect!==e.inspect&&(!r.constructor||r.constructor.prototype!==r)){var o=r.inspect(n,t);return _(o)||(o=f(t,o,n)),o}var i=function(t,e){if(g(e))return t.stylize("undefined","undefined");if(_(e)){var r="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(r,"string")}if(v(e))return t.stylize(""+e,"number");if(d(e))return t.stylize(""+e,"boolean");if(y(e))return t.stylize("null","null")}(t,r);if(i)return i;var u=Object.keys(r),a=function(t){var e={};return t.forEach(function(t,r){e[t]=!0;}),e}(u);if(t.showHidden&&(u=Object.getOwnPropertyNames(r)),w(r)&&(u.indexOf("message")>=0||u.indexOf("description")>=0))return l(r);if(0===u.length){if(O(r)){var c=r.name?": "+r.name:"";return t.stylize("[Function"+c+"]","special")}if(b(r))return t.stylize(RegExp.prototype.toString.call(r),"regexp");if(j(r))return t.stylize(Date.prototype.toString.call(r),"date");if(w(r))return l(r)}var s,m="",E=!1,A=["{","}"];(h(r)&&(E=!0,A=["[","]"]),O(r))&&(m=" [Function"+(r.name?": "+r.name:"")+"]");return b(r)&&(m=" "+RegExp.prototype.toString.call(r)),j(r)&&(m=" "+Date.prototype.toUTCString.call(r)),w(r)&&(m=" "+l(r)),0!==u.length||E&&0!=r.length?n<0?b(r)?t.stylize(RegExp.prototype.toString.call(r),"regexp"):t.stylize("[Object]","special"):(t.seen.push(r),s=E?function(t,e,r,n,o){for(var i=[],u=0,a=e.length;u<a;++u)R(e,String(u))?i.push(p(t,e,r,n,String(u),!0)):i.push("");return o.forEach(function(o){o.match(/^\d+$/)||i.push(p(t,e,r,n,o,!0));}),i}(t,r,n,a,u):u.map(function(e){return p(t,r,n,a,e,E)}),t.seen.pop(),function(t,e,r){if(t.reduce(function(t,e){return e.indexOf("\n")>=0&&0,t+e.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60)return r[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+r[1];return r[0]+e+" "+t.join(", ")+" "+r[1]}(s,m,A)):A[0]+m+A[1]}function l(t){return "["+Error.prototype.toString.call(t)+"]"}function p(t,e,r,n,o,i){var u,a,c;if((c=Object.getOwnPropertyDescriptor(e,o)||{value:e[o]}).get?a=c.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):c.set&&(a=t.stylize("[Setter]","special")),R(n,o)||(u="["+o+"]"),a||(t.seen.indexOf(c.value)<0?(a=y(r)?f(t,c.value,null):f(t,c.value,r-1)).indexOf("\n")>-1&&(a=i?a.split("\n").map(function(t){return "  "+t}).join("\n").substr(2):"\n"+a.split("\n").map(function(t){return "   "+t}).join("\n")):a=t.stylize("[Circular]","special")),g(u)){if(i&&o.match(/^\d+$/))return a;(u=JSON.stringify(""+o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(u=u.substr(1,u.length-2),u=t.stylize(u,"name")):(u=u.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),u=t.stylize(u,"string"));}return u+": "+a}function h(t){return Array.isArray(t)}function d(t){return "boolean"==typeof t}function y(t){return null===t}function v(t){return "number"==typeof t}function _(t){return "string"==typeof t}function g(t){return void 0===t}function b(t){return m(t)&&"[object RegExp]"===E(t)}function m(t){return "object"==typeof t&&null!==t}function j(t){return m(t)&&"[object Date]"===E(t)}function w(t){return m(t)&&("[object Error]"===E(t)||t instanceof Error)}function O(t){return "function"==typeof t}function E(t){return Object.prototype.toString.call(t)}function A(t){return t<10?"0"+t.toString(10):t.toString(10)}e.debuglog=function(r){if(g(i)&&(i=t.env.NODE_DEBUG||""),r=r.toUpperCase(),!u[r])if(new RegExp("\\b"+r+"\\b","i").test(i)){var n=t.pid;u[r]=function(){var t=e.format.apply(e,arguments);console.error("%s %d: %s",r,n,t);};}else u[r]=function(){};return u[r]},e.inspect=a,a.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},a.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},e.isArray=h,e.isBoolean=d,e.isNull=y,e.isNullOrUndefined=function(t){return null==t},e.isNumber=v,e.isString=_,e.isSymbol=function(t){return "symbol"==typeof t},e.isUndefined=g,e.isRegExp=b,e.isObject=m,e.isDate=j,e.isError=w,e.isFunction=O,e.isPrimitive=function(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t},e.isBuffer=r(39);var S=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function R(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.log=function(){var t,r;console.log("%s - %s",(t=new Date,r=[A(t.getHours()),A(t.getMinutes()),A(t.getSeconds())].join(":"),[t.getDate(),S[t.getMonth()],r].join(" ")),e.format.apply(e,arguments));},e.inherits=r(38),e._extend=function(t,e){if(!e||!m(e))return t;for(var r=Object.keys(e),n=r.length;n--;)t[r[n]]=e[r[n]];return t};var T="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function D(t,e){if(!t){var r=new Error("Promise was rejected with a falsy value");r.reason=t,t=r;}return e(t)}e.promisify=function(t){if("function"!=typeof t)throw new TypeError('The "original" argument must be of type Function');if(T&&t[T]){var e;if("function"!=typeof(e=t[T]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,T,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,r,n=new Promise(function(t,n){e=t,r=n;}),o=[],i=0;i<arguments.length;i++)o.push(arguments[i]);o.push(function(t,n){t?r(t):e(n);});try{t.apply(this,o);}catch(t){r(t);}return n}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),T&&Object.defineProperty(e,T,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,n(t))},e.promisify.custom=T,e.callbackify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');function r(){for(var r=[],n=0;n<arguments.length;n++)r.push(arguments[n]);var o=r.pop();if("function"!=typeof o)throw new TypeError("The last argument must be of type Function");var i=this,u=function(){return o.apply(i,arguments)};e.apply(this,r).then(function(e){t.nextTick(u,null,e);},function(e){t.nextTick(D,e,u);});}return Object.setPrototypeOf(r,Object.getPrototypeOf(e)),Object.defineProperties(r,n(e)),r};}).call(this,r(8));},function(t,e,r){(function(t,r){var n=200,o="Expected a function",i="__lodash_hash_undefined__",u=1,a=2,c=1/0,s=9007199254740991,f="[object Arguments]",l="[object Array]",p="[object Boolean]",h="[object Date]",d="[object Error]",y="[object Function]",v="[object GeneratorFunction]",_="[object Map]",g="[object Number]",b="[object Object]",m="[object RegExp]",j="[object Set]",w="[object String]",O="[object Symbol]",E="[object ArrayBuffer]",A="[object DataView]",S=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,R=/^\w*$/,T=/^\./,D=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,k=/\\(\\)?/g,C=/^\[object .+?Constructor\]$/,F=/^(?:0|[1-9]\d*)$/,P={};P["[object Float32Array]"]=P["[object Float64Array]"]=P["[object Int8Array]"]=P["[object Int16Array]"]=P["[object Int32Array]"]=P["[object Uint8Array]"]=P["[object Uint8ClampedArray]"]=P["[object Uint16Array]"]=P["[object Uint32Array]"]=!0,P[f]=P[l]=P[E]=P[p]=P[A]=P[h]=P[d]=P[y]=P[_]=P[g]=P[b]=P[m]=P[j]=P[w]=P["[object WeakMap]"]=!1;var x="object"==typeof t&&t&&t.Object===Object&&t,$="object"==typeof self&&self&&self.Object===Object&&self,L=x||$||Function("return this")(),M="object"==typeof e&&e&&!e.nodeType&&e,I=M&&"object"==typeof r&&r&&!r.nodeType&&r,U=I&&I.exports===M&&x.process,N=function(){try{return U&&U.binding("util")}catch(t){}}(),B=N&&N.isTypedArray;function Y(t,e){for(var r=-1,n=t?t.length:0,o=Array(n);++r<n;)o[r]=e(t[r],r,t);return o}function H(t,e){for(var r=-1,n=e.length,o=t.length;++r<n;)t[o+r]=e[r];return t}function q(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return !0;return !1}function z(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}function V(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t];}),r}function W(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t;}),r}var G,Q,J,K=Array.prototype,Z=Function.prototype,X=Object.prototype,tt=L["__core-js_shared__"],et=(G=/[^.]+$/.exec(tt&&tt.keys&&tt.keys.IE_PROTO||""))?"Symbol(src)_1."+G:"",rt=Z.toString,nt=X.hasOwnProperty,ot=X.toString,it=RegExp("^"+rt.call(nt).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ut=L.Symbol,at=L.Uint8Array,ct=X.propertyIsEnumerable,st=K.splice,ft=ut?ut.isConcatSpreadable:void 0,lt=(Q=Object.keys,J=Object,function(t){return Q(J(t))}),pt=Wt(L,"DataView"),ht=Wt(L,"Map"),dt=Wt(L,"Promise"),yt=Wt(L,"Set"),vt=Wt(L,"WeakMap"),_t=Wt(Object,"create"),gt=re(pt),bt=re(ht),mt=re(dt),jt=re(yt),wt=re(vt),Ot=ut?ut.prototype:void 0,Et=Ot?Ot.valueOf:void 0,At=Ot?Ot.toString:void 0;function St(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Rt(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Tt(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Dt(t){var e=-1,r=t?t.length:0;for(this.__data__=new Tt;++e<r;)this.add(t[e]);}function kt(t){this.__data__=new Rt(t);}function Ct(t,e){var r=ue(t)||ie(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],n=r.length,o=!!n;for(var i in t)!e&&!nt.call(t,i)||o&&("length"==i||Jt(i,n))||r.push(i);return r}function Ft(t,e){for(var r=t.length;r--;)if(oe(t[r][0],e))return r;return -1}St.prototype.clear=function(){this.__data__=_t?_t(null):{};},St.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},St.prototype.get=function(t){var e=this.__data__;if(_t){var r=e[t];return r===i?void 0:r}return nt.call(e,t)?e[t]:void 0},St.prototype.has=function(t){var e=this.__data__;return _t?void 0!==e[t]:nt.call(e,t)},St.prototype.set=function(t,e){return this.__data__[t]=_t&&void 0===e?i:e,this},Rt.prototype.clear=function(){this.__data__=[];},Rt.prototype.delete=function(t){var e=this.__data__,r=Ft(e,t);return !(r<0||(r==e.length-1?e.pop():st.call(e,r,1),0))},Rt.prototype.get=function(t){var e=this.__data__,r=Ft(e,t);return r<0?void 0:e[r][1]},Rt.prototype.has=function(t){return Ft(this.__data__,t)>-1},Rt.prototype.set=function(t,e){var r=this.__data__,n=Ft(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},Tt.prototype.clear=function(){this.__data__={hash:new St,map:new(ht||Rt),string:new St};},Tt.prototype.delete=function(t){return Vt(this,t).delete(t)},Tt.prototype.get=function(t){return Vt(this,t).get(t)},Tt.prototype.has=function(t){return Vt(this,t).has(t)},Tt.prototype.set=function(t,e){return Vt(this,t).set(t,e),this},Dt.prototype.add=Dt.prototype.push=function(t){return this.__data__.set(t,i),this},Dt.prototype.has=function(t){return this.__data__.has(t)},kt.prototype.clear=function(){this.__data__=new Rt;},kt.prototype.delete=function(t){return this.__data__.delete(t)},kt.prototype.get=function(t){return this.__data__.get(t)},kt.prototype.has=function(t){return this.__data__.has(t)},kt.prototype.set=function(t,e){var r=this.__data__;if(r instanceof Rt){var o=r.__data__;if(!ht||o.length<n-1)return o.push([t,e]),this;r=this.__data__=new Tt(o);}return r.set(t,e),this};var Pt,$t=(Pt=function(t,e){return t&&Lt(t,e,de)},function(t,e){if(null==t)return t;if(!ae(t))return Pt(t,e);for(var r=t.length,n=-1,o=Object(t);(++n<r)&&!1!==e(o[n],n,o););return t});var Lt=function(t){return function(e,r,n){for(var o=-1,i=Object(e),u=n(e),a=u.length;a--;){var c=u[t?a:++o];if(!1===r(i[c],c,i))break}return e}}();function Mt(t,e){for(var r=0,n=(e=Kt(e,t)?[e]:qt(e)).length;null!=t&&r<n;)t=t[ee(e[r++])];return r&&r==n?t:void 0}function It(t,e){return null!=t&&e in Object(t)}function Ut(t,e,r,n,o){return t===e||(null==t||null==e||!fe(t)&&!le(e)?t!=t&&e!=e:function(t,e,r,n,o,i){var c=ue(t),s=ue(e),y=l,v=l;c||(y=(y=Gt(t))==f?b:y);s||(v=(v=Gt(e))==f?b:v);var S=y==b&&!z(t),R=v==b&&!z(e),T=y==v;if(T&&!S)return i||(i=new kt),c||he(t)?zt(t,e,r,n,o,i):function(t,e,r,n,o,i,c){switch(r){case A:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return !1;t=t.buffer,e=e.buffer;case E:return !(t.byteLength!=e.byteLength||!n(new at(t),new at(e)));case p:case h:case g:return oe(+t,+e);case d:return t.name==e.name&&t.message==e.message;case m:case w:return t==e+"";case _:var s=V;case j:var f=i&a;if(s||(s=W),t.size!=e.size&&!f)return !1;var l=c.get(t);if(l)return l==e;i|=u,c.set(t,e);var y=zt(s(t),s(e),n,o,i,c);return c.delete(t),y;case O:if(Et)return Et.call(t)==Et.call(e)}return !1}(t,e,y,r,n,o,i);if(!(o&a)){var D=S&&nt.call(t,"__wrapped__"),k=R&&nt.call(e,"__wrapped__");if(D||k){var C=D?t.value():t,F=k?e.value():e;return i||(i=new kt),r(C,F,n,o,i)}}if(!T)return !1;return i||(i=new kt),function(t,e,r,n,o,i){var u=o&a,c=de(t),s=c.length,f=de(e).length;if(s!=f&&!u)return !1;for(var l=s;l--;){var p=c[l];if(!(u?p in e:nt.call(e,p)))return !1}var h=i.get(t);if(h&&i.get(e))return h==e;var d=!0;i.set(t,e),i.set(e,t);for(var y=u;++l<s;){p=c[l];var v=t[p],_=e[p];if(n)var g=u?n(_,v,p,e,t,i):n(v,_,p,t,e,i);if(!(void 0===g?v===_||r(v,_,n,o,i):g)){d=!1;break}y||(y="constructor"==p);}if(d&&!y){var b=t.constructor,m=e.constructor;b!=m&&"constructor"in t&&"constructor"in e&&!("function"==typeof b&&b instanceof b&&"function"==typeof m&&m instanceof m)&&(d=!1);}return i.delete(t),i.delete(e),d}(t,e,r,n,o,i)}(t,e,Ut,r,n,o))}function Nt(t){return !(!fe(t)||et&&et in t)&&(ce(t)||z(t)?it:C).test(re(t))}function Bt(t){return "function"==typeof t?t:null==t?ye:"object"==typeof t?ue(t)?function(t,e){if(Kt(t)&&Zt(e))return Xt(ee(t),e);return function(r){var n=function(t,e,r){var n=null==t?void 0:Mt(t,e);return void 0===n?r:n}(r,t);return void 0===n&&n===e?function(t,e){return null!=t&&function(t,e,r){var n,o=-1,i=(e=Kt(e,t)?[e]:qt(e)).length;for(;++o<i;){var u=ee(e[o]);if(!(n=null!=t&&r(t,u)))break;t=t[u];}if(n)return n;return !!(i=t?t.length:0)&&se(i)&&Jt(u,i)&&(ue(t)||ie(t))}(t,e,It)}(r,t):Ut(e,n,void 0,u|a)}}(t[0],t[1]):function(t){var e=function(t){var e=de(t),r=e.length;for(;r--;){var n=e[r],o=t[n];e[r]=[n,o,Zt(o)];}return e}(t);if(1==e.length&&e[0][2])return Xt(e[0][0],e[0][1]);return function(r){return r===t||function(t,e,r,n){var o=r.length,i=o,c=!n;if(null==t)return !i;for(t=Object(t);o--;){var s=r[o];if(c&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return !1}for(;++o<i;){var f=(s=r[o])[0],l=t[f],p=s[1];if(c&&s[2]){if(void 0===l&&!(f in t))return !1}else {var h=new kt;if(n)var d=n(l,p,f,t,e,h);if(!(void 0===d?Ut(p,l,n,u|a,h):d))return !1}}return !0}(r,t,e)}}(t):Kt(e=t)?(r=ee(e),function(t){return null==t?void 0:t[r]}):function(t){return function(e){return Mt(e,t)}}(e);var e,r;}function Yt(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||X,e!==n)return lt(t);var e,r,n,o=[];for(var i in Object(t))nt.call(t,i)&&"constructor"!=i&&o.push(i);return o}function Ht(t,e){var r=-1,n=ae(t)?Array(t.length):[];return $t(t,function(t,o,i){n[++r]=e(t,o,i);}),n}function qt(t){return ue(t)?t:te(t)}function zt(t,e,r,n,o,i){var c=o&a,s=t.length,f=e.length;if(s!=f&&!(c&&f>s))return !1;var l=i.get(t);if(l&&i.get(e))return l==e;var p=-1,h=!0,d=o&u?new Dt:void 0;for(i.set(t,e),i.set(e,t);++p<s;){var y=t[p],v=e[p];if(n)var _=c?n(v,y,p,e,t,i):n(y,v,p,t,e,i);if(void 0!==_){if(_)continue;h=!1;break}if(d){if(!q(e,function(t,e){if(!d.has(e)&&(y===t||r(y,t,n,o,i)))return d.add(e)})){h=!1;break}}else if(y!==v&&!r(y,v,n,o,i)){h=!1;break}}return i.delete(t),i.delete(e),h}function Vt(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function Wt(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return Nt(r)?r:void 0}var Gt=function(t){return ot.call(t)};function Qt(t){return ue(t)||ie(t)||!!(ft&&t&&t[ft])}function Jt(t,e){return !!(e=null==e?s:e)&&("number"==typeof t||F.test(t))&&t>-1&&t%1==0&&t<e}function Kt(t,e){if(ue(t))return !1;var r=typeof t;return !("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!pe(t))||(R.test(t)||!S.test(t)||null!=e&&t in Object(e))}function Zt(t){return t==t&&!fe(t)}function Xt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}(pt&&Gt(new pt(new ArrayBuffer(1)))!=A||ht&&Gt(new ht)!=_||dt&&"[object Promise]"!=Gt(dt.resolve())||yt&&Gt(new yt)!=j||vt&&"[object WeakMap]"!=Gt(new vt))&&(Gt=function(t){var e=ot.call(t),r=e==b?t.constructor:void 0,n=r?re(r):void 0;if(n)switch(n){case gt:return A;case bt:return _;case mt:return "[object Promise]";case jt:return j;case wt:return "[object WeakMap]"}return e});var te=ne(function(t){var e;t=null==(e=t)?"":function(t){if("string"==typeof t)return t;if(pe(t))return At?At.call(t):"";var e=t+"";return "0"==e&&1/t==-c?"-0":e}(e);var r=[];return T.test(t)&&r.push(""),t.replace(D,function(t,e,n,o){r.push(n?o.replace(k,"$1"):e||t);}),r});function ee(t){if("string"==typeof t||pe(t))return t;var e=t+"";return "0"==e&&1/t==-c?"-0":e}function re(t){if(null!=t){try{return rt.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}function ne(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(o);var r=function(){var n=arguments,o=e?e.apply(this,n):n[0],i=r.cache;if(i.has(o))return i.get(o);var u=t.apply(this,n);return r.cache=i.set(o,u),u};return r.cache=new(ne.Cache||Tt),r}function oe(t,e){return t===e||t!=t&&e!=e}function ie(t){return function(t){return le(t)&&ae(t)}(t)&&nt.call(t,"callee")&&(!ct.call(t,"callee")||ot.call(t)==f)}ne.Cache=Tt;var ue=Array.isArray;function ae(t){return null!=t&&se(t.length)&&!ce(t)}function ce(t){var e=fe(t)?ot.call(t):"";return e==y||e==v}function se(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=s}function fe(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function le(t){return !!t&&"object"==typeof t}function pe(t){return "symbol"==typeof t||le(t)&&ot.call(t)==O}var he=B?function(t){return function(e){return t(e)}}(B):function(t){return le(t)&&se(t.length)&&!!P[ot.call(t)]};function de(t){return ae(t)?Ct(t):Yt(t)}function ye(t){return t}r.exports=function(t,e){return function t(e,r,n,o,i){var u=-1,a=e.length;for(n||(n=Qt),i||(i=[]);++u<a;){var c=e[u];r>0&&n(c)?r>1?t(c,r-1,n,o,i):H(i,c):o||(i[i.length]=c);}return i}(function(t,e){return (ue(t)?Y:Ht)(t,Bt(e))}(t,e),1)};}).call(this,r(0),r(2)(t));},function(t,e,r){(function(t,r){var n=200,o="Expected a function",i="__lodash_hash_undefined__",u=1,a=2,c=1/0,s=9007199254740991,f="[object Arguments]",l="[object Array]",p="[object Boolean]",h="[object Date]",d="[object Error]",y="[object Function]",v="[object GeneratorFunction]",_="[object Map]",g="[object Number]",b="[object Object]",m="[object RegExp]",j="[object Set]",w="[object String]",O="[object Symbol]",E="[object ArrayBuffer]",A="[object DataView]",S=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,R=/^\w*$/,T=/^\./,D=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,k=/\\(\\)?/g,C=/^\[object .+?Constructor\]$/,F=/^(?:0|[1-9]\d*)$/,P={};P["[object Float32Array]"]=P["[object Float64Array]"]=P["[object Int8Array]"]=P["[object Int16Array]"]=P["[object Int32Array]"]=P["[object Uint8Array]"]=P["[object Uint8ClampedArray]"]=P["[object Uint16Array]"]=P["[object Uint32Array]"]=!0,P[f]=P[l]=P[E]=P[p]=P[A]=P[h]=P[d]=P[y]=P[_]=P[g]=P[b]=P[m]=P[j]=P[w]=P["[object WeakMap]"]=!1;var x="object"==typeof t&&t&&t.Object===Object&&t,$="object"==typeof self&&self&&self.Object===Object&&self,L=x||$||Function("return this")(),M="object"==typeof e&&e&&!e.nodeType&&e,I=M&&"object"==typeof r&&r&&!r.nodeType&&r,U=I&&I.exports===M&&x.process,N=function(){try{return U&&U.binding("util")}catch(t){}}(),B=N&&N.isTypedArray;function Y(t,e){for(var r=-1,n=t?t.length:0,o=Array(n);++r<n;)o[r]=e(t[r],r,t);return o}function H(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return !0;return !1}function q(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}function z(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t];}),r}function V(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t;}),r}var W,G,Q,J=Array.prototype,K=Function.prototype,Z=Object.prototype,X=L["__core-js_shared__"],tt=(W=/[^.]+$/.exec(X&&X.keys&&X.keys.IE_PROTO||""))?"Symbol(src)_1."+W:"",et=K.toString,rt=Z.hasOwnProperty,nt=Z.toString,ot=RegExp("^"+et.call(rt).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),it=L.Symbol,ut=L.Uint8Array,at=Z.propertyIsEnumerable,ct=J.splice,st=(G=Object.keys,Q=Object,function(t){return G(Q(t))}),ft=zt(L,"DataView"),lt=zt(L,"Map"),pt=zt(L,"Promise"),ht=zt(L,"Set"),dt=zt(L,"WeakMap"),yt=zt(Object,"create"),vt=Xt(ft),_t=Xt(lt),gt=Xt(pt),bt=Xt(ht),mt=Xt(dt),jt=it?it.prototype:void 0,wt=jt?jt.valueOf:void 0,Ot=jt?jt.toString:void 0;function Et(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function At(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function St(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Rt(t){var e=-1,r=t?t.length:0;for(this.__data__=new St;++e<r;)this.add(t[e]);}function Tt(t){this.__data__=new At(t);}function Dt(t,e){var r=ne(t)||re(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],n=r.length,o=!!n;for(var i in t)!e&&!rt.call(t,i)||o&&("length"==i||Wt(i,n))||r.push(i);return r}function kt(t,e){for(var r=t.length;r--;)if(ee(t[r][0],e))return r;return -1}Et.prototype.clear=function(){this.__data__=yt?yt(null):{};},Et.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},Et.prototype.get=function(t){var e=this.__data__;if(yt){var r=e[t];return r===i?void 0:r}return rt.call(e,t)?e[t]:void 0},Et.prototype.has=function(t){var e=this.__data__;return yt?void 0!==e[t]:rt.call(e,t)},Et.prototype.set=function(t,e){return this.__data__[t]=yt&&void 0===e?i:e,this},At.prototype.clear=function(){this.__data__=[];},At.prototype.delete=function(t){var e=this.__data__,r=kt(e,t);return !(r<0||(r==e.length-1?e.pop():ct.call(e,r,1),0))},At.prototype.get=function(t){var e=this.__data__,r=kt(e,t);return r<0?void 0:e[r][1]},At.prototype.has=function(t){return kt(this.__data__,t)>-1},At.prototype.set=function(t,e){var r=this.__data__,n=kt(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},St.prototype.clear=function(){this.__data__={hash:new Et,map:new(lt||At),string:new Et};},St.prototype.delete=function(t){return qt(this,t).delete(t)},St.prototype.get=function(t){return qt(this,t).get(t)},St.prototype.has=function(t){return qt(this,t).has(t)},St.prototype.set=function(t,e){return qt(this,t).set(t,e),this},Rt.prototype.add=Rt.prototype.push=function(t){return this.__data__.set(t,i),this},Rt.prototype.has=function(t){return this.__data__.has(t)},Tt.prototype.clear=function(){this.__data__=new At;},Tt.prototype.delete=function(t){return this.__data__.delete(t)},Tt.prototype.get=function(t){return this.__data__.get(t)},Tt.prototype.has=function(t){return this.__data__.has(t)},Tt.prototype.set=function(t,e){var r=this.__data__;if(r instanceof At){var o=r.__data__;if(!lt||o.length<n-1)return o.push([t,e]),this;r=this.__data__=new St(o);}return r.set(t,e),this};var Ct,Pt=(Ct=function(t,e){return t&&xt(t,e,le)},function(t,e){if(null==t)return t;if(!oe(t))return Ct(t,e);for(var r=t.length,n=-1,o=Object(t);(++n<r)&&!1!==e(o[n],n,o););return t}),xt=function(t){return function(e,r,n){for(var o=-1,i=Object(e),u=n(e),a=u.length;a--;){var c=u[t?a:++o];if(!1===r(i[c],c,i))break}return e}}();function $t(t,e){for(var r=0,n=(e=Gt(e,t)?[e]:Yt(e)).length;null!=t&&r<n;)t=t[Zt(e[r++])];return r&&r==n?t:void 0}function Lt(t,e){return null!=t&&e in Object(t)}function Mt(t,e,r,n,o){return t===e||(null==t||null==e||!ae(t)&&!ce(e)?t!=t&&e!=e:function(t,e,r,n,o,i){var c=ne(t),s=ne(e),y=l,v=l;c||(y=(y=Vt(t))==f?b:y);s||(v=(v=Vt(e))==f?b:v);var S=y==b&&!q(t),R=v==b&&!q(e),T=y==v;if(T&&!S)return i||(i=new Tt),c||fe(t)?Ht(t,e,r,n,o,i):function(t,e,r,n,o,i,c){switch(r){case A:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return !1;t=t.buffer,e=e.buffer;case E:return !(t.byteLength!=e.byteLength||!n(new ut(t),new ut(e)));case p:case h:case g:return ee(+t,+e);case d:return t.name==e.name&&t.message==e.message;case m:case w:return t==e+"";case _:var s=z;case j:var f=i&a;if(s||(s=V),t.size!=e.size&&!f)return !1;var l=c.get(t);if(l)return l==e;i|=u,c.set(t,e);var y=Ht(s(t),s(e),n,o,i,c);return c.delete(t),y;case O:if(wt)return wt.call(t)==wt.call(e)}return !1}(t,e,y,r,n,o,i);if(!(o&a)){var D=S&&rt.call(t,"__wrapped__"),k=R&&rt.call(e,"__wrapped__");if(D||k){var C=D?t.value():t,F=k?e.value():e;return i||(i=new Tt),r(C,F,n,o,i)}}if(!T)return !1;return i||(i=new Tt),function(t,e,r,n,o,i){var u=o&a,c=le(t),s=c.length,f=le(e).length;if(s!=f&&!u)return !1;for(var l=s;l--;){var p=c[l];if(!(u?p in e:rt.call(e,p)))return !1}var h=i.get(t);if(h&&i.get(e))return h==e;var d=!0;i.set(t,e),i.set(e,t);for(var y=u;++l<s;){p=c[l];var v=t[p],_=e[p];if(n)var g=u?n(_,v,p,e,t,i):n(v,_,p,t,e,i);if(!(void 0===g?v===_||r(v,_,n,o,i):g)){d=!1;break}y||(y="constructor"==p);}if(d&&!y){var b=t.constructor,m=e.constructor;b!=m&&"constructor"in t&&"constructor"in e&&!("function"==typeof b&&b instanceof b&&"function"==typeof m&&m instanceof m)&&(d=!1);}return i.delete(t),i.delete(e),d}(t,e,r,n,o,i)}(t,e,Mt,r,n,o))}function It(t){return !(!ae(t)||tt&&tt in t)&&(ie(t)||q(t)?ot:C).test(Xt(t))}function Ut(t){return "function"==typeof t?t:null==t?pe:"object"==typeof t?ne(t)?function(t,e){if(Gt(t)&&Qt(e))return Jt(Zt(t),e);return function(r){var n=function(t,e,r){var n=null==t?void 0:$t(t,e);return void 0===n?r:n}(r,t);return void 0===n&&n===e?function(t,e){return null!=t&&function(t,e,r){var n,o=-1,i=(e=Gt(e,t)?[e]:Yt(e)).length;for(;++o<i;){var u=Zt(e[o]);if(!(n=null!=t&&r(t,u)))break;t=t[u];}if(n)return n;return !!(i=t?t.length:0)&&ue(i)&&Wt(u,i)&&(ne(t)||re(t))}(t,e,Lt)}(r,t):Mt(e,n,void 0,u|a)}}(t[0],t[1]):function(t){var e=function(t){var e=le(t),r=e.length;for(;r--;){var n=e[r],o=t[n];e[r]=[n,o,Qt(o)];}return e}(t);if(1==e.length&&e[0][2])return Jt(e[0][0],e[0][1]);return function(r){return r===t||function(t,e,r,n){var o=r.length,i=o,c=!n;if(null==t)return !i;for(t=Object(t);o--;){var s=r[o];if(c&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return !1}for(;++o<i;){var f=(s=r[o])[0],l=t[f],p=s[1];if(c&&s[2]){if(void 0===l&&!(f in t))return !1}else {var h=new Tt;if(n)var d=n(l,p,f,t,e,h);if(!(void 0===d?Mt(p,l,n,u|a,h):d))return !1}}return !0}(r,t,e)}}(t):Gt(e=t)?(r=Zt(e),function(t){return null==t?void 0:t[r]}):function(t){return function(e){return $t(e,t)}}(e);var e,r;}function Nt(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||Z,e!==n)return st(t);var e,r,n,o=[];for(var i in Object(t))rt.call(t,i)&&"constructor"!=i&&o.push(i);return o}function Bt(t,e){var r=-1,n=oe(t)?Array(t.length):[];return Pt(t,function(t,o,i){n[++r]=e(t,o,i);}),n}function Yt(t){return ne(t)?t:Kt(t)}function Ht(t,e,r,n,o,i){var c=o&a,s=t.length,f=e.length;if(s!=f&&!(c&&f>s))return !1;var l=i.get(t);if(l&&i.get(e))return l==e;var p=-1,h=!0,d=o&u?new Rt:void 0;for(i.set(t,e),i.set(e,t);++p<s;){var y=t[p],v=e[p];if(n)var _=c?n(v,y,p,e,t,i):n(y,v,p,t,e,i);if(void 0!==_){if(_)continue;h=!1;break}if(d){if(!H(e,function(t,e){if(!d.has(e)&&(y===t||r(y,t,n,o,i)))return d.add(e)})){h=!1;break}}else if(y!==v&&!r(y,v,n,o,i)){h=!1;break}}return i.delete(t),i.delete(e),h}function qt(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function zt(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return It(r)?r:void 0}var Vt=function(t){return nt.call(t)};function Wt(t,e){return !!(e=null==e?s:e)&&("number"==typeof t||F.test(t))&&t>-1&&t%1==0&&t<e}function Gt(t,e){if(ne(t))return !1;var r=typeof t;return !("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!se(t))||(R.test(t)||!S.test(t)||null!=e&&t in Object(e))}function Qt(t){return t==t&&!ae(t)}function Jt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}(ft&&Vt(new ft(new ArrayBuffer(1)))!=A||lt&&Vt(new lt)!=_||pt&&"[object Promise]"!=Vt(pt.resolve())||ht&&Vt(new ht)!=j||dt&&"[object WeakMap]"!=Vt(new dt))&&(Vt=function(t){var e=nt.call(t),r=e==b?t.constructor:void 0,n=r?Xt(r):void 0;if(n)switch(n){case vt:return A;case _t:return _;case gt:return "[object Promise]";case bt:return j;case mt:return "[object WeakMap]"}return e});var Kt=te(function(t){var e;t=null==(e=t)?"":function(t){if("string"==typeof t)return t;if(se(t))return Ot?Ot.call(t):"";var e=t+"";return "0"==e&&1/t==-c?"-0":e}(e);var r=[];return T.test(t)&&r.push(""),t.replace(D,function(t,e,n,o){r.push(n?o.replace(k,"$1"):e||t);}),r});function Zt(t){if("string"==typeof t||se(t))return t;var e=t+"";return "0"==e&&1/t==-c?"-0":e}function Xt(t){if(null!=t){try{return et.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}function te(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(o);var r=function(){var n=arguments,o=e?e.apply(this,n):n[0],i=r.cache;if(i.has(o))return i.get(o);var u=t.apply(this,n);return r.cache=i.set(o,u),u};return r.cache=new(te.Cache||St),r}function ee(t,e){return t===e||t!=t&&e!=e}function re(t){return function(t){return ce(t)&&oe(t)}(t)&&rt.call(t,"callee")&&(!at.call(t,"callee")||nt.call(t)==f)}te.Cache=St;var ne=Array.isArray;function oe(t){return null!=t&&ue(t.length)&&!ie(t)}function ie(t){var e=ae(t)?nt.call(t):"";return e==y||e==v}function ue(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=s}function ae(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function ce(t){return !!t&&"object"==typeof t}function se(t){return "symbol"==typeof t||ce(t)&&nt.call(t)==O}var fe=B?function(t){return function(e){return t(e)}}(B):function(t){return ce(t)&&ue(t.length)&&!!P[nt.call(t)]};function le(t){return oe(t)?Dt(t):Nt(t)}function pe(t){return t}r.exports=function(t,e){return (ne(t)?Y:Bt)(t,Ut(e))};}).call(this,r(0),r(2)(t));},function(t,e,r){(function(t,r){var n=200,o="Expected a function",i="__lodash_hash_undefined__",u=1,a=2,c=1/0,s=9007199254740991,f="[object Arguments]",l="[object Array]",p="[object Boolean]",h="[object Date]",d="[object Error]",y="[object Function]",v="[object GeneratorFunction]",_="[object Map]",g="[object Number]",b="[object Object]",m="[object RegExp]",j="[object Set]",w="[object String]",O="[object Symbol]",E="[object ArrayBuffer]",A="[object DataView]",S=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,R=/^\w*$/,T=/^\./,D=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,k=/\\(\\)?/g,C=/^\[object .+?Constructor\]$/,F=/^(?:0|[1-9]\d*)$/,P={};P["[object Float32Array]"]=P["[object Float64Array]"]=P["[object Int8Array]"]=P["[object Int16Array]"]=P["[object Int32Array]"]=P["[object Uint8Array]"]=P["[object Uint8ClampedArray]"]=P["[object Uint16Array]"]=P["[object Uint32Array]"]=!0,P[f]=P[l]=P[E]=P[p]=P[A]=P[h]=P[d]=P[y]=P[_]=P[g]=P[b]=P[m]=P[j]=P[w]=P["[object WeakMap]"]=!1;var x="object"==typeof t&&t&&t.Object===Object&&t,$="object"==typeof self&&self&&self.Object===Object&&self,L=x||$||Function("return this")(),M="object"==typeof e&&e&&!e.nodeType&&e,I=M&&"object"==typeof r&&r&&!r.nodeType&&r,U=I&&I.exports===M&&x.process,N=function(){try{return U&&U.binding("util")}catch(t){}}(),B=N&&N.isTypedArray;function Y(t,e){for(var r=-1,n=t?t.length:0,o=0,i=[];++r<n;){var u=t[r];e(u,r,t)&&(i[o++]=u);}return i}function H(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return !0;return !1}function q(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}function z(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t];}),r}function V(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t;}),r}var W,G,Q,J=Array.prototype,K=Function.prototype,Z=Object.prototype,X=L["__core-js_shared__"],tt=(W=/[^.]+$/.exec(X&&X.keys&&X.keys.IE_PROTO||""))?"Symbol(src)_1."+W:"",et=K.toString,rt=Z.hasOwnProperty,nt=Z.toString,ot=RegExp("^"+et.call(rt).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),it=L.Symbol,ut=L.Uint8Array,at=Z.propertyIsEnumerable,ct=J.splice,st=(G=Object.keys,Q=Object,function(t){return G(Q(t))}),ft=zt(L,"DataView"),lt=zt(L,"Map"),pt=zt(L,"Promise"),ht=zt(L,"Set"),dt=zt(L,"WeakMap"),yt=zt(Object,"create"),vt=Xt(ft),_t=Xt(lt),gt=Xt(pt),bt=Xt(ht),mt=Xt(dt),jt=it?it.prototype:void 0,wt=jt?jt.valueOf:void 0,Ot=jt?jt.toString:void 0;function Et(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function At(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function St(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Rt(t){var e=-1,r=t?t.length:0;for(this.__data__=new St;++e<r;)this.add(t[e]);}function Tt(t){this.__data__=new At(t);}function Dt(t,e){var r=ne(t)||re(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],n=r.length,o=!!n;for(var i in t)!e&&!rt.call(t,i)||o&&("length"==i||Wt(i,n))||r.push(i);return r}function kt(t,e){for(var r=t.length;r--;)if(ee(t[r][0],e))return r;return -1}Et.prototype.clear=function(){this.__data__=yt?yt(null):{};},Et.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},Et.prototype.get=function(t){var e=this.__data__;if(yt){var r=e[t];return r===i?void 0:r}return rt.call(e,t)?e[t]:void 0},Et.prototype.has=function(t){var e=this.__data__;return yt?void 0!==e[t]:rt.call(e,t)},Et.prototype.set=function(t,e){return this.__data__[t]=yt&&void 0===e?i:e,this},At.prototype.clear=function(){this.__data__=[];},At.prototype.delete=function(t){var e=this.__data__,r=kt(e,t);return !(r<0||(r==e.length-1?e.pop():ct.call(e,r,1),0))},At.prototype.get=function(t){var e=this.__data__,r=kt(e,t);return r<0?void 0:e[r][1]},At.prototype.has=function(t){return kt(this.__data__,t)>-1},At.prototype.set=function(t,e){var r=this.__data__,n=kt(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},St.prototype.clear=function(){this.__data__={hash:new Et,map:new(lt||At),string:new Et};},St.prototype.delete=function(t){return qt(this,t).delete(t)},St.prototype.get=function(t){return qt(this,t).get(t)},St.prototype.has=function(t){return qt(this,t).has(t)},St.prototype.set=function(t,e){return qt(this,t).set(t,e),this},Rt.prototype.add=Rt.prototype.push=function(t){return this.__data__.set(t,i),this},Rt.prototype.has=function(t){return this.__data__.has(t)},Tt.prototype.clear=function(){this.__data__=new At;},Tt.prototype.delete=function(t){return this.__data__.delete(t)},Tt.prototype.get=function(t){return this.__data__.get(t)},Tt.prototype.has=function(t){return this.__data__.has(t)},Tt.prototype.set=function(t,e){var r=this.__data__;if(r instanceof At){var o=r.__data__;if(!lt||o.length<n-1)return o.push([t,e]),this;r=this.__data__=new St(o);}return r.set(t,e),this};var Ct,Pt=(Ct=function(t,e){return t&&$t(t,e,le)},function(t,e){if(null==t)return t;if(!oe(t))return Ct(t,e);for(var r=t.length,n=-1,o=Object(t);(++n<r)&&!1!==e(o[n],n,o););return t});function xt(t,e){var r=[];return Pt(t,function(t,n,o){e(t,n,o)&&r.push(t);}),r}var $t=function(t){return function(e,r,n){for(var o=-1,i=Object(e),u=n(e),a=u.length;a--;){var c=u[t?a:++o];if(!1===r(i[c],c,i))break}return e}}();function Lt(t,e){for(var r=0,n=(e=Gt(e,t)?[e]:Yt(e)).length;null!=t&&r<n;)t=t[Zt(e[r++])];return r&&r==n?t:void 0}function Mt(t,e){return null!=t&&e in Object(t)}function It(t,e,r,n,o){return t===e||(null==t||null==e||!ae(t)&&!ce(e)?t!=t&&e!=e:function(t,e,r,n,o,i){var c=ne(t),s=ne(e),y=l,v=l;c||(y=(y=Vt(t))==f?b:y);s||(v=(v=Vt(e))==f?b:v);var S=y==b&&!q(t),R=v==b&&!q(e),T=y==v;if(T&&!S)return i||(i=new Tt),c||fe(t)?Ht(t,e,r,n,o,i):function(t,e,r,n,o,i,c){switch(r){case A:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return !1;t=t.buffer,e=e.buffer;case E:return !(t.byteLength!=e.byteLength||!n(new ut(t),new ut(e)));case p:case h:case g:return ee(+t,+e);case d:return t.name==e.name&&t.message==e.message;case m:case w:return t==e+"";case _:var s=z;case j:var f=i&a;if(s||(s=V),t.size!=e.size&&!f)return !1;var l=c.get(t);if(l)return l==e;i|=u,c.set(t,e);var y=Ht(s(t),s(e),n,o,i,c);return c.delete(t),y;case O:if(wt)return wt.call(t)==wt.call(e)}return !1}(t,e,y,r,n,o,i);if(!(o&a)){var D=S&&rt.call(t,"__wrapped__"),k=R&&rt.call(e,"__wrapped__");if(D||k){var C=D?t.value():t,F=k?e.value():e;return i||(i=new Tt),r(C,F,n,o,i)}}if(!T)return !1;return i||(i=new Tt),function(t,e,r,n,o,i){var u=o&a,c=le(t),s=c.length,f=le(e).length;if(s!=f&&!u)return !1;for(var l=s;l--;){var p=c[l];if(!(u?p in e:rt.call(e,p)))return !1}var h=i.get(t);if(h&&i.get(e))return h==e;var d=!0;i.set(t,e),i.set(e,t);for(var y=u;++l<s;){p=c[l];var v=t[p],_=e[p];if(n)var g=u?n(_,v,p,e,t,i):n(v,_,p,t,e,i);if(!(void 0===g?v===_||r(v,_,n,o,i):g)){d=!1;break}y||(y="constructor"==p);}if(d&&!y){var b=t.constructor,m=e.constructor;b!=m&&"constructor"in t&&"constructor"in e&&!("function"==typeof b&&b instanceof b&&"function"==typeof m&&m instanceof m)&&(d=!1);}return i.delete(t),i.delete(e),d}(t,e,r,n,o,i)}(t,e,It,r,n,o))}function Ut(t){return !(!ae(t)||tt&&tt in t)&&(ie(t)||q(t)?ot:C).test(Xt(t))}function Nt(t){return "function"==typeof t?t:null==t?pe:"object"==typeof t?ne(t)?function(t,e){if(Gt(t)&&Qt(e))return Jt(Zt(t),e);return function(r){var n=function(t,e,r){var n=null==t?void 0:Lt(t,e);return void 0===n?r:n}(r,t);return void 0===n&&n===e?function(t,e){return null!=t&&function(t,e,r){var n,o=-1,i=(e=Gt(e,t)?[e]:Yt(e)).length;for(;++o<i;){var u=Zt(e[o]);if(!(n=null!=t&&r(t,u)))break;t=t[u];}if(n)return n;return !!(i=t?t.length:0)&&ue(i)&&Wt(u,i)&&(ne(t)||re(t))}(t,e,Mt)}(r,t):It(e,n,void 0,u|a)}}(t[0],t[1]):function(t){var e=function(t){var e=le(t),r=e.length;for(;r--;){var n=e[r],o=t[n];e[r]=[n,o,Qt(o)];}return e}(t);if(1==e.length&&e[0][2])return Jt(e[0][0],e[0][1]);return function(r){return r===t||function(t,e,r,n){var o=r.length,i=o,c=!n;if(null==t)return !i;for(t=Object(t);o--;){var s=r[o];if(c&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return !1}for(;++o<i;){var f=(s=r[o])[0],l=t[f],p=s[1];if(c&&s[2]){if(void 0===l&&!(f in t))return !1}else {var h=new Tt;if(n)var d=n(l,p,f,t,e,h);if(!(void 0===d?It(p,l,n,u|a,h):d))return !1}}return !0}(r,t,e)}}(t):Gt(e=t)?(r=Zt(e),function(t){return null==t?void 0:t[r]}):function(t){return function(e){return Lt(e,t)}}(e);var e,r;}function Bt(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||Z,e!==n)return st(t);var e,r,n,o=[];for(var i in Object(t))rt.call(t,i)&&"constructor"!=i&&o.push(i);return o}function Yt(t){return ne(t)?t:Kt(t)}function Ht(t,e,r,n,o,i){var c=o&a,s=t.length,f=e.length;if(s!=f&&!(c&&f>s))return !1;var l=i.get(t);if(l&&i.get(e))return l==e;var p=-1,h=!0,d=o&u?new Rt:void 0;for(i.set(t,e),i.set(e,t);++p<s;){var y=t[p],v=e[p];if(n)var _=c?n(v,y,p,e,t,i):n(y,v,p,t,e,i);if(void 0!==_){if(_)continue;h=!1;break}if(d){if(!H(e,function(t,e){if(!d.has(e)&&(y===t||r(y,t,n,o,i)))return d.add(e)})){h=!1;break}}else if(y!==v&&!r(y,v,n,o,i)){h=!1;break}}return i.delete(t),i.delete(e),h}function qt(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function zt(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return Ut(r)?r:void 0}var Vt=function(t){return nt.call(t)};function Wt(t,e){return !!(e=null==e?s:e)&&("number"==typeof t||F.test(t))&&t>-1&&t%1==0&&t<e}function Gt(t,e){if(ne(t))return !1;var r=typeof t;return !("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!se(t))||(R.test(t)||!S.test(t)||null!=e&&t in Object(e))}function Qt(t){return t==t&&!ae(t)}function Jt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}(ft&&Vt(new ft(new ArrayBuffer(1)))!=A||lt&&Vt(new lt)!=_||pt&&"[object Promise]"!=Vt(pt.resolve())||ht&&Vt(new ht)!=j||dt&&"[object WeakMap]"!=Vt(new dt))&&(Vt=function(t){var e=nt.call(t),r=e==b?t.constructor:void 0,n=r?Xt(r):void 0;if(n)switch(n){case vt:return A;case _t:return _;case gt:return "[object Promise]";case bt:return j;case mt:return "[object WeakMap]"}return e});var Kt=te(function(t){var e;t=null==(e=t)?"":function(t){if("string"==typeof t)return t;if(se(t))return Ot?Ot.call(t):"";var e=t+"";return "0"==e&&1/t==-c?"-0":e}(e);var r=[];return T.test(t)&&r.push(""),t.replace(D,function(t,e,n,o){r.push(n?o.replace(k,"$1"):e||t);}),r});function Zt(t){if("string"==typeof t||se(t))return t;var e=t+"";return "0"==e&&1/t==-c?"-0":e}function Xt(t){if(null!=t){try{return et.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}function te(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(o);var r=function(){var n=arguments,o=e?e.apply(this,n):n[0],i=r.cache;if(i.has(o))return i.get(o);var u=t.apply(this,n);return r.cache=i.set(o,u),u};return r.cache=new(te.Cache||St),r}function ee(t,e){return t===e||t!=t&&e!=e}function re(t){return function(t){return ce(t)&&oe(t)}(t)&&rt.call(t,"callee")&&(!at.call(t,"callee")||nt.call(t)==f)}te.Cache=St;var ne=Array.isArray;function oe(t){return null!=t&&ue(t.length)&&!ie(t)}function ie(t){var e=ae(t)?nt.call(t):"";return e==y||e==v}function ue(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=s}function ae(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function ce(t){return !!t&&"object"==typeof t}function se(t){return "symbol"==typeof t||ce(t)&&nt.call(t)==O}var fe=B?function(t){return function(e){return t(e)}}(B):function(t){return ce(t)&&ue(t.length)&&!!P[nt.call(t)]};function le(t){return oe(t)?Dt(t):Bt(t)}function pe(t){return t}r.exports=function(t,e){return (ne(t)?Y:xt)(t,Nt(e))};}).call(this,r(0),r(2)(t));},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.FrontendFileReader=void 0,r(48);e.FrontendFileReader=class{setRecordTransformer(t){this.recordTransformer=t;}checkFile(t){fetch(t,{method:"HEAD",credentials:"same-origin",redirect:"follow"}).then(t=>Promise.resolve(t));}readText(t,e,r){fetch(t).then(t=>t.text()).then(t=>{e(null,t);}).catch(r=>{e(`${t} read error: ${r}`);});}};},function(t,e,r){r.r(e);var n=new Date,o=new Date;function i(t,e,r,u){function a(e){return t(e=0===arguments.length?new Date:new Date(+e)),e}return a.floor=function(e){return t(e=new Date(+e)),e},a.ceil=function(r){return t(r=new Date(r-1)),e(r,1),t(r),r},a.round=function(t){var e=a(t),r=a.ceil(t);return t-e<r-t?e:r},a.offset=function(t,r){return e(t=new Date(+t),null==r?1:Math.floor(r)),t},a.range=function(r,n,o){var i,u=[];if(r=a.ceil(r),o=null==o?1:Math.floor(o),!(r<n&&o>0))return u;do{u.push(i=new Date(+r)),e(r,o),t(r);}while(i<r&&r<n);return u},a.filter=function(r){return i(function(e){if(e>=e)for(;t(e),!r(e);)e.setTime(e-1);},function(t,n){if(t>=t)if(n<0)for(;++n<=0;)for(;e(t,-1),!r(t););else for(;--n>=0;)for(;e(t,1),!r(t););})},r&&(a.count=function(e,i){return n.setTime(+e),o.setTime(+i),t(n),t(o),Math.floor(r(n,o))},a.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?a.filter(u?function(e){return u(e)%t==0}:function(e){return a.count(0,e)%t==0}):a:null}),a}var u=6e4,a=6048e5;function c(t){return i(function(e){e.setUTCDate(e.getUTCDate()-(e.getUTCDay()+7-t)%7),e.setUTCHours(0,0,0,0);},function(t,e){t.setUTCDate(t.getUTCDate()+7*e);},function(t,e){return (e-t)/a})}var s=c(0),f=c(1),l=c(2),p=c(3),h=c(4),d=c(5),y=c(6),v=(s.range,f.range,l.range,p.range,h.range,d.range,y.range,i(function(t){t.setUTCHours(0,0,0,0);},function(t,e){t.setUTCDate(t.getUTCDate()+e);},function(t,e){return (e-t)/864e5},function(t){return t.getUTCDate()-1})),_=v;v.range;function g(t){return i(function(e){e.setDate(e.getDate()-(e.getDay()+7-t)%7),e.setHours(0,0,0,0);},function(t,e){t.setDate(t.getDate()+7*e);},function(t,e){return (e-t-(e.getTimezoneOffset()-t.getTimezoneOffset())*u)/a})}var b=g(0),m=g(1),j=g(2),w=g(3),O=g(4),E=g(5),A=g(6),S=(b.range,m.range,j.range,w.range,O.range,E.range,A.range,i(function(t){t.setHours(0,0,0,0);},function(t,e){t.setDate(t.getDate()+e);},function(t,e){return (e-t-(e.getTimezoneOffset()-t.getTimezoneOffset())*u)/864e5},function(t){return t.getDate()-1})),R=S,T=(S.range,i(function(t){t.setMonth(0,1),t.setHours(0,0,0,0);},function(t,e){t.setFullYear(t.getFullYear()+e);},function(t,e){return e.getFullYear()-t.getFullYear()},function(t){return t.getFullYear()}));T.every=function(t){return isFinite(t=Math.floor(t))&&t>0?i(function(e){e.setFullYear(Math.floor(e.getFullYear()/t)*t),e.setMonth(0,1),e.setHours(0,0,0,0);},function(e,r){e.setFullYear(e.getFullYear()+r*t);}):null};var D=T,k=(T.range,i(function(t){t.setUTCMonth(0,1),t.setUTCHours(0,0,0,0);},function(t,e){t.setUTCFullYear(t.getUTCFullYear()+e);},function(t,e){return e.getUTCFullYear()-t.getUTCFullYear()},function(t){return t.getUTCFullYear()}));k.every=function(t){return isFinite(t=Math.floor(t))&&t>0?i(function(e){e.setUTCFullYear(Math.floor(e.getUTCFullYear()/t)*t),e.setUTCMonth(0,1),e.setUTCHours(0,0,0,0);},function(e,r){e.setUTCFullYear(e.getUTCFullYear()+r*t);}):null};var C=k;k.range;function F(t){if(0<=t.y&&t.y<100){var e=new Date(-1,t.m,t.d,t.H,t.M,t.S,t.L);return e.setFullYear(t.y),e}return new Date(t.y,t.m,t.d,t.H,t.M,t.S,t.L)}function P(t){if(0<=t.y&&t.y<100){var e=new Date(Date.UTC(-1,t.m,t.d,t.H,t.M,t.S,t.L));return e.setUTCFullYear(t.y),e}return new Date(Date.UTC(t.y,t.m,t.d,t.H,t.M,t.S,t.L))}function x(t,e,r){return {y:t,m:e,d:r,H:0,M:0,S:0,L:0}}function $(t){var e=t.dateTime,r=t.date,n=t.time,o=t.periods,i=t.days,u=t.shortDays,a=t.months,c=t.shortMonths,s=W(o),l=G(o),p=W(i),h=G(i),d=W(u),y=G(u),v=W(a),g=G(a),b=W(c),j=G(c),w={a:function(t){return u[t.getDay()]},A:function(t){return i[t.getDay()]},b:function(t){return c[t.getMonth()]},B:function(t){return a[t.getMonth()]},c:null,d:yt,e:yt,f:mt,g:Ct,G:Pt,H:vt,I:_t,j:gt,L:bt,m:jt,M:wt,p:function(t){return o[+(t.getHours()>=12)]},q:function(t){return 1+~~(t.getMonth()/3)},Q:re,s:ne,S:Ot,u:Et,U:At,V:Rt,w:Tt,W:Dt,x:null,X:null,y:kt,Y:Ft,Z:xt,"%":ee},O={a:function(t){return u[t.getUTCDay()]},A:function(t){return i[t.getUTCDay()]},b:function(t){return c[t.getUTCMonth()]},B:function(t){return a[t.getUTCMonth()]},c:null,d:$t,e:$t,f:Nt,g:Kt,G:Xt,H:Lt,I:Mt,j:It,L:Ut,m:Bt,M:Yt,p:function(t){return o[+(t.getUTCHours()>=12)]},q:function(t){return 1+~~(t.getUTCMonth()/3)},Q:re,s:ne,S:Ht,u:qt,U:zt,V:Wt,w:Gt,W:Qt,x:null,X:null,y:Jt,Y:Zt,Z:te,"%":ee},E={a:function(t,e,r){var n=d.exec(e.slice(r));return n?(t.w=y[n[0].toLowerCase()],r+n[0].length):-1},A:function(t,e,r){var n=p.exec(e.slice(r));return n?(t.w=h[n[0].toLowerCase()],r+n[0].length):-1},b:function(t,e,r){var n=b.exec(e.slice(r));return n?(t.m=j[n[0].toLowerCase()],r+n[0].length):-1},B:function(t,e,r){var n=v.exec(e.slice(r));return n?(t.m=g[n[0].toLowerCase()],r+n[0].length):-1},c:function(t,r,n){return T(t,e,r,n)},d:it,e:it,f:lt,g:et,G:tt,H:at,I:at,j:ut,L:ft,m:ot,M:ct,p:function(t,e,r){var n=s.exec(e.slice(r));return n?(t.p=l[n[0].toLowerCase()],r+n[0].length):-1},q:nt,Q:ht,s:dt,S:st,u:J,U:K,V:Z,w:Q,W:X,x:function(t,e,n){return T(t,r,e,n)},X:function(t,e,r){return T(t,n,e,r)},y:et,Y:tt,Z:rt,"%":pt};function A(t,e){return function(r){var n,o,i,u=[],a=-1,c=0,s=t.length;for(r instanceof Date||(r=new Date(+r));++a<s;)37===t.charCodeAt(a)&&(u.push(t.slice(c,a)),null!=(o=B[n=t.charAt(++a)])?n=t.charAt(++a):o="e"===n?" ":"0",(i=e[n])&&(n=i(r,o)),u.push(n),c=a+1);return u.push(t.slice(c,a)),u.join("")}}function S(t,e){return function(r){var n,o,i=x(1900,void 0,1);if(T(i,t,r+="",0)!=r.length)return null;if("Q"in i)return new Date(i.Q);if("s"in i)return new Date(1e3*i.s+("L"in i?i.L:0));if(!e||"Z"in i||(i.Z=0),"p"in i&&(i.H=i.H%12+12*i.p),void 0===i.m&&(i.m="q"in i?i.q:0),"V"in i){if(i.V<1||i.V>53)return null;"w"in i||(i.w=1),"Z"in i?(n=(o=(n=P(x(i.y,0,1))).getUTCDay())>4||0===o?f.ceil(n):f(n),n=_.offset(n,7*(i.V-1)),i.y=n.getUTCFullYear(),i.m=n.getUTCMonth(),i.d=n.getUTCDate()+(i.w+6)%7):(n=(o=(n=F(x(i.y,0,1))).getDay())>4||0===o?m.ceil(n):m(n),n=R.offset(n,7*(i.V-1)),i.y=n.getFullYear(),i.m=n.getMonth(),i.d=n.getDate()+(i.w+6)%7);}else ("W"in i||"U"in i)&&("w"in i||(i.w="u"in i?i.u%7:"W"in i?1:0),o="Z"in i?P(x(i.y,0,1)).getUTCDay():F(x(i.y,0,1)).getDay(),i.m=0,i.d="W"in i?(i.w+6)%7+7*i.W-(o+5)%7:i.w+7*i.U-(o+6)%7);return "Z"in i?(i.H+=i.Z/100|0,i.M+=i.Z%100,P(i)):F(i)}}function T(t,e,r,n){for(var o,i,u=0,a=e.length,c=r.length;u<a;){if(n>=c)return -1;if(37===(o=e.charCodeAt(u++))){if(o=e.charAt(u++),!(i=E[o in B?e.charAt(u++):o])||(n=i(t,r,n))<0)return -1}else if(o!=r.charCodeAt(n++))return -1}return n}return w.x=A(r,w),w.X=A(n,w),w.c=A(e,w),O.x=A(r,O),O.X=A(n,O),O.c=A(e,O),{format:function(t){var e=A(t+="",w);return e.toString=function(){return t},e},parse:function(t){var e=S(t+="",!1);return e.toString=function(){return t},e},utcFormat:function(t){var e=A(t+="",O);return e.toString=function(){return t},e},utcParse:function(t){var e=S(t+="",!0);return e.toString=function(){return t},e}}}var L,M,I,U,N,B={"-":"",_:" ",0:"0"},Y=/^\s*\d+/,H=/^%/,q=/[\\^$*+?|[\]().{}]/g;function z(t,e,r){var n=t<0?"-":"",o=(n?-t:t)+"",i=o.length;return n+(i<r?new Array(r-i+1).join(e)+o:o)}function V(t){return t.replace(q,"\\$&")}function W(t){return new RegExp("^(?:"+t.map(V).join("|")+")","i")}function G(t){for(var e={},r=-1,n=t.length;++r<n;)e[t[r].toLowerCase()]=r;return e}function Q(t,e,r){var n=Y.exec(e.slice(r,r+1));return n?(t.w=+n[0],r+n[0].length):-1}function J(t,e,r){var n=Y.exec(e.slice(r,r+1));return n?(t.u=+n[0],r+n[0].length):-1}function K(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.U=+n[0],r+n[0].length):-1}function Z(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.V=+n[0],r+n[0].length):-1}function X(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.W=+n[0],r+n[0].length):-1}function tt(t,e,r){var n=Y.exec(e.slice(r,r+4));return n?(t.y=+n[0],r+n[0].length):-1}function et(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.y=+n[0]+(+n[0]>68?1900:2e3),r+n[0].length):-1}function rt(t,e,r){var n=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(r,r+6));return n?(t.Z=n[1]?0:-(n[2]+(n[3]||"00")),r+n[0].length):-1}function nt(t,e,r){var n=Y.exec(e.slice(r,r+1));return n?(t.q=3*n[0]-3,r+n[0].length):-1}function ot(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.m=n[0]-1,r+n[0].length):-1}function it(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.d=+n[0],r+n[0].length):-1}function ut(t,e,r){var n=Y.exec(e.slice(r,r+3));return n?(t.m=0,t.d=+n[0],r+n[0].length):-1}function at(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.H=+n[0],r+n[0].length):-1}function ct(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.M=+n[0],r+n[0].length):-1}function st(t,e,r){var n=Y.exec(e.slice(r,r+2));return n?(t.S=+n[0],r+n[0].length):-1}function ft(t,e,r){var n=Y.exec(e.slice(r,r+3));return n?(t.L=+n[0],r+n[0].length):-1}function lt(t,e,r){var n=Y.exec(e.slice(r,r+6));return n?(t.L=Math.floor(n[0]/1e3),r+n[0].length):-1}function pt(t,e,r){var n=H.exec(e.slice(r,r+1));return n?r+n[0].length:-1}function ht(t,e,r){var n=Y.exec(e.slice(r));return n?(t.Q=+n[0],r+n[0].length):-1}function dt(t,e,r){var n=Y.exec(e.slice(r));return n?(t.s=+n[0],r+n[0].length):-1}function yt(t,e){return z(t.getDate(),e,2)}function vt(t,e){return z(t.getHours(),e,2)}function _t(t,e){return z(t.getHours()%12||12,e,2)}function gt(t,e){return z(1+R.count(D(t),t),e,3)}function bt(t,e){return z(t.getMilliseconds(),e,3)}function mt(t,e){return bt(t,e)+"000"}function jt(t,e){return z(t.getMonth()+1,e,2)}function wt(t,e){return z(t.getMinutes(),e,2)}function Ot(t,e){return z(t.getSeconds(),e,2)}function Et(t){var e=t.getDay();return 0===e?7:e}function At(t,e){return z(b.count(D(t)-1,t),e,2)}function St(t){var e=t.getDay();return e>=4||0===e?O(t):O.ceil(t)}function Rt(t,e){return t=St(t),z(O.count(D(t),t)+(4===D(t).getDay()),e,2)}function Tt(t){return t.getDay()}function Dt(t,e){return z(m.count(D(t)-1,t),e,2)}function kt(t,e){return z(t.getFullYear()%100,e,2)}function Ct(t,e){return z((t=St(t)).getFullYear()%100,e,2)}function Ft(t,e){return z(t.getFullYear()%1e4,e,4)}function Pt(t,e){var r=t.getDay();return z((t=r>=4||0===r?O(t):O.ceil(t)).getFullYear()%1e4,e,4)}function xt(t){var e=t.getTimezoneOffset();return (e>0?"-":(e*=-1,"+"))+z(e/60|0,"0",2)+z(e%60,"0",2)}function $t(t,e){return z(t.getUTCDate(),e,2)}function Lt(t,e){return z(t.getUTCHours(),e,2)}function Mt(t,e){return z(t.getUTCHours()%12||12,e,2)}function It(t,e){return z(1+_.count(C(t),t),e,3)}function Ut(t,e){return z(t.getUTCMilliseconds(),e,3)}function Nt(t,e){return Ut(t,e)+"000"}function Bt(t,e){return z(t.getUTCMonth()+1,e,2)}function Yt(t,e){return z(t.getUTCMinutes(),e,2)}function Ht(t,e){return z(t.getUTCSeconds(),e,2)}function qt(t){var e=t.getUTCDay();return 0===e?7:e}function zt(t,e){return z(s.count(C(t)-1,t),e,2)}function Vt(t){var e=t.getUTCDay();return e>=4||0===e?h(t):h.ceil(t)}function Wt(t,e){return t=Vt(t),z(h.count(C(t),t)+(4===C(t).getUTCDay()),e,2)}function Gt(t){return t.getUTCDay()}function Qt(t,e){return z(f.count(C(t)-1,t),e,2)}function Jt(t,e){return z(t.getUTCFullYear()%100,e,2)}function Kt(t,e){return z((t=Vt(t)).getUTCFullYear()%100,e,2)}function Zt(t,e){return z(t.getUTCFullYear()%1e4,e,4)}function Xt(t,e){var r=t.getUTCDay();return z((t=r>=4||0===r?h(t):h.ceil(t)).getUTCFullYear()%1e4,e,4)}function te(){return "+0000"}function ee(){return "%"}function re(t){return +t}function ne(t){return Math.floor(+t/1e3)}function oe(t){return L=$(t),M=L.format,I=L.parse,U=L.utcFormat,N=L.utcParse,L}oe({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});var ie=Date.prototype.toISOString?function(t){return t.toISOString()}:U("%Y-%m-%dT%H:%M:%S.%LZ");var ue=+new Date("2000-01-01T00:00:00.000Z")?function(t){var e=new Date(t);return isNaN(e)?null:e}:N("%Y-%m-%dT%H:%M:%S.%LZ");r.d(e,"timeFormatDefaultLocale",function(){return oe}),r.d(e,"timeFormat",function(){return M}),r.d(e,"timeParse",function(){return I}),r.d(e,"utcFormat",function(){return U}),r.d(e,"utcParse",function(){return N}),r.d(e,"timeFormatLocale",function(){return $}),r.d(e,"isoFormat",function(){return ie}),r.d(e,"isoParse",function(){return ue});},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.githubPathAdapter=void 0,e.githubPathAdapter=function(t){const e=t=>(t.match(/\//g)||[]).length;return t.startsWith("https://raw.githubusercontent.com/")?(t.endsWith("/datapackage.json")&&(t=t.replace("/datapackage.json","")),t.endsWith("/")&&(t=t.replace(/.$/,"")),4===e(t)&&(t+="/master"),t):t.startsWith("https://github.com/")?(t.endsWith(".git")&&(t=t.replace(".git","")),t.endsWith("/datapackage.json")&&(t=t.replace("/datapackage.json","")),t.endsWith("/")&&(t=t.replace(/.$/,"")),(t=t.replace("https://github.com/","https://raw.githubusercontent.com/")).includes("/blob")&&(t=t.replace("/blob","")),4===e(t)&&(t+="/master"),t):t};},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const n=r(13);e.getLevelAvailability=((t,e)=>{const r=[n.Level.OFF,n.Level.FATAL,n.Level.ERROR,n.Level.WARNING,n.Level.DEBUG,n.Level.ALL];let o=n.Level.OFF;for(const e of r)if(o|=e,e===t)break;return 0!=(o&e)});class o{constructor(t){this.diagnosticDescriptor=t,this.parents=[],this.diagnosticDescriptor.level||(this.diagnosticDescriptor.level=n.Level.ERROR);}addOutputTo(t){this.parents.push(t);}getFatalListener(){return this.onFatal}setFatalListener(t){this.onFatal=t;}fatal(t,r,o){if(e.getLevelAvailability(this.diagnosticDescriptor.level,n.Level.FATAL)){const e=o instanceof Error?o.stack:o;this.onFatal&&this.onFatal(e),this.addRecord(this.prepareRecord({funName:t,message:r,attachment:e},n.Level.FATAL));}}error(t,r,o){if(e.getLevelAvailability(this.diagnosticDescriptor.level,n.Level.ERROR)){const e=o instanceof Error?o.stack:o;this.addRecord(this.prepareRecord({funName:t,message:r,attachment:e},n.Level.ERROR));}}warning(t,r,o){e.getLevelAvailability(this.diagnosticDescriptor.level,n.Level.WARNING)&&this.addRecord(this.prepareRecord({funName:t,message:r,attachment:o},n.Level.WARNING));}debug(t,r,o){e.getLevelAvailability(this.diagnosticDescriptor.level,n.Level.DEBUG)&&this.addRecord(this.prepareRecord({funName:t,message:r,attachment:o},n.Level.DEBUG));}prepareDiagnosticFor(t){return {fatal:this.prepareFatalFor(t),error:this.prepareErrorFor(t),warning:this.prepareWarningFor(t),debug:this.prepareDebugFor(t)}}addRecord(t){if(this.parents.length<=0)throw Error(`parents are missing for ${this.diagnosticDescriptor.module}@${this.diagnosticDescriptor.version} on ${this.diagnosticDescriptor.requestId}`);for(const e of this.parents)e.addRecord(t);}prepareFatalFor(t){return (e,r)=>{this.fatal(t,e,r);}}prepareErrorFor(t){return (e,r)=>{this.error(t,e,r);}}prepareWarningFor(t){return (e,r)=>{this.warning(t,e,r);}}prepareDebugFor(t){return (e,r)=>{this.debug(t,e,r);}}prepareRecord(t,e){const{funName:r,message:o,attachment:i}=t,u={time:(new Date).toISOString(),module:this.diagnosticDescriptor.module,version:this.diagnosticDescriptor.version,requestId:this.diagnosticDescriptor.requestId,funName:r,message:o,level:n.getLabelByLevel(e)};return i&&(u.attachment=i),u}}e.LiftingDiagnosticManager=o;class i extends o{constructor(){super(...arguments),this.content=[];}addRecord(t){this.content.push(t);}putDiagnosticContentInto(t){t._diagnostic=this.content;}extractDiagnosticContentFrom(t){const e=JSON.parse(t);if(!e._diagnostic)throw Error('"_diagnostic" field is NOT defined');this.content.push(...e._diagnostic);}}e.EndpointDiagnosticManager=i,e.createDiagnosticManagerOn=function(t,e){return {forRequest:r=>{const n={module:t,version:e,requestId:r,level:null};return {withSeverityLevel:t=>(n.level=t,new i(n))}},basedOn:r=>{const n={module:t,version:e,requestId:r.diagnosticDescriptor.requestId,level:r.diagnosticDescriptor.level},i=new o(n);return i.addOutputTo(r),r.getFatalListener()&&i.setFatalListener(r.getFatalListener()),i}}};},function(t,e,r){var n,o,i;
/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/o=[],void 0===(i="function"==typeof(n=function t(){var e="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==e?e:{},r=!e.document&&!!e.postMessage,n=r&&/blob:/i.test((e.location||{}).protocol),o={},i=0,u={parse:function(r,n){var a=(n=n||{}).dynamicTyping||!1;if(j(a)&&(n.dynamicTypingFunction=a,a={}),n.dynamicTyping=a,n.transform=!!j(n.transform)&&n.transform,n.worker&&u.WORKERS_SUPPORTED){var c=function(){if(!u.WORKERS_SUPPORTED)return !1;var r,n,a=(r=e.URL||e.webkitURL||null,n=t.toString(),u.BLOB_URL||(u.BLOB_URL=r.createObjectURL(new Blob(["(",n,")();"],{type:"text/javascript"})))),c=new e.Worker(a);return c.onmessage=v,c.id=i++,o[c.id]=c}();return c.userStep=n.step,c.userChunk=n.chunk,c.userComplete=n.complete,c.userError=n.error,n.step=j(n.step),n.chunk=j(n.chunk),n.complete=j(n.complete),n.error=j(n.error),delete n.worker,void c.postMessage({input:r,config:n,workerId:c.id})}var h=null;return u.NODE_STREAM_INPUT,"string"==typeof r?h=n.download?new s(n):new l(n):!0===r.readable&&j(r.read)&&j(r.on)?h=new p(n):(e.File&&r instanceof File||r instanceof Object)&&(h=new f(n)),h.stream(r)},unparse:function(t,e){var r=!1,n=!0,o=",",i="\r\n",a='"',c=a+a,s=!1,f=null,l=!1;!function(){if("object"==typeof e){if("string"!=typeof e.delimiter||u.BAD_DELIMITERS.filter(function(t){return -1!==e.delimiter.indexOf(t)}).length||(o=e.delimiter),("boolean"==typeof e.quotes||"function"==typeof e.quotes||Array.isArray(e.quotes))&&(r=e.quotes),"boolean"!=typeof e.skipEmptyLines&&"string"!=typeof e.skipEmptyLines||(s=e.skipEmptyLines),"string"==typeof e.newline&&(i=e.newline),"string"==typeof e.quoteChar&&(a=e.quoteChar),"boolean"==typeof e.header&&(n=e.header),Array.isArray(e.columns)){if(0===e.columns.length)throw new Error("Option columns is empty");f=e.columns;}void 0!==e.escapeChar&&(c=e.escapeChar+a),("boolean"==typeof e.escapeFormulae||e.escapeFormulae instanceof RegExp)&&(l=e.escapeFormulae instanceof RegExp?e.escapeFormulae:/^[=+\-@\t\r].*$/);}}();var p=new RegExp(d(a),"g");if("string"==typeof t&&(t=JSON.parse(t)),Array.isArray(t)){if(!t.length||Array.isArray(t[0]))return h(null,t,s);if("object"==typeof t[0])return h(f||Object.keys(t[0]),t,s)}else if("object"==typeof t)return "string"==typeof t.data&&(t.data=JSON.parse(t.data)),Array.isArray(t.data)&&(t.fields||(t.fields=t.meta&&t.meta.fields||f),t.fields||(t.fields=Array.isArray(t.data[0])?t.fields:"object"==typeof t.data[0]?Object.keys(t.data[0]):[]),Array.isArray(t.data[0])||"object"==typeof t.data[0]||(t.data=[t.data])),h(t.fields||[],t.data||[],s);throw new Error("Unable to serialize unrecognized input");function h(t,e,r){var u="";"string"==typeof t&&(t=JSON.parse(t)),"string"==typeof e&&(e=JSON.parse(e));var a=Array.isArray(t)&&0<t.length,c=!Array.isArray(e[0]);if(a&&n){for(var s=0;s<t.length;s++)0<s&&(u+=o),u+=y(t[s],s);0<e.length&&(u+=i);}for(var f=0;f<e.length;f++){var l=a?t.length:e[f].length,p=!1,h=a?0===Object.keys(e[f]).length:0===e[f].length;if(r&&!a&&(p="greedy"===r?""===e[f].join("").trim():1===e[f].length&&0===e[f][0].length),"greedy"===r&&a){for(var d=[],v=0;v<l;v++){var _=c?t[v]:v;d.push(e[f][_]);}p=""===d.join("").trim();}if(!p){for(var g=0;g<l;g++){0<g&&!h&&(u+=o);var b=a&&c?t[g]:g;u+=y(e[f][b],g);}f<e.length-1&&(!r||0<l&&!h)&&(u+=i);}}return u}function y(t,e){if(null==t)return "";if(t.constructor===Date)return JSON.stringify(t).slice(1,25);var n=!1;l&&"string"==typeof t&&l.test(t)&&(t="'"+t,n=!0);var i=t.toString().replace(p,c);return (n=n||!0===r||"function"==typeof r&&r(t,e)||Array.isArray(r)&&r[e]||function(t,e){for(var r=0;r<e.length;r++)if(-1<t.indexOf(e[r]))return !0;return !1}(i,u.BAD_DELIMITERS)||-1<i.indexOf(o)||" "===i.charAt(0)||" "===i.charAt(i.length-1))?a+i+a:i}}};if(u.RECORD_SEP=String.fromCharCode(30),u.UNIT_SEP=String.fromCharCode(31),u.BYTE_ORDER_MARK="\ufeff",u.BAD_DELIMITERS=["\r","\n",'"',u.BYTE_ORDER_MARK],u.WORKERS_SUPPORTED=!r&&!!e.Worker,u.NODE_STREAM_INPUT=1,u.LocalChunkSize=10485760,u.RemoteChunkSize=5242880,u.DefaultDelimiter=",",u.Parser=y,u.ParserHandle=h,u.NetworkStreamer=s,u.FileStreamer=f,u.StringStreamer=l,u.ReadableStreamStreamer=p,e.jQuery){var a=e.jQuery;a.fn.parse=function(t){var r=t.config||{},n=[];return this.each(function(t){if("INPUT"!==a(this).prop("tagName").toUpperCase()||"file"!==a(this).attr("type").toLowerCase()||!e.FileReader||!this.files||0===this.files.length)return !0;for(var o=0;o<this.files.length;o++)n.push({file:this.files[o],inputElem:this,instanceConfig:a.extend({},r)});}),o(),this;function o(){if(0!==n.length){var e,r,o,c,s=n[0];if(j(t.before)){var f=t.before(s.file,s.inputElem);if("object"==typeof f){if("abort"===f.action)return e="AbortError",r=s.file,o=s.inputElem,c=f.reason,void(j(t.error)&&t.error({name:e},r,o,c));if("skip"===f.action)return void i();"object"==typeof f.config&&(s.instanceConfig=a.extend(s.instanceConfig,f.config));}else if("skip"===f)return void i()}var l=s.instanceConfig.complete;s.instanceConfig.complete=function(t){j(l)&&l(t,s.file,s.inputElem),i();},u.parse(s.file,s.instanceConfig);}else j(t.complete)&&t.complete();}function i(){n.splice(0,1),o();}};}function c(t){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(t){var e=b(t);e.chunkSize=parseInt(e.chunkSize),t.step||t.chunk||(e.chunkSize=null),this._handle=new h(e),(this._handle.streamer=this)._config=e;}.call(this,t),this.parseChunk=function(t,r){if(this.isFirstChunk&&j(this._config.beforeFirstChunk)){var o=this._config.beforeFirstChunk(t);void 0!==o&&(t=o);}this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+t;this._partialLine="";var a=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var c=a.meta.cursor;this._finished||(this._partialLine=i.substring(c-this._baseIndex),this._baseIndex=c),a&&a.data&&(this._rowCount+=a.data.length);var s=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(n)e.postMessage({results:a,workerId:u.WORKER_ID,finished:s});else if(j(this._config.chunk)&&!r){if(this._config.chunk(a,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);a=void 0,this._completeResults=void 0;}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(a.data),this._completeResults.errors=this._completeResults.errors.concat(a.errors),this._completeResults.meta=a.meta),this._completed||!s||!j(this._config.complete)||a&&a.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),s||a&&a.meta.paused||this._nextChunk(),a}this._halted=!0;},this._sendError=function(t){j(this._config.error)?this._config.error(t):n&&this._config.error&&e.postMessage({workerId:u.WORKER_ID,error:t,finished:!1});};}function s(t){var e;(t=t||{}).chunkSize||(t.chunkSize=u.RemoteChunkSize),c.call(this,t),this._nextChunk=r?function(){this._readChunk(),this._chunkLoaded();}:function(){this._readChunk();},this.stream=function(t){this._input=t,this._nextChunk();},this._readChunk=function(){if(this._finished)this._chunkLoaded();else {if(e=new XMLHttpRequest,this._config.withCredentials&&(e.withCredentials=this._config.withCredentials),r||(e.onload=m(this._chunkLoaded,this),e.onerror=m(this._chunkError,this)),e.open(this._config.downloadRequestBody?"POST":"GET",this._input,!r),this._config.downloadRequestHeaders){var t=this._config.downloadRequestHeaders;for(var n in t)e.setRequestHeader(n,t[n]);}if(this._config.chunkSize){var o=this._start+this._config.chunkSize-1;e.setRequestHeader("Range","bytes="+this._start+"-"+o);}try{e.send(this._config.downloadRequestBody);}catch(t){this._chunkError(t.message);}r&&0===e.status&&this._chunkError();}},this._chunkLoaded=function(){var t;4===e.readyState&&(e.status<200||400<=e.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:e.responseText.length,this._finished=!this._config.chunkSize||this._start>=(null===(t=e.getResponseHeader("Content-Range"))?-1:parseInt(t.substring(t.lastIndexOf("/")+1))),this.parseChunk(e.responseText)));},this._chunkError=function(t){var r=e.statusText||t;this._sendError(new Error(r));};}function f(t){var e,r;(t=t||{}).chunkSize||(t.chunkSize=u.LocalChunkSize),c.call(this,t);var n="undefined"!=typeof FileReader;this.stream=function(t){this._input=t,r=t.slice||t.webkitSlice||t.mozSlice,n?((e=new FileReader).onload=m(this._chunkLoaded,this),e.onerror=m(this._chunkError,this)):e=new FileReaderSync,this._nextChunk();},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk();},this._readChunk=function(){var t=this._input;if(this._config.chunkSize){var o=Math.min(this._start+this._config.chunkSize,this._input.size);t=r.call(t,this._start,o);}var i=e.readAsText(t,this._config.encoding);n||this._chunkLoaded({target:{result:i}});},this._chunkLoaded=function(t){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(t.target.result);},this._chunkError=function(){this._sendError(e.error);};}function l(t){var e;c.call(this,t=t||{}),this.stream=function(t){return e=t,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var t,r=this._config.chunkSize;return r?(t=e.substring(0,r),e=e.substring(r)):(t=e,e=""),this._finished=!e,this.parseChunk(t)}};}function p(t){c.call(this,t=t||{});var e=[],r=!0,n=!1;this.pause=function(){c.prototype.pause.apply(this,arguments),this._input.pause();},this.resume=function(){c.prototype.resume.apply(this,arguments),this._input.resume();},this.stream=function(t){this._input=t,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError);},this._checkIsFinished=function(){n&&1===e.length&&(this._finished=!0);},this._nextChunk=function(){this._checkIsFinished(),e.length?this.parseChunk(e.shift()):r=!0;},this._streamData=m(function(t){try{e.push("string"==typeof t?t:t.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(e.shift()));}catch(t){this._streamError(t);}},this),this._streamError=m(function(t){this._streamCleanUp(),this._sendError(t);},this),this._streamEnd=m(function(){this._streamCleanUp(),n=!0,this._streamData("");},this),this._streamCleanUp=m(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError);},this);}function h(t){var e,r,n,o=Math.pow(2,53),i=-o,a=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,c=/^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/,s=this,f=0,l=0,p=!1,h=!1,v=[],_={data:[],errors:[],meta:{}};if(j(t.step)){var g=t.step;t.step=function(e){if(_=e,O())w();else {if(w(),0===_.data.length)return;f+=e.data.length,t.preview&&f>t.preview?r.abort():(_.data=_.data[0],g(_,s));}};}function m(e){return "greedy"===t.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function w(){return _&&n&&(A("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+u.DefaultDelimiter+"'"),n=!1),t.skipEmptyLines&&(_.data=_.data.filter(function(t){return !m(t)})),O()&&function(){if(_)if(Array.isArray(_.data[0])){for(var e=0;O()&&e<_.data.length;e++)_.data[e].forEach(r);_.data.splice(0,1);}else _.data.forEach(r);function r(e,r){j(t.transformHeader)&&(e=t.transformHeader(e,r)),v.push(e);}}(),function(){if(!_||!t.header&&!t.dynamicTyping&&!t.transform)return _;function e(e,r){var n,o=t.header?{}:[];for(n=0;n<e.length;n++){var i=n,u=e[n];t.header&&(i=n>=v.length?"__parsed_extra":v[n]),t.transform&&(u=t.transform(u,i)),u=E(i,u),"__parsed_extra"===i?(o[i]=o[i]||[],o[i].push(u)):o[i]=u;}return t.header&&(n>v.length?A("FieldMismatch","TooManyFields","Too many fields: expected "+v.length+" fields but parsed "+n,l+r):n<v.length&&A("FieldMismatch","TooFewFields","Too few fields: expected "+v.length+" fields but parsed "+n,l+r)),o}var r=1;return !_.data.length||Array.isArray(_.data[0])?(_.data=_.data.map(e),r=_.data.length):_.data=e(_.data,0),t.header&&_.meta&&(_.meta.fields=v),l+=r,_}()}function O(){return t.header&&0===v.length}function E(e,r){return n=e,t.dynamicTypingFunction&&void 0===t.dynamicTyping[n]&&(t.dynamicTyping[n]=t.dynamicTypingFunction(n)),!0===(t.dynamicTyping[n]||t.dynamicTyping)?"true"===r||"TRUE"===r||"false"!==r&&"FALSE"!==r&&(function(t){if(a.test(t)){var e=parseFloat(t);if(i<e&&e<o)return !0}return !1}(r)?parseFloat(r):c.test(r)?new Date(r):""===r?null:r):r;var n;}function A(t,e,r,n){var o={type:t,code:e,message:r};void 0!==n&&(o.row=n),_.errors.push(o);}this.parse=function(o,i,a){var c=t.quoteChar||'"';if(t.newline||(t.newline=function(t,e){t=t.substring(0,1048576);var r=new RegExp(d(e)+"([^]*?)"+d(e),"gm"),n=(t=t.replace(r,"")).split("\r"),o=t.split("\n"),i=1<o.length&&o[0].length<n[0].length;if(1===n.length||i)return "\n";for(var u=0,a=0;a<n.length;a++)"\n"===n[a][0]&&u++;return u>=n.length/2?"\r\n":"\r"}(o,c)),n=!1,t.delimiter)j(t.delimiter)&&(t.delimiter=t.delimiter(o),_.meta.delimiter=t.delimiter);else {var s=function(e,r,n,o,i){var a,c,s,f;i=i||[",","\t","|",";",u.RECORD_SEP,u.UNIT_SEP];for(var l=0;l<i.length;l++){var p=i[l],h=0,d=0,v=0;s=void 0;for(var _=new y({comments:o,delimiter:p,newline:r,preview:10}).parse(e),g=0;g<_.data.length;g++)if(n&&m(_.data[g]))v++;else {var b=_.data[g].length;d+=b,void 0!==s?0<b&&(h+=Math.abs(b-s),s=b):s=b;}0<_.data.length&&(d/=_.data.length-v),(void 0===c||h<=c)&&(void 0===f||f<d)&&1.99<d&&(c=h,a=p,f=d);}return {successful:!!(t.delimiter=a),bestDelimiter:a}}(o,t.newline,t.skipEmptyLines,t.comments,t.delimitersToGuess);s.successful?t.delimiter=s.bestDelimiter:(n=!0,t.delimiter=u.DefaultDelimiter),_.meta.delimiter=t.delimiter;}var f=b(t);return t.preview&&t.header&&f.preview++,e=o,r=new y(f),_=r.parse(e,i,a),w(),p?{meta:{paused:!0}}:_||{meta:{paused:!1}}},this.paused=function(){return p},this.pause=function(){p=!0,r.abort(),e=j(t.chunk)?"":e.substring(r.getCharIndex());},this.resume=function(){s.streamer._halted?(p=!1,s.streamer.parseChunk(e,!0)):setTimeout(s.resume,3);},this.aborted=function(){return h},this.abort=function(){h=!0,r.abort(),_.meta.aborted=!0,j(t.complete)&&t.complete(_),e="";};}function d(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function y(t){var e,r=(t=t||{}).delimiter,n=t.newline,o=t.comments,i=t.step,a=t.preview,c=t.fastMode,s=e=void 0===t.quoteChar||null===t.quoteChar?'"':t.quoteChar;if(void 0!==t.escapeChar&&(s=t.escapeChar),("string"!=typeof r||-1<u.BAD_DELIMITERS.indexOf(r))&&(r=","),o===r)throw new Error("Comment character same as delimiter");!0===o?o="#":("string"!=typeof o||-1<u.BAD_DELIMITERS.indexOf(o))&&(o=!1),"\n"!==n&&"\r"!==n&&"\r\n"!==n&&(n="\n");var f=0,l=!1;this.parse=function(t,u,p){if("string"!=typeof t)throw new Error("Input must be a string");var h=t.length,y=r.length,v=n.length,_=o.length,g=j(i),b=[],m=[],w=[],O=f=0;if(!t)return L();if(c||!1!==c&&-1===t.indexOf(e)){for(var E=t.split(n),A=0;A<E.length;A++){if(w=E[A],f+=w.length,A!==E.length-1)f+=n.length;else if(p)return L();if(!o||w.substring(0,_)!==o){if(g){if(b=[],F(w.split(r)),M(),l)return L()}else F(w.split(r));if(a&&a<=A)return b=b.slice(0,a),L(!0)}}return L()}for(var S=t.indexOf(r,f),R=t.indexOf(n,f),T=new RegExp(d(s)+d(e),"g"),D=t.indexOf(e,f);;)if(t[f]!==e)if(o&&0===w.length&&t.substring(f,f+_)===o){if(-1===R)return L();f=R+v,R=t.indexOf(n,f),S=t.indexOf(r,f);}else if(-1!==S&&(S<R||-1===R))w.push(t.substring(f,S)),f=S+y,S=t.indexOf(r,f);else {if(-1===R)break;if(w.push(t.substring(f,R)),$(R+v),g&&(M(),l))return L();if(a&&b.length>=a)return L(!0)}else for(D=f,f++;;){if(-1===(D=t.indexOf(e,D+1)))return p||m.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:b.length,index:f}),x();if(D===h-1)return x(t.substring(f,D).replace(T,e));if(e!==s||t[D+1]!==s){if(e===s||0===D||t[D-1]!==s){-1!==S&&S<D+1&&(S=t.indexOf(r,D+1)),-1!==R&&R<D+1&&(R=t.indexOf(n,D+1));var k=P(-1===R?S:Math.min(S,R));if(t.substr(D+1+k,y)===r){w.push(t.substring(f,D).replace(T,e)),t[f=D+1+k+y]!==e&&(D=t.indexOf(e,f)),S=t.indexOf(r,f),R=t.indexOf(n,f);break}var C=P(R);if(t.substring(D+1+C,D+1+C+v)===n){if(w.push(t.substring(f,D).replace(T,e)),$(D+1+C+v),S=t.indexOf(r,f),D=t.indexOf(e,f),g&&(M(),l))return L();if(a&&b.length>=a)return L(!0);break}m.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:b.length,index:f}),D++;}}else D++;}return x();function F(t){b.push(t),O=f;}function P(e){var r=0;if(-1!==e){var n=t.substring(D+1,e);n&&""===n.trim()&&(r=n.length);}return r}function x(e){return p||(void 0===e&&(e=t.substring(f)),w.push(e),f=h,F(w),g&&M()),L()}function $(e){f=e,F(w),w=[],R=t.indexOf(n,f);}function L(t){return {data:b,errors:m,meta:{delimiter:r,linebreak:n,aborted:l,truncated:!!t,cursor:O+(u||0)}}}function M(){i(L()),b=[],m=[];}},this.abort=function(){l=!0;},this.getCharIndex=function(){return f};}function v(t){var e=t.data,r=o[e.workerId],n=!1;if(e.error)r.userError(e.error,e.file);else if(e.results&&e.results.data){var i={abort:function(){n=!0,_(e.workerId,{data:[],errors:[],meta:{aborted:!0}});},pause:g,resume:g};if(j(r.userStep)){for(var u=0;u<e.results.data.length&&(r.userStep({data:e.results.data[u],errors:e.results.errors,meta:e.results.meta},i),!n);u++);delete e.results;}else j(r.userChunk)&&(r.userChunk(e.results,i,e.file),delete e.results);}e.finished&&!n&&_(e.workerId,e.results);}function _(t,e){var r=o[t];j(r.userComplete)&&r.userComplete(e),r.terminate(),delete o[t];}function g(){throw new Error("Not implemented.")}function b(t){if("object"!=typeof t||null===t)return t;var e=Array.isArray(t)?[]:{};for(var r in t)e[r]=b(t[r]);return e}function m(t,e){return function(){t.apply(e,arguments);}}function j(t){return "function"==typeof t}return n&&(e.onmessage=function(t){var r=t.data;if(void 0===u.WORKER_ID&&r&&(u.WORKER_ID=r.workerId),"string"==typeof r.input)e.postMessage({workerId:u.WORKER_ID,results:u.parse(r.input,r.config),finished:!0});else if(e.File&&r.input instanceof File||r.input instanceof Object){var n=u.parse(r.input,r.config);n&&e.postMessage({workerId:u.WORKER_ID,results:n,finished:!0});}}),(s.prototype=Object.create(c.prototype)).constructor=s,(f.prototype=Object.create(c.prototype)).constructor=f,(l.prototype=Object.create(l.prototype)).constructor=l,(p.prototype=Object.create(c.prototype)).constructor=p,u})?n.apply(e,o):n)||(t.exports=i);},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const n=r(11),o=r(16),i=r(12),u=r(3),a=r(15);function c(t){return u.isDatapointsQuery(t)&&1===n(t.where).length&&o(t.where)&&t.where.$and?a.QueryFeature.WhereClauseBasedOnConjunction:null}e.featureDetectors=[c,(t,e)=>{if(!c(t))return null;for(const r of t.where.$and){const o=n(r);if(1===o.length){const u=i(o),c=r[u];if(t.join&&t.join[c]){const r=t.join[c],o=r.where,s=i(n(o));if(r.key===u&&r.key===s&&1===n(o).length){const t=o[s],i=e.get(r.key),u=!!t.$in||!!t.$nin,c="entity_set"===i.concept_type||"entity_domain"===i.concept_type;if(1===n(t).length&&u&&c)return a.QueryFeature.ConjunctionPartFromWhereClauseCorrespondsToJoin}}}}return null}];},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const n=r(7),o=r(1),i=r(4),u=r(3);function a(t,e){const{dataset:r,branch:n,commit:o}=e;return `${t}${r}/${n}/${o}`}function c(t){return t?"default ":""}function s(t,e){return `${c(e)}dataset '${t}'`}e.getRepositoryPath=a,e.getFilePath=function(t,e="datapackage.json"){return `${t}/${e}`},e.extendQueryWithRepository=function(t,e={repositoryDescriptors:{}}){const r=i(e,"repositoryDescriptors",{}),f=n(t.dataset);if(!f){const[e,r]=t.dataset.split("#");!t.branch&&r&&(t.branch=r,t.dataset=e);}const l=n(t.branch)||t.branch===e.defaultRepositoryBranch,p=n(t.commit)||t.commit===e.defaultRepositoryCommit,{dataset:h=i(e,"defaultRepository",u.DEFAULT_REPOSITORY_NAME),branch:d=i(e,"defaultRepositoryBranch",u.DEFAULT_REPOSITORY_BRANCH)}=t;if(n(r[h]))throw new Error(`No ${s(h,f)} was found`);if(n(r[h][d]))throw new Error(`No ${function(t,e){return `${c(e)}branch '${t}'`}(d,l)} in ${s(h,f)} was found`);"HEAD"===t.commit&&(t.commit=i(r,`${h}.${d}.0`)||i(e,"defaultRepositoryCommit",u.DEFAULT_REPOSITORY_HASH));const{commit:y=i(r,`${h}.${d}.0`)||i(e,"defaultRepositoryCommit",u.DEFAULT_REPOSITORY_HASH)}=t;if(!o(r[h][d],y))throw new Error(`No ${function(t,e){return `${c(e)}commit '${t}'`}(y,p)} in ${c(l)}branch '${d}' in ${s(h,f)} was found`);const v=a("",{dataset:h,branch:d,commit:y});return Object.assign(t,{repositoryPath:v}),{dataset:h,branch:d,commit:y,isDefaultBranch:l,isDefaultCommit:p}};},function(t,e,r){(function(e){var r=200,n="__lodash_hash_undefined__",o="[object Function]",i="[object GeneratorFunction]",u=/^\[object .+?Constructor\]$/,a="object"==typeof e&&e&&e.Object===Object&&e,c="object"==typeof self&&self&&self.Object===Object&&self,s=a||c||Function("return this")();function f(t,e){return !!(t?t.length:0)&&function(t,e,r){if(e!=e)return function(t,e,r,n){var o=t.length,i=r+(n?1:-1);for(;n?i--:++i<o;)if(e(t[i],i,t))return i;return -1}(t,p,r);var n=r-1,o=t.length;for(;++n<o;)if(t[n]===e)return n;return -1}(t,e,0)>-1}function l(t,e,r){for(var n=-1,o=t?t.length:0;++n<o;)if(r(e,t[n]))return !0;return !1}function p(t){return t!=t}function h(t,e){return t.has(e)}function d(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t;}),r}var y,v=Array.prototype,_=Function.prototype,g=Object.prototype,b=s["__core-js_shared__"],m=(y=/[^.]+$/.exec(b&&b.keys&&b.keys.IE_PROTO||""))?"Symbol(src)_1."+y:"",j=_.toString,w=g.hasOwnProperty,O=g.toString,E=RegExp("^"+j.call(w).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),A=v.splice,S=M(s,"Map"),R=M(s,"Set"),T=M(Object,"create");function D(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function k(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function C(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function F(t){var e=-1,r=t?t.length:0;for(this.__data__=new C;++e<r;)this.add(t[e]);}function P(t,e){for(var r,n,o=t.length;o--;)if((r=t[o][0])===(n=e)||r!=r&&n!=n)return o;return -1}function x(t){return !(!I(t)||m&&m in t)&&(function(t){var e=I(t)?O.call(t):"";return e==o||e==i}(t)||function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}(t)?E:u).test(function(t){if(null!=t){try{return j.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}(t))}D.prototype.clear=function(){this.__data__=T?T(null):{};},D.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},D.prototype.get=function(t){var e=this.__data__;if(T){var r=e[t];return r===n?void 0:r}return w.call(e,t)?e[t]:void 0},D.prototype.has=function(t){var e=this.__data__;return T?void 0!==e[t]:w.call(e,t)},D.prototype.set=function(t,e){return this.__data__[t]=T&&void 0===e?n:e,this},k.prototype.clear=function(){this.__data__=[];},k.prototype.delete=function(t){var e=this.__data__,r=P(e,t);return !(r<0||(r==e.length-1?e.pop():A.call(e,r,1),0))},k.prototype.get=function(t){var e=this.__data__,r=P(e,t);return r<0?void 0:e[r][1]},k.prototype.has=function(t){return P(this.__data__,t)>-1},k.prototype.set=function(t,e){var r=this.__data__,n=P(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},C.prototype.clear=function(){this.__data__={hash:new D,map:new(S||k),string:new D};},C.prototype.delete=function(t){return L(this,t).delete(t)},C.prototype.get=function(t){return L(this,t).get(t)},C.prototype.has=function(t){return L(this,t).has(t)},C.prototype.set=function(t,e){return L(this,t).set(t,e),this},F.prototype.add=F.prototype.push=function(t){return this.__data__.set(t,n),this},F.prototype.has=function(t){return this.__data__.has(t)};var $=R&&1/d(new R([,-0]))[1]==1/0?function(t){return new R(t)}:function(){};function L(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function M(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return x(r)?r:void 0}function I(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}t.exports=function(t){return t&&t.length?function(t,e,n){var o=-1,i=f,u=t.length,a=!0,c=[],s=c;if(n)a=!1,i=l;else if(u>=r){var p=e?null:$(t);if(p)return d(p);a=!1,i=h,s=new F;}else s=e?[]:c;t:for(;++o<u;){var y=t[o],v=e?e(y):y;if(y=n||0!==y?y:0,a&&v==v){for(var _=s.length;_--;)if(s[_]===v)continue t;e&&s.push(v),c.push(y);}else i(s,v,n)||(s!==c&&s.push(v),c.push(y));}return c}(t):[]};}).call(this,r(0));},function(t,e){var r="[object String]",n=Object.prototype.toString,o=Array.isArray;t.exports=function(t){return "string"==typeof t||!o(t)&&function(t){return !!t&&"object"==typeof t}(t)&&n.call(t)==r};},function(t,e,r){(function(t,r){var n=200,o="Expected a function",i="__lodash_hash_undefined__",u=1,a=2,c=1/0,s=9007199254740991,f="[object Arguments]",l="[object Array]",p="[object Boolean]",h="[object Date]",d="[object Error]",y="[object Function]",v="[object GeneratorFunction]",_="[object Map]",g="[object Number]",b="[object Object]",m="[object RegExp]",j="[object Set]",w="[object String]",O="[object Symbol]",E="[object ArrayBuffer]",A="[object DataView]",S=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,R=/^\w*$/,T=/^\./,D=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,k=/\\(\\)?/g,C=/^\[object .+?Constructor\]$/,F=/^(?:0|[1-9]\d*)$/,P={};P["[object Float32Array]"]=P["[object Float64Array]"]=P["[object Int8Array]"]=P["[object Int16Array]"]=P["[object Int32Array]"]=P["[object Uint8Array]"]=P["[object Uint8ClampedArray]"]=P["[object Uint16Array]"]=P["[object Uint32Array]"]=!0,P[f]=P[l]=P[E]=P[p]=P[A]=P[h]=P[d]=P[y]=P[_]=P[g]=P[b]=P[m]=P[j]=P[w]=P["[object WeakMap]"]=!1;var x="object"==typeof t&&t&&t.Object===Object&&t,$="object"==typeof self&&self&&self.Object===Object&&self,L=x||$||Function("return this")(),M="object"==typeof e&&e&&!e.nodeType&&e,I=M&&"object"==typeof r&&r&&!r.nodeType&&r,U=I&&I.exports===M&&x.process,N=function(){try{return U&&U.binding("util")}catch(t){}}(),B=N&&N.isTypedArray;function Y(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(!e(t[r],r,t))return !1;return !0}function H(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return !0;return !1}function q(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}function z(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t];}),r}function V(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t;}),r}var W,G,Q,J=Array.prototype,K=Function.prototype,Z=Object.prototype,X=L["__core-js_shared__"],tt=(W=/[^.]+$/.exec(X&&X.keys&&X.keys.IE_PROTO||""))?"Symbol(src)_1."+W:"",et=K.toString,rt=Z.hasOwnProperty,nt=Z.toString,ot=RegExp("^"+et.call(rt).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),it=L.Symbol,ut=L.Uint8Array,at=Z.propertyIsEnumerable,ct=J.splice,st=(G=Object.keys,Q=Object,function(t){return G(Q(t))}),ft=zt(L,"DataView"),lt=zt(L,"Map"),pt=zt(L,"Promise"),ht=zt(L,"Set"),dt=zt(L,"WeakMap"),yt=zt(Object,"create"),vt=Xt(ft),_t=Xt(lt),gt=Xt(pt),bt=Xt(ht),mt=Xt(dt),jt=it?it.prototype:void 0,wt=jt?jt.valueOf:void 0,Ot=jt?jt.toString:void 0;function Et(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function At(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function St(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Rt(t){var e=-1,r=t?t.length:0;for(this.__data__=new St;++e<r;)this.add(t[e]);}function Tt(t){this.__data__=new At(t);}function Dt(t,e){var r=ne(t)||re(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],n=r.length,o=!!n;for(var i in t)!e&&!rt.call(t,i)||o&&("length"==i||Wt(i,n))||r.push(i);return r}function kt(t,e){for(var r=t.length;r--;)if(ee(t[r][0],e))return r;return -1}Et.prototype.clear=function(){this.__data__=yt?yt(null):{};},Et.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},Et.prototype.get=function(t){var e=this.__data__;if(yt){var r=e[t];return r===i?void 0:r}return rt.call(e,t)?e[t]:void 0},Et.prototype.has=function(t){var e=this.__data__;return yt?void 0!==e[t]:rt.call(e,t)},Et.prototype.set=function(t,e){return this.__data__[t]=yt&&void 0===e?i:e,this},At.prototype.clear=function(){this.__data__=[];},At.prototype.delete=function(t){var e=this.__data__,r=kt(e,t);return !(r<0||(r==e.length-1?e.pop():ct.call(e,r,1),0))},At.prototype.get=function(t){var e=this.__data__,r=kt(e,t);return r<0?void 0:e[r][1]},At.prototype.has=function(t){return kt(this.__data__,t)>-1},At.prototype.set=function(t,e){var r=this.__data__,n=kt(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},St.prototype.clear=function(){this.__data__={hash:new Et,map:new(lt||At),string:new Et};},St.prototype.delete=function(t){return qt(this,t).delete(t)},St.prototype.get=function(t){return qt(this,t).get(t)},St.prototype.has=function(t){return qt(this,t).has(t)},St.prototype.set=function(t,e){return qt(this,t).set(t,e),this},Rt.prototype.add=Rt.prototype.push=function(t){return this.__data__.set(t,i),this},Rt.prototype.has=function(t){return this.__data__.has(t)},Tt.prototype.clear=function(){this.__data__=new At;},Tt.prototype.delete=function(t){return this.__data__.delete(t)},Tt.prototype.get=function(t){return this.__data__.get(t)},Tt.prototype.has=function(t){return this.__data__.has(t)},Tt.prototype.set=function(t,e){var r=this.__data__;if(r instanceof At){var o=r.__data__;if(!lt||o.length<n-1)return o.push([t,e]),this;r=this.__data__=new St(o);}return r.set(t,e),this};var Ct,Pt=(Ct=function(t,e){return t&&$t(t,e,le)},function(t,e){if(null==t)return t;if(!oe(t))return Ct(t,e);for(var r=t.length,n=-1,o=Object(t);(++n<r)&&!1!==e(o[n],n,o););return t});function xt(t,e){var r=!0;return Pt(t,function(t,n,o){return r=!!e(t,n,o)}),r}var $t=function(t){return function(e,r,n){for(var o=-1,i=Object(e),u=n(e),a=u.length;a--;){var c=u[t?a:++o];if(!1===r(i[c],c,i))break}return e}}();function Lt(t,e){for(var r=0,n=(e=Gt(e,t)?[e]:Yt(e)).length;null!=t&&r<n;)t=t[Zt(e[r++])];return r&&r==n?t:void 0}function Mt(t,e){return null!=t&&e in Object(t)}function It(t,e,r,n,o){return t===e||(null==t||null==e||!ae(t)&&!ce(e)?t!=t&&e!=e:function(t,e,r,n,o,i){var c=ne(t),s=ne(e),y=l,v=l;c||(y=(y=Vt(t))==f?b:y);s||(v=(v=Vt(e))==f?b:v);var S=y==b&&!q(t),R=v==b&&!q(e),T=y==v;if(T&&!S)return i||(i=new Tt),c||fe(t)?Ht(t,e,r,n,o,i):function(t,e,r,n,o,i,c){switch(r){case A:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return !1;t=t.buffer,e=e.buffer;case E:return !(t.byteLength!=e.byteLength||!n(new ut(t),new ut(e)));case p:case h:case g:return ee(+t,+e);case d:return t.name==e.name&&t.message==e.message;case m:case w:return t==e+"";case _:var s=z;case j:var f=i&a;if(s||(s=V),t.size!=e.size&&!f)return !1;var l=c.get(t);if(l)return l==e;i|=u,c.set(t,e);var y=Ht(s(t),s(e),n,o,i,c);return c.delete(t),y;case O:if(wt)return wt.call(t)==wt.call(e)}return !1}(t,e,y,r,n,o,i);if(!(o&a)){var D=S&&rt.call(t,"__wrapped__"),k=R&&rt.call(e,"__wrapped__");if(D||k){var C=D?t.value():t,F=k?e.value():e;return i||(i=new Tt),r(C,F,n,o,i)}}if(!T)return !1;return i||(i=new Tt),function(t,e,r,n,o,i){var u=o&a,c=le(t),s=c.length,f=le(e).length;if(s!=f&&!u)return !1;for(var l=s;l--;){var p=c[l];if(!(u?p in e:rt.call(e,p)))return !1}var h=i.get(t);if(h&&i.get(e))return h==e;var d=!0;i.set(t,e),i.set(e,t);for(var y=u;++l<s;){p=c[l];var v=t[p],_=e[p];if(n)var g=u?n(_,v,p,e,t,i):n(v,_,p,t,e,i);if(!(void 0===g?v===_||r(v,_,n,o,i):g)){d=!1;break}y||(y="constructor"==p);}if(d&&!y){var b=t.constructor,m=e.constructor;b!=m&&"constructor"in t&&"constructor"in e&&!("function"==typeof b&&b instanceof b&&"function"==typeof m&&m instanceof m)&&(d=!1);}return i.delete(t),i.delete(e),d}(t,e,r,n,o,i)}(t,e,It,r,n,o))}function Ut(t){return !(!ae(t)||tt&&tt in t)&&(ie(t)||q(t)?ot:C).test(Xt(t))}function Nt(t){return "function"==typeof t?t:null==t?pe:"object"==typeof t?ne(t)?function(t,e){if(Gt(t)&&Qt(e))return Jt(Zt(t),e);return function(r){var n=function(t,e,r){var n=null==t?void 0:Lt(t,e);return void 0===n?r:n}(r,t);return void 0===n&&n===e?function(t,e){return null!=t&&function(t,e,r){var n,o=-1,i=(e=Gt(e,t)?[e]:Yt(e)).length;for(;++o<i;){var u=Zt(e[o]);if(!(n=null!=t&&r(t,u)))break;t=t[u];}if(n)return n;return !!(i=t?t.length:0)&&ue(i)&&Wt(u,i)&&(ne(t)||re(t))}(t,e,Mt)}(r,t):It(e,n,void 0,u|a)}}(t[0],t[1]):function(t){var e=function(t){var e=le(t),r=e.length;for(;r--;){var n=e[r],o=t[n];e[r]=[n,o,Qt(o)];}return e}(t);if(1==e.length&&e[0][2])return Jt(e[0][0],e[0][1]);return function(r){return r===t||function(t,e,r,n){var o=r.length,i=o,c=!n;if(null==t)return !i;for(t=Object(t);o--;){var s=r[o];if(c&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return !1}for(;++o<i;){var f=(s=r[o])[0],l=t[f],p=s[1];if(c&&s[2]){if(void 0===l&&!(f in t))return !1}else {var h=new Tt;if(n)var d=n(l,p,f,t,e,h);if(!(void 0===d?It(p,l,n,u|a,h):d))return !1}}return !0}(r,t,e)}}(t):Gt(e=t)?(r=Zt(e),function(t){return null==t?void 0:t[r]}):function(t){return function(e){return Lt(e,t)}}(e);var e,r;}function Bt(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||Z,e!==n)return st(t);var e,r,n,o=[];for(var i in Object(t))rt.call(t,i)&&"constructor"!=i&&o.push(i);return o}function Yt(t){return ne(t)?t:Kt(t)}function Ht(t,e,r,n,o,i){var c=o&a,s=t.length,f=e.length;if(s!=f&&!(c&&f>s))return !1;var l=i.get(t);if(l&&i.get(e))return l==e;var p=-1,h=!0,d=o&u?new Rt:void 0;for(i.set(t,e),i.set(e,t);++p<s;){var y=t[p],v=e[p];if(n)var _=c?n(v,y,p,e,t,i):n(y,v,p,t,e,i);if(void 0!==_){if(_)continue;h=!1;break}if(d){if(!H(e,function(t,e){if(!d.has(e)&&(y===t||r(y,t,n,o,i)))return d.add(e)})){h=!1;break}}else if(y!==v&&!r(y,v,n,o,i)){h=!1;break}}return i.delete(t),i.delete(e),h}function qt(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function zt(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return Ut(r)?r:void 0}var Vt=function(t){return nt.call(t)};function Wt(t,e){return !!(e=null==e?s:e)&&("number"==typeof t||F.test(t))&&t>-1&&t%1==0&&t<e}function Gt(t,e){if(ne(t))return !1;var r=typeof t;return !("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!se(t))||(R.test(t)||!S.test(t)||null!=e&&t in Object(e))}function Qt(t){return t==t&&!ae(t)}function Jt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}(ft&&Vt(new ft(new ArrayBuffer(1)))!=A||lt&&Vt(new lt)!=_||pt&&"[object Promise]"!=Vt(pt.resolve())||ht&&Vt(new ht)!=j||dt&&"[object WeakMap]"!=Vt(new dt))&&(Vt=function(t){var e=nt.call(t),r=e==b?t.constructor:void 0,n=r?Xt(r):void 0;if(n)switch(n){case vt:return A;case _t:return _;case gt:return "[object Promise]";case bt:return j;case mt:return "[object WeakMap]"}return e});var Kt=te(function(t){var e;t=null==(e=t)?"":function(t){if("string"==typeof t)return t;if(se(t))return Ot?Ot.call(t):"";var e=t+"";return "0"==e&&1/t==-c?"-0":e}(e);var r=[];return T.test(t)&&r.push(""),t.replace(D,function(t,e,n,o){r.push(n?o.replace(k,"$1"):e||t);}),r});function Zt(t){if("string"==typeof t||se(t))return t;var e=t+"";return "0"==e&&1/t==-c?"-0":e}function Xt(t){if(null!=t){try{return et.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}function te(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(o);var r=function(){var n=arguments,o=e?e.apply(this,n):n[0],i=r.cache;if(i.has(o))return i.get(o);var u=t.apply(this,n);return r.cache=i.set(o,u),u};return r.cache=new(te.Cache||St),r}function ee(t,e){return t===e||t!=t&&e!=e}function re(t){return function(t){return ce(t)&&oe(t)}(t)&&rt.call(t,"callee")&&(!at.call(t,"callee")||nt.call(t)==f)}te.Cache=St;var ne=Array.isArray;function oe(t){return null!=t&&ue(t.length)&&!ie(t)}function ie(t){var e=ae(t)?nt.call(t):"";return e==y||e==v}function ue(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=s}function ae(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function ce(t){return !!t&&"object"==typeof t}function se(t){return "symbol"==typeof t||ce(t)&&nt.call(t)==O}var fe=B?function(t){return function(e){return t(e)}}(B):function(t){return ce(t)&&ue(t.length)&&!!P[nt.call(t)]};function le(t){return oe(t)?Dt(t):Bt(t)}function pe(t){return t}r.exports=function(t,e,r){var n=ne(t)?Y:xt;return r&&function(t,e,r){if(!ae(r))return !1;var n=typeof e;return !!("number"==n?oe(r)&&Wt(e,r.length):"string"==n&&e in r)&&ee(r[e],t)}(t,e,r)&&(e=void 0),n(t,Nt(e))};}).call(this,r(0),r(2)(t));},function(t,e,r){(function(e){var r="Expected a function",n="__lodash_hash_undefined__",o=1/0,i=9007199254740991,u="[object Arguments]",a="[object Function]",c="[object GeneratorFunction]",s="[object Symbol]",f=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,l=/^\w*$/,p=/^\./,h=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,d=/\\(\\)?/g,y=/^\[object .+?Constructor\]$/,v=/^(?:0|[1-9]\d*)$/,_="object"==typeof e&&e&&e.Object===Object&&e,g="object"==typeof self&&self&&self.Object===Object&&self,b=_||g||Function("return this")();var m,j=Array.prototype,w=Function.prototype,O=Object.prototype,E=b["__core-js_shared__"],A=(m=/[^.]+$/.exec(E&&E.keys&&E.keys.IE_PROTO||""))?"Symbol(src)_1."+m:"",S=w.toString,R=O.hasOwnProperty,T=O.toString,D=RegExp("^"+S.call(R).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),k=b.Symbol,C=O.propertyIsEnumerable,F=j.splice,P=q(b,"Map"),x=q(Object,"create"),$=k?k.prototype:void 0,L=$?$.toString:void 0;function M(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function I(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function U(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function N(t,e){for(var r,n,o=t.length;o--;)if((r=t[o][0])===(n=e)||r!=r&&n!=n)return o;return -1}function B(t,e){return null!=t&&R.call(t,e)}function Y(t){return !(!Z(t)||A&&A in t)&&(J(t)||function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}(t)?D:y).test(function(t){if(null!=t){try{return S.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}(t))}function H(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function q(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return Y(r)?r:void 0}function z(t,e,r){for(var n,o,a=-1,c=(e=function(t,e){if(Q(t))return !1;var r=typeof t;if("number"==r||"symbol"==r||"boolean"==r||null==t||tt(t))return !0;return l.test(t)||!f.test(t)||null!=e&&t in Object(e)}(e,t)?[e]:Q(n=e)?n:V(n)).length;++a<c;){var s=W(e[a]);if(!(o=null!=t&&r(t,s)))break;t=t[s];}return o||!!(c=t?t.length:0)&&K(c)&&function(t,e){return !!(e=null==e?i:e)&&("number"==typeof t||v.test(t))&&t>-1&&t%1==0&&t<e}(s,c)&&(Q(t)||function(t){return function(t){return X(t)&&function(t){return null!=t&&K(t.length)&&!J(t)}(t)}(t)&&R.call(t,"callee")&&(!C.call(t,"callee")||T.call(t)==u)}(t))}M.prototype.clear=function(){this.__data__=x?x(null):{};},M.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},M.prototype.get=function(t){var e=this.__data__;if(x){var r=e[t];return r===n?void 0:r}return R.call(e,t)?e[t]:void 0},M.prototype.has=function(t){var e=this.__data__;return x?void 0!==e[t]:R.call(e,t)},M.prototype.set=function(t,e){return this.__data__[t]=x&&void 0===e?n:e,this},I.prototype.clear=function(){this.__data__=[];},I.prototype.delete=function(t){var e=this.__data__,r=N(e,t);return !(r<0||(r==e.length-1?e.pop():F.call(e,r,1),0))},I.prototype.get=function(t){var e=this.__data__,r=N(e,t);return r<0?void 0:e[r][1]},I.prototype.has=function(t){return N(this.__data__,t)>-1},I.prototype.set=function(t,e){var r=this.__data__,n=N(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},U.prototype.clear=function(){this.__data__={hash:new M,map:new(P||I),string:new M};},U.prototype.delete=function(t){return H(this,t).delete(t)},U.prototype.get=function(t){return H(this,t).get(t)},U.prototype.has=function(t){return H(this,t).has(t)},U.prototype.set=function(t,e){return H(this,t).set(t,e),this};var V=G(function(t){var e;t=null==(e=t)?"":function(t){if("string"==typeof t)return t;if(tt(t))return L?L.call(t):"";var e=t+"";return "0"==e&&1/t==-o?"-0":e}(e);var r=[];return p.test(t)&&r.push(""),t.replace(h,function(t,e,n,o){r.push(n?o.replace(d,"$1"):e||t);}),r});function W(t){if("string"==typeof t||tt(t))return t;var e=t+"";return "0"==e&&1/t==-o?"-0":e}function G(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(r);var n=function(){var r=arguments,o=e?e.apply(this,r):r[0],i=n.cache;if(i.has(o))return i.get(o);var u=t.apply(this,r);return n.cache=i.set(o,u),u};return n.cache=new(G.Cache||U),n}G.Cache=U;var Q=Array.isArray;function J(t){var e=Z(t)?T.call(t):"";return e==a||e==c}function K(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=i}function Z(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function X(t){return !!t&&"object"==typeof t}function tt(t){return "symbol"==typeof t||X(t)&&T.call(t)==s}t.exports=function(t,e){return null!=t&&z(t,e,B)};}).call(this,r(0));},function(t,e){t.exports=function(t){return t?t[0]:void 0};},function(t,e){var r=9007199254740991,n="[object Arguments]",o="[object Function]",i="[object GeneratorFunction]",u=/^(?:0|[1-9]\d*)$/;function a(t,e){return function(t,e){for(var r=-1,n=t?t.length:0,o=Array(n);++r<n;)o[r]=e(t[r],r,t);return o}(e,function(e){return t[e]})}var c,s,f=Object.prototype,l=f.hasOwnProperty,p=f.toString,h=f.propertyIsEnumerable,d=(c=Object.keys,s=Object,function(t){return c(s(t))});function y(t,e){var r=g(t)||function(t){return function(t){return function(t){return !!t&&"object"==typeof t}(t)&&b(t)}(t)&&l.call(t,"callee")&&(!h.call(t,"callee")||p.call(t)==n)}(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],o=r.length,i=!!o;for(var u in t)!e&&!l.call(t,u)||i&&("length"==u||_(u,o))||r.push(u);return r}function v(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||f,e!==n)return d(t);var e,r,n,o=[];for(var i in Object(t))l.call(t,i)&&"constructor"!=i&&o.push(i);return o}function _(t,e){return !!(e=null==e?r:e)&&("number"==typeof t||u.test(t))&&t>-1&&t%1==0&&t<e}var g=Array.isArray;function b(t){return null!=t&&function(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=r}(t.length)&&!function(t){var e=function(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}(t)?p.call(t):"";return e==o||e==i}(t)}t.exports=function(t){return t?a(t,function(t){return b(t)?y(t):v(t)}(t)):[]};},function(t,e,r){(function(t,r){var n=200,o="__lodash_hash_undefined__",i=9007199254740991,u="[object Arguments]",a="[object Boolean]",c="[object Date]",s="[object Function]",f="[object GeneratorFunction]",l="[object Map]",p="[object Number]",h="[object Object]",d="[object RegExp]",y="[object Set]",v="[object String]",_="[object Symbol]",g="[object ArrayBuffer]",b="[object DataView]",m="[object Float32Array]",j="[object Float64Array]",w="[object Int8Array]",O="[object Int16Array]",E="[object Int32Array]",A="[object Uint8Array]",S="[object Uint8ClampedArray]",R="[object Uint16Array]",T="[object Uint32Array]",D=/\w*$/,k=/^\[object .+?Constructor\]$/,C=/^(?:0|[1-9]\d*)$/,F={};F[u]=F["[object Array]"]=F[g]=F[b]=F[a]=F[c]=F[m]=F[j]=F[w]=F[O]=F[E]=F[l]=F[p]=F[h]=F[d]=F[y]=F[v]=F[_]=F[A]=F[S]=F[R]=F[T]=!0,F["[object Error]"]=F[s]=F["[object WeakMap]"]=!1;var P="object"==typeof t&&t&&t.Object===Object&&t,x="object"==typeof self&&self&&self.Object===Object&&self,$=P||x||Function("return this")(),L="object"==typeof e&&e&&!e.nodeType&&e,M=L&&"object"==typeof r&&r&&!r.nodeType&&r,I=M&&M.exports===L;function U(t,e){return t.set(e[0],e[1]),t}function N(t,e){return t.add(e),t}function B(t,e,r,n){var o=-1,i=t?t.length:0;for(n&&i&&(r=t[++o]);++o<i;)r=e(r,t[o],o,t);return r}function Y(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}function H(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t];}),r}function q(t,e){return function(r){return t(e(r))}}function z(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t;}),r}var V,W=Array.prototype,G=Function.prototype,Q=Object.prototype,J=$["__core-js_shared__"],K=(V=/[^.]+$/.exec(J&&J.keys&&J.keys.IE_PROTO||""))?"Symbol(src)_1."+V:"",Z=G.toString,X=Q.hasOwnProperty,tt=Q.toString,et=RegExp("^"+Z.call(X).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),rt=I?$.Buffer:void 0,nt=$.Symbol,ot=$.Uint8Array,it=q(Object.getPrototypeOf,Object),ut=Object.create,at=Q.propertyIsEnumerable,ct=W.splice,st=Object.getOwnPropertySymbols,ft=rt?rt.isBuffer:void 0,lt=q(Object.keys,Object),pt=Mt($,"DataView"),ht=Mt($,"Map"),dt=Mt($,"Promise"),yt=Mt($,"Set"),vt=Mt($,"WeakMap"),_t=Mt(Object,"create"),gt=Yt(pt),bt=Yt(ht),mt=Yt(dt),jt=Yt(yt),wt=Yt(vt),Ot=nt?nt.prototype:void 0,Et=Ot?Ot.valueOf:void 0;function At(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function St(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Rt(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1]);}}function Tt(t){this.__data__=new St(t);}function Dt(t,e){var r=qt(t)||function(t){return function(t){return function(t){return !!t&&"object"==typeof t}(t)&&zt(t)}(t)&&X.call(t,"callee")&&(!at.call(t,"callee")||tt.call(t)==u)}(t)?function(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}(t.length,String):[],n=r.length,o=!!n;for(var i in t)!e&&!X.call(t,i)||o&&("length"==i||Nt(i,n))||r.push(i);return r}function kt(t,e,r){var n=t[e];X.call(t,e)&&Ht(n,r)&&(void 0!==r||e in t)||(t[e]=r);}function Ct(t,e){for(var r=t.length;r--;)if(Ht(t[r][0],e))return r;return -1}function Ft(t,e,r,n,o,i,k){var C;if(n&&(C=i?n(t,o,i,k):n(t)),void 0!==C)return C;if(!Gt(t))return t;var P=qt(t);if(P){if(C=function(t){var e=t.length,r=t.constructor(e);e&&"string"==typeof t[0]&&X.call(t,"index")&&(r.index=t.index,r.input=t.input);return r}(t),!e)return function(t,e){var r=-1,n=t.length;e||(e=Array(n));for(;++r<n;)e[r]=t[r];return e}(t,C)}else {var x=Ut(t),$=x==s||x==f;if(Vt(t))return function(t,e){if(e)return t.slice();var r=new t.constructor(t.length);return t.copy(r),r}(t,e);if(x==h||x==u||$&&!i){if(Y(t))return i?t:{};if(C=function(t){return "function"!=typeof t.constructor||Bt(t)?{}:(e=it(t),Gt(e)?ut(e):{});var e;}($?{}:t),!e)return function(t,e){return $t(t,It(t),e)}(t,function(t,e){return t&&$t(e,Qt(e),t)}(C,t))}else {if(!F[x])return i?t:{};C=function(t,e,r,n){var o=t.constructor;switch(e){case g:return xt(t);case a:case c:return new o(+t);case b:return function(t,e){var r=e?xt(t.buffer):t.buffer;return new t.constructor(r,t.byteOffset,t.byteLength)}(t,n);case m:case j:case w:case O:case E:case A:case S:case R:case T:return function(t,e){var r=e?xt(t.buffer):t.buffer;return new t.constructor(r,t.byteOffset,t.length)}(t,n);case l:return function(t,e,r){return B(e?r(H(t),!0):H(t),U,new t.constructor)}(t,n,r);case p:case v:return new o(t);case d:return (s=new(u=t).constructor(u.source,D.exec(u))).lastIndex=u.lastIndex,s;case y:return function(t,e,r){return B(e?r(z(t),!0):z(t),N,new t.constructor)}(t,n,r);case _:return i=t,Et?Object(Et.call(i)):{}}var i;var u,s;}(t,x,Ft,e);}}k||(k=new Tt);var L=k.get(t);if(L)return L;if(k.set(t,C),!P)var M=r?function(t){return function(t,e,r){var n=e(t);return qt(t)?n:function(t,e){for(var r=-1,n=e.length,o=t.length;++r<n;)t[o+r]=e[r];return t}(n,r(t))}(t,Qt,It)}(t):Qt(t);return function(t,e){for(var r=-1,n=t?t.length:0;++r<n&&!1!==e(t[r],r,t););}(M||t,function(o,i){M&&(o=t[i=o]),kt(C,i,Ft(o,e,r,n,i,t,k));}),C}function Pt(t){return !(!Gt(t)||K&&K in t)&&(Wt(t)||Y(t)?et:k).test(Yt(t))}function xt(t){var e=new t.constructor(t.byteLength);return new ot(e).set(new ot(t)),e}function $t(t,e,r,n){r||(r={});for(var o=-1,i=e.length;++o<i;){var u=e[o],a=n?n(r[u],t[u],u,r,t):void 0;kt(r,u,void 0===a?t[u]:a);}return r}function Lt(t,e){var r,n,o=t.__data__;return ("string"==(n=typeof(r=e))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof e?"string":"hash"]:o.map}function Mt(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return Pt(r)?r:void 0}At.prototype.clear=function(){this.__data__=_t?_t(null):{};},At.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},At.prototype.get=function(t){var e=this.__data__;if(_t){var r=e[t];return r===o?void 0:r}return X.call(e,t)?e[t]:void 0},At.prototype.has=function(t){var e=this.__data__;return _t?void 0!==e[t]:X.call(e,t)},At.prototype.set=function(t,e){return this.__data__[t]=_t&&void 0===e?o:e,this},St.prototype.clear=function(){this.__data__=[];},St.prototype.delete=function(t){var e=this.__data__,r=Ct(e,t);return !(r<0||(r==e.length-1?e.pop():ct.call(e,r,1),0))},St.prototype.get=function(t){var e=this.__data__,r=Ct(e,t);return r<0?void 0:e[r][1]},St.prototype.has=function(t){return Ct(this.__data__,t)>-1},St.prototype.set=function(t,e){var r=this.__data__,n=Ct(r,t);return n<0?r.push([t,e]):r[n][1]=e,this},Rt.prototype.clear=function(){this.__data__={hash:new At,map:new(ht||St),string:new At};},Rt.prototype.delete=function(t){return Lt(this,t).delete(t)},Rt.prototype.get=function(t){return Lt(this,t).get(t)},Rt.prototype.has=function(t){return Lt(this,t).has(t)},Rt.prototype.set=function(t,e){return Lt(this,t).set(t,e),this},Tt.prototype.clear=function(){this.__data__=new St;},Tt.prototype.delete=function(t){return this.__data__.delete(t)},Tt.prototype.get=function(t){return this.__data__.get(t)},Tt.prototype.has=function(t){return this.__data__.has(t)},Tt.prototype.set=function(t,e){var r=this.__data__;if(r instanceof St){var o=r.__data__;if(!ht||o.length<n-1)return o.push([t,e]),this;r=this.__data__=new Rt(o);}return r.set(t,e),this};var It=st?q(st,Object):function(){return []},Ut=function(t){return tt.call(t)};function Nt(t,e){return !!(e=null==e?i:e)&&("number"==typeof t||C.test(t))&&t>-1&&t%1==0&&t<e}function Bt(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||Q)}function Yt(t){if(null!=t){try{return Z.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}function Ht(t,e){return t===e||t!=t&&e!=e}(pt&&Ut(new pt(new ArrayBuffer(1)))!=b||ht&&Ut(new ht)!=l||dt&&"[object Promise]"!=Ut(dt.resolve())||yt&&Ut(new yt)!=y||vt&&"[object WeakMap]"!=Ut(new vt))&&(Ut=function(t){var e=tt.call(t),r=e==h?t.constructor:void 0,n=r?Yt(r):void 0;if(n)switch(n){case gt:return b;case bt:return l;case mt:return "[object Promise]";case jt:return y;case wt:return "[object WeakMap]"}return e});var qt=Array.isArray;function zt(t){return null!=t&&function(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=i}(t.length)&&!Wt(t)}var Vt=ft||function(){return !1};function Wt(t){var e=Gt(t)?tt.call(t):"";return e==s||e==f}function Gt(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}function Qt(t){return zt(t)?Dt(t):function(t){if(!Bt(t))return lt(t);var e=[];for(var r in Object(t))X.call(t,r)&&"constructor"!=r&&e.push(r);return e}(t)}r.exports=function(t){return Ft(t,!0,!0)};}).call(this,r(0),r(2)(t));},function(t,e,r){(function(e){var r,n=9007199254740991,o="[object Function]",i="[object GeneratorFunction]",u="[object Map]",a="[object Set]",c="[object String]",s=/^\[object .+?Constructor\]$/,f="[\\ud800-\\udfff]",l="[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]",p="\\ud83c[\\udffb-\\udfff]",h="[^\\ud800-\\udfff]",d="(?:\\ud83c[\\udde6-\\uddff]){2}",y="[\\ud800-\\udbff][\\udc00-\\udfff]",v="(?:"+l+"|"+p+")"+"?",_="[\\ufe0e\\ufe0f]?"+v+("(?:\\u200d(?:"+[h,d,y].join("|")+")[\\ufe0e\\ufe0f]?"+v+")*"),g="(?:"+[h+l+"?",l,d,y,f].join("|")+")",b=RegExp(p+"(?="+p+")|"+g+_,"g"),m=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"),j="object"==typeof e&&e&&e.Object===Object&&e,w="object"==typeof self&&self&&self.Object===Object&&self,O=j||w||Function("return this")(),E=(r="length",function(t){return null==t?void 0:t[r]});function A(t){return function(t){return m.test(t)}(t)?function(t){var e=b.lastIndex=0;for(;b.test(t);)e++;return e}(t):E(t)}var S,R,T,D=Function.prototype,k=Object.prototype,C=O["__core-js_shared__"],F=(S=/[^.]+$/.exec(C&&C.keys&&C.keys.IE_PROTO||""))?"Symbol(src)_1."+S:"",P=D.toString,x=k.hasOwnProperty,$=k.toString,L=RegExp("^"+P.call(x).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),M=(R=Object.keys,T=Object,function(t){return R(T(t))}),I=J(O,"DataView"),U=J(O,"Map"),N=J(O,"Promise"),B=J(O,"Set"),Y=J(O,"WeakMap"),H=Z(I),q=Z(U),z=Z(N),V=Z(B),W=Z(Y);function G(t){return !(!et(t)||F&&F in t)&&(tt(t)||function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"");}catch(t){}return e}(t)?L:s).test(Z(t))}function Q(t){if(r=(e=t)&&e.constructor,n="function"==typeof r&&r.prototype||k,e!==n)return M(t);var e,r,n,o=[];for(var i in Object(t))x.call(t,i)&&"constructor"!=i&&o.push(i);return o}function J(t,e){var r=function(t,e){return null==t?void 0:t[e]}(t,e);return G(r)?r:void 0}var K=function(t){return $.call(t)};function Z(t){if(null!=t){try{return P.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}(I&&"[object DataView]"!=K(new I(new ArrayBuffer(1)))||U&&K(new U)!=u||N&&"[object Promise]"!=K(N.resolve())||B&&K(new B)!=a||Y&&"[object WeakMap]"!=K(new Y))&&(K=function(t){var e=$.call(t),r="[object Object]"==e?t.constructor:void 0,n=r?Z(r):void 0;if(n)switch(n){case H:return "[object DataView]";case q:return u;case z:return "[object Promise]";case V:return a;case W:return "[object WeakMap]"}return e});var X=Array.isArray;function tt(t){var e=et(t)?$.call(t):"";return e==o||e==i}function et(t){var e=typeof t;return !!t&&("object"==e||"function"==e)}t.exports=function(t){if(null==t)return 0;if(null!=(e=t)&&function(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=n}(e.length)&&!tt(e))return function(t){return "string"==typeof t||!X(t)&&function(t){return !!t&&"object"==typeof t}(t)&&$.call(t)==c}(t)?A(t):t.length;var e,r=K(t);return r==u||r==a?t.size:Q(t).length};}).call(this,r(0));},function(t,e){var r=Array.isArray;t.exports=r;},function(t,e,r){(function(t){Object.defineProperty(e,"__esModule",{value:!0});const n=r(5),o=r(7),i=r(16),u=r(36),a=r(35),c=(r(34),r(33)),s=r(11),f=r(19),l=(r(18),r(32)),p=r(20),h=r(10),d=r(4),y=r(31),v=r(30),_=r(9),g=r(29),b=r(1),m=r(28),j=r(3),w=r(17);function O(t,e={}){return new Promise((r,c)=>{const l=[...function(t,e){const r=[],n=d(t,"dataset"),i=d(t,"branch"),u=d(t,"commit");o(n)||g(n)||r.push("'dataset' clause must be string only");o(i)||g(i)||r.push("'branch' clause must be string only");o(u)||g(u)||r.push("'commit' clause must be string only");return r}(t),...function(t,e){const r=[],n=d(t,"from",null);o(n)&&r.push("'from' clause couldn't be empty");g(n)||r.push("'from' clause must be string only");if(!j.AVAILABLE_FROM_CLAUSE_VALUES.has(n)){const t=[...j.AVAILABLE_FROM_CLAUSE_VALUES];r.push(`'from' clause must be one of the list: ${t.join(", ")}`);}return r}(t),...function(t,e){const r=[],n=d(t,"select",null),o=d(t,"from",null),c=d(n,"key"),s=d(n,"value");switch(!0){case j.isSchemaQuery(t):r.push(E(n),function(t,e){if(!u(e)||2!==a(e))return `'select.key' clause for '${t}' queries must have exactly 2 items: 'key', 'value'`}(o,c),T(o,s));break;case j.isEntitiesQuery(t):case j.isConceptsQuery(t):r.push(E(n),D(n,c),k(o,c),T(o,s));break;case j.isDatapointsQuery(t):r.push(E(n),function(t,e,r){if(!i(t)||!u(e)||!u(r))return "'select' clause must have next structure: { key: [...], value: [...] }"}(n,c,s),function(t,e){if(a(e)<2)return `'select.key' clause for '${t}' queries must have at least 2 items`}(o,c),function(t,e){const r=(n=e,p(n,(t,e,r)=>b(r,t,e+1)));var n;if(a(r)>0)return `'select.key' clause for '${t}' queries contains duplicates: ${m(r).join(",")}`}(o,c),function(t,e){if(a(e)<1)return `'select.value' clause for '${t}' queries must have at least 1 item`}(o,s));break;default:r.push(E(n));}return _(r)}(t),...function(t,e){const r=[],i=d(t,"join",null),u=d(t,"where",null),a=function t(e){const r=[];for(const n in e)h(n,"$")&&r.push({name:n,isLeaf:!1}),w.isPrimitive(e[n])?h(e[n],"$")&&r.push({name:e[n],isLeaf:!0}):r.push(...t(e[n]));return r}(u);return r.push(function(t,e){if(!o(t)&&!A(t))return `'${e}where' clause must be object only`}(u,R(e)),function(t,e,r){const o=p(e,e=>!function(t,e){return function(t){return !t.isLeaf&&j.AVAILABLE_QUERY_OPERATORS.has(t.name)}(e)||function(t,e){return e.isLeaf&&h(e.name,"$")&&y(t,e.name)}(t,e)}(t,e)).map(t=>t.name),i=[...j.AVAILABLE_QUERY_OPERATORS.values(),...s(t)];if(!n(o))return `'${r}where' clause has unknown operator(s) '${o.join(", ")}', replace it with allowed operators: ${i.join(", ")}`}(i,a,R(e))),_(r)}(t,e),...function(t,e){const r=[],n=d(t,"language",null);switch(!0){case j.isSchemaQuery(t):r.push(function(t){if(y(t,"language"))return "'language' clause for '*.schema' queries shouldn't be present in query"}(t));break;case j.isEntitiesQuery(t):case j.isConceptsQuery(t):case j.isDatapointsQuery(t):default:r.push(function(t){if(!o(t)&&!g(t))return "'language' clause must be string only"}(n));}return _(r)}(t),...function(t,e){const r=[],n=d(t,"join",null);switch(!0){case j.isSchemaQuery(t):case j.isConceptsQuery(t):r.push(function(t){if(y(t,"join"))return `'join' clause for '${t.from}' queries shouldn't be present in query`}(t));break;case j.isEntitiesQuery(t):case j.isDatapointsQuery(t):default:r.push(function(t){if(!o(t)&&!A(t))return "'join' clause must be object only"}(n),...f(n,(t,e)=>(function(t,e){if(!o(t.key)&&!g(t.key))return `'${e}key' clause must be string only`})(t,R({joinID:e}))));}return _(r)}(t),...function(t,e){const r=[],n=d(t,"order_by",null);return r.push(function(t){if(!(o(t)||g(t)||(e=t,u(e)&&v(e,g))||function(t,e){return u(t)&&v(t,e)}(t,S)))return "'order_by' clause must be string or array of strings || objects only";var e;}(n)),_(r)}(t)];return n(l)?r():c(`Too many query structure errors: \n* ${l.join("\n* ")}`)})}function E(t){if(o(t))return "'select' clause couldn't be empty"}function A(t){return i(t)&&!u(t)}function S(t){return g(t)||A(t)&&1===a(t)&&j.AVAILABLE_ORDER_BY_CLAUSE_VALUES.has(l(c(t)))}function R(t){return d(t,"joinID",!1)?`join.${t.joinID}.`:""}function T(t,e){if(!u(e)&&!o(e))return `'select.value' clause for '${t}' queries should be array of strings or empty`}function D(t,e,r){if(!i(t)||!u(e))return "'select' clause must have next structure: { key: [...], value: [...] }"}function k(t,e){if(!u(e)||1!==a(e))return `'select.key' clause for '${t}' queries must have only 1 item`}e.validateQueryStructure=O,e.getVersion=function(){return t.env.npm_package_version};}).call(this,r(8));},function(t,e){"function"==typeof Object.create?t.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}});}:t.exports=function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t;};},function(t,e){t.exports=function(t){return t&&"object"==typeof t&&"function"==typeof t.copy&&"function"==typeof t.fill&&"function"==typeof t.readUInt8};},function(t,e,r){(function(e){var r=1/0,n="[object Symbol]",o=/^\s+/,i="[\\ud800-\\udfff]",u="[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]",a="\\ud83c[\\udffb-\\udfff]",c="[^\\ud800-\\udfff]",s="(?:\\ud83c[\\udde6-\\uddff]){2}",f="[\\ud800-\\udbff][\\udc00-\\udfff]",l="(?:"+u+"|"+a+")"+"?",p="[\\ufe0e\\ufe0f]?"+l+("(?:\\u200d(?:"+[c,s,f].join("|")+")[\\ufe0e\\ufe0f]?"+l+")*"),h="(?:"+[c+u+"?",u,s,f,i].join("|")+")",d=RegExp(a+"(?="+a+")|"+h+p,"g"),y=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"),v="object"==typeof e&&e&&e.Object===Object&&e,_="object"==typeof self&&self&&self.Object===Object&&self,g=v||_||Function("return this")();function b(t,e,r){if(e!=e)return function(t,e,r,n){for(var o=t.length,i=r+(n?1:-1);n?i--:++i<o;)if(e(t[i],i,t))return i;return -1}(t,m,r);for(var n=r-1,o=t.length;++n<o;)if(t[n]===e)return n;return -1}function m(t){return t!=t}function j(t){return function(t){return y.test(t)}(t)?function(t){return t.match(d)||[]}(t):function(t){return t.split("")}(t)}var w=Object.prototype.toString,O=g.Symbol,E=O?O.prototype:void 0,A=E?E.toString:void 0;function S(t){if("string"==typeof t)return t;if(function(t){return "symbol"==typeof t||function(t){return !!t&&"object"==typeof t}(t)&&w.call(t)==n}(t))return A?A.call(t):"";var e=t+"";return "0"==e&&1/t==-r?"-0":e}function R(t,e,r){var n=t.length;return r=void 0===r?n:r,!e&&r>=n?t:function(t,e,r){var n=-1,o=t.length;e<0&&(e=-e>o?0:o+e),(r=r>o?o:r)<0&&(r+=o),o=e>r?0:r-e>>>0,e>>>=0;for(var i=Array(o);++n<o;)i[n]=t[n+e];return i}(t,e,r)}t.exports=function(t,e,r){var n;if((t=null==(n=t)?"":S(n))&&(r||void 0===e))return t.replace(o,"");if(!t||!(e=S(e)))return t;var i=j(t);return R(i,function(t,e){for(var r=-1,n=t.length;++r<n&&b(e,t[r],0)>-1;);return r}(i,j(e))).join("")};}).call(this,r(0));},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const n=r(5),o=r(20),i=r(19),u=r(4),a=r(9),c=r(1),s=r(10),f=r(7),l=r(40),p=(r(18),r(3)),h=r(17);function d(t,e){return o(t,t=>!c(e,t))}function y(t,e){const r=o([...e.values()],({concept_type:e})=>c(t,e));return i(r,"concept")}e.validateQueryDefinitions=function(t,e={}){return new Promise((r,o)=>{const i=[...function(t,e){const r=[],o=u(t,"from",null),i=u(t,"select",null),c=u(i,"key"),s=u(i,"value"),f=[],l=[],{conceptsLookup:h}=e;switch(!0){case p.isDatapointsQuery(t):const e=[p.CONCEPT_TYPE_ENTITY_SET,p.CONCEPT_TYPE_ENTITY_DOMAIN,p.CONCEPT_TYPE_TIME];f.push(...y(e,h)),l.push(...h.keys());break;case p.isEntitiesQuery(t):const r=[p.CONCEPT_TYPE_ENTITY_SET,p.CONCEPT_TYPE_ENTITY_DOMAIN];f.push(...y(r,h)),l.push(...h.keys());break;case p.isConceptsQuery(t):f.push(p.RESERVED_CONCEPT),l.push(...h.keys(),p.RESERVED_CONCEPT,p.RESERVED_CONCEPT_TYPE,p.RESERVED_DOMAIN,p.RESERVED_UNIT,p.RESERVED_DRILL_UP);break;default:f.push(p.RESERVED_KEY,p.RESERVED_VALUE),l.push(p.RESERVED_KEY,p.RESERVED_VALUE);}return r.push(function(t,e,r){const o=d(e,r);if(!n(o))return `'select.key' clause for '${t}' query contains unavailable item(s): ${o.join(", ")}`}(o,c,f),function(t,e,r){if(!0!==t.debug)return;const o=u(t,"from",null),i=d(e,r);return n(e)||n(i)?void 0:`'select.value' clause for '${o}' query contains unavailable item(s): ${i.join(", ")}`}(t,s,l)),a(r)}(t,e),...function(t,e){if(!0!==t.debug)return [];const r=[],o=u(t,"where",null),i=(u(t,"from",null),u(t,"select",null));switch(u(i,"key"),u(i,"value"),function(t){const e={};!function t(e,r,o){for(const i in e){const u=!f(o),a=!u&&!s(i,"$")&&isNaN(+i),[c,...p]=i.split(".");a&&(f(r[c])&&(r[l(c,"is--")]=[]),n(p)||r[c].push(l(p.join("."),"is--"))),h.isPrimitive(e[i])||t(e[i],r,a?c:o);}}(t,e);}(o),!0){case p.isDatapointsQuery(t):const e=[];e.push(p.CONCEPT_TYPE_ENTITY_SET,p.CONCEPT_TYPE_ENTITY_DOMAIN,p.CONCEPT_TYPE_TIME),r.push();}return a(r)}(t)];return n(i)?r():o(`Too many query definition errors [repo: ${e.basePath}]: \n* ${i.join("\n* ")}`)})};},function(t,e,r){function n(t){for(var r in t)e.hasOwnProperty(r)||(e[r]=t[r]);}Object.defineProperty(e,"__esModule",{value:!0}),n(r(3)),n(r(41)),n(r(37)),n(r(27)),n(r(26)),n(r(15));},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.InClauseUnderConjunction=void 0;const n=r(12),o=r(11),i=r(4),u=r(5),a=r(10),c=r(1),s=r(9),f=r(6),l="where",p="join";e.InClauseUnderConjunction=class{constructor(t,e,r){this.parent=t,this.options=r,this.flow={},this.fileReader=r.fileReader,this.datasetPath=r.basePath,this.query=e,this.datapackage=r.datapackage,this.conceptsLookup=r.conceptsLookup;}isMatched(){return this.flow.joinObject=i(this.query,p),"datapoints"===this.query.from&&this.flow.joinObject}async getRecommendedFilesSet(){const{debug:t,error:e,warning:r}=this.options.diagnostic.prepareDiagnosticFor("getRecommendedFilesSet");if(this.isMatched()){let r;t("plugin matched");try{if(this.flow.processableClauses=await this.collectProcessableClauses(),!this.flow.processableClauses)return [];this.collectEntityFilesNames();const t=await this.collectEntities();this.fillEntityValuesHash(t),this.getFilesGroupsQueryClause(),r=this.getOptimalFilesGroup();}catch(t){return e("wrong data processing",t),[]}return t("recommended files found",r),r}{const t='Plugin "InClauseUnderConjunction" is not matched!';throw r(t),new f.DdfCsvError(t,"InClauseUnderConjunction plugin")}}collectProcessableClauses(){const t=o(this.flow.joinObject).filter(t=>{var e;return ["entity_domain","entity_set"].includes(null===(e=this.options.conceptsLookup.get(t.slice(1)))||void 0===e?void 0:e.concept_type)});return t.length?Promise.all(t.map(t=>{const e=this.flow.joinObject[t].key,r=i(this.flow.joinObject,`${t}.${l}`,{});return this.parent.queryData({select:{key:[e]},where:r,from:this.options.conceptsLookup.has(e)?"entities":"concepts"},Object.assign({joinID:t},this.options)).then(t=>({key:e,entities:new Set(t.map(t=>t[e]))}))})):Promise.resolve(!1)}collectEntityFilesNames(){this.flow.entityFilesNames=new Set,this.flow.entityResources=new Set,this.flow.fileNameToPrimaryKeyHash=new Map;for(const t of this.datapackage.ddfSchema.entities)for(const e of this.flow.processableClauses){const r=e.key;if(n(t.primaryKey)===r)for(const e of t.resources){const t=this.options.resourcesLookup.get(e);this.flow.entityResources.add(t),this.flow.entityFilesNames.add(t.path),this.flow.fileNameToPrimaryKeyHash.set(t.path,r);}}return this}collectEntities(){const t=this,e=[...t.flow.entityResources].map(e=>(e.data||(e.data=t.parent.loadFile(e.path,t.options))).then(t=>({result:t,file:e.path})));return Promise.all(e)}fillEntityValuesHash(t){const e=t=>s(o(t).filter(e=>a(e,"is--")&&!0===t[e]).map(t=>t.replace(/^is--/,"")));this.flow.entityValueToFileHash=new Map,this.flow.entityValueToDomainHash=new Map;for(const r of t)for(const t of r.result.data){const n=this.flow.fileNameToPrimaryKeyHash.get(r.file),o=[...e(t)];u(o)&&o.push(n);const i=t[n]||t[o[0]];this.flow.entityValueToDomainHash.set(i,o),this.flow.entityValueToFileHash.set(i,r.file);}return this}getFilesGroupsQueryClause(){var t;const e=new Map;for(const r of this.flow.processableClauses){const n={datapoints:new Set};for(const e of r.entities){const r=this.flow.entityValueToDomainHash.get(e);for(const o of r)for(const r of this.datapackage.ddfSchema.datapoints)for(const i of r.resources)if(c(r.primaryKey,o)){const r=this.options.resourcesLookup.get(i),u=null===(t=r.constraints)||void 0===t?void 0:t[o];u?u.includes(e)&&n.datapoints.add(r.path):n.datapoints.add(r.path);}}e.set(r.key,n);}return this.flow.filesGroupsByClause=e,this}getOptimalFilesGroup(){const t=this.flow.entityFilesNames,e=new Set;for(const t of this.datapackage.ddfSchema.concepts)for(const r of t.resources)e.add(this.options.resourcesLookup.get(r).path);const r=this.flow.filesGroupsByClause.keys();let n=Array.from(this.flow.filesGroupsByClause.get(r.next().value).datapoints);for(const t of r)n=this.intersectArray(n,Array.from(this.flow.filesGroupsByClause.get(t).datapoints));return [...Array.from(e),...Array.from(t)].concat(n)}intersectArray(t,e){return t.filter(t=>e.includes(t))}};},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.getAppropriatePlugin=void 0;const n=r(43),o=r(12);e.getAppropriatePlugin=function(t,e,r){const i=[new n.InClauseUnderConjunction(t,e,r)];return o(i.filter(t=>t.isMatched()))};},function(t,e,r){t.exports=(t=>{if("string"!=typeof t)throw new TypeError("Expected a string, got "+typeof t);return 65279===t.charCodeAt(0)?t.slice(1):t});},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.ddfCsvReader=void 0;const n=r(1),o=r(5),i=r(45),u=r(44),a=r(6),c=r(42),s=r(25),f=r(22),l=t=>!("number"!=typeof t&&!t);e.ddfCsvReader=function(t){const e=[{concept:"concept",concept_type:"string",domain:null},{concept:"concept_type",concept_type:"string",domain:null}],r=new Map([["$and",(t,e)=>e.every(e=>w(t,e))],["$or",(t,e)=>e.some(e=>w(t,e))],["$not",(t,e)=>!w(t,e)],["$nor",(t,e)=>!e.some(e=>w(t,e))],["$eq",(t,e)=>t==e],["$ne",(t,e)=>t!=e],["$gt",(t,e)=>l(t)&&t>e],["$gte",(t,e)=>l(t)&&t>=e],["$lt",(t,e)=>l(t)&&t<e],["$lte",(t,e)=>l(t)&&t<=e],["$in",(t,e)=>e.has(t)],["$nin",(t,e)=>!e.has(t)]]),p=new Map,h=new Map;let d,y,v=[],_=!1;function g(t){const e=(0, c.getFilePath)(t.basePath),{debug:r,error:n}=t.diagnostic.prepareDiagnosticFor("loadDataPackage");return new Promise((o,u)=>{if(d)return o(d);t.fileReader.readText(e,(t,c)=>{if(t)return n("file reading",t),u(new a.DdfCsvError(a.FILE_READING_ERROR,t,e));try{d=JSON.parse(i(c)),v=[],function(t){if(h.size>0)return h;t.resources.forEach(t=>{Array.isArray(t.schema.primaryKey)||(t.schema.primaryKey=[t.schema.primaryKey]);const e=t.schema.fields.reduce((t,e)=>{var r;return (null===(r=e.constraints)||void 0===r?void 0:r.enum)&&(_||(_=!0),t[e.name]=e.constraints.enum.map(t=>+t||t)),t},{});t.constraints=e,t.translations={},h.set(t.name,t);});}(d),function(t){if(p.size>0)return p;for(const e in t.ddfSchema)t.ddfSchema[e].map(t=>{const e=k(t.primaryKey),r=t.resources.map(t=>h.get(t));p.has(e)?p.get(e).set(t.value,r):p.set(e,new Map([[t.value,r]]));});}(d);}catch(t){return n("json file parsing",t),u(new a.DdfCsvError(a.JSON_PARSING_ERROR,t.message,e))}r("datapackage content is ready"),o(d);});})}async function b(t,r){const{error:n}=r.diagnostic.prepareDiagnosticFor("loadConcepts");m(e,r);const o={select:{key:["concept"],value:["concept_type","domain"]},from:"concepts"};let i;try{!function(t,r){const n=t.filter(t=>"entity_set"===t.concept_type).map(t=>({concept:"is--"+t.concept,concept_type:"boolean",domain:null}));m(t=t.concat(n).concat(e),r);}(await j(o,r),r),i=await function({conceptsLookup:t}){const e=new Map([["boolean",t=>"true"===t||"TRUE"===t],["measure",t=>parseFloat(t)]]),r=[...S(["concept"])].map(r=>r.data.then(r=>{const n=Object.keys(r.data[0]),o=new Map;return n.forEach(r=>{const n=t.get(r).concept_type,i=e.get(n);i&&o.set(r,i);}),r.data.forEach(t=>{for(const[e,r]of o)t[e]=r(t[e]);})}));return Promise.all(r)}(r);}catch(t){throw n("concepts processing",t),t}return i}function m(t,e){e.conceptsLookup.clear(),t.forEach(t=>e.conceptsLookup.set(t.concept,t));}function j(t,e){const r=Object.assign({},e),{debug:i}=r.diagnostic.prepareDiagnosticFor("queryData"),{select:{key:u=[],value:a=[]},from:c="",where:s={},join:l={},order_by:p=[],language:h}=t,d={key:u,value:a};i("start all data loading",t);const y=new Set(d.key.concat(d.value)),v=E(s).filter(t=>"entities"===c||!y.has(t)),_=function(t,e,r,o,i){const{debug:u}=o.diagnostic.prepareDiagnosticFor("loadResource"),a=S(t,e);return u("resources list by query",{queryParam:i,resources:[...a]}),Promise.all([...a].map(t=>(function(t,e,r){const{warning:o}=r.diagnostic.prepareDiagnosticFor("loadResource"),i=[];void 0===t.data&&(t.data=C(t.path,r)),i.push(t.data);const u=void 0!==e&&n(function(t){return t.datapackage.translations?t.datapackage.translations.map(t=>t.id):[]}(r),e),a=void 0!==t.translations[e];if(u){if(!a){const n=`lang/${e}/${t.path}`;t.translations[e]=C(n,r).catch(t=>(o(`translation file ${n}`,t),Promise.resolve({})));}i.push(t.translations[e]);}return Promise.all(i).then(e=>{const r=e.map(t=>t.data||[]),n=t.schema.primaryKey,o=T(n,"translation",...r);return {data:o,resource:t}})})(t,r,o)))}(d.key,[...d.value,...v],h,r,t),g=function(t,e,r){return Promise.all(Object.keys(t).map(e=>(function(t,e,r,n){return "time"===n.conceptsLookup.get(e.key).concept_type?Promise.resolve({[t]:e.where}):j({select:{key:[e.key]},where:e.where,from:n.conceptsLookup.has(e.key)?"entities":"concepts"},Object.assign({joinID:t},n)).then(r=>({[t]:{[e.key]:{$in:new Set(r.map(t=>t[e.key]))}}}))})(e,t[e],0,r))).then(t=>t.reduce(O,{}))}(l,0,r),b=function(t,e,r){const n=A(["entity_set"],t,r).map(t=>j({select:{key:[t.domain],value:["is--"+t.concept]},from:"entities"},Object.assign({},r)).then(e=>({[t.concept]:{$in:new Set(e.filter(e=>e["is--"+t.concept]).map(e=>e[t.domain]))}})));return Promise.all(n).then(t=>t.reduce((t,e)=>Object.assign(t,e),{}))}(d.key,0,r);return Promise.all([_,b,g]).then(([e,u,a])=>{i("finish all data loading",t);const c=function(...t){return t.reduce((t,e)=>(o(e)||t.$and.push(e),t),{$and:[]})}(u,function t(e,r){const o={};for(const i in e){const u=e[i];n(["$and","$or","$nor"],i)?o[i]=u.map(e=>t(e,r)):"$in"===i||"$nin"===i?o[i]=new Set(u):void 0!==r[u]?Object.assign(o,r[u]):o[i]="object"==typeof u?t(u,r):u;}return o}(s,a));i("dataTables processing",t);const l=e.map(t=>(function(t,e,r,n){const o=t.resource.schema.primaryKey,i=new Set([...o,...e.value,...r]),u=function(t,e,r){const n=new Set(e),o=["entity_set","entity_domain"],i=A(o,t,r);if(0===i.length)return new Map;const u=A(o,null,r);return i.map(t=>u.filter(e=>"entity_set"===t.concept_type?n.has(e.concept)&&e.concept!==t.concept&&(e.domain===t.domain||e.concept===t.domain):n.has(e.concept)&&e.concept!==t.concept&&e.domain===t.concept).reduce((e,r)=>e.set(r.concept,t.concept),new Map)).reduce((t,e)=>new Map([...t,...e]),new Map)}(e.key,o,n);return t.data.map(t=>R(t,i)).map(t=>(function(t,e){const r={};for(const n of Object.keys(t))r[e.get(n)||n]=t[n];return r})(t,u))})(t,d,v,r));i("queryResult processing",t);const h=T(d.key,"overwrite",...l).filter(t=>w(t,c)).map(t=>(function(t,e){for(const r of e)void 0===t[r]&&(t[r]=null);return t})(t,y)).map(t=>R(t,y));return i("result ordering",t),function(t,e=[]){if(0===e.length)return;const r=e.map(t=>{if("string"==typeof t)return {concept:t,direction:1};{const e=Object.keys(t)[0],r="asc"===t[e]?1:-1;return {concept:e,direction:r}}}),n=r.length;t.sort((t,e)=>{for(let o=0;o<n;o++){const n=r[o];if(t[n.concept]<e[n.concept])return -1*n.direction;if(t[n.concept]>e[n.concept])return 1*n.direction}return 0});}(h,p),i("final result is ready",t),function(t,e){const r=e.conceptsLookup;return Object.keys(t[0]||{}).map(t=>r.get(t)||{}).filter(t=>"time"==t.concept_type).forEach(({concept:r})=>{const n=function(t,e){const{error:r}=e.diagnostic.prepareDiagnosticFor("queryData"),n={year:(0, f.utcParse)("%Y"),month:(0, f.utcParse)("%Y-%m"),day:(0, f.utcParse)("%Y%m%d"),hour:(0, f.utcParse)("%Y%m%dt%H"),minute:(0, f.utcParse)("%Y%m%dt%H%M"),second:(0, f.utcParse)("%Y%m%dt%H%M%S"),week:(0, f.utcParse)("%Yw%V"),quarter:(0, f.utcParse)("%Yq%q")};return "time"==t?function(t){for(const e in n){const r=n[e](t);if(r)return r}return r("Could not parse time string: "+t),null}:n[t]?n[t]:(r("No time parser found for time concept: "+t),t=>t)}(r,e);t.forEach(t=>{t[r]=n(t[r]);});}),t}(h,r)})}function w(t,e){return Object.keys(e).every(n=>{const o=r.get(n);return o?o(t,e[n]):"object"!=typeof e[n]?r.get("$eq")(t[n],e[n]):w(t[n],e[n])})}function O(t,e){return Object.assign(t,e)}function E(t){const e=[];for(const r in t)n(["$and","$or","$not","$nor"],r)?t[r].map(E).forEach(t=>e.push(...t)):e.push(r);return [...new Set(e)]}function A(t,e,r){const o=e||Array.from(r.conceptsLookup.keys()),i=[];for(const e of o){const o=r.conceptsLookup.get(e);n(t,o.concept_type)&&i.push(o);}return i}function S(t,e){if(!e||0===e.length||t[0]===e)return new Set([...p.get(k(t)).values()].reduce((t,e)=>t.concat(e)));if(Array.isArray(e))return e.map(e=>S(t,e)).reduce((t,e)=>new Set([...t,...e]),new Set);let r=p.get(k(t)).get(e);return r&&(r=r.filter(t=>o(v)||n(v,t.path))),new Set(r)}function R(t,e){const r={};for(const n of Object.keys(t))e.has(n)&&(r[n]=t[n]);return r}function T(t,e,...r){if(1===r.length)return r[0];const n=t.slice(0).sort();return [...r.reduce((t,r)=>(r.forEach(r=>{const o=n.map(t=>r[t]).join(",");t.has(o)?function(t,e,r){switch(r){case"overwrite":Object.assign(t,e);break;case"translation":for(const r in e)""!==e[r]&&(t[r]=e[r]);break;case"overwriteWithError":for(const r in e)if(void 0!==t[r]&&t[r]!==e[r]){const n=JSON.stringify(e),o=JSON.stringify(t),i=`JOIN Error: two resources have different data for "${r}": ${n},${o}`;D(new a.DdfCsvError(a.DDF_ERROR,i));}else t[r]=e[r];}}(t.get(o),r,e):t.set(o,r);}),t),new Map).values()]}function D(e){throw (t||console).error(e.message),e}function k(t,e=!1){const r=t.slice(0).sort();return e?r.map(t=>e[t]).join(","):r.join(",")}function C(t,e){const{debug:r,error:o}=e.diagnostic.prepareDiagnosticFor("loadFile"),u=(0, c.getFilePath)(e.basePath,t);return r(`start reading "${t}"`),new Promise((c,f)=>{e.fileReader.readText(u,(l,p)=>{if(l)return o(`fail "${t}" reading`,l),f(new a.DdfCsvError(a.FILE_READING_ERROR,l,u));s.parse(i(p),{header:!0,skipEmptyLines:!0,dynamicTyping:t=>{const r=e.conceptsLookup.get(t)||{};return !n(["time","string"],r.concept_type)},complete:e=>{r(`finish reading "${t}"`),c(e);},error:e=>{o(`fail "${t}" parsing`,e),f(new a.DdfCsvError(a.CSV_PARSING_ERROR,e,t));}});});})}return {query:async function(t,e){const r=Object.assign({},e),{warning:n,error:o}=r.diagnostic.prepareDiagnosticFor("query");let i;try{if(await(0,c.validateQueryStructure)(t,r),r.datapackage=await(y||(y=g(r))),r.resourcesLookup=h,await b(0,r),await(0,c.validateQueryDefinitions)(t,r),(0,c.isSchemaQuery)(t))i=await function(t,e){const{debug:r,error:n}=e.diagnostic.prepareDiagnosticFor("query"),o=t=>(r(`get schema for collection ${t}`),e.datapackage.ddfSchema[t].map(({primaryKey:t,value:e})=>({key:t,value:e}))),i=t.from.split(".")[0];if(e.datapackage.ddfSchema[i])return o(i);if("*"===i)return Object.keys(e.datapackage.ddfSchema).map(o).reduce((t,e)=>t.concat(e));{const t=`No valid collection (${i}) for schema query`;n(t),D(new a.DdfCsvError(a.DDF_ERROR,t));}}(t,r);else {const e=_&&(0,u.getAppropriatePlugin)(this,t,r);if(v=[],e){const r=await e.getRecommendedFilesSet();v=r,t.optimalFilesSet=[].concat(r,t.optimalFilesSet),n("get custom optimal files list by a plugin",v);}i=await j(t,r);}}catch(t){throw o("general query error",t),t}return i},queryData:j,loadFile:C}};},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.prepareDDFCsvReaderObject=void 0;const n=r(5),o=r(46),i=r(6),u=r(14),a=r(14),c=r(23),s="@vizabi/reader-ddfcsv",f="4.3.2";e.prepareDDFCsvReaderObject=function(t){return function(e,r){return {init(n){this._basePath=(0, c.githubPathAdapter)(n.path||""),this._lastModified=n._lastModified,this.fileReader=e||t,this.logger=r,this.resultTransformer=n.resultTransformer,this.readerOptions={basePath:this._basePath,fileReader:this.fileReader,logger:this.logger},this.reader=(0, o.ddfCsvReader)(this.logger);},getDatasetInfo(){return {name:this._basePath.slice(this._basePath.indexOf("ddf--"))}},async checkFile(t){return new Promise((e,r)=>e({status:this.fileReader.checkFile(t),url:t}))},async getFile(t,e,r){return new Promise((n,o)=>{this.fileReader.readText(t,(t,r)=>{if(t)return o(t);try{return n(e?JSON.parse(r):r)}catch(t){return o(t)}},r);})},async checkIfAssetExists(t,e=""){if(n(e)&&n(this._basePath))throw new i.DdfCsvError("Neither initial 'path' nor 'repositoryPath' as a second param were found.","Happens in 'checkIfAssetExists' function",t);const r=`${e||this._basePath}/assets/${t}`;return await this.checkFile(r)},async getAsset(t,e=""){if(n(e)&&n(this._basePath))throw new i.DdfCsvError("Neither initial 'path' nor 'repositoryPath' as a second param were found.","Happens in 'getAsset' function",t);const r=`${e||this._basePath}/${t}`,o=".json"===r.slice(-".json".length);return await this.getFile(r,o)},async read(t,e,o){const c=o?(0, u.createDiagnosticManagerOn)(s,f).basedOn(o):(0, u.createDiagnosticManagerOn)(s,f).forRequest("").withSeverityLevel(a.Level.OFF),{debug:l,error:p,fatal:h}=c.prepareDiagnosticFor("read");let d;l("start reading",t);try{if(n(t.repositoryPath)&&n(this._basePath)){const e="Neither initial 'path' nor 'repositoryPath' in query were found.",r=new i.DdfCsvError(e,JSON.stringify(t));throw p(e,r),r}d=await this.reader.query(t,{basePath:t.repositoryPath||this._basePath,fileReader:this.fileReader,logger:this.logger,conceptsLookup:new Map,diagnostic:c}),d=e?this._prettifyData(d,e):d,this.resultTransformer&&(d=this.resultTransformer(d)),this.logger&&this.logger.log&&(r.log(JSON.stringify(t),d.length),r.log(d));}catch(t){throw h("global data reading error",t),t}return d},_prettifyData:(t,e)=>t.map(t=>(Object.keys(t).forEach(r=>{e[r]&&(t[r]=e[r](t[r]));}),t))}}};},function(t,e){!function(){if(!self.fetch){i.prototype.append=function(t,e){t=n(t),e=o(e);var r=this.map[t];r||(r=[],this.map[t]=r),r.push(e);},i.prototype.delete=function(t){delete this.map[n(t)];},i.prototype.get=function(t){var e=this.map[n(t)];return e?e[0]:null},i.prototype.getAll=function(t){return this.map[n(t)]||[]},i.prototype.has=function(t){return this.map.hasOwnProperty(n(t))},i.prototype.set=function(t,e){this.map[n(t)]=[o(e)];},i.prototype.forEach=function(t){var e=this;Object.getOwnPropertyNames(this.map).forEach(function(r){t(r,e.map[r]);});};var t={blob:"FileReader"in self&&"Blob"in self&&function(){try{return new Blob,!0}catch(t){return !1}}(),formData:"FormData"in self},e=["DELETE","GET","HEAD","OPTIONS","POST","PUT"],r=!("undefined"==typeof window||!window.ActiveXObject||window.XMLHttpRequest&&(new XMLHttpRequest).dispatchEvent);s.call(f.prototype),s.call(p.prototype),self.Headers=i,self.Request=f,self.Response=p,self.fetch=function(e,n){var o;return o=f.prototype.isPrototypeOf(e)&&!n?e:new f(e,n),new fetch.Promise(function(e,n){var u=function(){return r&&!/^(get|post|head|put|delete|options)$/i.test(this.method)?(this.usingActiveXhr=!0,new ActiveXObject("Microsoft.XMLHTTP")):new XMLHttpRequest}();function a(){if(4===u.readyState){var t=1223===u.status?204:u.status;if(t<100||t>599)n(new TypeError("Network request failed"));else {var r={status:t,statusText:u.statusText,headers:function(t){var e=new i;return t.getAllResponseHeaders().trim().split("\n").forEach(function(t){var r=t.trim().split(":"),n=r.shift().trim(),o=r.join(":").trim();e.append(n,o);}),e}(u),url:"responseURL"in u?u.responseURL:/^X-Request-URL:/m.test(u.getAllResponseHeaders())?u.getResponseHeader("X-Request-URL"):void 0},o="response"in u?u.response:u.responseText;e(new p(o,r));}}}"cors"===o.credentials&&(u.withCredentials=!0),u.onreadystatechange=a,self.usingActiveXhr||(u.onload=a,u.onerror=function(){n(new TypeError("Network request failed"));}),u.open(o.method,o.url,!0),"responseType"in u&&t.blob&&(u.responseType="blob"),o.headers.forEach(function(t,e){e.forEach(function(e){u.setRequestHeader(t,e);});}),u.send(void 0===o._bodyInit?null:o._bodyInit);})},fetch.Promise=self.Promise,self.fetch.polyfill=!0;}function n(t){if("string"!=typeof t&&(t=t.toString()),/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(t))throw new TypeError("Invalid character in header field name");return t.toLowerCase()}function o(t){return "string"!=typeof t&&(t=t.toString()),t}function i(t){this.map={};var e=this;t instanceof i?t.forEach(function(t,r){r.forEach(function(r){e.append(t,r);});}):t&&Object.getOwnPropertyNames(t).forEach(function(r){e.append(r,t[r]);});}function u(t){if(t.bodyUsed)return fetch.Promise.reject(new TypeError("Already read"));t.bodyUsed=!0;}function a(t){return new fetch.Promise(function(e,r){t.onload=function(){e(t.result);},t.onerror=function(){r(t.error);};})}function c(t){var e=new FileReader;return e.readAsArrayBuffer(t),a(e)}function s(){return this.bodyUsed=!1,this._initBody=function(e){if(this._bodyInit=e,"string"==typeof e)this._bodyText=e;else if(t.blob&&Blob.prototype.isPrototypeOf(e))this._bodyBlob=e;else if(t.formData&&FormData.prototype.isPrototypeOf(e))this._bodyFormData=e;else {if(e)throw new Error("unsupported BodyInit type");this._bodyText="";}},t.blob?(this.blob=function(){var t=u(this);if(t)return t;if(this._bodyBlob)return fetch.Promise.resolve(this._bodyBlob);if(this._bodyFormData)throw new Error("could not read FormData body as blob");return fetch.Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this.blob().then(c)},this.text=function(){var t,e,r=u(this);if(r)return r;if(this._bodyBlob)return t=this._bodyBlob,(e=new FileReader).readAsText(t),a(e);if(this._bodyFormData)throw new Error("could not read FormData body as text");return fetch.Promise.resolve(this._bodyText)}):this.text=function(){var t=u(this);return t||fetch.Promise.resolve(this._bodyText)},t.formData&&(this.formData=function(){return this.text().then(l)}),this.json=function(){return this.text().then(function(t){return JSON.parse(t)})},this}function f(t,r){var n,o;if(r=r||{},this.url=t,this.credentials=r.credentials||"omit",this.headers=new i(r.headers),this.method=(n=r.method||"GET",o=n.toUpperCase(),e.indexOf(o)>-1?o:n),this.mode=r.mode||null,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&r.body)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(r.body);}function l(t){var e=new FormData;return t.trim().split("&").forEach(function(t){if(t){var r=t.split("="),n=r.shift().replace(/\+/g," "),o=r.join("=").replace(/\+/g," ");e.append(decodeURIComponent(n),decodeURIComponent(o));}}),e}function p(t,e){e||(e={}),this._initBody(t),this.type="default",this.url=null,this.status=e.status,this.ok=this.status>=200&&this.status<300,this.statusText=e.statusText,this.headers=e.headers instanceof i?e.headers:new i(e.headers),this.url=e.url||"";}}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.getDDFCsvReaderObject=e.DdfCsvError=e.FrontendFileReader=void 0;const n=r(21);var o=r(21);Object.defineProperty(e,"FrontendFileReader",{enumerable:!0,get:function(){return o.FrontendFileReader}});var i=r(6);Object.defineProperty(e,"DdfCsvError",{enumerable:!0,get:function(){return i.DdfCsvError}});const u=r(47);e.getDDFCsvReaderObject=(0, u.prepareDDFCsvReaderObject)(new n.FrontendFileReader);},function(t,e,r){t.exports=r(49);}])});
})();
//# sourceMappingURL=tools.js.map
